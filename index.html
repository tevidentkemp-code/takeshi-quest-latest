<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shateki Quest Scorer</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='14' fill='%230f1220'/%3E%3Cpath d='M22 12h24l-8 18h10L18 52l10-20H18z' fill='%23ff7a00'/%3E%3C/svg%3E" />


<!-- =====================================================================
     FILE MAP (MOT)
     1) <head>: meta, external libs, CSS
     2) <body>: screens + modals (static DOM)
     ===================================================================== -->
<!-- =====================================================================
     SQ AUDIT + INDEX
     - Housekeeping:
       â€¢ Removed duplicate favicon + invalid escaped shortcut icon tag
       â€¢ Removed misleading commented "<script>:</script>" snippet (kept the real SQ NAV INDEX in main script)

     - Jump points (approx line numbers):
       â€¢ Select Game Mode UI: line 3391
       â€¢ Match Setup UI: line 3189
       â€¢ New Player Modal UI: line 2380
       â€¢ Admin Hub UI: line 1182
       â€¢ Saved Players Admin UI: line 3678
       â€¢ Stats Progression chart: line 5965
       â€¢ Target Hit % chart: line 22716

     - Known issues to revisit:
       â€¢ Supabase rename/merge conflicts: protect against duplicate-name unique constraint in admin rename flow
===================================================================== -->
<!-- Supabase JS v2 -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<!-- Chart.js v4 -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>


<style>
/* ===== @CSS:TOKENS | CSS: THEME TOKENS ===== */
:root{
  /* Theme */
  --bg:#0f1220;
  --card:#171a2b;
  --ink:#e7e9f5;
  --muted:#a8acc3;
  --accent:#7bdcff;
  --accent-2:#8cff9e;
  --leader-lime:#9BFF2E;
  --danger:#ff6b6b;
  --warn:#ffcc66;
  --good:#7fffd4;
  --shadow:0 10px 30px rgba(0,0,0,.35);
  --radius:14px;

  /* Layout */
  --pad-h:148px;
  --left-col-w:96px;
  --start-btn-h:52px;
  --title-w:640px;
  --homeW: min(calc(var(--title-w) * 0.6667), 820px);
  --navGap: 10px;      /* fallback until JS measures */
  --section-gap:10px;   /* global vertical spacing */

  /* Leaderboard widths */
  --lb-num-w:72px;      /* each G# */
  --lb-pct-w:86px;      /* Match % */
  --lb-total-w:96px;    /* Match Total */
  --lb-win-w:56px;      /* Win */
}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; min-height:100dvh; overflow:hidden;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,"Apple Color Emoji","Segoe UI Emoji";
    background:radial-gradient(1000px 600px at 0% 0%,#1b1f36 0%,#0f1220 45%,#0b0e1a 100%); color:var(--ink);
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
  }

  /* Scroll guard */
  @media (max-height: 820px), (max-width: 420px){
    body{ overflow-y:auto; }
  }

  /* Start/Back buttons under the player box (scope to #players only) */
#players #startMatchRow,
#players #backRow{
  max-width: 640px;
  width: 100%;
  margin: 12px auto 0;
}

/* Make the buttons themselves fill those rows */
#players #startMatchBtn,
#players #startScreenBtn{
  width: 100%;
}


#startMatchBtn{
  width:100%;          /* same width as the box */
}
 .wrap{max-width:1100px;margin-inline:auto;padding:16px; padding-bottom:calc(var(--pad-h) + 16px)}
.start-actions{
  width: min(420px, 94%);
  display:flex;
  flex-direction:column;
  align-items:center;
  margin:0 auto;
  text-align:center;
}
/* Game Details layout tweaks */
#details h2 {
  display: none;
}
#details #appTitle {
  display: block;               /* override the display:none */
  text-transform: uppercase;
  text-align: center;
  margin: 8px 0 24px;
  line-height: 1.02;
}

#details #appTitle .titleMain{
  display:block;
  font-size: 3.3rem;
  font-weight: 900;
  letter-spacing: 0.06em;
  color: #ff7a00;
}

#details #appTitle .titleSub{
  display:block;
  margin-top: 6px;
  font-size: 1.25rem;
  font-weight: 800;
  letter-spacing: 0.55em;
  color: #f2f4ff;
  opacity: 0.92;
}
/* Game Details screen: content aligned towards top with some breathing room */
#details {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;           /* no vertical centering */
  min-height: calc(100vh - var(--pad-h));
  padding-top: 32px;                     /* move SHATEKI-QUEST / New / Resume closer to top */
  --homeW: min(420px, 94%);
}

/* Center the main buttons block */
#details .start-actions {
  margin: 0 auto;
}

/* Player Select layout tweaks */
#players h2{
  display:none;              /* hide "Player Select" text */
}


/* Center the Player Select screen vertically like page 1 */
#players{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;              /* vertical centering */
  min-height:calc(100vh - var(--pad-h));
  padding: 24px 0;                     /* breathing room top/bottom */
}


/* Box wrappers on Player Select: games/players + player list */
.ps-config-row{
  padding:12px;
  border-radius:12px;
  background:#101533;
  border:1px solid #23284a;
  display:flex;
  flex-direction:column;
  gap:10px;
  max-width:640px;
  width:100%;
  margin:12px auto 0;
}
  /* Player Select: steppers for games/players instead of native selects */
.setup-row {
  display: flex;
  gap: 18px;
  margin-bottom: 4px;
}

.setup-field {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.setup-label {
  font-size: 0.75rem;
  letter-spacing: 0.04em;
  text-transform: uppercase;
  color: var(--muted);
  text-align: center;
}

.setup-stepper {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 10px;
  border-radius: 999px;
  background:
    radial-gradient(circle at 0 0, rgba(255,255,255,0.03), transparent 55%),
    rgba(12, 15, 32, 0.95);
  box-shadow:
    0 0 0 1px rgba(124, 142, 255, 0.25),
    var(--shadow);
  gap: 8px;
}

.stepper-btn {
  border: none;
  outline: none;
  width: 26px;
  height: 26px;
  border-radius: 999px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  font-weight: 700;
  background: linear-gradient(
    135deg,
    rgba(123, 220, 255, 0.18),
    rgba(140, 255, 158, 0.12)
  );
  color: var(--ink);
  cursor: pointer;
  transition:
    transform 0.1s ease,
    box-shadow 0.1s ease,
    background 0.15s ease;
}

.stepper-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
}

.stepper-btn:active {
  transform: translateY(0);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
}

.stepper-value {
  flex: 1;
  display: flex;
  align-items: baseline;
  justify-content: center;
  gap: 4px;
  font-variant-numeric: tabular-nums;
}

.stepper-number {
  font-size: 1rem;
  font-weight: 700;
  color: var(--ink);
}

.stepper-suffix {
  font-size: 0.75rem;
  color: var(--muted);
}

.native-select-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0 0 0 0);
  border: 0;
}

@media (max-width: 600px) {
  .setup-row {
    flex-direction: column;
  }
}

/* Box each player row (guest name + select/save buttons) */
#psPlayerFields .pf{
  padding:10px 12px;
  border-radius:12px;
  border:1px solid #23284a;
  background:#101533;
}
.th-throws{
  font-size: 11px;
  line-height: 1;
  color: var(--muted);
  min-height: 14px;
}
.leader-total{
  color: var(--leader-lime) !important;
  text-shadow: 0 0 10px rgba(155,255,46,.18);
}

#psPlayerFields .pf input[data-role="display"]{
  background:#ffffff;
  color:#000000;
}

#psPlayerFields .pf .btn{
  min-width:120px;
}

#adminCodeRow{
  width: var(--homeW);
  max-width: var(--homeW);
  margin: 10px auto 22px;
  display: flex;
  justify-content: center;
  box-sizing: border-box;
}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .column{display:flex;flex-direction:column;gap:10px}
  .grow{flex:1}
  .hidden{display:none!important}
  .tag{font-size:.78rem;color:var(--muted);padding:.15rem .45rem;border:1px solid #2b3050;border-radius:999px}
  .banner{background:linear-gradient(180deg,#14284a,#12213d);border:1px solid #2a4777;border-radius:12px;padding:12px;margin-top:10px}

  input[type="text"],select,input[type="password"]{
    background:#101329;border:1px solid #2b3050;color:var(--ink);padding:.65rem .8rem;border-radius:10px;outline:none;width:100%
  }
  .btn{appearance:none;border:1px solid #2b3050;border-radius:12px;background:#131733;color:var(--ink);
       padding:.7rem 1rem;cursor:pointer;transition:.15s transform,.15s background,.15s border-color,.15s opacity;font-weight:700}
  .btn:hover{transform:translateY(-1px);background:#161a3a}
  .btn:disabled{opacity:.55;cursor:not-allowed;transform:none}
  .btn.primary{background:linear-gradient(180deg,#1d255a,#19214f);border-color:#32407a}
  .btn.good{background:linear-gradient(180deg,#1b3d2e,#183628);border-color:#2e6a4f}
  .btn.warn{background:linear-gradient(180deg,#3a3219,#2f2914);border-color:#6b5821}
  .btn.danger{background:linear-gradient(180deg,#47212a,#3c1b23);border-color:#7a2e3f}
  .btn.big{font-size:1.15rem;padding:1rem 1.25rem;border-radius:14px}
  .btn.small { padding: 4px 8px; font-size: 0.8rem; min-width: 30px; min-height: 24px; }
  .btn.range { padding: 6px 10px; font-size: 0.82rem; min-height: 28px; min-width: 78px; opacity: .85; }
  .btn.range.active { opacity: 1; box-shadow: 0 0 0 1px rgba(255,255,255,.35) inset; }

  /* Tables */
  .table-wrap{overflow:auto;border-radius:12px;border:1px solid #2a2e48}
  table{width:100%;border-collapse:separate;border-spacing:0;background:#0f1329;table-layout:fixed}
  thead th{
    background:#14183a;border-bottom:1px solid #2a2e48;padding:.6rem .5rem;text-align:left;font-weight:700;
    position:sticky; top:0; z-index:5;
  }
  #scoreWrap thead th:first-child{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w)}
  #scoreWrap tbody th{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w);
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-right:6px}
  thead th.player, tbody td.player{min-width:120px; text-align:center}
  tbody td,tbody th{padding:.55rem .5rem;border-bottom:1px dashed #23284a;text-align:left;vertical-align:middle}
  tbody td{white-space:nowrap; overflow:hidden; text-overflow:clip}
  tbody tr:last-child td{border-bottom:none}
  tbody th{font-weight:600;color:#cfd3ee;background:#101533;border-right:1px solid #22264a}

/* Mini-league table background override */
.home-mini-printer table{ background: transparent !important; }
.home-mini-printer thead th{ background: transparent !important; position: static !important; top: auto !important; }
.home-mini-printer tbody th{ background: transparent !important; }
.home-mini-printer tbody tr:hover{ background: transparent !important; }

  .num{font-variant-numeric:tabular-nums}
  .center{text-align:center}

/* === Stats popup polish (nav buttons + rank colouring) === */
.sq-pill{ border-radius:999px !important; padding:8px 14px !important; min-height:34px; font-size:13px; }
.sq-rank-cell{ color: rgba(255,123,26,.95) !important; font-weight: 800; }

/* Reusable button style that matches the home nav buttons */
.sq-navBtn{ 
  width: min(420px, 92vw);
  height: 64px;
  padding: 0 10px;
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 10px;
  border-radius: 16px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.14);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.06), 0 10px 30px rgba(0,0,0,0.35);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  letter-spacing: 0.08em;
  font-weight: 700;
  text-transform: uppercase;
}
.sq-navBtn:hover{ transform: translateY(-1px); }
.sq-navBtn:active{ transform: translateY(0); }
.sq-navBtn.navGreen{ color:#3cff86; border-color: rgba(60,255,134,0.35); }
.sq-navBtn.navBlue{  color:#4aa3ff; border-color: rgba(74,163,255,0.35); }
.sq-navBtn.navOrange{color:#ffb14a; border-color: rgba(255,177,74,0.35); }
  .current-cell{background:rgba(255,122,0,.06)!important;box-shadow:inset 0 0 0 1px rgba(255,122,0,.45)}
  .current-col{background:rgba(255,122,0,.035)}

  /* Header content */
  thead th .th-wrap{display:flex;flex-direction:column;align-items:center;gap:2px}
  thead th .th-name{font-weight:900;letter-spacing:.02em;font-size:18px;line-height:1.05}
  thead th .th-beers{font-size:12px;line-height:1;min-height:14px;letter-spacing:.5px;filter:drop-shadow(0 0 6px rgba(255,204,102,.35)); text-align:center}
  .th-throw-arrow{font-size:13px; line-height:1}

  /* Base total style (used everywhere) */
  .th-total{
    font-weight:800;
    letter-spacing:.02em;
  }

/* Floating header: hero total score */
.float-head .th-total{
  font-size:34px;
  color: rgba(255,255,255,.98);
  line-height:1.1;
  display:block;
  margin:0;
  text-align:center;
}

/* Floating header: scale total score for 5/6 players */
.float-head.players-5 .th-total{ font-size: calc(34px * 0.95); }
.float-head.players-6 .th-total{ font-size: calc(34px * 0.90); }
/* Floating header: scale initials/name size for 5/6 players */
.float-head.players-5 thead th .th-name{ font-size:16px; }
.float-head.players-6 thead th .th-name{ font-size:15px; }


/* Throw indicator colours */
:root{ --shatekiOrange: #ff7a00; --shatekiBlue:#2f86ff; --shatekiBlueLight:#4aa3ff; }

/* Single shared go-indicator shown under TARGET (A) */
.go-darts{ display:flex; justify-content:center; gap:8px; margin-top:8px; }
.go-darts .dart-slot{
  display:inline-flex; align-items:center; justify-content:center;
  width:20px; height:20px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.16);
  font-size:12px; font-weight:900; letter-spacing:.02em;
}

/* Arrows are orange, always */
.go-darts .dart-slot.dart-empty{
  color: var(--shatekiOrange);
  border-color: rgba(255,122,0,.35);
}

/* Hits show white (S/D/T/OB/B). Miss stays slightly muted but still readable. */
.go-darts .dart-slot:not(.dart-empty){
  color: rgba(255,255,255,.95);
  border-color: rgba(255,255,255,.22);
}
.go-darts .dart-slot.dart-miss{ color: rgba(255,255,255,.82); }

/* Turn underline: animated sliding bar (moves Player 1 â†’ Player 2 â†’ â€¦ â†’ Player 1) */
#floatHead{ position: sticky; overflow: visible; } /* keep; also acts as containing block for abs children */
#floatHead .turn-bar{
  position:absolute;
  left:0; top:0;
  height:3px;
  width:0;
  background: rgba(255,122,0,.95);
  border-radius:3px;
  box-shadow: 0 0 12px rgba(255,122,0,.22);
  transform: translate(0px, 0px);
  transition: transform 260ms ease, width 260ms ease;
    z-index: 90001;
  will-change: transform, width;
  pointer-events:none;
}

/* Keep legacy class (no longer used for the underline animation) */
#floatWrap thead tr:nth-child(2) th.player.turn-active{ box-shadow:none; }

/* Round indicator: animated right-edge glow bar for the active round label */
#scoreWrap{ position: relative; z-index:1; }
#scoreWrap .round-bar{
  position:absolute;
  left:0; top:0;
  width:2px;
  height:0;
  background: rgba(255,122,0,.95);
  border-radius:2px;
  box-shadow: 0 0 14px rgba(255,122,0,.22);
  transform: translate(0px, 0px);
  transition: transform 260ms ease, height 260ms ease;
    z-index: 50;
  will-change: transform, height;
  pointer-events:none;
}

#scoreWrap .round-seam-bar{
  position:absolute;
  display:none; /* single boundary bar uses #roundBar */
  left:0; top:0;
  width:2px;
  height:0;
  background: rgba(255,122,0,.95);
  border-radius:2px;
  box-shadow: 0 0 14px rgba(255,122,0,.22);
  transform: translate(0px, 0px);
  transition: transform 260ms ease, height 260ms ease;
  z-index: 50;
  will-change: transform, height;
  pointer-events:none;
}

/* Smooth transitions for the active round label (A2) */
#scoreWrap tbody th.round-label{
  transition: font-size 220ms ease, font-weight 220ms ease, text-shadow 220ms ease, transform 220ms ease;
}
/* Active round separator glow (between round labels and Player 1 column) */
#scoreWrap tbody th.active-round-glow{
  border-right: 2px solid rgba(255,122,0,.95) !important;
  box-shadow: none !important;
}
#scoreWrap tbody td.active-round-leftglow{
  border-left: none !important;
  box-shadow: none !important;
}

/* Active round label sizing */
#scoreWrap tbody th.round-label.active-round-label{
  font-size:20px !important;
  font-weight:900 !important;
  opacity:1;
  color: rgba(255,255,255,.98);
  text-shadow: none !important;
  transform: scale(1.06);
  box-shadow: none !important;
  border-radius:10px;
}



/* --- FIX: active round label bottom edge getting eaten by dashed row border --- */
#scoreWrap tbody th.round-label{ position: relative; overflow: visible; }
#scoreWrap tbody th.round-label.active-round-label{
  font-size:20px !important;
  font-weight:900 !important;
  opacity:1;
  color: rgba(255,255,255,.98);
  text-shadow: none !important;
  transform: scale(1.06);
  border-radius:10px;
  background: rgba(255,255,255,.05); /* faint grey */
  /* Standard borders (top/left/bottom) without affecting the orange right edge */
  box-shadow:
    inset 1px 0 0 rgba(255,255,255,.10),
    inset 0 1px 0 rgba(255,255,255,.10),
    inset 0 -1px 0 rgba(255,255,255,.10) !important;
}


#scoreWrap tbody th.round-label.active-round-label::after{ content:none !important; }

.th-diff{
    font-size:10px;
    line-height:1;
    font-weight:400 !important;
    color:var(--muted);
    text-align:center;
  }
  .th-diff-label{font-size:11px; font-weight:400 !important; color:var(--muted)}

/* Floating header: layout under player names */
.float-head thead th .th-wrap{
  border-bottom:none;
  padding-bottom:2px;
  margin-bottom:0;
}

  /* Score cell */
  .cell-wrap{display:inline-flex;flex-direction:column;align-items:center;gap:1px;line-height:1}
  .cell-main{font-weight:800;line-height:1.1}
  .cell-sub{color:var(--muted);font-size:.52em;font-weight:400;opacity:.92;letter-spacing:-0.01em;line-height:1.05;display:block;min-height:1em}
  .cell-sub:empty::before{content:'\00a0';}

  .sub-win{color:var(--accent-2)!important;font-weight:400}

  /* Stats (kept for layout sync; shown via modals) */
  .stats-box{display:none}
  #statsWrap thead th:first-child,
  #mstatsWrap thead th:first-child{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w)}
  #statsWrap tbody th.stats-th,
  #mstatsWrap tbody th.stats-th{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w);
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-right:8px}
  .stats-th{background:#101533;color:#cfd3ee}
  .stats-row th,.stats-row td{font-size:.86rem;line-height:1.15;padding:.45rem .5rem}
  .stats-row td{color:#e1e4fb}

  /* Floating names header */
  .float-head{position:sticky; top:1px; z-index:200000;
    background:rgba(17,19,38,.96); backdrop-filter:blur(6px);
    border:1px solid #2a2e48; border-radius:12px; margin-bottom:10px}
  .float-head .table-wrap{
    border:none;
    border-radius:12px;
    overflow:hidden; /* allow horizontal sync scrolling of header */
  }
  #floatWrap thead th:first-child{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w)}

  /* ===== @CSS:GAME_TOPMENU_COLLAPSE =====
   Top menu is part of the sticky header and collapses away as you scroll.
   - Sticky inset: 4px from top
   - Menu collapses until only a thin divider remains
===== */
:root{
  --gameTopInset:0px;
  --fhMenuH:48px;   /* JS will overwrite */
  --fhCollapse:0px; /* JS updates on scroll */
  --fhScrollGate:0px; /* JS updates: hold content until B1 collapsed */
}

#floatHead.float-head{
  background: var(--bg);
  position: sticky;
  top: var(--gameTopInset);
  z-index: 20000;
  backdrop-filter:none !important;
  -webkit-backdrop-filter:none !important;
  isolation:isolate;
  overflow: visible;
}

.fh-menu-wrap{
  height: calc(var(--fhMenuH) - var(--fhCollapse));
  overflow: hidden;
  position: relative;
  background: var(--bg);
}

#gameTopRow.fh-menu{
  margin: 0 !important;
  position: relative;
  padding-top: 4px; /* B1 sits 4px below header edge */
  padding-bottom: 4px; /* match top inset: B1->B2 gap */
  transform: translateY(calc(-1 * var(--fhCollapse)));
}

.fh-menu-line{
  position:absolute;
  left:0; right:0;
  top: calc(var(--fhMenuH) - var(--fhCollapse));
  height: 1px;
  background: rgba(255,255,255,.10);
  pointer-events:none;
}

/* ===== @CSS:GAME_SCROLL_GATE =====
   Consume initial scroll to collapse B1 before the scoreboard content (A2/D) starts moving under A1/B2/B3. */
body[data-page="game"] #gameScrollGate{
  /* Cancel the first part of scroll (used to collapse B1) without creating a gap under the header */
  transform: translateY(var(--fhScrollGate));
  margin-top: calc(-1 * var(--fhScrollGate));
  will-change: transform;
}

/* ===== @CSS:FLOATHEAD_NAMES_COLOR =====
   B2 names are white by default; active player's name turns Shateki orange. */
.float-head .th-name{ color:#ffffff !important; }
.float-head thead tr:nth-child(1) th.player.is-go .th-name{ color:var(--shatekiOrange, #ff7a00) !important; }
/* Vertical divider after the TARGET column in floating header */
.float-head thead th:first-child{
  border-right:1px solid #22264a;
}

/* Vertical dividers BETWEEN player columns (so 3+ players stay separated) */
.float-head thead tr th:nth-child(n+3){
  border-left:1px solid #22264a;
}

/* Floating header: base header cells */
.float-head thead th{
  border-bottom:none;
  vertical-align:middle;
}

/* Row B (names): divider line just under player names */
.float-head thead tr:nth-child(1) th{
  border-bottom:1px solid #2a2e48;
  padding-top:8px;
  padding-bottom:6px;
}

/* Row C (totals): divider line under totals */
.float-head thead tr:nth-child(2) th{
  padding-top:8px;
  padding-bottom:6px;
  text-align:center;
  border-bottom:1px solid #22264a;
}

/* Row D (darts): compact row */
.float-head thead tr:nth-child(3) th{
  padding-top:6px;
  padding-bottom:8px;
  text-align:center;
}
.th-wins{
  font-size:12px;
  line-height:1;
  letter-spacing:.08em;
  opacity:.9;
  margin-bottom:6px;
  color:rgba(255,255,255,.75);
}
.th-wins span{ display:inline-block; margin:0 2px; }
.th-wins .win-star{color:rgba(255,255,255,.85);}
.th-wins .win-circle{color:rgba(255,255,255,.35);}
.th-darts{
  display:flex;
  justify-content:center;
  gap:8px;
}
.dart-slot{
  width:22px;
  height:22px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  border-radius:999px;
  font-weight:800;
  font-size:12px;
  background:rgba(255,255,255,.04);
  border:1px solid rgba(255,255,255,.06);
}
.dart-empty{
  color:rgba(255,255,255,.55);
}
.dart-miss{
  color:rgba(255,255,255,.85);
}
.dart-s,.dart-d,.dart-t,.dart-b{
  color:currentColor; /* use player colour */
}
.th-darts.is-active .dart-slot{
  box-shadow:0 0 0 2px rgba(255,255,255,.06) inset;
}
.th-darts.is-active .dart-slot.dart-empty{
  color:#ff7a00;
  border-color:rgba(255,122,0,.28);
  background:rgba(255,122,0,.08);
}
#floatWrap #froundlabel .round-now{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  padding:8px 4px;
}
#floatWrap #froundlabel .rn-label{
  font-size:11px;
  font-weight:700;
  letter-spacing:.18em;
  color:var(--muted);
  margin-bottom:4px;
  text-transform:uppercase;
}
#floatWrap #froundlabel .rn-value{
  font-weight:900;
  line-height:1;
  /* Big, but responsive so it nearly fills the cell */
  font-size:clamp(28px, 6.5vw, 64px);
  letter-spacing:.01em;
}
/* Bigger, bold S / D / T buttons + match size for pad actions & top bar */
.btn.letter-throw{
  font-size: 1.25rem;
  font-weight: 700;
}
.pad .btn.letter-throw{
  min-height: 46px;
  
}
/* Center + bold the "10sâ€¦Bull" row labels in the main scoreboard */
#scoreWrap tbody th{
  text-align:center;
  font-weight:800;   /* bold target labels (10â€“Bull) */
}

/* round sub-value (the bracketed "(30)") defaults to muted */
.round-sub { color: var(--hint, rgba(255,255,255,.65)); }

/* only the top per-round score(s) get green */
.round-sub.is-round-high { color: var(--green, #37d67a); font-weight: 400; }

/* Reverted: show cumulative total as main and round score in parentheses below */
#scoreWrap .cell-main{
  display:block !important;
  font-size:1.6rem;
  font-weight:900;
  line-height:1.1;
}
  #scoreWrap .cell-sub{
    display:block !important;
    font-size:.72rem;
    font-weight:400;
    color: var(--muted);
    opacity:.92;
    line-height:1.05;
  }

/* Revert UI: hide perâ€‘dart markers */
.cell-throws{ display:none !important; }

  /* Round rows height â€“ reverted to original sizing */
  #scoreWrap tbody th,
  #scoreWrap tbody td{
    padding-top: 0.55rem;
    padding-bottom: 0.55rem;
  }

/* Landscape: keep TARGET cell (float header) aligned with the round-label column */
@media (orientation: landscape){
  #floatWrap thead th:first-child,
  #scoreWrap thead th:first-child,
  #scoreWrap tbody th{
    width: var(--left-col-w);
    min-width: var(--left-col-w);
    max-width: var(--left-col-w);
  }
}
#leaderboardTopRow .btn.top-throw{
  flex: 1 1 0;
  min-width: 0;
  min-height: 35px;
  font-size: 1rem;
  font-weight: 500;
}
  /* Hide Throw Pad off non-game pages */
  body[data-page="details"] .pad-bar,
  body[data-page="players"] .pad-bar,
  body[data-page="leaderboard"] .pad-bar.hidden { display:none; }
  body[data-page="game"] .pad-bar { display:block; }

  /* Fixed Throw Pad */
  .pad-bar{position:fixed;left:0;right:0;bottom:0;background:rgba(17,19,38,.96);backdrop-filter:blur(6px);
    border-top:1px solid #23284a;z-index:100000;padding-bottom:max(8px, env(safe-area-inset-bottom))}
  .pad-inner{width:100%;max-width:none;margin:0;padding:8px 10px}
  .pad-head{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:6px}
  .pad-left{display:flex;align-items:center;gap:10px}
  .pad-hint{color:#a8acc3;font-size:.82rem}
.pad{
  display:flex;
  flex-direction:column;
  align-items:stretch;
  gap:6px;
  width:100%;
  max-height:140px;
  overflow:auto;
}
.pad .btn{min-width:52px;min-height:38px}
  .pad-spacer{flex:1 1 auto}
  .pad .btn.main-throw{
    min-width:104px;
  }

  /* Modal */
  .modal-backdrop{position:fixed; inset:0; background:rgba(0,0,0,.5); display:flex; align-items:center; justify-content:center; z-index:400000}
  .modal{
    background:#0f1329;
    border:1px solid #2a2e48;
    border-radius:14px;
    box-shadow:var(--shadow);
    padding:12px;
    width:92%;
    max-width:640px;

    /* keep footer visible; scroll only the body */
    display:flex;
    flex-direction:column;
    max-height:80vh;
    overflow:hidden;
  }
  .modal h3{ margin:0 0 8px 0; font-size:1.02rem }
  .modal-body{
    flex:1 1 auto;
    overflow:auto;
    padding-right:2px;
    min-height:0; /* allow flexbox scroll */
  }
  .modal-footer{
    margin-top:10px;
    display:flex;
    gap:8px;
    position:sticky;
    bottom:0;
    background:#0f1329;
    padding-top:8px;
    padding-bottom:max(0px, env(safe-area-inset-bottom));
  }

  


/* ===== @CSS:POWER_RANKINGS_TOGGLES | Power Rankings popup toggles ===== */
.pr-modal-head{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:12px;
  margin:2px 2px 10px;
}
.pr-modal-titlewrap{flex:1; min-width:0;}
.pr-modal-titlewrap h3{margin:0;}
.pr-toggle{
  display:flex;
  gap:6px;
  align-items:center;
  justify-content:flex-end;
  padding-top:2px;
  flex:0 0 auto;
}
.pr-toggle button{
  height:30px;
  padding:0 10px;
  border-radius:10px;
  border:1px solid #2a2e48;
  background:rgba(255,255,255,.04);
  color:#d7dcff;
  font-weight:700;
  letter-spacing:.2px;
}
.pr-toggle button.active{
  background:rgba(255,122,0,.16);
  border-color:rgba(255,122,0,.45);
  color:#ff7a00;
}


/* ===== @CSS:START_GAME_MODAL | Home START GAME popup ===== */

/* Darker overlay for this modal only (obscure home behind) */
#startGameModal.modal-backdrop{
  background: rgba(0,0,0,.78);
  backdrop-filter: blur(6px);
}

.modal.sg-modal{
  max-width: 520px;
  padding: 0;
  border-radius: 18px;
  background: rgba(15,18,32,.97);
  border: 1px solid rgba(255,255,255,.10);
  overflow:hidden;
}

.sg-head{
  padding: 18px 18px 10px;
  text-align:center;
}
.sg-title{
  font-size: 26px;
  font-weight: 900;
  letter-spacing: .06em;
  text-transform: uppercase;
  color: rgba(240,242,255,.96);
}
.sg-sub{
  margin-top: 6px;
  font-size: 12px;
  font-weight: 800;
  letter-spacing: .12em;
  text-transform: uppercase;
  color: rgba(255,255,255,.55);
}

.sg-options{
  display:flex;
  flex-direction:column;
  gap: 12px;
  padding: 12px 18px 18px;
}

/* Clean, cut card style: no coloured backgrounds, only subtle accent on icon */
.sg-opt{
  --sgAccent: rgba(255,255,255,.18);
  width:100%;
  text-align:left;
  border-radius: 16px;
  padding: 14px 16px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(20,24,44,.82);
  box-shadow: 0 10px 26px rgba(0,0,0,.28);
  display:flex;
  align-items:center;
  gap: 14px;
  transition: transform .12s ease, border-color .12s ease, filter .12s ease, background .12s ease;
  position:relative;
  overflow:hidden;
}
.sg-opt:hover{
  transform: translateY(-1px);
  border-color: rgba(255,255,255,.18);
  background: rgba(22,27,50,.86);
}
.sg-opt:active{ transform: translateY(0); }

.sg-opt .sg-ico{
  width: 44px;
  height: 44px;
  border-radius: 14px;
  display:grid;
  place-items:center;
  flex: 0 0 44px;
  background: rgba(255,255,255,.04);
  border: 1px solid rgba(255,255,255,.10);
  box-shadow: 0 8px 18px rgba(0,0,0,.18);
}
.sg-opt .sg-ico svg{
  width: 24px;
  height: 24px;
  display:block;
  color: var(--sgAccent);
  opacity: .98;
}

.sg-opt .sg-copy{
  flex:1 1 auto;
  min-width:0;
}
.sg-opt .sg-opt-top{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap: 10px;
}
.sg-opt .sg-opt-title{
  font-size: 20px;
  font-weight: 900;
  letter-spacing: .04em;
  text-transform: uppercase;
  color: rgba(245,247,255,.97);
}
.sg-opt .sg-opt-desc{
  margin-top: 6px;
  font-size: 11px;
  font-weight: 800;
  letter-spacing: .10em;
  text-transform: uppercase;
  color: rgba(255,255,255,.52);
  line-height: 1.2;
}
.sg-opt .sg-opt-soon{
  font-size: 11px;
  font-weight: 900;
  letter-spacing: .10em;
  text-transform: uppercase;
  color: rgba(255,122,0,.92);
  white-space: nowrap;
}

/* Mode accents (icon colour only) */
.sg-opt--match{ --sgAccent: var(--shatekiOrange, #ff7a00); }
.sg-opt--tournament{ --sgAccent: rgba(255,255,255,.32); }
.sg-opt--practice{ --sgAccent: #3aa5ff; }
.sg-opt--training{ --sgAccent: #2fe07b; }

.sg-opt.disabled{
  opacity: .55;
  filter: grayscale(.25);
  cursor:not-allowed;
}
.sg-opt.disabled:hover{ transform:none; border-color: rgba(255,255,255,.12); background: rgba(20,24,44,.82); }

.sg-footer{
  padding: 0 18px 16px;
  margin-top: 0;
  background: transparent;
  justify-content:center;
}
.sg-footer .btn{
  width: 140px;
}


/* ===== @CSS:MENU_MODAL | League & Rankings menu styling ===== */
.modal.menu-modal{
  max-width:440px;
  padding:16px 14px 14px;
}
.menu-modal-header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:4px 4px 10px;
}
.icon-btn{
  background:transparent;
  border:1px solid transparent;
  color:#d7dcff;
  border-radius:10px;
  width:38px;
  height:38px;
  display:grid;
  place-items:center;
}
.icon-btn:hover{
  background:rgba(255,255,255,.06);
  border-color:#2a2e48;
}
.menu-modal-title{
  flex:1;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:10px;
  min-width:0;
}
.menu-modal-icon{
  display:flex;
  height:28px;
  align-items:center;
  justify-content:center;
  color:#f6c453;
}
.menu-modal-icon svg{display:block;}
.menu-modal-icon span{
  display:block;
  width:4px;
  border-radius:4px;
  background:#3aa5ff;
}
.menu-modal-icon span:nth-child(1){height:18px;}
.menu-modal-icon span:nth-child(2){height:26px;}
.menu-modal-icon span:nth-child(3){height:14px;}

.menu-modal-title-text{
  font-weight:800;
  letter-spacing:1px;
  font-size:18px;
  color:#fff;
  text-transform:uppercase;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.modal-body.menu-modal-body{
  padding:0 4px 6px;
  overflow:auto;
}
.menu-list{
  display:flex;
  flex-direction:column;
  gap:12px;
  padding:6px 2px 2px;
}
.menu-row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  width:100%;
  padding:14px 14px;
  border-radius:14px;
  border:1px solid #2a2e48;
  background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
  color:#eaf0ff;
  text-align:left;
}
.menu-row:active{transform:translateY(1px);}
.menu-row-left{
  display:flex;
  align-items:center;
  gap:12px;
  min-width:0;
}
.menu-row-icon{
  width:34px;
  height:34px;
  border-radius:12px;
  display:grid;
  place-items:center;
  background:rgba(255,255,255,.05);
  border:1px solid #2a2e48;
  color:var(--accent, #41d3ff);
  flex:0 0 auto;
}
.menu-row-text{
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  min-width:0;
}
.menu-row-label{
  font-weight:700;
  letter-spacing:.2px;
  font-size:15px;
  color:#fff;
  text-transform:none;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.menu-row-desc{
  margin-top:3px;
  font-size:11px;
  letter-spacing:.7px;
  text-transform:uppercase;
  color:rgba(215,220,255,.72);
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.menu-row-right{
  color:rgba(215,220,255,.75);
  flex:0 0 auto;
}

/* Support simple row markup: icon + text + chevron (used by Player Stats menu)
   Without this, justify-content:space-between centers the text block. */
.menu-row > .menu-row-icon{ margin-right:12px; }
.menu-row > .menu-row-text{ flex:1 1 auto; min-width:0; }
.menu-row > .menu-row-chev{
  margin-left:auto;
  color:rgba(215,220,255,.75);
  display:flex;
  align-items:center;
  flex:0 0 auto;
}


/* Admin Hub menu styling (align with current sub-menu look) */
.admin-menu-modal{ max-width:560px; }
.menu-section-label{
  margin:14px 4px 4px;
  padding:2px 6px;
  font-size:11px;
  letter-spacing:1.6px;
  text-transform:uppercase;
  color:rgba(168,172,195,.85);
}
.menu-section-label:first-child{ margin-top:0; }
.danger-row{
  border-color:rgba(255,107,107,.28);
  background:linear-gradient(180deg, rgba(255,107,107,.09), rgba(255,107,107,.03));
}
.danger-row .menu-row-title{ color:#ffe1e1; }
.danger-row .menu-row-icon{
  background:rgba(255,107,107,.12);
  border-color:rgba(255,107,107,.22);
  color:#ffd1d1;
}

/* Title/description typography (used by Player Stats menu) */
.menu-row-title{
  font-weight:700;
  letter-spacing:.2px;
  font-size:15px;
  color:#fff;
  text-transform:none;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.menu-row-sub{
  margin-top:3px;
  font-size:11px;
  letter-spacing:.7px;
  text-transform:uppercase;
  color:rgba(215,220,255,.72);
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

/* Game Complete popup hierarchy */
  .modal.game-complete h3.gc-title{
    font-size:1rem;
    font-weight:600;
    letter-spacing:0.04em;
    text-transform:uppercase;
    opacity:.9;
  }

  .modal.game-complete .gc-result{
    margin-top:6px;
    margin-bottom:10px;
    font-size:1.35rem;
    font-weight:700;
  }

  .modal.game-complete .gc-standings{
    margin-top:4px;
    font-size:.9rem;
    opacity:.9;
  }


  .hs-table{ width:100%; border-collapse:separate; border-spacing:0 }
  .hs-table th, .hs-table td{ padding:.5rem .5rem; border-bottom:1px dashed #23284a; }
  .hs-table th{ text-align:left; color:#cfd3ee; }
  .hs-table th .thSub{ display:block; font-size:.72rem; opacity:.85; font-weight:500; margin-top:2px; }

/* ===== SQ Table (modern league-style) ===== */
.sqTableWrap{ width:100%; }
table.sq-table{
  width:100%;
  border-collapse:separate;
  border-spacing:0;
  border-radius:14px;
  overflow:hidden;
  background: rgba(255,255,255,0.03);
  border:1px solid rgba(255,255,255,0.08);
}
table.sq-table thead th{
  text-align:left;
  padding:12px 14px;
  font-size:.72rem;
  letter-spacing:.14em;
  text-transform:uppercase;
  color: rgba(255,255,255,0.55);
  background: rgba(255,255,255,0.02);
}
table.sq-table tbody td{
  padding:12px 14px;
  border-top:1px solid rgba(255,255,255,0.07);
  font-size:.95rem;
  color: rgba(255,255,255,0.88);
  vertical-align:middle;
}
table.sq-table tbody tr:hover{
  background: rgba(255,255,255,0.04);
}
table.sq-table td.rank{
  width:56px;
  font-weight:800;
  color: var(--sqOrange, #ff7a1a);
}
table.sq-table td.num, table.sq-table th.num{ text-align:right; }
table.sq-table td.muted{ color: rgba(255,255,255,0.55); }
.sqTopRightToggles{ display:flex; gap:8px; align-items:center; }
.sqPill{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:7px 12px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.03);
  color: rgba(255,255,255,0.78);
  font-weight:700;
  font-size:.78rem;
  letter-spacing:.05em;
  cursor:pointer;
  user-select:none;
}
.sqPill.isActive{
  border-color: rgba(255,122,26,0.55);
  background: rgba(255,122,26,0.10);
  color: rgba(255,255,255,0.95);
}

.sq-lm-headrow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  margin: 6px 0 12px;
}
.sqTinyHint{
  margin-top:10px;
  font-size:.82rem;
  color: rgba(255,255,255,0.55);
}


  .hs-table th .thSub{ display:block; font-size:.72rem; opacity:.85; font-weight:600; }

/* >>> PATCH:hs-league-layout START â€” tidy High Score League columns */
.hs-table.hs-league-table{
  table-layout:fixed;
  width:100%;
}
.hs-table.hs-league-table th,
.hs-table.hs-league-table td{
  font-variant-numeric:tabular-nums;
}
/* # column: a bit wider, right-aligned, not crushed against the edge */
.hs-table.hs-league-table th:first-child,
.hs-table.hs-league-table td:first-child{
  width:3.5ch;
  min-width:3.5ch;
  max-width:4ch;
  text-align:right;
  padding-right:0.75rem;
}
/* Player column: main label */
.hs-table.hs-league-table th:nth-child(2),
.hs-table.hs-league-table td:nth-child(2){
  text-align:left;
}
/* High Score: align numbers to the right */
.hs-table.hs-league-table th:nth-child(3),
.hs-table.hs-league-table td:nth-child(3){
  text-align:right;
}
/* When: readable date/time */
.hs-table.hs-league-table th:nth-child(4),
.hs-table.hs-league-table td:nth-child(4){
  text-align:left;
}
/* >>> PATCH:hs-league-layout END */

  .row-practice {
  box-shadow: inset 4px 0 0 0 #ff8a00;
}

  /* Add / Select Player Modals */
  #addPlayerModal.hidden, #selectPlayerModal.hidden, #adminHubModal.hidden, #savedPlayersAdminModal.hidden { display:none; }

  /* Compact admin tables */
  .compact * { font-size: 12px !important; }
  .compact .btn { padding: 4px 8px; font-weight: 600; }
  .compact table th, .compact table td { padding: .35rem .4rem; }
  
  
  /* Latest Scores table tweaks */
.table-wrap th.col-idx, .table-wrap td.col-idx{
  width:1%;
  white-space:nowrap;
  text-align:center;
}
.table-wrap th.when-col, .table-wrap td.when-col{
  white-space:nowrap;
}
  
  
/* >>> PATCH:home-footer-nav START */
.home-footer-nav {
  /* Normal flow (not fixed) so content can scroll naturally */
  position: relative;
  left: auto;
  right: auto;
  bottom: auto;
  z-index: auto;
  width: min(520px, calc(100vw - 32px));
  margin: 10px auto 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  gap: 12px;
  pointer-events: auto;
}
.home-square-row{
  width: min(420px, 94%);
  display:grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
}
.home-square-row .home-square-btn{
  aspect-ratio: 3 / 2; /* reduce height ~33% */
  border-radius: 14px;
  padding: 10px;
  line-height: 1.05;
  font-weight: 800;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  display:flex;
  align-items:center;
  justify-content:center;
  text-align:center;
}
.home-admin-row{
  width: min(420px, 94%);
  display:flex;
  justify-content:center;
}
.home-admin-row .btn{ width: 100%; }
/* <<< PATCH:home-footer-nav END */


/* >>> PATCH:home-live-printer START */
.home-live-printer{
  min-height: 220px;
  max-height: 260px;
  height:clamp(320px,42vh,360px);
  display: flex;
  flex-direction: column;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(6, 10, 20, .78);
  box-shadow: 0 10px 40px rgba(0,0,0,.35);
  overflow: hidden;
  width: min(420px, 94%);
  margin: 22px auto 5px;
}


/* --- HOME: Testing overlays + badges (VIDE / High Score League / Power Rankings) --- */
.home-live-printer .lp-title,
.home-mini-printer .lp-title{
  display:inline-block;
}

.home-live-printer .lp-badge,
.home-mini-printer .lp-badge{
  margin-left:auto;
  display:inline-flex;
  align-items:center;
  gap:6px;
  font-size:10px;
  letter-spacing:.10em;
  text-transform:uppercase;
  color: rgba(210,215,235,.85);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}

.lp-badgeSep{ opacity:.55; }

.lp-dots{ display:inline-flex; gap:4px; margin-left:2px; }
.lp-dots i{
  width:4px; height:4px; border-radius:99px;
  background: rgba(210,215,235,.75);
  opacity:.25;
  animation: lpDotPulse 1.2s infinite;
}
.lp-dots i:nth-child(2){ animation-delay:.20s; }
.lp-dots i:nth-child(3){ animation-delay:.40s; }
@keyframes lpDotPulse{
  0%, 80%, 100% { opacity:.20; transform: translateY(0); }
  40% { opacity:.95; transform: translateY(-1px); }
}

.lp-mid-hold{ position:relative; }

/* Home panels: use centered overlay only (hide corner badge) */
#homeLivePrinter .lp-badge{ display:none !important; }


#homeLivePrinter.is-live .home-hold-overlay{ display:none !important; }
.home-mini-printer.is-live .home-hold-overlay{ display:none !important; }

.home-hold-overlay{
  position:absolute;
  inset: 0;
  z-index: 3;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap: 8px;
  background: rgba(6,10,20,.72);
  backdrop-filter: blur(3px);
  pointer-events:none;
}

/* Center hold content within panel content area (below panel headers) */
#homeLivePrinter .home-hold-overlay{ inset: 34px 0 0 0; }
.home-mini-printer .home-hold-overlay{ inset: 30px 0 0 0; }

.home-hold-overlay-mini{
  background: rgba(6,10,20,.78);
}

.home-hold-title{
  font-size: 16px;
  letter-spacing: .14em;
  font-weight: 900;
  text-transform: uppercase;
  color: rgba(230,235,250,.92);
}

.home-hold-sub{
  font-size: 12px;
  letter-spacing: .12em;
  font-weight: 800;
  text-transform: uppercase;
  color: rgba(255,122,0,.92);
}

.home-hold-sim{
  display:flex;
  gap: 10px;
  margin-top: 2px;
}
.home-hold-sim span{
  width: 28px;
  height: 4px;
  border-radius: 99px;
  background: rgba(230,235,250,.18);
  overflow:hidden;
  position:relative;
}
.home-hold-sim span::after{
  content:'';
  position:absolute;
  top:0; bottom:0;
  width: 60%;
  left: -60%;
  background: linear-gradient(90deg, rgba(255,122,0,0), rgba(255,122,0,.55), rgba(255,122,0,0));
  animation: holdSweep 1.3s infinite;
}
.home-hold-sim span:nth-child(2)::after{ animation-delay:.20s; }
.home-hold-sim span:nth-child(3)::after{ animation-delay:.40s; }
@keyframes holdSweep{
  0% { left:-60%; }
  100% { left: 120%; }
}

/* Ensure START/RESUME match VIDE width */
#details #startGameBtn,
#details #resumeBtn{
  width: min(420px, 94%) !important;
  margin-left:auto;
  margin-right:auto;
}
/* Center key home elements defensively */
#details #startGameBtn,
#details #resumeBtn,
#details #homeLivePrinter{
  display:block;
  margin-left:auto;
  margin-right:auto;
}

/* Meta (HS / PB) */
.home-live-printer .lp-meta{
  padding: 8px 10px;
  display:flex;
  flex-direction:column;
  gap: 4px;
}
.home-live-printer .lp-meta{display:none !important;}
#homeLpHS{display:none !important;}
.home-live-printer hr{display:none !important;}

.home-live-printer .lp-meta-line{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 12px;
  color: rgba(220,255,230,.9);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.home-live-printer .lp-meta-line b{ color: rgba(54,255,122,.95); font-weight: 900; }
.home-live-printer .lp-meta-rule{
  height: 1px;
  background: rgba(255,255,255,.10);
}

/* Top: MATCH_LOG.TXT */
.home-live-printer .lp-top{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 10px 12px;
  font-size: 12px;
  font-weight: 900;
  letter-spacing: .08em;
  text-transform: uppercase;
  color: #36ff7a;
  background: rgba(0,0,0,.22);
}
.home-live-printer .lp-dot{
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #36ff7a;
  opacity: .85;
}
.home-live-printer .lp-top span:last-child{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-weight: 800;
  letter-spacing: .06em;
}

/* Thin rules */
.home-live-printer .lp-rule{
  height: 1px;
  background: rgba(255,255,255,.10);
}

/* Middle: printer table */
.home-live-printer .lp-mid{
  padding: 18px 10px 8px;
  flex: 1;
  display: flex;
  align-items: flex-start;
  overflow: hidden;
}
/* Mini league panels: pull table content up a touch */
.home-mini-printer .lp-mid{ padding-top: 8px; }

.home-live-printer .lp-table{
  width: 100%;
  border-collapse: collapse;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 11px;
  line-height: 1.15;
  color: rgba(220,255,230,.95);
}
.home-live-printer .lp-row{ height: 16px; }
.home-live-printer .lp-row td{ padding: 1px 6px; vertical-align: top; }
.home-live-printer .lp-line{ padding-right: 6px; }
.home-live-printer .lp-ellipsis{
  display:block;
  overflow:hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 100%;
}
.home-live-printer .lp-row.lp-new .lp-line{ color: rgba(20,150,70,.95); }

/* PB / WR / ALERT lines in LIVE UPDATES */
.home-live-printer .lp-row.lp-roundpb .lp-line,
.home-live-printer .lp-row.lp-roundpb .lp-ellipsis{ color: rgba(255, 220, 90, .98) !important; font-weight: 800; }
.home-live-printer .lp-row.lp-gamepb .lp-line,
.home-live-printer .lp-row.lp-gamepb .lp-ellipsis{ color: rgba(255, 220, 90, .98) !important; font-weight: 900; }

/* Any line prefixed with ðŸš¨ (ALERT / PB / WR / NEW PLAYER / ROUND WR) */
.home-live-printer .lp-row.lp-alert .lp-line,
.home-live-printer .lp-row.lp-alert .lp-ellipsis{ color: rgba(255, 220, 90, .98) !important; font-weight: 900; }

/* Records (e.g., NEW GAME RECORD SCORE) */
.lp-record .lp-line, .lp-record .lp-ellipsis{
  color: rgba(255, 220, 90, .98) !important;
  font-weight: 900 !important;
}


/* Bottom: marquee */
.home-live-printer .lp-bottom{
  border-top:1px solid rgba(255,255,255,.08);
  background:rgba(0,0,0,.18);
}


/* The new players marquee sits below the VIDE box */
.home-newplayers{ margin-top: 10px; }
.home-live-printer .lp-marquee{
  margin:0;
  border:0;
  border-radius:0;
  background:transparent;
  padding:0;
  overflow:hidden;
  height:34px;
  display:flex;
  align-items:center;
  white-space:nowrap;
}

.home-live-printer .lp-marquee-track{
  display:inline-block;
  padding:0 14px;
  line-height:34px;
  font-size:12px;
  opacity:.92;
}

@keyframes lpMarquee{
  0%   { transform: translateX(100%); }
  100% { transform: translateX(-110%); }
}


/* <<< PATCH:home-mini-leagues START */
.home-mini-leagues{
  width:min(420px,94%);
  margin:0 auto 18px;
  display:flex;
  gap:14px;
}
@media (max-width: 520px){
  .home-mini-leagues{ flex-direction:column; }
}
.home-mini-printer{
  flex:1;
  min-height:170px;
  max-height:190px;
  display:flex;
  flex-direction:column;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.11);
  overflow:hidden;
  background: rgba(6,10,20,.78);
  box-shadow: 0 10px 40px rgba(0,0,0,.35), 0 0 20px rgba(255,255,255,.04) inset;
}
.home-mini-printer .lp-top{
  display:flex;
  align-items:center;
  gap:10px;
  padding:12px 14px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size:12px;
  letter-spacing:.08em;
  color: rgba(0,255,120,.85);
  text-transform:uppercase;
  background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.08));
}
.home-mini-printer .lp-dot{
  width:8px;
  height:8px;
  border-radius:999px;
  background: rgba(0,255,120,.95);
  box-shadow: 0 0 10px rgba(0,255,120,.45);
}
.home-mini-printer .lp-rule{
  height:1px;
  background: rgba(255,255,255,.09);
}
.home-mini-printer .lp-mid{
  flex:1;
  padding:0px 12px 10px;
  overflow:hidden;
}
.home-mini-printer table.mini-table{
  width:100%;
  border-collapse:collapse;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size:12px;
}
.home-mini-printer table.mini-table thead th{
  padding:6px 6px;
  color: rgba(0,255,120,.85);
  font-weight:700;
  letter-spacing:.08em;
  text-transform:uppercase;
  border-bottom: 1px solid rgba(0,255,120,.25);
}
.home-mini-printer table.mini-table tbody td{
  padding:4px 6px;
  border-bottom: 1px solid rgba(255,255,255,.08);
  color: rgba(220,255,230,.85);
}
.home-mini-printer table.mini-table tbody tr:last-child td{ border-bottom:none; }
.home-mini-muted{
  color: rgba(220,255,230,.55) !important;
  text-align:center;
  font-style:italic;
  padding:10px 0;
}
/* <<< PATCH:home-mini-leagues END */

/* <<< PATCH:home-live-printer END */



.start-actions .btn.big{
  width: 100%;
}


  /* --- FIX: centre bottom nav + admin buttons (and match RESUME styling) --- */
  #details .start-actions .start-secondary-row{
    width: var(--homeW) !important;
    margin: 10px auto 0 !important;
    display: flex !important;
    justify-content: center !important;
    gap: 14px !important;
  }
  #details .start-actions .start-secondary-row .btn{
    height: 74px;
    width: calc((var(--homeW) - 28px) / 3);
    max-width: 160px;
    background: #131733;            /* same as .btn base */
    border-color: #2b3050;
    box-shadow: 0 18px 44px rgba(0,0,0,.28);
  }
  #details .start-actions .start-secondary-row .btn:hover{
    background: #161a3a;
    border-color: #32407a;
    transform: translateY(-2px);
  }

  #details .start-actions .home-admin-row{
    width: var(--homeW) !important;
    margin: 10px auto 0 !important;
    display: flex !important;
    justify-content: center !important;
  }
  #details .start-actions .home-admin-row .btn{
    height: 52px;
    width: calc((var(--homeW) - 28px) / 3); /* same as STATS */
    max-width: 160px;
    background: #131733;
    border-color: #2b3050;
    font-weight: 800;
    letter-spacing: .14em;
    text-transform: uppercase;
  }
  #details .start-actions .home-admin-row .btn:hover{
    background: #161a3a;
    border-color: #32407a;
    transform: translateY(-2px);
  }


/* ===== VIDE HOME: fix footer/nav centering + unstick buttons ===== */
.home-footer-nav{
  position: static !important;
  left: auto !important;
  right: auto !important;
  bottom: auto !important;
  top: auto !important;
  transform: none !important;

  width: var(--homeW, min(420px, 94%)) !important;
  margin: 10px auto 0 !important;
  padding: 0 !important;

  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: flex-start !important;
  gap: 10px !important;
}

.home-square-row{
  width: 100% !important;
  margin: 0 auto !important;
  display: grid !important;
  grid-template-columns: repeat(3, 1fr) !important;
  gap: 14px !important;
  justify-items: stretch !important;
}

.home-admin-row{
  width: 100% !important;
  margin: 0 auto !important;
  display: flex !important;
  justify-content: center !important;
}

.home-admin-row button,
.home-admin-row .btn{
  width: calc((100% - 28px) / 3) !important; /* match one of the 3 square buttons */
  max-width: none !important;
  text-transform: uppercase !important;
}

/* match RESUME button vibe (neutral grey) */
.home-square-row .btn,
.home-admin-row .btn,
.home-square-row button,
.home-admin-row button{
  width:100%; max-width:180px;
  background: transparent;
  border: 0;
  border-radius: 14px;
  padding: 10px 14px;
  display:flex; flex-direction:column; align-items:center; gap:6px;
  color: rgba(150,156,168,0.95);
  letter-spacing: 0.22em;
  text-transform: uppercase;
  box-shadow: none;
  cursor:pointer;
}
.home-admin-row button:hover{ background: transparent; }


/* keep icons/text sizes readable */
.home-square-row .btn span,
.home-admin-row .btn span{
  letter-spacing: .08em !important;
}


/* --- Footer nav alignment + styling (mirrors start-actions nav styles) --- */
.home-footer-nav{
  width: var(--homeW);
  max-width: 92vw;
  margin: 12px auto 0;
}
.home-footer-nav .home-nav-row{
  display:flex;
  gap: var(--navGap, 12px);
  width: 100%;
  align-items: stretch;
  justify-content: space-between;
}
.home-footer-nav .home-nav-row .navBtn{
  flex: 1 1 0;
  height: 64px;
  padding: 0 10px;
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 10px;
  border-radius: 16px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.14);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.06), 0 10px 30px rgba(0,0,0,0.35);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  letter-spacing: 0.08em;
  font-weight: 700;
  text-transform: uppercase;
}
.home-footer-nav .home-nav-row .navBtn .navIcon{
  width: 22px;
  height: 22px;
  display:inline-flex;
}
.home-footer-nav .home-nav-row .navBtn .navIcon svg{
  width: 22px;
  height: 22px;
  fill: none;
  stroke: currentColor;
  stroke-width: 2;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.home-footer-nav .home-nav-row .navBtn .navLabel{
  font-size: 12px;
  line-height: 1;
  text-align:center;
}

/* Color accents (edge + text) */
.home-footer-nav .home-nav-row .navBtn.navGreen{ color:#3cff86; border-color: rgba(60,255,134,0.35); }
.home-footer-nav .home-nav-row .navBtn.navBlue{  color:#4aa3ff; border-color: rgba(74,163,255,0.35); }
.home-footer-nav .home-nav-row .navBtn.navOrange{color:#ffb14a; border-color: rgba(255,177,74,0.35); }

.home-footer-nav .home-nav-row .navBtn:hover{ transform: translateY(-1px); }
.home-footer-nav .home-nav-row .navBtn:active{ transform: translateY(0); }

.home-footer-nav .home-admin-row{
  margin-top: 10px;
  display:flex;
  justify-content:center;
}
.home-footer-nav .adminLink{
  border: none;
  background: transparent;
  color: rgba(255,255,255,0.55);
  cursor: pointer;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap: 6px;
  padding: 6px 8px;
  text-transform: uppercase;
  letter-spacing: 0.18em;
  font-weight: 700;
  font-size: 11px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
.home-footer-nav .adminLink .adminLock{
  width: 18px;
  height: 18px;
  display:inline-flex;
  opacity: 0.75;
}
.home-footer-nav .adminLink .adminLock svg{
  width: 18px;
  height: 18px;
  fill:none;
  stroke: currentColor;
  stroke-width: 2;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.home-footer-nav .adminLink:hover{ color: rgba(255,255,255,0.75); }

/* Ensure the start-actions container doesn't constrain/offset the nav */
#details .start-actions{
  width: var(--homeW);
  max-width: 92vw;
  margin-left:auto;
  margin-right:auto;
}
#details .home-live-printer, #details .hspr-row{
  width: var(--homeW);
  max-width: 92vw;
}



/* Home mini leagues: no headers/green rule */
.home-mini-printer .lp-rule{display:none;}
.mini-table-plain{width:100%;border-collapse:collapse;margin-top:10px;}
.mini-table-plain td{background:transparent !important;border:0 !important;padding:10px 12px;font-size:12.5px;}
.mini-table-plain tr + tr td{border-top:1px solid rgba(255,255,255,0.08) !important;}
.mini-table-plain .mini-rank{width:2.2em;text-align:center;color:rgba(233,238,255,0.65);} 
.mini-table-plain .mini-name{max-width:180px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:rgba(233,238,255,0.88);} 
.mini-table-plain .mini-val{text-align:right;font-variant-numeric:tabular-nums;color:rgba(233,238,255,0.88);} 



/* Admin link: fully transparent (no pill) */
.home-admin-row .adminLink{
  background:transparent !important;
  border:none !important;
  box-shadow:none !important;
  padding:0 !important;
  height:auto !important;
  width:auto !important;
  border-radius:0 !important;
  letter-spacing:0.18em !important;
}
.home-admin-row .adminLink:hover{background:transparent !important;}


/* ===== @CSS:MATCH-SETUP | Players screen redesign ===== */
.ms-topbar{
  display:flex; align-items:center; justify-content:flex-start;
  gap:10px;
  width:100%;
  margin: 0 0 10px;
  padding: 2px 2px 6px;
}
.ms-back{
  width:auto; height:auto;
  border-radius:0;
  background:transparent;
  border:0;
  color:#e7e9f5;
  font-size: 22px;
  line-height: 1;
  padding: 2px 6px 2px 0;
}
.ms-title{
  font-weight: 800;
  letter-spacing: .08em;
  color:#eef0ff;
  font-size: 22px;
}

.ms-title-inline{
  font-weight: 900;
  letter-spacing: .08em;
  color:#eef0ff;
  font-size: 22px;
  margin: 2px 0 10px;
}

.ms-primary{
  background: var(--shatekiOrange) !important;
  border: 1px solid rgba(0,0,0,.25) !important;
  color:#fff !important;
  font-weight: 900;
  letter-spacing: .08em;
}
.ms-primary:disabled{
  opacity:.35;
  filter: grayscale(.3);
}

.ms-primary-blue{
  background: var(--shatekiBlue) !important;
  border: 1px solid rgba(0,0,0,.25) !important;
  color:#fff !important;
  font-weight: 900;
  letter-spacing: .08em;
}
.ms-primary-blue:disabled{ opacity:.35; filter: grayscale(.3); }

.ms-primary-blueLight{
  background: var(--shatekiBlueLight) !important;
  border: 1px solid rgba(0,0,0,.25) !important;
  color:#fff !important;
  font-weight: 900;
  letter-spacing: .08em;
}
.ms-primary-blueLight:disabled{ opacity:.35; filter: grayscale(.3); }

/* Practice CTA sizing to match Match Setup */
.practice-cta{
  height: 52px !important;
  border-radius: 18px !important;
  font-size: 1rem !important;
  font-weight: 900;
  letter-spacing: .08em;
}

.ms-back-bottom{
  width: min(420px, 94%) !important;
  margin: 12px auto 0;
  height: 52px !important;
  border-radius:18px;
  display:block;
  padding: 0 18px !important;
  line-height: 52px;
  box-sizing:border-box;
  font-size: 1rem;
  background: rgba(255,255,255,.03);
  border: 1px solid rgba(255,255,255,.10);
  color: rgba(230,232,255,.75);
  font-weight: 800;
  letter-spacing: .06em;
}
.ms-spacer{ display:none; }

.ms-card{
  background:rgba(255,255,255,.04);
  border:1px solid rgba(255,255,255,.10);
  border-radius:18px;
  padding:16px;
  width: min(640px, 94%);
  margin: 0 auto 16px;
}
.ms-card-title{
  font-size:12px;
  letter-spacing:.12em;
  font-weight:800;
  color: #6aa9ff;
  margin-bottom:12px;
}
.ms-add{
  width:100%;
  height:52px;
  border-radius:16px;
  display:flex;
  align-items:center;
  justify-content:center;
  gap:10px;
  font-weight:800;
  letter-spacing:.08em;
}
.ms-add-registered{
  background: rgba(255,122,0,.12);
  border:1px solid rgba(255,122,0,.26);
  color: rgba(255,205,165,.95);
}
.ms-add-guest{
  margin-top:10px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.12);
  opacity:.75;
}
.ms-add-ic{ font-size:16px; }

.ms-players-list{
  margin-top:14px;
  display:flex;
  flex-direction:column;
  gap:10px;
}
.ms-player-row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  background: rgba(0,0,0,.18);
  border:1px solid rgba(255,255,255,.08);
  border-radius:14px;
  padding:10px 10px;
}
.ms-player-left{
  display:flex;
  align-items:center;
  gap:10px;
  min-width:0;
  flex:1;
}
.ms-player-chip{
  width:28px; height:28px;
  border-radius:10px;
  background: rgba(255,122,0,.20);
  border:1px solid rgba(255,122,0,.40);
  color:#ff7a00;
  display:flex; align-items:center; justify-content:center;
  font-weight:900;
  flex:0 0 auto;
}
.ms-player-name{
  color:#e7e9f5;
  font-weight:700;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.ms-player-input{
  width:100%;
  height:38px;
  border-radius:12px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.12);
  color:#e7e9f5;
  padding:0 12px;
  outline:none;
}
.ms-remove{
  width:40px;
  height:34px;
  border-radius:12px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.12);
  color: rgba(231,233,245,.85);
}
.ms-hint{
  text-align:center;
  color: rgba(231,233,245,.35);
  font-size:11px;
  letter-spacing:.12em;
  font-weight:800;
  margin-top:14px;
  transition: opacity .2s ease;
}
.ms-start{
  width: min(420px, 94%) !important;
  margin: 0 auto 12px;
  height: 52px !important;
  border-radius:18px;
  display:block;
  padding: 0 18px !important;
  line-height: 52px;
  box-sizing:border-box;
  font-size: 1rem;
}
.ms-start:disabled{
  opacity:.35;
  filter: grayscale(.4);
}
.ms-register{
  width: min(420px, 94%) !important;
  margin: 0 auto;
  height: 52px !important;
  border-radius:18px;
  display:block;
  padding: 0 18px !important;
  line-height: 52px;
  box-sizing:border-box;
  font-size: 1rem;
}

/* ===== @CSS:THROW-ORDER | modal ===== */
.modal-throworder{ width: min(680px, 92vw); padding: 0; overflow:hidden; }
.to-top{
  padding: 18px 18px 10px;
  text-align:center;
}
.to-title{
  font-size: 34px;
  font-weight: 900;
  letter-spacing: .06em;
  color:#eef0ff;
}
.to-subtitle{
  margin-top: 6px;
  font-size: 12px;
  letter-spacing: .18em;
  color: rgba(230,232,255,.55);
  font-weight: 700;
}
.to-body{ padding: 10px 18px 14px; }
.to-list{ display:flex; flex-direction:column; gap: 14px; }
.to-row{
  display:flex;
  align-items:center;
  gap: 14px;
  padding: 14px 14px;
  border-radius: 16px;
  background: rgba(255,255,255,.045);
  border: 1px solid rgba(255,255,255,.08);
}
.to-rank{
  width: 34px;
  color: rgba(230,232,255,.35);
  font-weight: 800;
  letter-spacing:.02em;
}
.to-badge{
  width: 44px; height: 44px;
  border-radius: 999px;
  display:flex; align-items:center; justify-content:center;
  background: rgba(0,0,0,.22);
  border: 1px solid rgba(255,255,255,.12);
  color:#eef0ff;
  font-weight: 900;
  letter-spacing:.06em;
}
.to-meta{ flex:1; min-width:0; }
.to-name{
  font-weight: 800;
  color:#eef0ff;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.to-small{
  margin-top: 4px;
  font-size: 11px;
  font-weight: 900;
  letter-spacing: .12em;
  color: var(--shatekiOrange);
}
.to-arrows{
  display:flex;
  flex-direction:column;
  gap: 8px;
  padding-left: 8px;
}
.to-arrow-btn{
  width: 38px; height: 34px;
  border-radius: 10px;
  background: rgba(255,255,255,.04);
  border: 1px solid rgba(255,255,255,.10);
  color:#eef0ff;
  font-weight: 900;
}
.to-arrow-btn:disabled{ opacity:.35; }
.to-actions{
  padding: 0 18px 18px;
  display:flex;
  flex-direction:column;
  gap: 12px;
}
.to-start{
  width: 100%;
  height: 56px;
  border-radius: 14px;
  background: var(--shatekiOrange) !important;
  border: 1px solid rgba(0,0,0,.25) !important;
  font-weight: 900;
  letter-spacing: .08em;
  color:#fff !important;
}

.to-start.to-blueLight{
  background: var(--shatekiBlueLight) !important;
  border: 1px solid rgba(0,0,0,.25) !important;
  color:#fff !important;
}
.to-start .to-start-ic{ margin-left: 10px; }
.to-back{
  width: 100%;
  height: 52px;
  border-radius: 14px;
  background: rgba(255,255,255,.03);
  border: 1px solid rgba(255,255,255,.10);
  color: rgba(230,232,255,.75);
  font-weight: 800;
  letter-spacing: .06em;
  font-size: 1rem;
}

/* ===== @CSS:MATCH-LENGTH | modal ===== */
.ml-modal{ width: min(680px, 92vw); }
.ml-top{
  display:flex; align-items:center; gap:12px;
  padding: 12px 14px 4px;
}
.ml-back{
  width:44px; height:38px;
  border-radius:12px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.10);
  color:#e7e9f5;
}
.ml-title{
  font-weight:900;
  font-size:26px;
  letter-spacing:.08em;
  text-align:center;
}
.ml-sub{
  font-size:11px;
  letter-spacing:.14em;
  font-weight:800;
  color: rgba(231,233,245,.55);
  margin-top:6px;
  text-align:center;
}
.ml-head{ flex:1; display:flex; flex-direction:column; align-items:center; }
.ml-spacer{ width:44px; height:38px; }
.ml-grid{
  display:flex;
  gap:10px;
  justify-content:center;
  align-items:stretch;
  padding: 14px 10px 2px;
}
.ml-tile{
  width:92px;
  height:110px;
  border-radius:18px;
  background: rgba(255,255,255,.05);
  border:1px solid rgba(255,255,255,.10);
  color:#e7e9f5;
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  gap:6px;
}
.ml-tile.selected{
  background: rgba(255,122,0,.12);
  border-color: rgba(255,122,0,.35);
  box-shadow: 0 0 0 2px rgba(255,122,0,.12) inset;
}
.ml-n{
  font-size:30px;
  font-weight:900;
}
.ml-lab{
  font-size:10px;
  letter-spacing:.14em;
  font-weight:900;
  color: rgba(231,233,245,.70);
}
.ml-footer{
  justify-content:center;
  padding-bottom: 14px;
}


/* ===== NEW PLAYER MODAL (Add Player) ===== */
.np-modal{
  width: min(360px, calc(100vw - 28px));
  border-radius: 16px;
  background: rgba(24, 30, 50, .96);
  border: 1px solid rgba(255,255,255,.10);
  box-shadow: 0 18px 40px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.04);
  overflow: hidden;
}
.np-top{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding: 14px 14px 10px;
}
.np-title{
  flex:1;
  text-align:left;
  padding-left: 8px;
  font-weight: 900;
  letter-spacing: .08em;
  color: #e7e9f5;
}
.np-back, .np-close{
  width: 38px;
  height: 38px;
  border-radius: 10px;
  background: rgba(255,255,255,.06);
  border: 1px solid rgba(255,255,255,.10);
  color: rgba(231,233,245,.9);
  font-weight: 900;
  font-size: 18px;
  line-height: 1;
}
.np-close{
  font-size: 22px;
}
.np-back:active, .np-close:active{ transform: translateY(1px); }

.np-body{
  padding: 0 14px 12px;
}
.np-field{ margin-top: 10px; }
.np-label{
  font-size: 11px;
  letter-spacing: .14em;
  font-weight: 900;
  color: rgba(231,233,245,.55);
  text-transform: uppercase;
  margin: 0 0 6px;
}
.np-body input{
  width: 100%;
  height: 44px;
  border-radius: 12px;
  background: rgba(0,0,0,.25);
  border: 1px solid rgba(255,255,255,.12);
  color: #e7e9f5;
  padding: 0 12px;
  outline: none;
}
.np-body input:focus{
  border-color: rgba(255,122,0,.42);
  box-shadow: 0 0 0 3px rgba(255,122,0,.10);
}
.np-nick-row{
  display:flex;
  gap: 10px;
  align-items: center;
}
.np-nick-row input{ flex: 1; }
.np-gen{
  width: 44px;
  height: 44px;
  border-radius: 12px;
  background: rgba(255,255,255,.06);
  border: 1px solid rgba(255,255,255,.12);
  color: rgba(231,233,245,.9);
  font-weight: 900;
  font-size: 18px;
}
.np-gen:active{ transform: translateY(1px); }

.np-footer{
  padding: 12px 14px 14px;
}
.np-save{
  width: 100%;
  height: 54px;
  border-radius: 14px;
  background: rgba(255,255,255,.08);
  border: 1px solid rgba(255,255,255,.12);
  color: rgba(231,233,245,.9);
  font-weight: 900;
  letter-spacing: .06em;
}
.np-save:not([disabled]){
  background: rgba(47,134,255,.18);
  border-color: rgba(47,134,255,.45);
}
.np-save:not([disabled]):hover{ filter: brightness(1.05); }
.np-save:active{ transform: translateY(1px); }
.np-save[disabled]{ opacity: .45; cursor: not-allowed; }


/* D/T number scroller */
.dtScroller{scrollbar-width:none;-ms-overflow-style:none}
.dtScroller::-webkit-scrollbar{display:none}

/* D/T + Bull round pad â€” full width */
.dtPadWrap{
  width:100% !important;
  max-width:none !important;
  margin:0 !important;
  display:grid;
  grid-template-columns: clamp(96px, 18vw, 132px) minmax(0,1fr);
  gap:8px;
  align-items:stretch;
  justify-items:stretch;
}
.dtPadWrap > *{min-width:0}


/* DT/BULL FULLWIDTH FORCE */
.pad{width:100%;}
.dtPadWrap{width:100% !important; max-width:none !important; margin:0 !important; justify-items:stretch !important; align-content:stretch !important;}
.dtRight{width:100% !important;}
.dtX3{
  width:110px;min-width:96px;max-width:132px;
  min-height:122px;
  border-radius:12px;
  background: rgba(120,20,30,.35);
  border:1px solid rgba(255,80,90,.35);
  color: rgba(231,233,245,.95);
  font-weight:900;
  letter-spacing:.02em;
  white-space:pre-line;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  line-height:1.05;
}
/* Fix: prevent D/T + Bull pad drifting to RHS */
.dtX3{width:100%;min-width:0;max-width:none;}
.dtRight{width:100%;}

.dtRight{display:flex;flex-direction:column;flex:1 1 0;min-width:0;gap:6px}
.dtNumBtn{
  height:58px;
  border-radius:12px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.12);
  color: rgba(231,233,245,.95);
  font-weight:900;
  font-size:15px;
  letter-spacing:.02em;
  display:flex;
  align-items:center;
  justify-content:center;
}
.dtNumBtn:active{transform:translateY(1px)}
.dtActions{display:flex;gap:8px;width:100%}
.dtActBtn{
  flex:1 1 0;min-width:0;
  height:58px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.28);
  color: rgba(231,233,245,.92);
  display:flex;
  flex-direction:row;
  align-items:center;
  justify-content:center;
  gap:10px;
  font-weight:900;
}

.dtActBtn .dtIcon{font-size:18px;line-height:1;color: rgba(255,255,255,.90)}
.dtActBtn .dtLbl{font-size:15px;font-weight:900;letter-spacing:.10em}
.dtActBtn.miss{background: rgba(120,20,30,.28); border-color: rgba(255,80,90,.25)}
.dtActBtn.undo{background: rgba(110,80,10,.26); border-color: rgba(255,170,60,.25)}
.dtActBtn.undo .dtIcon{color: rgba(255,140,0,.95)}
.dtActBtn.skip{background: rgba(15,35,85,.28); border-color: rgba(60,120,255,.25)}
.dtActBtn.skip .dtIcon{color: rgba(90,150,255,.95)}
.dtBullRow{display:flex;gap:8px;width:100%}
.dtBullBtn{
  flex:1 1 0;min-width:0;
  height:58px;
  border-radius:12px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.12);
  color: rgba(231,233,245,.95);
  font-weight:900;
  letter-spacing:.10em;
}
.dtBullBtn.inner{color: var(--accent-2); border-color: rgba(255,122,0,.35)}
.dtBullBtn:active{transform:translateY(1px)}


/* === Unified League/Rank popups (Latest Scores aesthetic) === */
.sq-wide-modal{max-width:980px; width:94vw;}
.sq-wide-modal h3{margin:0 0 4px; font-size:18px; font-weight:800; letter-spacing:.02em;}
.sq-wide-modal .modal-body{padding-top:8px;}
.sq-wide-modal .table-wrap,
.sq-wide-modal .latest-scores-table-wrap{
  border:1px solid rgba(255,255,255,.08);
  border-radius:14px;
  overflow:auto;
  max-height:56vh;
}
.sq-wide-modal table{width:100%; border-collapse:collapse; table-layout:fixed;}
.sq-wide-modal thead th{
  font-size:11px;
  letter-spacing:.18em;
  text-transform:uppercase;
  opacity:.65;
  padding:12px 14px;
  background:rgba(255,255,255,.04);
  border-bottom:1px solid rgba(255,255,255,.06);
}
.sq-wide-modal tbody td{
  padding:14px;
  border-bottom:1px solid rgba(255,255,255,.06);
  font-size:14px;
  vertical-align:middle;
}
.sq-wide-modal tbody tr:last-child td{border-bottom:0;}
/* Rank / position column */
.sq-wide-modal tbody td:first-child{
  color:rgba(255,123,26,.95);
  font-weight:800;
}

/* Live / filter buttons: orange edge on active */
.sq-wide-modal .pr-toggle button,
.sq-wide-modal .pl-filters button{
  padding:8px 12px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(10,12,24,.55);
  color:rgba(255,255,255,.85);
  font-weight:700;
  letter-spacing:.02em;
}
.sq-wide-modal .pr-toggle button.active,
.sq-wide-modal .pl-filters button.active{
  border-color:rgba(255,123,26,.85);
  box-shadow:0 0 0 2px rgba(255,123,26,.15) inset;
  background:rgba(255,123,26,.12);
  color:#fff;
}

/* Make league modal footer buttons match (keep existing classes) */
.sq-wide-modal .modal-footer{justify-content:flex-start; gap:10px;}

</style>
<style>
  /* Cloud status pill (top-right) */
.cloud-status {
  position: fixed;
  right: 12px;
  top: 12px;          /* moved from bottom to top */
  bottom: auto;
  background: rgba(10, 12, 30, .92);
  border: 1px solid #2b3050;
  color: var(--muted);
  font-size: 11px;
  padding: 4px 8px;
  border-radius: 999px;
  display: flex;
  align-items: center;
  gap: 6px;
  z-index: 500000;
  pointer-events: none;
}

.cloud-status .cloud-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #666;
}

/* States */
.cloud-status.checking .cloud-dot { background: var(--warn); }
.cloud-status.ok       .cloud-dot { background: var(--accent-2); }
.cloud-status.error    .cloud-dot { background: var(--danger); }


/* Top row of buttons: keep spacing on leaderboard etc. */
#leaderboardTopRow,
#gameTopRow{
margin-bottom: var(--section-gap);
}


/* Main game: stick the scoreboard (Game Wins row) directly to the bottom
   of the floating score block above it. */
.float-head{
  margin-bottom: 0;
}

/* Remove extra top margin on the scoreboard so it touches the float-head */
#scoreWrap{
  margin-top: 0 !important;
}


/* ===== @CSS:MENU_MODAL_EXT | Player Stats menu + select-player form ===== */
.menu-modal-title-sub{
  margin-top:2px;
  font-size:.82rem;
  color:var(--muted);
  font-weight:600;
  letter-spacing:.02em;
  text-transform:none;
}
.menu-modal-form{
  width:100%;
  display:flex;
  flex-direction:column;
  gap:10px;
  padding:8px 2px 4px;
}
.menu-modal-form label{
  font-size:.72rem;
  color:var(--muted);
  letter-spacing:.12em;
  text-transform:uppercase;
  font-weight:700;
}
.menu-modal-actions{
  width:100%;
  display:flex;
  gap:10px;
  padding-top:10px;
}
.menu-modal-actions .btn{
  flex:1;
}
.menu-modal-actions .btn.primary{
  width:100%;
}


/* ===== @CSS:GAME_SCROLL =====
   Body scrolling is intentionally disabled (overflow:hidden).
   These rules make the in-game scoreboard scrollable inside its allocated area,
   especially on mobile where the table can extend beyond the viewport. */
#game{
  height: 100dvh;
}
#game > .card.section{
  height: 100%;
  display: flex;
  flex-direction: column;
  min-height: 0; /* critical: allow overflow children to scroll inside flex */
}
#gameTopRow,
#floatHead{
  flex: 0 0 auto;
}
/* The main scroll container for the live scoreboard */
#scoreWrap{
  flex: 1 1 auto;
  min-height: 0;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  touch-action: pan-y;
}
/* Control pad stays anchored below */
#pad{
  flex: 0 0 auto;
}


/* keep these tiny + shorter */
#leaderboardTopRow .btn,
#gameTopRow .btn{
  font-size: 0.9rem;
  min-height: 34px;
  padding: 6px 10px;
}


/* ===== @CSS:GAME_SCROLL_CLASSIC =====
   Classic in-game scroll behaviour:
   - The PAGE scroll container is .wrap (not the table).
   - Top row (Start Screen / Restart / Stats) scrolls away.
   - Player info block (#floatHead) becomes sticky at the top.
   - Score pad (.pad-bar) stays fixed at the bottom.
*/

/* Game page background palette (match main menu tone) */
body[data-page="game"]{
  background:radial-gradient(1100px 700px at 0% 0%, #192033 0%, #0f1220 52%, #070913 100%);
}
body[data-page="game"] .wrap,
body[data-page="leaderboard"] .wrap{
  height: 100dvh;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  padding-top: 0 !important;
}


/* Game table palette */
body[data-page="game"] #scoreWrap table{ background:rgba(15,18,32,.72); }
body[data-page="game"] #scoreWrap thead th{ background:rgba(23,26,43,.96); }
body[data-page="game"] #scoreWrap tbody th{ background:rgba(16,19,38,.92); }
body[data-page="game"] .float-head{ background:rgba(17,20,34,.94); }
body[data-page="game"] .pad-bar{ background:rgba(17,20,34,.94); }

/* Undo the "internal table scroll" approach for the game page */
body[data-page="game"] #game{
  height: auto !important;
}
body[data-page="game"] #game > .card.section{
  height: auto !important;
  display: block !important;
}

/* Let the scoreboard table flow with the page scroll */
body[data-page="game"] #scoreWrap{
  overflow: visible !important;
  max-height: none !important;
}

/* Prevent the table header from sticking over the sticky player header */
body[data-page="game"] #scoreWrap thead th{
  position: static !important;
}

/* Sticky player info block */
body[data-page="game"] #floatHead{
  position: sticky;
  top: 0;
  z-index: 60;
  background: rgba(23,26,43,.98);
  backdrop-filter: blur(6px);
  border-radius: 12px;
  border-top-left-radius: 0;
  border-top-right-radius: 0;
  border: 1px solid rgba(42,46,72,.85);
}


/* ===== Start Screen sizing (page: #details) ===== */
#details #appTitle{ display:inline-flex; } /* measurable title width */

#details .start-actions{ max-width:none; }

/* Big buttons: 2/3 of title width, max 820px */
#details #questBtn,
#details #startGameBtn,
#details #resumeBtn{
  width: min(calc(var(--title-w) * 0.6667), 820px);
  margin-inline:auto;
}

/* High Scores + Player Stats row: same width as big buttons */
#details .start-actions > .row:first-of-type{
  width: min(calc(var(--title-w) * 0.6667), 820px);
  margin-inline:auto;
}

/* Small screens */
@media (max-width:560px){
  #details #questBtn,
  #details #startGameBtn,
  #details #resumeBtn,
  #details .start-actions > .row:first-of-type{ width:92vw; }
}


/* Make each button line fill that width */
#details .start-actions .btn.big{ width: 100%; }
#details .start-actions .row{ width: 100%; }     /* High Scores / Player Stats row */
#details .start-actions .row .btn{ width: 100%; }

/* ===== Start/Resume visual style (match orange mock) ===== */
#details #startGameBtn,
#details #resumeBtn{
  border-radius: 12px;
  text-transform: uppercase;
  letter-spacing: .08em;
  font-weight: 800;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
}

#details #startGameBtn{
  background: #ff6a00;
  border: 1px solid rgba(255,255,255,.12);
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
  color: #ffffff;
}

#details #resumeBtn{
  background: rgba(255,255,255,.06);
  border: 1px solid rgba(255,255,255,.10);
  color: rgba(255,255,255,.82);
}

#details #resumeBtn[disabled],
#details #resumeBtn.disabled{
  opacity: .55;
  filter: grayscale(.2);
}

#details .btnIcon{
  width: 22px;
  height: 22px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  line-height: 1;
}



/* Secondary navigation buttons + Admin (aligned to main column) */
#details .start-secondary-row{
  width: var(--homeW);
  max-width: var(--homeW);
  margin: 10px auto 0;
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: var(--navGap);
  box-sizing: border-box;
}

#details .start-secondary-row .btn{
  height: 86px;
  border-radius: 18px;
  background: rgba(255,255,255,.06);
  border: 1px solid rgba(255,255,255,.10);
  box-shadow: 0 12px 30px rgba(0,0,0,.35), 0 0 0 1px rgba(255,255,255,.04) inset;
  color: rgba(255,255,255,.86);
  font-weight: 800;
  text-transform: uppercase;
  letter-spacing: .12em;
}
#details .start-secondary-row .btn .navIcon{width:22px;height:22px;display:inline-flex;align-items:center;justify-content:center;}
#details .start-secondary-row .btn .navIcon svg{width:22px;height:22px;}
#details .start-secondary-row .btn .navText{font-size:14px;line-height:1;}

#latestScoresBtn{--acc:#37e08f;color:var(--acc);border-color:rgba(55,224,143,.35);} 
#latestScoresBtn .navIcon{color:var(--acc);} 
#playerStatsBtn{--acc:#4aa7ff;color:var(--acc);border-color:rgba(74,167,255,.35);} 
#playerStatsBtn .navIcon{color:var(--acc);} 
#leagueRankingsBtn{--acc:#ffb24a;color:var(--acc);border-color:rgba(255,178,74,.35);} 
#leagueRankingsBtn .navIcon{color:var(--acc);} 

/* Admin button: same width as one nav tile */
#adminCodeRow{
  width: var(--homeW);
  max-width: var(--homeW);
  margin: 10px auto 22px;
  display: flex;
  justify-content: center;
  box-sizing: border-box;
}
#adminCodeBtn{
  width: calc((var(--homeW) - (2 * var(--navGap))) / 3);
  max-width: 100%;
  height: 58px;
  border-radius: 14px;
  background: rgba(255,255,255,.06);
  border: 1px solid rgba(255,255,255,.10);
  box-shadow: 0 12px 30px rgba(0,0,0,.35), 0 0 0 1px rgba(255,255,255,.04) inset;
  color: rgba(255,255,255,.86);
  font-weight: 800;
  text-transform: uppercase;
  letter-spacing: .12em;
}

/* Final Leaderboard layout */
#leaderboard .lb-box{
  padding:12px;
  border-radius:12px;
  background:linear-gradient(180deg,#14284a,#12213d);
  border:1px solid #2a4777;
}

/* Leaderboard action buttons: full width of the leaderboard table */
#leaderboard .lb-box .stacked-actions{
  display:flex;
  flex-direction:column;
  gap:8px;
  width:100%;
  margin-top:8px;
}

#leaderboard .lb-box .stacked-actions .btn.big{
  width:100%;
  max-width:none;
  display:block;
}

/* table layout + no-wrap for player names */
#leaderboard #lbTable{
  table-layout: fixed; /* respect colgroup widths */
  width: 100%;
}
#leaderboard #lbTable thead th:first-child,
#leaderboard #lbTable tbody td:first-child{
  white-space: nowrap;
  border-right: 1px solid #2a2e48; /* vertical divider after Player */
}

/* divider after the LAST G# column */
#leaderboard #lbTable thead th.after-games-sep,
#leaderboard #lbTable tbody td.after-games-sep{
  border-right: 1px solid #2a2e48;
}

/* widths for numeric columns */
#lbTable thead th:first-child{
  text-align:left;
}

/* keep names tidy on small screens */
#leaderboard #lbTable th:first-child,
#leaderboard #lbTable td:first-child{
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}

/* numbers look better with tabular figures */
#leaderboard #lbTable td,
#leaderboard #lbTable th{ font-variant-numeric: tabular-nums; }

/* subtle zebra + hover */
#leaderboard #lbTable tbody tr:nth-child(odd) td{ background: rgba(255,255,255,.02); }
#leaderboard #lbTable tbody tr:hover td{ background: rgba(255,255,255,.03); }

/* === Start screen Game Ticker (single-line vertical scroll) === */
#psTicker{
  width: 100vw;
  max-width: none;
  margin: 0;

  /* full-bleed even inside centred layout */
  margin-left: calc(50% - 50vw);
  margin-right: calc(50% - 50vw);

  /* Videprinter styling */
  background: linear-gradient(180deg,#fdd45c,#f7b733);
  border-top: 2px solid #b98b00;
  border-bottom: 2px solid #b98b00;
  color: #111;

  /* Single-line strip; one score at a time */
  height: 32px;
  overflow: hidden;

  padding: 0;
  font-size: 0.85rem;
  font-weight: 700;
  font-variant-numeric: tabular-nums;

  /* Pin to bottom on the Start screen */
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  border-radius: 0;
  border-left: 0;
  border-right: 0;
  z-index: 300000;
}


/* === Start screen Extra Ticker (stacked above yellow) === */
#psTickerTop{
  width: 100vw;
  max-width: none;
  margin: 0;
  margin-left: calc(50% - 50vw);
  margin-right: calc(50% - 50vw);
  background: linear-gradient(180deg,#1e2654,#121630);
  border-top: 1px solid rgba(255,255,255,0.10);
  border-bottom: 1px solid rgba(255,255,255,0.10);
  color: #eaf0ff;
  height: 32px;
  overflow: hidden;
  padding: 0;
  font-size: 0.85rem;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  position: fixed;
  left: 0;
  right: 0;
  bottom: 32px;
  border-radius: 0;
  border-left: 0;
  border-right: 0;
  z-index: 300000;
}
#psTickerTop.hidden{display:none;}
/* Hard-disable bottom tickers (removed from UI) */
#psTicker,
#psTickerTop{ display:none !important; }

#psTickerTop .track{
  position: absolute;
  left: 14px;
  right: 14px;
  top: 0;
  height: 100%;
  display: flex;
  align-items: center;
  white-space: nowrap;
  font-size: 0.85rem;
  font-weight: 500;
  letter-spacing: 0.01em;
  line-height: 32px;
  will-change: transform;
  transform: translateY(0);
}
#psTicker.hidden{
  display:none;
}

/* Each line inside the ticker (we use two and slide them) */
#psTicker .track{
  position: absolute;
  left: 14px;
  right: 14px;
  top: 0;
  height: 100%;
  display: flex;
  align-items: center;
  white-space: nowrap;
  font-size: 0.85rem;
  font-weight: 500;
  letter-spacing: 0.01em;
  line-height: 32px;
  will-change: transform;
  transform: translateY(0);
}

/* >>> PATCH:ticker-marquee START */
#psTicker .track,
#psTickerTop .track{
  left: 0;
  right: 0;
  padding: 0 14px;
  overflow: hidden;
}
#psTicker .track .marquee,
#psTickerTop .track .marquee{
  display: inline-flex;
  align-items: center;
  white-space: nowrap;
  min-width: 300%;
  will-change: transform;
  animation: ticker-marquee 18s linear infinite;
}
/* Upper (new players) ticker: single-run scroll with a pause */
#psTickerTop .track .marquee{
  min-width: 0;              /* don't require repeats */
  animation: ticker-marquee-top 77s linear infinite; /* 72s scroll + ~5s pause */
}
#psTicker .track .marquee span,
#psTickerTop .track .marquee span{
  display: inline-block;
  padding-right: 64px;
}
@keyframes ticker-marquee{
  /* Start fully off-screen to the right, then scroll left across the whole ticker */
  0%{ transform: translateX(100%); }
  100%{ transform: translateX(-66.6667%); }
}

@keyframes ticker-marquee-top{
  /* One message: start offscreen right, traverse fully, pause, then restart */
  0%{ transform: translateX(100%); }
  93.5%{ transform: translateX(-100%); }
  100%{ transform: translateX(-100%); }
}
/* <<< PATCH:ticker-marquee END */



/* --- MOT3_47 home layout fixes --- */
#details{
  padding-bottom: calc(260px + env(safe-area-inset-bottom));
}
.home-live-printer .lp-top,
.home-mini-printer .lp-top{
  justify-content: center;
  text-align: center;
}
.home-live-printer .lp-top{
  gap: 0;
}


/* --- HOME NAV (Player Hub / Stats / League) --- */
#details .start-actions .home-nav-row{
  width: var(--homeW);
  margin: 12px auto 0;
  display: grid !important;
  grid-template-columns: repeat(3, 1fr);
  gap: 18px;
}
#details .start-actions .home-nav-row .navBtn.btn{
  width: 100%;
  max-width: none;
  min-height: 58px;
  padding: 0 14px;
  border-radius: 16px;
  background: #131733;
  border: 1px solid #2b3050;
  box-shadow: 0 10px 22px rgba(0,0,0,.28), inset 0 1px 0 rgba(255,255,255,.05);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  text-transform: uppercase;
  letter-spacing: .12em;
  font-weight: 800;
  font-size: 12px;
  line-height: 1;
  color: var(--ink);
}
#details .start-actions .home-nav-row .navBtn.btn .navIcon{
  display: inline-flex;
  width: 20px;
  height: 20px;
}
#details .start-actions .home-nav-row .navBtn.btn .navIcon svg{
  width: 20px;
  height: 20px;
}
#details .start-actions .home-nav-row .navBtn.btn:active{ transform: translateY(1px); }

/* Theme edges + text */
#details .start-actions .home-nav-row .navGreen{ color: #22e46b; border-color: rgba(34,228,107,.55); }
#details .start-actions .home-nav-row .navBlue{ color: #2f86ff; border-color: rgba(47,134,255,.55); }
#details .start-actions .home-nav-row .navAmber{ color: #ff9b22; border-color: rgba(255,155,34,.55); }

#details .start-actions .home-nav-row .navBtn.btn:hover{
  filter: brightness(1.05);
}

/* --- ADMIN (text link with lock) --- */
#details .start-actions .home-admin-row{
  width: var(--homeW);
  margin: 10px auto 0;
  display: flex;
  justify-content: center;
}
#details .start-actions .adminLink{
  background: transparent;
  border: 0;
  padding: 6px 10px 2px;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  color: rgba(230,230,230,.55);
  font-weight: 800;
  letter-spacing: .22em;
  text-transform: uppercase;
}
#details .start-actions .adminLink .adminLock{
  display: inline-flex;
  width: 16px;
  height: 16px;
  opacity: .9;
}
#details .start-actions .adminLink .adminLock svg{
  width: 16px;
  height: 16px;
}
#details .start-actions .adminLink:hover{ color: rgba(230,230,230,.8); }
</style>
</head>
<body data-page="details">
<!-- ===== @HTML:SCREENS ===== -->

  <div class="wrap">

    <!-- PAGE 1: GAME DETAILS -->
    <section id="details" class="card section">
<h2 id="appTitle"><span class="titleMain">SHATEKI</span><span class="titleSub">QUEST</span></h2>
      <div class="start-actions column" style="gap:8px">
        <button id="questBtn" class="btn primary big" type="button">New game â–¶</button>
                <button id="tournamentBtn" class="btn big" type="button">TOURNAMENT</button>
<button id="resumeBtn" class="btn secondary big" type="button" disabled title="No saved match"><span class="btnIcon">â†º</span><span class="btnLabel">RESUME GAME</span></button>

        <div class="row start-secondary-row home-nav-row">
  <button id="latestScoresBtn" class="btn navBtn navGreen" type="button">
    <span class="navIcon" aria-hidden="true">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/>
        <circle cx="9" cy="7" r="4"/>
        <path d="M22 21v-2a4 4 0 0 0-3-3.87"/>
        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
      </svg>
    </span>
    <span class="navText">PLAYER HUB</span>
  </button>

  <button id="playerStatsBtn" class="btn navBtn navBlue" type="button">
    <span class="navIcon" aria-hidden="true">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M3 3v18h18"/>
        <path d="M7 15v3"/>
        <path d="M12 11v7"/>
        <path d="M17 6v12"/>
      </svg>
    </span>
    <span class="navText">STATS</span>
  </button>

  <button id="leagueRankingsBtn" class="btn navBtn navAmber" type="button">
    <span class="navIcon" aria-hidden="true">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M8 21h8"/>
        <path d="M12 17v4"/>
        <path d="M7 4h10"/>
        <path d="M17 4v5a5 5 0 0 1-10 0V4"/>
        <path d="M5 6h2v3a4 4 0 0 1-2-3z"/>
        <path d="M19 6h-2v3a4 4 0 0 0 2-3z"/>
      </svg>
    </span>
    <span class="navText">LEAGUE &amp; RANKS</span>
  </button>
</div>

<!-- Admin (text link) -->
<div class="row home-admin-row" id="adminCodeRow">
  <button id="adminCodeBtn" class="adminLink" type="button">
    <span class="adminLock" aria-hidden="true">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="5" y="11" width="14" height="10" rx="2"/>
        <path d="M8 11V8a4 4 0 0 1 8 0v3"/>
      </svg>
    </span>
    <span class="adminText">ADMIN</span>
  </button>
</div>
      </div>

<div id="psTickerTop" class="hidden"><div class="track"></div></div>

<div id="psTicker" class="hidden"><div class="track"></div></div>
</section>

<!-- PAGE 2: PLAYER SELECT -->
<section id="players" class="card section hidden">
  <div class="ms-card">
    <div class="ms-title-inline">MATCH SETUP</div>
    <div class="ms-card-title">ADD PLAYERS</div>

    <button id="msAddRegisteredBtn" class="btn ms-add ms-add-registered" type="button">
      <span class="ms-add-ic">ðŸ‘¤</span>
      <span>ADD SAVED PLAYER</span>
    </button>

    <button id="msAddGuestBtn" class="btn ms-add ms-add-guest" type="button">
      <span class="ms-add-ic">ï¼‹</span>
      <span>ADD GUEST PLAYER</span>
    </button>

    <div id="msPlayersList" class="ms-players-list"></div>

    <div id="msMinHint" class="ms-hint">ADD 2+ PLAYERS TO START MATCH</div>
  </div>

  <button id="startMatchBtn" class="btn ms-start ms-primary" type="button" disabled>
    SELECT MATCH LENGTH <span class="ms-arrow">â–¶</span>
  </button>

  <button id="msRegisterPlayerBtn" class="btn ms-register" type="button">
    ï¼‹ SAVE NEW PLAYER
  </button>


  <button id="startScreenBtn" class="btn ms-back-bottom" type="button">â† BACK</button>
</section> <!-- end #players -->

   <!--PAGE3: GAME -->
<section id="game" class="hidden">
  <div class="card section">
<!-- Floating names + wins + totals -->
        <div class="float-head" id="floatHead">
          
      <div id="fhMenuWrap" class="fh-menu-wrap">
        <div class="row fh-menu" id="gameTopRow">
      <button id="startScreenBtnGame" class="btn letter-throw top-throw">Start Screen</button>
      <button id="restartGameBtnGame" class="btn letter-throw top-throw">Restart Game</button>
      <button id="statsHubBtnGame" class="btn letter-throw top-throw">Stats</button>
    </div>
      </div>
      <div id="fhMenuLine" class="fh-menu-line" aria-hidden="true"></div>
<div class="table-wrap" id="floatWrap">
            <table aria-hidden="true"><thead id="floatThead"></thead></table>
          </div>
          <div id="turnBar" class="turn-bar" aria-hidden="true"></div>
        </div>

        <div id="gameScrollGate">

        <!-- Scoreboard -->
        <div class="table-wrap" id="scoreWrap" style="margin-top:10px">
          <div id="roundBar" class="round-bar" aria-hidden="true"></div>
          <div id="roundSeamBar" class="round-seam-bar" aria-hidden="true"></div>
          <table aria-label="Scoreboard">
            <thead id="thead"></thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>

        <!-- Hidden stats tables used to keep column widths aligned -->
        <div class="stats-box">
          <div class="table-wrap" id="statsWrap">
            <table aria-label="Player statistics">
              <thead id="statsThead"></thead>
              <tbody id="statsTbody"></tbody>
            </table>
          </div>
        </div>
        <div class="stats-box">
          <div class="table-wrap" id="mstatsWrap">
            <table aria-label="Match statistics">
              <thead id="mstatsThead"></thead>
              <tbody id="mstatsTbody"></tbody>
            </table>
          </div>
        </div>

        <div id="endBanner" class="banner hidden"></div>
      </div>

      </div>
    </section>

<section id="leaderboard" class="card section hidden">
  <!-- Mirror the in-game top row (3 buttons, same sizing) -->
  <div class="row" id="leaderboardTopRow">
    <button id="startScreenBtnLB" class="btn letter-throw top-throw">Start Screen</button>
    <button id="restartGameBtnLB" class="btn letter-throw top-throw">Restart Game</button>
    <button id="statsHubBtnFinal" class="btn letter-throw top-throw">Stats</button>
  </div>

  <!-- Leaderboard in its own box -->
  <div class="lb-box" style="margin-top:8px;">
    <h2 style="margin-top:0;">Leaderboard</h2>
 <p class="tag hidden" style="margin-top:6px;"><span id="lbMatchInfo"></span></p>

    <div class="table-wrap" style="margin-top:8px">
      <table id="lbTable">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
      <!-- Stacked, centered actions -->
  <div class="stacked-actions">
    <button id="gameScoresBtn" class="btn big" type="button">GAME SCORES</button>
    <button id="highScoresMenuBtnLB" class="btn big" type="button">HIGH SCORES</button>

    <!-- NEXT GAME (shown while match ongoing) -->
    <button id="nextGameBtn" class="btn primary big" type="button">NEXT GAME â–¶</button>

    <!-- END MATCH (replaces NEXT GAME when match complete) -->
    <button id="newMatchBtn" class="btn danger big hidden" type="button">END MATCH</button>

  </div>
  </div>

</section>

  </div><!-- /.wrap -->

    <!-- Fixed Throw Pad (Game Stats / Match Stats / High Scores / Race appear here) -->
    <div class="pad-bar" id="padBar">
      <!-- keep your existing inner markup exactly as it is -->
      <div class="pad-inner">
        <div class="pad-head">
          <div class="pad-left">
            <div id="padHint" class="pad-hint"></div>
          </div>
        </div>
        <div id="pad" class="pad"></div>
      </div>
    </div>
    
    <div id="gifOverlay" class="gif-overlay hidden"></div>

    <!-- Add Player Modal -->
    <div id="addPlayerModal" class="modal-backdrop hidden">
      <div class="modal np-modal" role="dialog" aria-modal="true" aria-labelledby="npTitle">
        <div class="np-top">
          <button id="npBackBtn" class="np-back" type="button" aria-label="Back">â†</button>
          <div id="npTitle" class="np-title">NEW PLAYER</div>
          <button id="npCloseBtn" class="np-close" type="button" aria-label="Close">Ã—</button>
        </div>

        <div class="modal-body np-body">
          <div class="np-field">
            <div class="np-label">FIRST NAME</div>
            <input id="newPlayerFirst" type="text" autocomplete="given-name" placeholder="e.g. Luke" />
          </div>

          <div class="np-field np-nick">
            <div class="np-label">NICKNAME</div>
            <div class="np-nick-row">
              <input id="newPlayerNickname" type="text" autocomplete="off" placeholder="e.g. The Nuke" />
              <button id="genNicknameBtn" class="np-gen" type="button" aria-label="Generate nickname">âŸ³</button>
            </div>
          </div>

          <div class="np-field">
            <div class="np-label">LAST NAME</div>
            <input id="newPlayerLast" type="text" autocomplete="family-name" placeholder="e.g. Littler" />
          </div>

          <div class="np-field">
            <div class="np-label">INITIALS</div>
            <input id="newPlayerInitials" type="text" inputmode="text" maxlength="3" autocomplete="off" placeholder="e.g. LL" />
          </div>
        </div>

        <div class="modal-footer np-footer">
          <button id="savePlayerBtn" class="btn np-save" type="button" disabled>ðŸ’¾ SAVE PLAYER</button>
        </div>
      </div>
    </div>

<!-- Select Player Modal -->
<div id="selectPlayerModal" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Select Player</h3>
    <div class="modal-body">
      <div class="stack">
        <label class="tag">Player Name</label>
        <select id="existingPlayerSelect" style="width: 100%;">
          <option value="">Select a saved player...</option>
        </select>
      </div>
    </div>
    <div class="modal-footer">
      <button id="cancelSelectPlayerBtn" class="btn" type="button">Cancel</button>
<button id="confirmSelectPlayerBtn" class="btn primary" type="button">Enter</button>

    </div>
  </div>
</div>

<!-- Start Game Modal (Home > START GAME >) -->
<div id="startGameModal" class="modal-backdrop hidden">
  <div class="modal sg-modal">
    <div class="sg-head">
      <div class="sg-title">SELECT GAME MODE</div>
      <div class="sg-sub">CHOOSE HOW YOU WANT TO PLAY</div>
    </div>
    <div class="modal-body">
      <div id="startGameModalBody" class="sg-options"></div>
    </div>
    <div class="modal-footer sg-footer">
      <button id="closeStartGameModalBtn" class="btn" type="button">Back</button>
    </div>
  </div>
</div>


<!-- Match Length Modal (Players > Start Match) -->
<div id="matchLengthModal" class="modal-backdrop hidden">
  <div class="modal ml-modal">
    <div class="ml-top">
      <button id="mlBackBtn" class="ml-back" type="button" aria-label="Back">â†</button>
      <div class="ml-head">
        <div class="ml-title">MATCH LENGTH</div>
        <div class="ml-sub">SELECT NUMBER OF GAMES</div>
      </div>
      <div class="ml-spacer"></div>
    </div>

    <div class="modal-body">
      <div id="mlGrid" class="ml-grid" role="group" aria-label="Select number of games"></div>
    </div>

    <div class="modal-footer ml-footer">
      <!-- Styled to match Match Setup CTAs; label swaps via JS based on mode -->
      <button id="mlStartBtn" class="btn ms-start ms-primary" type="button" disabled>THROW ORDER <span class="ms-arrow">â–¶</span></button>
    </div>
  </div>
</div>
<!-- Admin Hub Modal -->
<div id="adminHubModal" class="modal-backdrop hidden">
  <div class="modal menu-modal admin-menu-modal">
    <div class="menu-modal-header">
      <button id="closeAdminHubBtn" class="icon-btn" type="button" aria-label="Back">
        <span style="font-size:18px;line-height:1;">â†</span>
      </button>

      <div class="menu-modal-title">
        <div class="menu-modal-title-text">ADMIN HUB</div>
        <div class="menu-modal-title-sub">Tools & maintenance</div>
      </div>

      <button id="closeAdminHubBtnX" class="icon-btn" type="button" aria-label="Close">
        <span style="font-size:18px;line-height:1;">âœ•</span>
      </button>
    </div>

    <div class="menu-modal-body">
      <div class="menu-section-label">GAMES</div>
      <div class="menu-list">
        <button id="openAllGamesBtn" class="menu-row" type="button">
          <span class="menu-row-icon">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
              <path d="M3 7h18"/><path d="M6 7v14"/><path d="M18 7v14"/><path d="M6 11h12"/><path d="M6 15h12"/><path d="M6 19h12"/>
            </svg>
          </span>
          <span class="menu-row-text">
            <span class="menu-row-title">All Games</span>
            <span class="menu-row-sub">Browse recent matches</span>
          </span>
          <span class="menu-row-chev">â€º</span>
        </button>
      </div>

      <div class="menu-section-label">LEAGUE</div>
      <div class="menu-list">
        <button id="openHsLeagueAdmin" class="menu-row" type="button">
          <span class="menu-row-icon">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
              <path d="M7 21h10"/><path d="M9 17h6"/><path d="M8 4h8l-1 6H9z"/><path d="M9 10v7"/><path d="M15 10v7"/>
            </svg>
          </span>
          <span class="menu-row-text">
            <span class="menu-row-title">League High Scores</span>
            <span class="menu-row-sub">Official leaderboard maintenance</span>
          </span>
          <span class="menu-row-chev">â€º</span>
        </button>

        <button id="openHsPracticeAdmin" class="menu-row" type="button">
          <span class="menu-row-icon">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
              <path d="M12 2v5"/><path d="M6 7h12"/><path d="M7 7l2 15h6l2-15"/><path d="M9 12h6"/>
            </svg>
          </span>
          <span class="menu-row-text">
            <span class="menu-row-title">Practice High Scores</span>
            <span class="menu-row-sub">Non-official leaderboard</span>
          </span>
          <span class="menu-row-chev">â€º</span>
        </button>

        <button id="openLeagueLowsAdmin" class="menu-row" type="button">
          <span class="menu-row-icon">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
              <path d="M4 17l6-6 4 4 6-8"/><path d="M20 7v6h-6"/>
            </svg>
          </span>
          <span class="menu-row-text">
            <span class="menu-row-title">League Low Scores</span>
            <span class="menu-row-sub">Official low-score table</span>
          </span>
          <span class="menu-row-chev">â€º</span>
        </button>
      </div>

      <div class="menu-section-label">PLAYERS</div>
      <div class="menu-list">
        <button id="openSavedPlayersAdminBtn" class="menu-row" type="button">
          <span class="menu-row-icon">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
              <path d="M20 21v-2a4 4 0 0 0-3-3.8"/><path d="M4 21v-2a4 4 0 0 1 3-3.8"/><path d="M12 12a4 4 0 1 0-4-4 4 4 0 0 0 4 4z"/>
            </svg>
          </span>
          <span class="menu-row-text">
            <span class="menu-row-title">Saved Player Admin</span>
            <span class="menu-row-sub">Edit names, initials & nicknames</span>
          </span>
          <span class="menu-row-chev">â€º</span>
        </button>

        <button id="openPBGRAdminBtn" class="menu-row" type="button">
          <span class="menu-row-icon">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
              <path d="M12 2l3 7h7l-5.5 4 2 7-6.5-4.5L5.5 20l2-7L2 9h7z"/>
            </svg>
          </span>
          <span class="menu-row-text">
            <span class="menu-row-title">PB / GR Admin</span>
            <span class="menu-row-sub">Personal best & game record tools</span>
          </span>
          <span class="menu-row-chev">â€º</span>
        </button>
      </div>

      <div class="menu-section-label">DATA</div>
      <div class="menu-list">
        <button id="openDataAdminBtn" class="menu-row" type="button">
          <span class="menu-row-icon">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
              <path d="M4 4h16v16H4z"/><path d="M8 8h8"/><path d="M8 12h8"/><path d="M8 16h8"/>
            </svg>
          </span>
          <span class="menu-row-text">
            <span class="menu-row-title">DATA</span>
            <span class="menu-row-sub">Dashboards & metrics</span>
          </span>
          <span class="menu-row-chev">â€º</span>
        </button>

        <button id="fixDuplicatesBtn" class="menu-row danger-row" type="button">
          <span class="menu-row-icon">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
              <path d="M12 9v4"/><path d="M12 17h.01"/><path d="M10.3 3.3h3.4L22 21H2z"/>
            </svg>
          </span>
          <span class="menu-row-text">
            <span class="menu-row-title">Remove Duplicate High Scores</span>
            <span class="menu-row-sub">Cleanup helper (use carefully)</span>
          </span>
          <span class="menu-row-chev">â€º</span>
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Data Modal -->
<div id="dataAdminModal" class="modal-backdrop hidden">
  <div class="modal compact">
    <h3>DATA</h3>
    <div class="modal-body">
      <p class="tag" id="dataPlayersCount">Number of saved players 0</p>
      <p class="tag" id="dataNewPlayers7">New saved players (past 7 days) 0</p>
      <hr style="margin:10px 0; border:0; border-top:1px solid #23284a;">
      <div class="column" style="align-items:center; gap:8px;">
        <button id="dataDailyGamesBtn" class="btn" style="width:min(360px,92%);">Daily Games</button>
        <button id="dataUniqueLogonsBtn" class="btn" style="width:min(360px,92%);">Unique Log Ons</button>
      </div>
    </div>
    <div class="modal-footer">
      <button id="dataAdminBackBtn" class="btn" type="button">Back</button>
      <button id="dataAdminCloseBtn" class="btn" type="button">Close</button>
    </div>
  </div>
</div>

<!-- Data Chart Modal -->
<div id="dataChartModal" class="modal-backdrop hidden">
  <div class="modal compact">
    <h3 id="dataChartTitle">Chart</h3>
    <div class="modal-body">
      <div class="row" style="gap:8px; flex-wrap:wrap; justify-content:center; margin-bottom:10px;">
        <button id="dataChartRangeDaily"  class="btn small range active" type="button">Daily</button>
        <button id="dataChartRangeWeekly" class="btn small range" type="button">Weekly</button>
        <button id="dataChartRangeMonthly" class="btn small range" type="button">Monthly</button>
        <button id="dataChartRangeYearly" class="btn small range" type="button">Yearly</button>
      </div>
      <div style="border-radius:12px;border:1px solid #23284a;padding:8px;background:#101533;min-height:260px;">
        <canvas id="dataChartCanvas" width="640" height="320" style="width:100%; height:auto;"></canvas>
      </div>
      <p class="tag" id="dataChartHint">Horizontal: Date, Vertical: Count</p>
    </div>
    <div class="modal-footer">
      <button id="dataChartBackBtn" class="btn" type="button">Back</button>
      <button id="dataChartCloseBtn" class="btn" type="button">Close</button>
    </div>
  </div>
</div>
</div>

<!-- All Games Modal -->
<div id="allGamesModal" class="modal-backdrop hidden">
  <div class="modal compact">
    <h3>All Games</h3>
    <div class="modal-body" id="allGamesBody">
      <div id="allGamesTableWrap"></div>
    </div>
    <div class="modal-footer">
      <button id="allGamesBackBtn" class="btn" type="button">Back</button>
      <button id="allGamesCloseBtn" class="btn" type="button">Close</button>
    </div>
  </div>
</div>

<!-- League Low Scores Admin Modal -->
<div id="leagueLowsAdminModal" class="modal-backdrop hidden">
  <div class="modal compact">
    <h3>League Low Scores â€” Admin</h3>
    <div class="modal-body" id="leagueLowsAdminBody">
      <p class="tag">Loading league low scoresâ€¦</p>
    </div>
    <div class="modal-footer">
      <button id="leagueLowsBackBtn" class="btn" type="button">Back</button>
      <button id="leagueLowsCloseBtn" class="btn" type="button">Close</button>
    </div>
  </div>
</div>

<!-- PB / GR Admin Modal -->
<div id="pbgrAdminModal" class="modal-backdrop hidden">
  <div class="modal compact">
    <h3>PB / GR Admin</h3>
    <div class="modal-body">
      <p class="tag">Manage Personal Bests and Game Records. Deleting a row will remove the underlying round from the cloud.</p>
      <h4 style="margin-top:8px;">World Records (All Players)</h4>
      <div id="pbgrGlobal"></div>
      <hr style="margin:10px 0;">
      <div class="row" style="align-items:center; gap:8px;">
        <select id="pbgrPlayerSelect" style="flex:1; min-width: 180px;">
          <option value="">Select a saved playerâ€¦</option>
        </select>
        <button id="pbgrRefreshBtn" class="btn" type="button">Refresh</button>
      </div>
      <div class="row" style="margin-top:10px; gap:8px; align-items:center;">
        <button id="pbgrBackfillBtn" class="btn warn" type="button">Backdate PB / WR</button>
        <span class="tag">Scan cloud throws (saved players, official games) and write PBs + WRs to cloud tables.</span>
      </div>
      <div id="pbgrPlayer" style="margin-top:8px;"></div>
    </div>
    <div class="modal-footer">
      <button id="pbgrBackBtn" class="btn" type="button">Back</button>
      <button id="pbgrCloseBtn" class="btn" type="button">Close</button>
    </div>
  </div>
</div>

  <!-- Round High Scores (public) -->
  <div id="roundHighScoresModal" class="modal-backdrop hidden">
    <div class="modal compact">
      <h3>Round High Scores</h3>
      <div class="modal-body" id="roundHSBody">
        <p class="tag">Loadingâ€¦</p>
      </div>
      <div class="modal-footer">
        <button id="roundHSBackBtn" class="btn" type="button">Back</button>
        <button id="roundHSCloseBtn" class="btn" type="button">Close</button>
      </div>
    </div>
  </div>

    <!-- Saved Players Admin Modal -->
    <div id="savedPlayersAdminModal" class="modal-backdrop hidden">
      <div class="modal compact">
        <h3>Saved Players Admin</h3>
        <div class="modal-body">
          <div id="savedPlayersAdminBody"></div>
        </div>
        <div class="modal-footer">
          <button id="backSavedPlayersAdminBtn" class="btn" type="button">Back</button>
          <button id="closeSavedPlayersAdminBtn" class="btn" type="button">Close</button>
        </div>
      </div>
    </div>

    <!-- Cloud Status -->
    <div id="cloudStatus" class="cloud-status checking">
      <span class="cloud-dot"></span>
      <span id="cloudStatusText">Checking cloudâ€¦</span>
    </div>
    <script>
// ===== JS: BOOT / GLOBALS =====


// ===== SQ NAV INDEX (CTRL+F KEYS) =====
/*
  STYLE
  - @CSS:TOKENS
  - @CSS:HOME
  - @CSS:MODALS
  - @CSS:TICKER

  HTML (STATIC DOM)
  - @HTML:SCREENS
  - @HTML:MODALS
  - @HTML:ADMIN

  JS (PUBLIC ENTRYPOINTS / CORE)
  - @JS:BOOT
  - @JS:UI:HOME
  - @JS:UI:GAME
  - @JS:UI:ADMIN
  - @JS:CLOUD:SUPABASE_INIT
  - @JS:CLOUD:PLAYERS
  - @JS:CLOUD:GAMES
  - @JS:CLOUD:HIGHSCORES

  MODALS (OPENERS)
  - @JS:MODAL:LEAGUE_RANKINGS
  - @JS:MODAL:HIGH_SCORE_LEAGUE
  - @JS:MODAL:PREMIER_LEAGUE
  - @JS:MODAL:LATEST_SCORES

  PATCHES
  - @PATCHES:REGISTRY
  - @PATCH:<name>  (search the patch name exactly as printed)
*/
// ===== @JS:BOOT =====
// ===== @JS:UTIL:UI_MUTATION_BUS =====
// Single DOM mutation observer + per-frame flush (replaces many per-feature MutationObservers)
(function(){
  if (window.__sqUIMutationBus) return;

  const listeners = new Set();
  let pending = false;
  /** @type {MutationRecord[]} */
  let buf = [];

  function flush(){
    pending = false;
    const muts = buf;
    buf = [];
    for (const fn of listeners){
      try { fn(muts); } catch(e){ try{ console.warn('sqUIMutationBus listener failed', e); }catch(_){ } }
    }
  }

  function schedule(){
    if (pending) return;
    pending = true;
    const raf = window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : (cb)=>setTimeout(cb, 0);
    raf(flush);
  }

  const mo = new MutationObserver((muts)=>{
    if (muts && muts.length) {
      buf = buf.concat(muts);
      schedule();
    }
  });

  function start(){
    const root = document.body || document.documentElement;
    if (!root) return;
    try {
      mo.observe(root, { childList:true, subtree:true, characterData:true });
    } catch(_){}
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', start, { once:true });
  } else {
    start();
  }

  window.__sqUIMutationBus = {
    on(fn){
      if (typeof fn !== 'function') return ()=>{};
      listeners.add(fn);
      return ()=>{ try{ listeners.delete(fn); }catch(_){ } };
    },
    emit(){ try{ schedule(); }catch(_){ } }
  };
})();


// Global guard: some thirdâ€‘party embeds reference a global `F`; define a harmless fallback
if (typeof window.F === 'undefined') {
  window.F = function(){ /* no-op */ };
}

// Compute the per-dart symbol for a given dart + round
function symbolForDart(d, rd){
  // No dart thrown yet
  if (!d || (typeof d.points === 'undefined' && !d.kind)) return { ch: 'â—‹', cls: '' };
  // Miss (no points registered)
  if (!d || Number(d.points || 0) === 0){
    // Bulls: if it's marked as a Bull hit, show 50 / 25 even if points werenâ€™t recorded
    if (rd && rd.type === 'bull' && d && d.kind === 'Bull'){
      const isInner = (d.bull === 'Inner');
      return { ch: isInner ? '50' : '25', cls: '' };
    }
    return { ch: 'âœ•', cls: 'miss' };
  }

  // Number rounds
  if (rd && rd.type === 'number'){
    const k = (d.kind || '').toUpperCase();
    if (k === 'TRIPLE' || k === 'T') return { ch: 'T', cls: '' };
    if (k === 'DOUBLE' || k === 'D') return { ch: 'D', cls: '' };
    return { ch: 'S', cls: '' };
  }

  // Doubles / Triples with explicit numbers
  if (rd && rd.type === 'doubles'){
    const pts = Number(d.points || 0);
    let n = pts ? pts / 2 : null;
    if (!Number.isInteger(n) || n < 1 || n > 20){
      const t = Number(d.target ?? d.num ?? d.number ?? NaN);
      if (Number.isInteger(t) && t >= 1 && t <= 20) n = t;
    }
    const label = Number.isInteger(n) ? `D${n}` : 'D?';
    return { ch: label, cls: '' };
  }
  if (rd && rd.type === 'triples'){
    const pts = Number(d.points || 0);
    let n = pts ? pts / 3 : null;
    if (!Number.isInteger(n) || n < 1 || n > 20){
      const t = Number(d.target ?? d.num ?? d.number ?? NaN);
      if (Number.isInteger(t) && t >= 1 && t <= 20) n = t;
    }
    const label = Number.isInteger(n) ? `T${n}` : 'T?';
    return { ch: label, cls: '' };
  }

  // Bull round â€“ show 50/25
  if (rd && rd.type === 'bull'){
    if (d.kind === 'Bull'){
      const isInner = (d.bull === 'Inner');
      return { ch: isInner ? '50' : '25', cls: '' };
    }
    const pts = Number(d.points || 0);
    if (pts === 50 || pts === 25) return { ch: String(pts), cls: '' };
    return { ch: 'âœ•', cls: 'miss' };
  }

  // Fallback
  return { ch: 'â—‹', cls: '' };
}

// Mark the highest bracketed value per round as green.
// Works on any score-sheet markup as long as the bracket text contains a number.
window.markRoundHighs = function markRoundHighs(root = document) {
  // cover 10..20 + D/T/B = 14 rows => indexes 0..13
  for (let r = 0; r <= 13; r++) {
    // try to find bracketed elements; prefer ones tagged with data-round if present
    const subs = Array.from(
      root.querySelectorAll(`.round-sub[data-round="${r}"], [data-round="${r}"] .round-sub`)
    );

    // fallback: just grab all .round-sub in the table section for this round
    const bucket = subs.length ? subs :
      Array.from(root.querySelectorAll(`.round-sub`))
        .filter(el => el.closest('[data-round-index]')?.getAttribute('data-round-index') == String(r));

    if (!bucket.length) continue;

    // read a numeric value from data-points if provided, else parse `(123)`
    const values = bucket.map(el => {
      const v = Number(el.dataset.points);
      if (Number.isFinite(v)) return v;
      const m = (el.textContent || '').match(/-?\d+(?:\.\d+)?/);
      return m ? Number(m[0]) : 0;
    });

    const max = Math.max(0, ...values);

    const iMax = (max > 0) ? values.indexOf(max) : -1;

    bucket.forEach((el, i) => {
      el.classList.toggle('is-round-high', i === iMax && iMax >= 0);
    });
}
};

// Fetch per-dart pattern for a specific game/player/round (e.g. "S/S/D" or "x/T/T")
async function fetchRoundPattern(gameId, playerName, ridx){
  if (!gameId || playerName == null || ridx == null) return '';

  // 1) Preferred: per-dart throws table (only if available)
  if (FEATURE_CLOUD_THROWS && !cloudIsTableMissing(TABLE_GAME_THROWS)){
    try{
      const { data, error } = await sb
        .from(TABLE_GAME_THROWS)
        .select('dart_index, points, kind, bull')
        .eq('game_id', gameId)
        .eq('player', playerName)
        .eq('round_index', ridx)
        .order('dart_index', { ascending: true });
      if (error) throw error;

      const rd = ROUNDS[ridx];
      const chars = [];
      for (let i = 0; i < 3; i++){
        const d = (data || []).find(r => Number(r.dart_index) === i) || null;
        const sym = symbolForDart(d, rd);
        let ch = sym && sym.ch ? sym.ch : 'x';
        if (ch === 'âœ•') ch = 'x';
        chars.push(ch);
      }
      return chars.join('/');
    } catch(e){
      cloudMarkTableMissing(TABLE_GAME_THROWS, e);
    }
  }

  // 2) Fallback: games.state.board (if stored)
  try{
    const { data, error } = await sb.from(TABLE_GAMES).select('state').eq('id', gameId).single();
    if (error) throw error;
    const rd = ROUNDS[ridx];
    const players = (data?.state?.players || []).map(p => (typeof p === 'string' ? { name:p } : p));
    const pIdx = players.findIndex(p => eqName(p.name, playerName));
    const ent  = pIdx >= 0 ? (data?.state?.board?.[pIdx] || [])[ridx] : null;
    const chars = [];
    for (let i = 0; i < 3; i++){
      const d = ent && Array.isArray(ent.darts) ? ent.darts[i] : null;
      const sym = symbolForDart(d, rd);
      let ch = sym && sym.ch ? sym.ch : 'x';
      if (ch === 'âœ•') ch = 'x';
      chars.push(ch);
    }
    return chars.join('/');
  }catch(_){
    return '';
  }
}
window.fetchRoundPattern = fetchRoundPattern;

// Fetch a game's timestamp from the cloud (with fallbacks)
async function fetchGameTS(gameId){
  try{
    const { data, error } = await sb
      .from(TABLE_GAMES)
      .select('ts, created_at, inserted_at')
      .eq('id', gameId)
      .single();
    if (error) throw error;
    return data?.ts || data?.created_at || data?.inserted_at || null;
  }catch(e){
    return null;
  }
}

// Earliest TS for a specific game/player/round (fallback for Date/Time column)
async function fetchRoundTS(gameId, playerName, ridx){
  if (!FEATURE_CLOUD_THROWS || cloudIsTableMissing(TABLE_GAME_THROWS)) return null;
  try{
    const { data, error } = await sb
      .from(TABLE_GAME_THROWS)
      .select('ts')
      .eq('game_id', gameId)
      .eq('player', playerName)
      .eq('round_index', ridx)
      .order('ts', { ascending: true })
      .limit(1);
    if (error) throw error;
    return (data && data[0] && data[0].ts) ? data[0].ts : null;
  }catch(_){
    return null;
  }
}

function setupRoundScoreObserver(){
  // PB/GR disabled on the scoreboard: scrub any tokens that might be rendered by legacy code
  const tbody = document.getElementById('tbody');
  if (!tbody) { setTimeout(setupRoundScoreObserver, 250); return; }

  function scrub(){
    const subs = tbody.querySelectorAll('.cell-sub');
    subs.forEach(sub => {
      // Flatten to plain text and strip (PB) / (GR) tokens, preserving the round score e.g. (30)
      const raw = (sub.textContent || '');
      const cleaned = raw
        .replace(/\s*\(PB\)\s*/gi, ' ')
        .replace(/\s*\(GR\)\s*/gi, ' ')
        .replace(/\s{2,}/g, ' ')
        .trim();
      if (cleaned !== raw) sub.textContent = cleaned;

      // Remove any leftover elements used by older implementations
      sub.querySelectorAll('.pbgr, .pb-badge').forEach(n => {
        try {
          // If it wraps text like "(30) (PB) (GR)", keep the text but without tokens
          const txt = (n.textContent || '')
            .replace(/\s*\(PB\)\s*/gi, ' ')
            .replace(/\s*\(GR\)\s*/gi, ' ')
            .replace(/\s{2,}/g, ' ')
            .trim();
          n.replaceWith(document.createTextNode(txt));
        } catch(_) { try { n.remove(); } catch(_){} }
      });
    });
  }

  // Observe scoreboard updates and continuously scrub (via shared UI mutation bus)
  try {
    if (!tbody.dataset.sqScrubWired) {
      tbody.dataset.sqScrubWired = '1';
      window.__sqUIMutationBus?.on((muts) => {
        try{
          if (!tbody || !tbody.isConnected) return;
          for (const m of (muts || [])){
            const t = m.target;
            if (t && tbody.contains(t)) { scrub(); return; }
            for (const n of (m.addedNodes || [])){
              if (n && n.nodeType === 1 && tbody.contains(n)) { scrub(); return; }
            }
          }
        }catch(_){}
      });
    }
  } catch(_){}

  // Initial + delayed passes
  scrub();
  setTimeout(scrub, 300);
  setTimeout(scrub, 1000);
}
// --- Global high-score de-dup helpers ---
function _keyNameScore(row){
  const n = String(row?.name || '').trim().toLowerCase();
  const s = Number(row?.score || 0);
  return `${n}|${s}`;
}
function dedupeRowsByNameScoreKeepEarliest(rows){
  const map = new Map(); // key => row with earliest ts
  for (const r of (rows || [])){
    if (!r) continue;
    const key = _keyNameScore(r);
    const existing = map.get(key);
    const tNew = r?.ts ? Date.parse(r.ts) : Infinity;
    if (!existing){
      map.set(key, r);
    } else {
      const tOld = existing?.ts ? Date.parse(existing.ts) : Infinity;
      if (tNew < tOld) map.set(key, r); // keep the earliest/original
    }
  }
  return [...map.values()];
}
async function dedupeTableHighScores(table){
  const { data, error } = await sb
    .from(table)
    .select('name, score, ts')
    .order('ts', { ascending: true })
    .limit(10000);
  if (error) { markCloudError(error); throw error; }
  const groups = new Map();
  for (const r of (data || [])){
    const key = _keyNameScore(r);
    const arr = groups.get(key) || [];
    arr.push(r);
    groups.set(key, arr);
  }
  let deleted = 0;
  for (const [, arr] of groups){
    if (arr.length <= 1) continue;
    arr.sort((a,b)=> (Date.parse(a.ts||'')||0) - (Date.parse(b.ts||'')||0));
    // keep earliest (index 0), delete the rest
    for (let i = 1; i < arr.length; i++){
      const row = arr[i];
      const { error: delErr } = await sb.from(table)
        .delete()
        .eq('name', row.name)
        .eq('score', row.score)
        .eq('ts', row.ts);
      if (!delErr) deleted++;
    }
  }
  markCloudOk();
  return deleted;
}
async function dedupeAllHighScores(){
  let total = 0;
  try { total += await dedupeTableHighScores(TABLE_HS_LEAGUE); } catch(e){ console.error(e); }
  try { total += await dedupeTableHighScores(TABLE_HS_PRACTICE); } catch(e){ console.error(e); }
  return total;
}
// ---- Admin Hub ----
// ===== @JS:UI:ADMIN =====
function openAdminHub(){
  const hub = document.getElementById('adminHubModal');
  try { window.__sqNavContext = 'admin'; } catch(_) {}
  if (!hub) return;
  hub.classList.remove('hidden');

  // Buttons
  const btnAll   = document.getElementById('openAllGamesBtn');
  const btnLHS   = document.getElementById('openHsLeagueAdmin');
  const btnPHS   = document.getElementById('openHsPracticeAdmin');
  const btnLLS   = document.getElementById('openLeagueLowsAdmin');
  const btnSave  = document.getElementById('openSavedPlayersAdminBtn');
  const btnClose = document.getElementById('closeAdminHubBtn');
  const btnCloseX = document.getElementById('closeAdminHubBtnX');
  const btnFix   = document.getElementById('fixDuplicatesBtn');
  const btnPBGR  = document.getElementById('openPBGRAdminBtn');

if (btnAll)  btnAll.onclick  = ()=>{ hub.classList.add('hidden'); openAllGamesDialog(); };
if (btnLHS)  btnLHS.onclick  = ()=>{ hub.classList.add('hidden'); openHighScoresAdminDialog(false); };
if (btnPHS)  btnPHS.onclick  = ()=>{ hub.classList.add('hidden'); openHighScoresAdminDialog(true); };
if (btnLLS)  btnLLS.onclick  = () => {
  hub.classList.add('hidden');
  openLeagueLowsAdminDialog();
};
if (btnSave) btnSave.onclick = ()=>{ hub.classList.add('hidden'); openSavedPlayersAdminDialog(); };
  if (btnPBGR) btnPBGR.onclick = ()=>{ hub.classList.add('hidden'); openPBGRAdminDialog(); };

  if (btnFix) btnFix.onclick = async ()=>{
    hub.classList.add('hidden');
    try{
      const removed = await dedupeAllHighScores();
      toast(`Removed ${removed} duplicate row${removed===1?'':'s'}.`);
    }catch(e){
      console.error(e);
      toast('Dedupe failed');
    }
  };

  if (btnClose) btnClose.onclick = ()=>{ hub.classList.add('hidden'); try{ window.__sqNavContext = null; }catch(_){} };
  if (btnCloseX) btnCloseX.onclick = ()=>{ hub.classList.add('hidden'); try{ window.__sqNavContext = null; }catch(_){} };
}

// Export Admin Hub opener for any callers that use window.openAdminHub
try { window.openAdminHub = openAdminHub; } catch(_) {}


// === All Games modal (simple list) ===
function openAllGamesDialog(){
  const modal = document.getElementById('allGamesModal');
  if (!modal) return;
  modal.classList.remove('hidden');

  const wrap   = document.getElementById('allGamesTableWrap');
  const back   = document.getElementById('allGamesBackBtn');
  const close  = document.getElementById('allGamesCloseBtn');
  if (back)  back.onclick  = () => { modal.classList.add('hidden'); openAdminHub(); };
  if (close) close.onclick = () => { modal.classList.add('hidden'); };

  // Hard cleanup: remove any rogue Official/Practice filter buttons injected by older code
  function __stripAllGamesFilterButtons(){
    try{
      const btns = Array.from(modal.querySelectorAll('button'));
      btns.forEach(b=>{
        const t = (b.textContent || '').trim().toLowerCase();
        if (t === 'official' || t === 'practice') {
          b.remove();
        }
      });
      // If their parent container is now empty and only existed for those buttons, remove it too
      Array.from(modal.querySelectorAll('.filters, .row, .header, div')).forEach(node=>{
        if (!node || node === modal) return;
        // Only consider small containers near the heading
        const isSmall = node.childElementCount <= 1;
        if (isSmall) {
          const hasButtons = Array.from(node.querySelectorAll('button')).length === 0;
          if (hasButtons && /^\s*$/.test(node.textContent || '')) {
            // empty and had no other content
            // (wrapped containers that are now empty)
            try { node.remove(); } catch(_) {}
          }
        }
      });
    }catch(_){}
  }
  __stripAllGamesFilterButtons();

  const toTS = (g)=> {
    const t = g?.ts || g?.created_at || g?.inserted_at || (g?.meta && (g.meta.ts || g.meta.date)) || null;
    const n = t ? Date.parse(t) : NaN;
    return Number.isFinite(n) ? n : 0;
  };

  async function render(){
    if (wrap) wrap.innerHTML = '<p class="tag">Loadingâ€¦</p>';

    let games = [];
    try { games = await cloudFetchAllGamesAsLocal(); } catch(e){ console.error(e); }

    games = (games || []).filter(Boolean).sort((a,b)=> toTS(b) - toTS(a));

    // Build table
    const table = document.createElement('table');
    table.className = 'hs-table';

    const colgroup = document.createElement('colgroup');
    const maxDigits = Math.max(2, String(games.length || 0).length);
    const colNum  = document.createElement('col');  colNum.style.width  = `${Math.min(3, maxDigits)}ch`;
    const colWhen = document.createElement('col');  colWhen.style.width = '10ch';
    const colRes  = document.createElement('col');
    colgroup.append(colNum, colWhen, colRes);
    table.appendChild(colgroup);

    const thead = document.createElement('thead');
    const trh   = document.createElement('tr');
    ['#','When','Result'].forEach(h => {
      const th = document.createElement('th'); th.textContent = h; trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');

    games.forEach((g, idx) => {
      const tr  = document.createElement('tr');

      // #
      const td1 = document.createElement('td'); td1.textContent = String(idx + 1);

      // When (locale short form; original behaviour)
      const td2 = document.createElement('td');
      const tsVal = g.ts || g.created_at || g.inserted_at || (g.meta && (g.meta.ts || g.meta.date)) || null;
      if (tsVal){
        const d = new Date(tsVal);
        td2.textContent = !Number.isNaN(d.getTime())
          ? `${String(d.getDate()).padStart(2,'0')}/${String(d.getMonth()+1).padStart(2,'0')}/${String(d.getFullYear()).slice(-2)} @ ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`
      : '';
      } else {
        td2.textContent = '';
      }

      // Result
      const players = (g.players || []).map(playerNameFrom).filter(Boolean).map(displayName);
      const totals  = Array.isArray(g.totals) ? g.totals : [];
      const ordered = players
        .map((name, i) => ({ name, score: Number(totals[i] || 0) }))
        .filter(x => x.name)
        .sort((a, b) => b.score - a.score);

      let result = 'â€”';
      if (ordered.length >= 2) {
        result = `${ordered[0].name} ${ordered[0].score} beat ${ordered[1].name} ${ordered[1].score}`;
        if (ordered.length > 2) {
          result += ' ' + ordered.slice(2).map(o => `${o.name} ${o.score}`).join(' ');
        }
      } else if (ordered.length === 1) {
        result = `${ordered[0].name} ${ordered[0].score}`;
      }

      const td3 = document.createElement('td'); td3.textContent = result;

      tr.append(td1, td2, td3);

      // Click row to open the score sheet if available
      tr.style.cursor = 'pointer';
      tr.title = 'Open score sheet';
      tr.onclick = () => { try { if (typeof openSingleGameScoreSheet === 'function') openSingleGameScoreSheet(g); } catch(_) {} };

      tbody.appendChild(tr);
    });

    table.appendChild(tbody);

    if (wrap) {
      wrap.innerHTML = '';
      const tw = document.createElement('div'); tw.className = 'table-wrap';
      tw.appendChild(table);
      wrap.appendChild(tw);
      // After DOM insert, clean up any rogue filter buttons
      __stripAllGamesFilterButtons();
    }
  }

  render();
}

// League Low Scores Admin dialog (global)
function openLeagueLowsAdminDialog(){
  const modal = document.getElementById('leagueLowsAdminModal');
  const body  = document.getElementById('leagueLowsAdminBody');
  const back  = document.getElementById('leagueLowsBackBtn');
  const close = document.getElementById('leagueLowsCloseBtn');
  if (!modal || !body) return;

  modal.classList.remove('hidden');

  if (back)  back.onclick  = () => { modal.classList.add('hidden'); openAdminHub(); };
  if (close) close.onclick = () => { modal.classList.add('hidden'); };

  (async () => {
    body.innerHTML = '<p class="tag">Loading league low scoresâ€¦</p>';

    try {
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()){
        body.innerHTML = '<p>Cloud not initialised.</p>';
        return;
      }
    } catch(_) {}

    let rows = [];
    try {
      const { data, error } = await sb
        .from(TABLE_PLAYER_GAMES)
        .select('sheet_id, player, score, ts, is_practice, rounds')
        .eq('is_practice', false)
        .order('score', { ascending: true })
        .order('ts',    { ascending: true })
        .limit(1000);
      if (error) throw error;
      rows = data || [];
    } catch(e) {
      console.error('League low scores fetch failed', e);
      const msg = (e && e.message) ? e.message : 'Unknown error';
      body.innerHTML = '<p>Failed to load league low scores.</p>' +
        '<p class="tag">' + msg + '</p>';
      return;
    }

    if (!rows.length){
      body.innerHTML = '<p>No league low scores found.</p>';
      return;
    }

    const table = document.createElement('table');
    table.className = 'hs-table compact';

    const thead = document.createElement('thead');
    const trh   = document.createElement('tr');
    ['#','Player','Score','Avg / Round','When','Actions'].forEach(h=>{
      const th = document.createElement('th');
      th.textContent = h;
      trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    rows.forEach((row, idx) => {
      const tr    = document.createElement('tr');

      const tdIdx = document.createElement('td');
      tdIdx.textContent = String(idx + 1);

      const tdName = document.createElement('td');
      tdName.textContent = row.player || '';

      const tdScore = document.createElement('td');
      tdScore.textContent = String(row.score ?? '');

      const tdAvg = document.createElement('td');
      const rounds = Number(row.rounds || 0);
      if (rounds > 0) {
        const avg = row.score / rounds;
        tdAvg.textContent = avg.toFixed(1);
      } else {
        tdAvg.textContent = 'â€”';
      }

      const tdWhen = document.createElement('td');
      if (row.ts){
        const d = new Date(row.ts);
        tdWhen.textContent = !Number.isNaN(d.getTime())
          ? d.toLocaleString(undefined,{
              year: '2-digit',
              month: 'short',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit'
            })
          : '';
      } else {
        tdWhen.textContent = '';
      }

      const tdAct = document.createElement('td');
      tdAct.className = 'center';

      const delBtn = document.createElement('button');
      delBtn.className = 'btn small danger';
      delBtn.textContent = 'Delete game';
      delBtn.onclick = async (e) => {
        e.stopPropagation();
        const sheetId = row.sheet_id;
        if (!sheetId){
          if (typeof toast === 'function') toast('Missing game id for this row');
          return;
        }
        const msg = `Delete game ${sheetId} for ${row.player || 'Unknown'} (score ${row.score})?\n\nThis will remove the game and all related stats from the cloud.`;
        if (!confirm(msg)) return;
        try{
          // Delete throws first, then game record
          try {
            await sb.from(TABLE_GAME_THROWS).delete().eq('game_id', sheetId);
          } catch(e1){
            console.error('Delete game_throws failed', e1);
          }
          const { error: delErr } = await sb.from(TABLE_GAMES).delete().eq('id', sheetId);
          if (delErr) throw delErr;
          if (typeof toast === 'function') toast('Game deleted');
          // re-render list
          openLeagueLowsAdminDialog();
        }catch(err){
          console.error('Delete league low game failed', err);
          if (typeof toast === 'function') toast('Delete failed');
        }
      };

      tdAct.appendChild(delBtn);
      tr.append(tdIdx, tdName, tdScore, tdAvg, tdWhen, tdAct);
      tbody.appendChild(tr);
    });

    table.appendChild(tbody);
    body.innerHTML = '';
    body.appendChild(table);
  })();
}

// Player Stats â€” Select Player flow (uses the generic Select Player modal)
function openPlayerStatsSelectDialog(){
  try{ if (typeof __sqSetStatsOrigin==='function') __sqSetStatsOrigin('home'); }catch(_){ }
  try{ console.debug('[Popup]', window.__sqStatsDebugName || 'New Game Screen Stats'); }catch(_){ }
  // New: dedicated Player Stats select modal (menu/data-input style)
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal menu-modal';

  const header = document.createElement('div');
  header.className = 'menu-modal-header';

  const backBtn = document.createElement('button');
  backBtn.className = 'icon-btn';
  backBtn.type = 'button';
  backBtn.setAttribute('aria-label', 'Back');
  backBtn.innerHTML = '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'icon-btn';
  closeBtn.type = 'button';
  closeBtn.setAttribute('aria-label', 'Close');
  closeBtn.innerHTML = '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M18 6L6 18M6 6l12 12"/></svg>';

  const titleWrap = document.createElement('div');
  titleWrap.className = 'menu-modal-title';

  const icon = document.createElement('div');
  icon.className = 'menu-modal-icon';
  icon.innerHTML = '<svg viewBox="0 0 24 24" width="28" height="28" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M4 19V5"/><path d="M8 19V9"/><path d="M12 19V3"/><path d="M16 19v-6"/><path d="M20 19V7"/></svg>';

  const title = document.createElement('div');
  title.className = 'menu-modal-title-text';
  title.textContent = 'SELECT PLAYER';

  titleWrap.append(icon, title);

  header.append(backBtn, titleWrap, closeBtn);

  const body = document.createElement('div');
  body.className = 'menu-modal-body';

  const form = document.createElement('div');
  form.className = 'menu-modal-form';

  const label = document.createElement('label');
  label.textContent = 'Player Name';

  const sel = document.createElement('select');
  sel.innerHTML = '<option value="">Select a saved player...</option>';

  form.append(label, sel);
  body.appendChild(form);

  const actions = document.createElement('div');
  actions.className = 'menu-modal-actions';

  const cancel = document.createElement('button');
  cancel.className = 'btn';
  cancel.type = 'button';
  cancel.textContent = 'Cancel';

  const go = document.createElement('button');
  go.className = 'btn primary';
  go.type = 'button';
  go.textContent = 'View Stats';

  actions.append(cancel, go);

  modal.append(header, body, actions);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  const close = () => { try{ overlay.remove(); }catch(_){ overlay.parentNode && overlay.parentNode.removeChild(overlay); } };
  backBtn.onclick = close;
  closeBtn.onclick = close;
  cancel.onclick  = close;
  overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });

  // Populate saved players
  (async () => {
    try{
      const items = await cloudListPlayers(); // [{name}]
      sel.innerHTML = '<option value="">Select a saved player...</option>' +
        (items || []).map(p => `<option value="${p.name}">${p.name}</option>`).join('');
    }catch(e){
      console.error('Stats: load players failed', e);
      try{ if (typeof toast==='function') toast('Cloud offline'); }catch(_){}
    }
  })();

  const openStats = () => {
    const name = (sel.value || '').trim();
    if (!name){ try{ toast('Pick a player'); }catch(_){} return; }
    close();
    try{ if (typeof __sqSetStatsOrigin==='function') __sqSetStatsOrigin('home', name); }catch(_){ }
    try{
      if (typeof openPlayerStatsHub === 'function') {
        openPlayerStatsHub(name);
      } else if (typeof openPlayerStatsDialog === 'function') {
        openPlayerStatsDialog(name);
      } else {
        console.warn('No player stats dialog function found');
      }
    }catch(err){
      console.error('Open Player Stats failed', err);
    }
  };

  go.onclick = openStats;
  sel.addEventListener('change', () => {
    // Optional: enable only when selection is made (keeps UX tidy)
    go.disabled = !String(sel.value || '').trim();
  });
  go.disabled = true;
}

// Ensure the Start screen button opens the Stats select flow
document.addEventListener('DOMContentLoaded', function(){
  const btn = document.getElementById('playerStatsBtn');
  if (btn) btn.onclick = () => openPlayerStatsSelectDialog();
});

// --- PB / GR Admin: open/close + minimal render ---
function openPBGRAdminDialog(){
  const modal = document.getElementById('pbgrAdminModal');
  if (!modal) return;
  modal.classList.remove('hidden');

  const back  = document.getElementById('pbgrBackBtn');
  const close = document.getElementById('pbgrCloseBtn');
  const sel   = document.getElementById('pbgrPlayerSelect');
  const ref   = document.getElementById('pbgrRefreshBtn');

  if (back)  back.onclick  = () => { modal.classList.add('hidden'); openAdminHub(); };
  if (close) close.onclick = () => { modal.classList.add('hidden'); };

  // Populate dropdown once per open
  (async () => {
    try{
      const items = await cloudListPlayers(); // [{name}]
      if (sel){
        sel.innerHTML = '<option value="">Select a saved playerâ€¦</option>' +
          (items||[]).map(p => `<option value="${p.name}">${p.name}</option>`).join('');
      }
    }catch(e){ console.error(e); }
  })();

  if (ref) ref.onclick = () => { try{ if (typeof refreshPBGRCloud === 'function') refreshPBGRCloud(); }catch(_){ } };
}

// Saved Players Admin
async function openSavedPlayersAdminDialog(){
  const modal = document.getElementById('savedPlayersAdminModal');
  const body  = document.getElementById('savedPlayersAdminBody');
  const back  = document.getElementById('backSavedPlayersAdminBtn');
  const close = document.getElementById('closeSavedPlayersAdminBtn');
  if (!modal || !body) return;

  modal.classList.remove('hidden');
  if (back)  back.onclick  = () => { modal.classList.add('hidden'); openAdminHub(); };
  if (close) close.onclick = () => { modal.classList.add('hidden'); };

  await renderSavedPlayersAdmin();
}

// Generic renderer that can write the PB/GR table into any mount id
async function renderPBGRTableInto(mountId){
  const mount = document.getElementById(mountId);
  if (!mount) return;
  mount.innerHTML = '<p class="tag">Loadingâ€¦</p>';
  try{
    const snap = await (typeof getPBGRSnapshot === 'function' ? getPBGRSnapshot() : Promise.resolve({ byTargetMeta: {} }));
    const order = [...Array.from({length:11},(_,i)=>10+i), 'D','T','B'];

    // Build table with Date / Time column included
    const table = document.createElement('table'); table.className='hs-table';
    const thead = document.createElement('thead');
    const trh = document.createElement('tr');
    ['Round','WR','Darts','Date / Time','Holder'].forEach(h=>{
      const th = document.createElement('th');
      th.textContent = h;
      trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    table.appendChild(tbody);

    const fmtDate = (ts) => {
      if (!ts) return 'â€”';
      const d = new Date(ts);
      if (Number.isNaN(d.getTime())) return 'â€”';
      return d.toLocaleString('en-GB', {
        year: 'numeric',
        month: 'short',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    };

    const pending = [];

    order.forEach(key=>{
      const meta = (snap.byTargetMeta && snap.byTargetMeta[key]) ? snap.byTargetMeta[key] : { val:0, player:'', game_id:null, ridx:null, ts:null };
      const tr   = document.createElement('tr');

      const tdR  = document.createElement('td'); tdR.textContent = String(key);
      const tdV  = document.createElement('td'); tdV.textContent = String(meta.val || 0);
      const tdD  = document.createElement('td'); tdD.textContent = 'â€”'; // async filled with S/D/T/x pattern
      const tdT  = document.createElement('td'); tdT.textContent = fmtDate(meta.ts);
      const tdN  = document.createElement('td');
        // Holder: if multiple saved players share the WR value for this round, show "Name +X"
        let holderText = meta.player ? String(meta.player) : 'â€”';
        try{
          const bpm = snap.byPlayerMeta;
          const wrVal = Number(meta.val||0);
          if (bpm && typeof bpm.forEach === 'function' && wrVal > 0 && meta.player){
            let cnt = 0;
            bpm.forEach((m) => {
              const rec = m && m[String(key)];
              if (rec && Number(rec.val||0) === wrVal) cnt++;
            });
            if (cnt > 1) holderText = `${holderText} +${cnt-1}`;
          }
        }catch(_){}
        tdN.textContent = holderText || 'â€”';

      tr.append(tdR, tdV, tdD, tdT, tdN);
      tbody.appendChild(tr);

      // Fetch the per-dart pattern (S/D/T etc.)
      if (meta && meta.game_id != null && meta.player && (meta.ridx || meta.ridx === 0)){
        pending.push(
          fetchRoundPattern(meta.game_id, meta.player, meta.ridx)
            .then(pat => { tdD.textContent = pat || 'â€”'; })
            .catch(()=>{ tdD.textContent = 'â€”'; })
        );
      }

      // Fill Date/Time if missing: try Games.ts -> earliest throw ts
      if (!meta?.ts && meta?.game_id){
        pending.push(
          (async ()=>{
            const gts = await fetchGameTS(meta.game_id);
            if (gts){
              tdT.textContent = fmtDate(gts);
              return;
            }
            if (meta.player && (meta.ridx || meta.ridx === 0)){
              const rts = await fetchRoundTS(meta.game_id, meta.player, meta.ridx);
              if (rts) tdT.textContent = fmtDate(rts);
            }
          })()
        );
      }
    });

    if (pending.length){ try{ await Promise.allSettled(pending); }catch(_){ /* ignore */ } }
    mount.innerHTML = '';
    mount.appendChild(table);
  }catch(e){
    console.error('renderPBGRTableInto failed', e);
    mount.innerHTML = '<p>Unable to load World Records right now.</p>';
  }
}

// Keep admin renderer for pb/gr admin modal
async function renderPBGRGlobalTable(){
  return renderPBGRTableInto('pbgrGlobal');
}
// Public Round High Scores modal
function openRoundHighScoresDialog(){
  const modal = document.getElementById('roundHighScoresModal');
  const body  = document.getElementById('roundHSBody');
  const btnBack  = document.getElementById('roundHSBackBtn');
  const btnClose = document.getElementById('roundHSCloseBtn');
  if (!modal || !body) return;

  modal.classList.remove('hidden');
  if (btnBack)  btnBack.onclick  = () => { modal.classList.add('hidden'); };
  if (btnClose) btnClose.onclick = () => { modal.classList.add('hidden'); };

  // Re-use the generic PB/GR table builder
  renderPBGRTableInto('roundHSBody').catch(()=>{
    body.innerHTML = '<p>Unable to load right now.</p>';
  });
}

function _normName(s){ return String(s||'').trim(); }

// Initials helpers (cloud-first; name fallback)
function __sqComputeInitialsFromName(name){
  const s = String(name||'').trim();
  if (!s) return '';
  // Split on whitespace + hyphen; keep alphanumerics
  const parts = s.split(/\s+|-/g).map(x=>x.replace(/[^A-Za-z0-9]/g,'')).filter(Boolean);
  if (!parts.length) return '';
  if (parts.length === 1){
    const w = parts[0].toUpperCase();
    return w.slice(0, Math.min(2, w.length));
  }
  const a = parts[0].toUpperCase().slice(0,1);
  const b = parts[parts.length-1].toUpperCase().slice(0,1);
  return (a+b).trim();
}
function __sqComputeInitials(first, last){
  const f0 = String(first||'').trim();
  const l0 = String(last||'').trim();
  const f = f0.replace(/[^A-Za-z0-9]/g,'');
  const l = l0.replace(/[^A-Za-z0-9]/g,'');
  if (f && l){
    return (f[0] + l[0]).toUpperCase();
  }
  if (f){
    return f.toUpperCase().slice(0, Math.min(2, f.length));
  }
  return __sqComputeInitialsFromName((f0 + (l0 ? ' ' + l0 : '')).trim());
}
function __sqNormalizeInitials(init, nameFallback){
  const raw = String(init||'').trim().toUpperCase().replace(/[^A-Z0-9]/g,'');
  if (raw) return raw.slice(0,3);
  return __sqComputeInitialsFromName(nameFallback);
}
function __sqFindSavedPlayerMetaByName(name){
  const key = String(name||'').trim().toLowerCase();
  if (!key) return null;
  try{
    const arr = getSavedPlayers() || [];
    return arr.find(p => p && String(p.name||'').trim().toLowerCase() === key) || null;
  }catch(_){ return null; }
}

function __sqNameParts(name){
  const s = String(name||'').trim();
  if (!s) return { first:'', last:'' };
  const parts = s.split(/\s+/).filter(Boolean);
  if (parts.length <= 1) return { first: parts[0] || '', last: '' };
  return { first: parts[0] || '', last: parts.slice(1).join(' ') };
}

function __sqPlayerPretty(p){
  const nm = (p && p.name != null) ? String(p.name).trim() : '';
  const parts = __sqNameParts(nm);
  const first = String((p && p.first_name) || '').trim() || parts.first;
  const last  = String((p && p.last_name)  || '').trim() || parts.last;
  const nick  = String((p && p.nickname)   || '').trim();

  let out = first || nm || '';
  if (nick) out += ' "' + nick + '"';
  if (last) out += (out ? ' ' : '') + last;

  out = out.trim();
  return out || nm || '';
}

function __sqPlayerOptionLabel(p){
  const pretty = __sqPlayerPretty(p);
  const ini = __sqNormalizeInitials(p && p.initials, (p && p.name) || pretty);
  return ini ? (pretty + ' (' + ini + ')') : pretty;
}

function __sqHeaderLabelForPlayer(pl){
  const nm = pl && pl.name ? String(pl.name) : '';
  const init = pl && pl.initials ? String(pl.initials) : '';
  return __sqNormalizeInitials(init, nm) || nm || '';
}

function __sqLoadPlayerAliases(){
  try { return JSON.parse(localStorage.getItem('SQ_PLAYER_ALIASES') || '{}') || {}; } catch(e){ return {}; }
}
function __sqSavePlayerAliases(map){
  try { localStorage.setItem('SQ_PLAYER_ALIASES', JSON.stringify(map || {})); } catch(e){}
}
function __sqRememberPlayerRename(oldName, newName){
  const o = _normName(oldName), n = _normName(newName);
  if (!o || !n || o === n) return;
  const map = __sqLoadPlayerAliases();

  // Collapse chains: if something already pointed to old, repoint to new
  try { Object.keys(map).forEach(k => { if (map[k] === o) map[k] = n; }); } catch(_){ }

  map[o] = n;
  __sqSavePlayerAliases(map);

  try { document.dispatchEvent(new CustomEvent('sq:player-alias-updated', { detail: { oldName:o, newName:n }})); } catch(_){ }
}
function __sqApplyPlayerAlias(name){
  let x = _normName(name);
  if (!x) return x;
  const map = __sqLoadPlayerAliases();
  const seen = new Set();
  while (map[x] && !seen.has(x)){
    seen.add(x);
    x = _normName(map[x]);
  }
  return x;
}
window.__sqApplyPlayerAlias = __sqApplyPlayerAlias;
window.__sqRememberPlayerRename = __sqRememberPlayerRename;

function renamePlayerInLocalState(oldName, newName){
  const o = _normName(oldName), n = _normName(newName);
  if (!o || !n || o === n) return;

  // Update in-memory current game
  let changed = false;
  try {
    (state.players||[]).forEach(pl=>{
      if (pl && _normName(pl.name) === o){ pl.name = n; changed = true; }
    });
  } catch(_) {}

  // Persist current state snapshot
  if (changed){
    try { save(); } catch(_) {}
    try { if (typeof buildScoreHeader==='function') buildScoreHeader(); } catch(_) {}
    try { if (typeof buildFloatingHeader==='function') buildFloatingHeader(); } catch(_) {}
    try { if (typeof buildMatchStatsHead==='function') buildMatchStatsHead(); } catch(_) {}
    try { if (typeof buildMatchStatsBody==='function') buildMatchStatsBody(); } catch(_) {}
    try { if (typeof updateMatchStats==='function') updateMatchStats(); } catch(_) {}
    try { if (typeof updateUI==='function') updateUI(); } catch(_) {}
  }

  // Update persisted state in localStorage (safety)
  try {
    const st = safeLoad(STORAGE_KEY);
    if (st && Array.isArray(st.players)){
      let ch = false;
      st.players.forEach(pl=>{
        if (pl && _normName(pl.name) === o){ pl.name = n; ch = true; }
      });
      if (ch) safeSave(STORAGE_KEY, st);
    }
  } catch(_) {}

  // Update saved players cache (offline fallback / quick UI refresh)
  try {
    const arr = getSavedPlayers();
    let ch = false;
    (arr||[]).forEach(x=>{
      if (x && _normName(x.name) === o){ x.name = n; ch = true; }
    });
    if (ch) setSavedPlayers(arr);
  } catch(_) {}
}

function removePlayerFromLocalCache(name){
  const n = _normName(name);
  if (!n) return;
  try {
    const arr = (getSavedPlayers()||[]).filter(x => _normName(x && x.name) !== n);
    setSavedPlayers(arr);
  } catch(_) {}
}

async function renderSavedPlayersAdmin(){
  const body = document.getElementById('savedPlayersAdminBody');
  if (!body) return;
  body.innerHTML = '<p class="tag">Loading playersâ€¦</p>';

  let players = [];
  try { players = await cloudListPlayers(); }
  catch(e){ console.error(e); body.innerHTML = '<p>Failed to load players.</p>'; return; }

  if (!Array.isArray(players) || players.length === 0){
    body.innerHTML = '<p>No players found.</p>';
    return;
  }

  const table = document.createElement('table');
  table.className = 'hs-table';

  const thead = document.createElement('thead');
  const hr = document.createElement('tr');
  ['First','Nickname','Last','Initials','Actions'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; hr.appendChild(th); });
  thead.appendChild(hr);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');

  players.forEach(p=>{
    const tr = document.createElement('tr');
    const nmOld = String((p && p.name) ? p.name : '').trim();
    const pid = (p && p.id) ? p.id : null;

    const firstTd = document.createElement('td');
    const firstIn = document.createElement('input');
    firstIn.type='text';
    firstIn.value = String(p?.first_name || (nmOld.split(' ')[0]||'')).trim();
    firstIn.style.width='100%';
    firstTd.appendChild(firstIn);

    const nickTd = document.createElement('td');
    const nickIn = document.createElement('input');
    nickIn.type='text';
    nickIn.value = String(p?.nickname || '').trim();
    nickIn.style.width='100%';
    nickTd.appendChild(nickIn);

    const lastTd = document.createElement('td');
    const lastIn = document.createElement('input');
    lastIn.type='text';
    // Best-effort derive last name from existing full name if column missing
    const derivedLast = (()=>{
      const parts = nmOld.split(' ').filter(Boolean);
      if (parts.length <= 1) return '';
      return parts.slice(1).join(' ');
    })();
    lastIn.value = String(p?.last_name || derivedLast).trim();
    lastIn.style.width='100%';
    lastTd.appendChild(lastIn);

    const initTd = document.createElement('td');
    const initIn = document.createElement('input');
    initIn.type='text';
    initIn.value = __sqNormalizeInitials(p?.initials ? p.initials : '', nmOld);
    initIn.maxLength = 3;
    initIn.style.width = '70px';
    initIn.style.textTransform = 'uppercase';
    initTd.appendChild(initIn);

    const actTd = document.createElement('td');
    const saveBtn = document.createElement('button');
    saveBtn.className = 'btn small';
    saveBtn.textContent = 'Save';

    const delBtn = document.createElement('button');
    delBtn.className = 'btn small danger';
    delBtn.textContent = 'Delete';

    actTd.append(saveBtn, document.createTextNode(' '), delBtn);

    saveBtn.onclick = async ()=>{
      const first = String(firstIn.value||'').trim();
      const last  = String(lastIn.value||'').trim();
      const nick  = String(nickIn.value||'').trim();
      if (!first){ toast('First name required'); return; }

      // IMPORTANT: we do NOT rename `players.name` here.
      // Name is a legacy key used across games/history; changing it risks data integrity and can violate unique constraints.
      const init = __sqNormalizeInitials(initIn.value, __sqBuildFullName(first, last));

      try{
        let id = pid;
        if (!id && nmOld){
          const key = await cloudResolvePlayerKeyByName(nmOld);
          id = key && key.id ? key.id : null;
        }
        if (!id){
          toast('Save failed: missing player id');
          return;
        }

        // Cloud-first: update profile fields only
        await cloudUpdatePlayerProfile({ id, name: nmOld }, {
          first_name: first,
          last_name: last,
          nickname: nick,
          initials: init
        });

        // Ensure initials are set even on older deployments
        try { await cloudUpdatePlayerInitials({ id, name: nmOld }, init); } catch(_){}

        try { await syncSavedPlayersFromCloud(); } catch(_){}
        try { document.dispatchEvent(new Event('sq:savedPlayersUpdated')); } catch(_){}
        toast('Saved');
        await renderSavedPlayersAdmin();
      }catch(e){
        console.error(e);
        // Handle uniqueness conflict cleanly (e.g. if DB still enforces something unexpected)
        const msg = (e && (e.message || e.details)) ? String(e.message || e.details) : '';
        if (/duplicate key|unique/i.test(msg)) toast('Save failed: name already exists');
        else toast('Save failed');
      }
    };

    delBtn.onclick = async ()=>{
      if (!nmOld){ toast('Invalid player'); return; }

      // Safety: donâ€™t delete a player whoâ€™s currently in an active game/match (would corrupt indices).
      const inCurrent = (state && Array.isArray(state.players)) ? state.players.some(pl => pl && _normName(pl.name) === _normName(nmOld)) : false;
      const gameStarted = !!(state && ((state.currentRound||0) > 0 || (state.history && state.history.length)));
      if (inCurrent && gameStarted){
        toast('Finish/reset the current game before deleting this player.');
        return;
      }

      if (!confirm(`Delete ${nmOld}?`)) return;
      try{
        await cloudDeletePlayer(pid ? { id: pid, name: nmOld } : nmOld);
        removePlayerFromLocalCache(nmOld);
        try { await syncSavedPlayersFromCloud(); } catch(_) {}
        try { document.dispatchEvent(new Event('sq:savedPlayersUpdated')); } catch(_) {}
        toast('Deleted');
        await renderSavedPlayersAdmin();
      }catch(e){
        console.error(e);
        toast('Delete failed');
      }
    };

    tr.append(firstTd, nickTd, lastTd, initTd, actTd);
    tbody.appendChild(tr);
  });

  table.appendChild(tbody);
  body.innerHTML = '';
  body.appendChild(table);
}


/* Premier League â€” TODAY chip wiring (no <script> tags) */
(function () {
  function todayRangeLocalTZ(){
    const start = new Date(); start.setHours(0,0,0,0);
    const end = new Date(start); end.setDate(start.getDate()+1);
    return { from: start.toISOString(), to: end.toISOString() };
  }

  document.addEventListener('click', async (ev) => {
    const btn = ev.target && ev.target.closest('button');
    if (!btn) return;
    if ((btn.textContent || '').trim().toUpperCase() !== 'TODAY') return;
    // New Premier League dialog uses data-filter-id buttons; don't intercept those.
    if (btn.dataset && btn.dataset.filterId) return;


    // Limit to the Premier League modal/panel
    const modal = btn.closest('.modal, #leaderboard');
    if (!modal) return;
    ev.preventDefault();

    const mount =
      modal.querySelector('#hsLeagueBody') ||
      modal.querySelector('.modal-body') ||
      modal;

    const { from, to } = todayRangeLocalTZ();

    try {
      if (typeof renderLeagueLeaderboardRange === 'function') {
        await renderLeagueLeaderboardRange(mount, { from, to, label: 'Today' });
        return;
      }
      if (typeof renderHsLeague === 'function') {
        await renderHsLeague({ mount, from, to, label: 'Today' });
        return;
      }
      if (typeof loadHsLeague === 'function') {
        await loadHsLeague(mount, { from, to, label: 'Today' });
        return;
      }
    } catch (e) {
      console.error('TODAY renderer error, falling back', e);
    }

    // --- Fallback: simple â€œtodayâ€ table ---
    if (mount) mount.innerHTML = '<p class="tag">Loading todayâ€¦</p>';

    try {
      const { data, error } = await sb
        .from(TABLE_PLAYER_GAMES)
        .select('player, score, is_practice, ts')
        .eq('is_practice', false)
        .gte('ts', from)
        .lt('ts', to);

      if (error) throw error;

      const map = new Map();
      for (const r of (data || [])) {
        const m = map.get(r.player) || { player: r.player, games: 0, total: 0, best: 0 };
        m.games++; m.total += Number(r.score || 0); m.best = Math.max(m.best, Number(r.score || 0));
        map.set(r.player, m);
      }

      const rows = [...map.values()]
        .map(r => ({ ...r, avg: r.games ? r.total / r.games : 0 }))
        .sort((a,b) => b.avg - a.avg);

      mount.innerHTML = `
        <div class="table-wrap">
          <table class="hs-table hs-league-table">
            <thead>
              <tr><th>#</th><th>Player</th><th>Avg Total</th><th>Best</th><th>Games</th></tr>
            </thead>
            <tbody>
              ${rows.map((r,i)=>`
                <tr>
                  <td>${i+1}</td>
                  <td>${r.player || ''}</td>
                  <td class="num">${r.avg.toFixed(1)}</td>
                  <td class="num">${r.best}</td>
                  <td class="num">${r.games}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>`;
    } catch (e) {
      console.error('League TODAY fallback failed', e);
      mount.innerHTML = '<p class="tag">Unable to load todayâ€™s scores.</p>';
    }
  });
})();

/* Premier League â€“ replace TODAY chip with a fresh working one */
(function () {
  // Disabled: native Premier League TODAY tab is now handled by the 4-row filter layout.
  return;

  function startOfTodayISO() {
    const s = new Date(); s.setHours(0,0,0,0);
    return s.toISOString();
  }
  function startOfTomorrowISO() {
    const s = new Date(); s.setHours(0,0,0,0);
    s.setDate(s.getDate() + 1);
    return s.toISOString();
  }

  function buildTodayTable(rows) {
    const by = new Map();
    for (const r of rows || []) {
      const k = r.player || '';
      const m = by.get(k) || { player: k, games: 0, total: 0, best: 0 };
      m.games += 1;
      m.total += Number(r.score || 0);
      m.best = Math.max(m.best, Number(r.score || 0));
      by.set(k, m);
    }
    const agg = [...by.values()]
      .map(x => ({ ...x, avg: x.games ? x.total / x.games : 0 }))
      .sort((a, b) => b.avg - a.avg);

    const table = document.createElement('table');
    table.className = 'hs-table hs-league-table';

    const thead = document.createElement('thead');
    const trh = document.createElement('tr');
    ['#','Player','Games','Avg Total','Best'].forEach(h => {
      const th = document.createElement('th'); th.textContent = h; trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    agg.forEach((r, i) => {
      const tr = document.createElement('tr');
      const tdIdx   = document.createElement('td'); tdIdx.textContent = String(i + 1);
      const tdName  = document.createElement('td'); tdName.textContent = r.player || '';
      const tdGames = document.createElement('td'); tdGames.textContent = String(r.games);
      const tdAvg   = document.createElement('td'); tdAvg.className = 'num'; tdAvg.textContent = r.avg.toFixed(1);
      const tdBest  = document.createElement('td'); tdBest.className = 'num'; tdBest.textContent = String(r.best || 0);
      tr.append(tdIdx, tdName, tdGames, tdAvg, tdBest);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);

    const wrap = document.createElement('div');
    wrap.className = 'table-wrap';
    wrap.style.border='1px solid rgba(255,255,255,.08)';
    wrap.style.borderRadius='14px';
    wrap.style.overflow='auto';
    wrap.style.maxHeight='56vh';
    wrap.appendChild(table);
    return wrap;
  }

  async function renderTodayInto(modal) {
    const body = modal.querySelector('#hsLeagueBody') ||
                 modal.querySelector('.modal-body') ||
                 modal;
    body.innerHTML = '<p class="tag">Loading todayâ€¦</p>';

    try {
      const { data, error } = await sb
        .from(TABLE_PLAYER_GAMES)
        .select('player, score, ts, is_practice')
        .eq('is_practice', false)
        .gte('ts', startOfTodayISO())
        .lt('ts', startOfTomorrowISO());

      if (error) throw error;

      const table = buildTodayTable(data || []);
      body.innerHTML = '';
      body.appendChild(table);
      try { if (typeof markCloudOk === 'function') markCloudOk(); } catch(_) {}
    } catch (e) {
      console.error('Premier League TODAY fetch failed', e);
      body.innerHTML = '<p class="tag">Unable to load todayâ€™s scores.</p>';
      try { if (typeof markCloudError === 'function') markCloudError(e); } catch(_) {}
    }
  }

  function patchPremierLeagueModal(modal) {
    if (!modal || modal.dataset.todayChipDone === '1') return;
    modal.dataset.todayChipDone = '1';

    // Remove any existing TODAY buttons
    Array.from(modal.querySelectorAll('button')).forEach(b => {
      const t = (b.textContent || '').trim().toUpperCase();
      if (t === 'TODAY') b.remove();
    });

    // Find a chip row (use the parent of "ALL TIME" if present)
    const allTimeBtn = Array.from(modal.querySelectorAll('button'))
      .find(b => (b.textContent || '').trim().toUpperCase() === 'ALL TIME');
    const chipRow = allTimeBtn ? allTimeBtn.parentElement : (modal.querySelector('.modal-body') || modal);

    // Insert our new chip
    const btn = document.createElement('button');
    btn.className = 'btn small';
    btn.textContent = 'TODAY';
    btn.setAttribute('data-role', 'today-chip');
    btn.addEventListener('click', (ev) => { ev.preventDefault(); renderTodayInto(modal); });

    // Place it next to the other chips (after "ALL TIME" if found)
    if (allTimeBtn && allTimeBtn.nextSibling) {
      chipRow.insertBefore(btn, allTimeBtn.nextSibling);
    } else {
      chipRow.insertBefore(btn, chipRow.firstChild);
    }
  }

  // Watch for modals opening; patch the one titled "Premier League" (via shared UI mutation bus)
  try {
    window.__sqUIMutationBus?.on((muts) => {
      for (const m of (muts || [])) {
        for (const n of (m.addedNodes || [])) {
          if (!(n instanceof HTMLElement)) continue;
          const modal = n.matches?.('.modal') ? n : n.querySelector?.('.modal');
          if (!modal) continue;
          const title = (modal.querySelector('h3')?.textContent || '').trim();
          if (/^premier league$/i.test(title)) patchPremierLeagueModal(modal);
        }
      }
    });
  } catch(_) {}

  // Also try to patch immediately if itâ€™s already open
  setTimeout(() => {
    const openModal = Array.from(document.querySelectorAll('.modal'))
      .find(m => /^premier league$/i.test((m.querySelector('h3')?.textContent || '').trim()));
    if (openModal) patchPremierLeagueModal(openModal);
  }, 0);
})();

// === Final version: single-line psTicker vertical scroller ===
(function () {
  const IN_MS   = 800;   // time for the scroll animation (ms)
  const HOLD_MS = 3000;  // time each score stays fully visible (ms)

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  function formatGameForTicker(g) {
    if (!g) return '';

    const alias = (typeof window !== 'undefined' && typeof window.__sqApplyPlayerAlias === 'function')
      ? window.__sqApplyPlayerAlias
      : (x)=>x;

    const players = (g.players || []).map(p => {
      const nm = (p && typeof p === 'object' && 'name' in p) ? p.name : String(p || '');
      return alias(nm);
    });
    const totals  = Array.isArray(g.totals) ? g.totals : [];

    const ordered = players
      .map((name, i) => ({ name, score: Number(totals[i] || 0) }))
      .filter(x => x.name)
      .sort((a, b) => b.score - a.score);

    let resultHtml = 'â€”';
    if (ordered.length >= 2) {
      const winnerLabel = `${ordered[0].name} ${ordered[0].score}`;
      const losersLabel = ordered
        .slice(1)
        .map(o => `${o.name} ${o.score}`)
        .join(' ');

      // Winner name + score in bold, losers normal, with extra gap before bts
      resultHtml = `<strong>${winnerLabel}</strong>&nbsp;&nbsp;bts ${losersLabel}`;
    } else if (ordered.length === 1) {
      const winnerLabel = `${ordered[0].name} ${ordered[0].score}`;
      resultHtml = `<strong>${winnerLabel}</strong>`;
    }

    const tsVal =
      g.ts ||
      g.created_at ||
      g.inserted_at ||
      (g.meta && (g.meta.ts || g.meta.date)) ||
      null;

    let when = '';
    if (tsVal) {
      const d = new Date(tsVal);
      if (!Number.isNaN(d.getTime())) {
        when = d.toLocaleString('en-GB', {
          day:    '2-digit',
          month:  '2-digit',
          hour:   '2-digit',
          minute: '2-digit'
        }).replace(',', '');
      }
    }

    // Date/time in bold, followed by the formatted result with extra gap
    if (when) {
      return `<strong>${when}</strong>&nbsp;&nbsp;&nbsp;&nbsp;${resultHtml}`;
    }
    return resultHtml;
  }

  async function startPsTicker(container, items) {
    if (!container || !items || !items.length) return;

    // Prevent multiple ticker loops if init is ever called twice
    if (container.dataset.vtickerRunning === '1') return;
    container.dataset.vtickerRunning = '1';

    // Clear any legacy content and create two stacked lines
    container.innerHTML = '';
    const lineA = document.createElement('div');
    const lineB = document.createElement('div');
    lineA.className = 'track';
    lineB.className = 'track';
    container.appendChild(lineA);
    container.appendChild(lineB);

    const height = container.clientHeight || 32;

    let currentIdx = 0;
    let active = lineA;
    let next   = lineB;

    // Initial state: first score visible, second line parked just below
    active.innerHTML = items[currentIdx];
    active.style.transition = 'none';
    next.style.transition   = 'none';
    active.style.transform  = 'translateY(0)';
    next.style.transform    = `translateY(${height}px)`;
    // Force a reflow so the browser applies initial transforms
    void active.offsetHeight;

    while (container.isConnected && items.length) {
      // Hold the current score fully visible
      await sleep(HOLD_MS);

      const nextIdx = (currentIdx + 1) % items.length;
      next.innerHTML = items[nextIdx];

      // Reset start positions (active in centre, next just below)
      active.style.transition = 'none';
      next.style.transition   = 'none';
      active.style.transform  = 'translateY(0)';
      next.style.transform    = `translateY(${height}px)`;
      void active.offsetHeight; // reflow

      // Animate both lines upwards together
      const dur = IN_MS;
      active.style.transition = `transform ${dur}ms ease-in-out`;
      next.style.transition   = `transform ${dur}ms ease-in-out`;
      active.style.transform  = `translateY(-${height}px)`;
      next.style.transform    = 'translateY(0)';

      // Wait for the animation to finish
      await sleep(dur);

      // Swap roles: the line that just slid in becomes the new active line
      const tmp = active;
      active = next;
      next   = tmp;
      currentIdx = nextIdx;
    }
  }

  async function initSingleLinePsTicker() {
    const ticker = document.getElementById('psTicker');
    if (!ticker) return;

    try {
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) {
        ticker.classList.add('hidden');
        return;
      }
  // Expose a safe refresh hook (used after player renames)
  window.__sqRefreshRecentMatchesTicker = initSingleLinePsTicker;
    } catch (_) {}

    let games = [];
    try {
      if (typeof cloudFetchAllGamesAsLocal === 'function') {
        games = await cloudFetchAllGamesAsLocal();
      }
    } catch (e) {
      console.error('psTicker: failed to fetch games', e);
    }

    if (!Array.isArray(games) || !games.length) {
      ticker.classList.add('hidden');
      return;
    }

    const toTS = (g) => {
      const t =
        g?.ts ||
        g?.created_at ||
        g?.inserted_at ||
        (g?.meta && (g.meta.ts || g.meta.date)) ||
        null;
      const n = t ? Date.parse(t) : NaN;
      return Number.isFinite(n) ? n : 0;
    };

    games = games
      .filter(Boolean)
      .sort((a, b) => toTS(b) - toTS(a))
      .slice(0, 25);

    // Phase 1 IDs: hide deleted players from the ticker.
    // We treat "active" players as those currently present in the players table.
    try {
      let activeSet = window.__sqActivePlayerNameSet;
      if (!(activeSet instanceof Set) && typeof cloudListPlayers === 'function') {
        const plist = await cloudListPlayers();
        activeSet = window.__sqActivePlayerNameSet;
      }
      const alias = (typeof window !== 'undefined' && typeof window.__sqApplyPlayerAlias === 'function')
        ? window.__sqApplyPlayerAlias
        : (x)=>x;

      if (activeSet instanceof Set && activeSet.size) {
        games = games.filter(g => {
          const names = (g?.players || []).map(p => (p && typeof p === 'object' && 'name' in p) ? p.name : String(p || ''));
          const mapped = names.map(n => String(alias(n) || '').trim().toLowerCase()).filter(Boolean);
          if (!mapped.length) return false;
          return mapped.every(n => activeSet.has(n));
        });
      }
    } catch (_) {}

    const items = games
      .map(formatGameForTicker)
      .filter(line => line && line.trim().length > 0);

    if (!items.length) {
      ticker.classList.add('hidden');
      return;
    }

    ticker.classList.remove('hidden');
    startPsTicker(ticker, items).catch(err => {
      console.error('psTicker loop error', err);
    });
  }

  // Remove any legacy ticker entry points so they can't interfere
  window.buildStartTicker = function () {};
  window.initVerticalGameTicker = function () {};

  document.addEventListener('DOMContentLoaded', function () {
    initSingleLinePsTicker().catch(function (err) {
      console.error('psTicker init failed', err);
    });
  });
})();

// Propagate a player rename to other cloud tables that store name strings.
// Best-effort only (ignore failures so we never break the app).
async function cloudPropagatePlayerRename(oldName, newName){
  // Keep this conservative: only touch tables that are known to exist in your current Supabase schema.
  const o = String(oldName||'').trim();
  const n = String(newName||'').trim();
  if (!o || !n || o === n) return;

  const tasks = [];
  try { tasks.push(sb.from(TABLE_HS_LEAGUE).update({ name: n }).eq('name', o)); } catch(_) {}
  try { tasks.push(sb.from(TABLE_HS_PRACTICE).update({ name: n }).eq('name', o)); } catch(_) {}

  // Best-effort only; never throw (avoid console red spam on missing tables/views)
  try { await Promise.allSettled(tasks); } catch(_) {}
}

// Best-effort: rename the player inside historical games.state JSON so stats/ranks stay unified.
// This updates state.players[].name (board is index-based so it stays valid).
async function cloudRenamePlayerInGamesState(oldName, newName, maxRows=500){
  const o = String(oldName||'').trim();
  const n = String(newName||'').trim();
  if (!o || !n || o === n) return { updated: 0 };
  let updated = 0;
  let offset = 0;
  const page = 100;

  while (updated < maxRows){
    const { data, error } = await sb
      .from(TABLE_GAMES)
      .select('id, state')
      .contains('state', { players: [{ name: o }] })
      .range(offset, offset + page - 1);

    if (error) throw error;
    const rows = data || [];
    if (!rows.length) break;

    for (const row of rows){
      if (updated >= maxRows) break;
      const st = row.state;
      if (!st || !Array.isArray(st.players)) continue;

      let changed = false;
      const players = st.players.map(pl => {
        if (pl && typeof pl === 'object' && String(pl.name||'').trim() === o){
          changed = true;
          return { ...pl, name: n };
        }
        return pl;
      });

      if (!changed) continue;

      const nextState = { ...st, players };
      const { error: uErr } = await sb.from(TABLE_GAMES).update({ state: nextState }).eq('id', row.id);
      if (uErr) throw uErr;
      updated += 1;
    }

    if (rows.length < page) break;
    offset += rows.length;
  }

  return { updated };
}


// Rename helper (updates `name` column)
async function cloudResolvePlayerKeyByName(name){
  const nm = String(name||'').trim();
  if (!nm) return null;
  // Use case-insensitive match to avoid "0 rows updated" silent failures
  try{
    const { data, error } = await sb
      .from(TABLE_PLAYERS)
      .select('id, name')
      .ilike('name', nm)
      .maybeSingle();
    if (error) throw error;
    return data || null;
  }catch(_){
    return null;
  }
}


// >>> PATCH:PLAYER_ID_SUPPORT START


// >>> PATCH:PLAYER_RENAME_RPC START
// Use Supabase RPC to merge rename across history (DB function: public.rename_player_merge(old_name, new_name)).
// This keeps legacy name-based data coherent while we gradually migrate UI to IDs.
async function cloudRenamePlayerMerge(oldName, newName){
  const o = String(oldName||'').trim();
  const n = String(newName||'').trim();
  if (!o || !n || o === n) return;

  const { error } = await sb.rpc('rename_player_merge', { old_name: o, new_name: n });
  if (error) { markCloudError(error); throw error; }
  markCloudOk();
}
// <<< PATCH:PLAYER_RENAME_RPC END

// Player rename by UUID id (keeps name-based propagation for legacy tables)
async function cloudRenamePlayerById(playerId, oldName, newName){
  const id = String(playerId||'').trim();
  const fallbackOld = String(oldName||'').trim();
  const n  = String(newName||'').trim();
  if (!id || !n) return;

  // Prefer the authoritative current name for this id (protects against case/whitespace mismatches)
  let o = fallbackOld;
  try{
    const { data, error } = await sb
      .from(TABLE_PLAYERS)
      .select('name')
      .eq('id', id)
      .maybeSingle();
    if (error) throw error;
    if (data && data.name) o = String(data.name).trim();
  }catch(_){ /* fall back */ }

  if (!o || o === n) return;

  // Server-side merge rename (players + match_players + matches JSON + highscores)
  await cloudRenamePlayerMerge(o, n);

  // Extra legacy cleanup: some views still parse games.state; keep those unified too.
  try { await cloudRenamePlayerInGamesState(o, n); } catch(_) {}
}
// <<< PATCH:PLAYER_ID_SUPPORT END


async function cloudRenamePlayer(oldName, newName){
  const o = String(oldName||'').trim();
  const n = String(newName||'').trim();
  if (!o || !n || o === n) return;

  // Server-side merge rename (players + match_players + matches JSON + highscores)
  await cloudRenamePlayerMerge(o, n);

  // Extra legacy cleanup: some views still parse games.state; keep those unified too.
  try { await cloudRenamePlayerInGamesState(o, n); } catch(_) {}
}

// Update player profile (first/last/region) while keeping `name` as the app-wide display key.
// Falls back to name-only update if profile columns do not exist.
// Update player profile (MOT2.2): rename-only shim.
// Your Supabase schema (players) appears to be name-only.
// Keeping this function prevents older UI code from breaking if it still calls it.

async function cloudUpdatePlayerProfile(playerOrName, profile){
  const obj = (playerOrName && typeof playerOrName === 'object') ? playerOrName : null;
  const keyName = String(obj ? (obj.name||'') : (playerOrName||'')).trim();
  const keyId   = String(obj ? (obj.id||'')   : '').trim();
  const p = (profile && typeof profile === 'object') ? profile : {};

  if (!keyName && !keyId) return null;

  // Build payload (only include defined keys)
  const payload = {};
  if (p.first_name != null) payload.first_name = String(p.first_name||'').trim();
  if (p.last_name  != null) payload.last_name  = String(p.last_name ||'').trim();
  if (p.nickname   != null) payload.nickname   = String(p.nickname  ||'').trim();
  if (p.initials   != null) payload.initials   = __sqNormalizeInitials(String(p.initials||''), (p.name||keyName));

  // Optional name update (normally handled via rename RPC first)
  if (p.name != null){
    const nm = String(p.name||'').trim();
    if (nm) payload.name = nm;
  }

  if (!Object.keys(payload).length) return null;

  try{
    let q = sb.from(TABLE_PLAYERS).update(payload);
    if (keyId) q = q.eq('id', keyId);
    else q = q.eq('name', keyName);

    const { data, error } = await q.select('id,name,first_name,last_name,nickname,initials').maybeSingle();
    if (error) { markCloudError(error); throw error; }
    markCloudOk();
    await cloudRefreshPlayerDirectory(true);
    window.dispatchEvent(new CustomEvent('sq:players-changed'));
    return data || null;
  }catch(e){
    // If some columns don't exist on older deployments, fall back to safe minimal update.
    const msg  = String(e?.message || e || '');
    const code = String(e?.code || '');
    const missing = (code === '42703') || /column .* does not exist/i.test(msg);
    if (!missing) throw e;

    const fallback = {};
    if (payload.initials != null) fallback.initials = payload.initials;
    if (payload.name != null)     fallback.name     = payload.name;
    if (!Object.keys(fallback).length) return null;

    const q2 = keyId
      ? sb.from(TABLE_PLAYERS).update(fallback).eq('id', keyId)
      : sb.from(TABLE_PLAYERS).update(fallback).eq('name', keyName);
    const { data, error } = await q2.select('id,name,initials').maybeSingle();
    if (error) { markCloudError(error); throw error; }
    markCloudOk();
    return data || null;
  }
}

/* ===== @CLOUD:PLAYER_DIRECTORY (game-wide display + cache) ===== */
const TABLE_PLAYERS = 'players';
const TABLE_PLAYERS_ARCHIVE = 'players_archive'; // create this table in Supabase (see notes)

let _sqPlayerDir = { byId:{}, byName:{}, list:[], loadedAt:0 };

function sqIsUuidLike(v){
  return typeof v === 'string' && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(v.trim());
}

async function cloudRefreshPlayerDirectory(force=false){
  if (!ensureCloudInit()) return _sqPlayerDir;

  const now = Date.now();
  if (!force && _sqPlayerDir.loadedAt && (now - _sqPlayerDir.loadedAt) < 30_000 && _sqPlayerDir.list?.length) return _sqPlayerDir;

  try{
    const sb = window.supabaseClient;
    const { data, error } = await sb
      .from(TABLE_PLAYERS)
      .select('id,name,first_name,last_name,initials,nickname,created_at,deleted_at')
      .order('created_at', { ascending: true });

    if (error) throw error;

    const list = (data || []).filter(p => !p?.deleted_at);

    const byId = {};
    const byName = {};
    for (const p of list){
      if (p?.id) byId[p.id] = p;
      if (p?.name) byName[String(p.name).trim().toLowerCase()] = p;
    }

    _sqPlayerDir = { byId, byName, list, loadedAt: now };
  }catch(e){
    console.warn('[SQ] player directory refresh failed:', e?.message || e);
  }

  return _sqPlayerDir;
}

function sqFormatPlayerLabelFromProfile(p){
  if (!p) return '';
  const first = (p.first_name || '').trim();
  const last  = (p.last_name || '').trim();
  const nick  = (p.nickname || '').trim();
  const baseName = (p.name || '').trim();

  // Prefer: First "Nickname" Last, else fallback to name
  if (first){
    if (nick && last) return `${first} "${nick}" ${last}`.trim();
    if (nick) return `${first} "${nick}"`.trim();
    if (last) return `${first} ${last}`.trim();
    return first;
  }

  if (baseName){
    if (nick) return `${baseName} "${nick}"`.trim();
    return baseName;
  }

  return '';
}

// Use anywhere UI needs a player label, even if history stores only `name`
function sqDisplayNameForPlayerField(nameOrId){
  if (nameOrId == null) return '';
  const raw = String(nameOrId);
  const t = raw.trim();
  if (!t) return '';

  const p =
    (_sqPlayerDir.byId && _sqPlayerDir.byId[t]) ||
    (_sqPlayerDir.byName && _sqPlayerDir.byName[t.toLowerCase()]);

  return p ? sqFormatPlayerLabelFromProfile(p) : raw;
}

function sqInitialsForPlayerField(nameOrId, fallback=''){
  if (nameOrId == null) return fallback;
  const raw = String(nameOrId).trim();
  if (!raw) return fallback;

  const p =
    (_sqPlayerDir.byId && _sqPlayerDir.byId[raw]) ||
    (_sqPlayerDir.byName && _sqPlayerDir.byName[raw.toLowerCase()]);

  return (p?.initials ? String(p.initials).trim() : fallback) || fallback;
}

async function cloudArchivePlayerSnapshot(playerRow, reason='admin_change'){
  if (!ensureCloudInit() || !playerRow?.id) return;
  try{
    const sb = window.supabaseClient;
    // best-effort archive (table may not exist yet)
    await sb.from(TABLE_PLAYERS_ARCHIVE).insert({
      player_id: playerRow.id,
      player_name: playerRow.name || null,
      reason,
      payload: playerRow,
      archived_at: new Date().toISOString(),
    });
  }catch(e){
    // ignore (archive table not present / RLS / etc.)
  }
}



// Game Complete modal hierarchy tweak (title + big result + smaller standings)

(function(){
  if (window.__gameCompleteModalPatch) return;
  window.__gameCompleteModalPatch = true;

  function patchGameCompleteModal(root){
    try{
      const modal = root.querySelector('.modal');
      if (!modal) return;

      const titleEl = modal.querySelector('h3');
      if (!titleEl) return;
      const titleText = (titleEl.textContent || '').trim();
      if (!/game complete/i.test(titleText)) return; // only touch the Game Complete popup

      // Tag modal + title for CSS
      modal.classList.add('game-complete');
      titleEl.classList.add('gc-title');

      const body = modal.querySelector('.modal-body') || modal;
      if (!body) return;

      // Find the existing winners line (WINNER: / JOINT WINNERS: ...)
      const children = Array.from(body.children || []);
      let resultEl = children.find(el => /winner/i.test((el.textContent || '')));

      // Fallback: first strong/heading that mentions winner
      if (!resultEl){
        const candidate = body.querySelector('strong, h1, h2, h3');
        if (candidate && /winner/i.test((candidate.textContent || ''))) {
          resultEl = candidate;
        }
      }

      if (resultEl){
        resultEl.classList.add('gc-result');
      }

      // Style the standings list (ordered or unordered list)
      const list = body.querySelector('ol, ul');
      if (list){
        list.classList.add('gc-standings');
      }
    } catch(e){
      console.error('patchGameCompleteModal error', e);
    }
  }

  // Watch for modals being added; when a Game Complete popup appears, patch it (via shared UI mutation bus)
  try {
    window.__sqUIMutationBus?.on((muts) => {
      for (const m of (muts || [])){
        for (const n of (m.addedNodes || [])){
          if (!(n instanceof HTMLElement)) continue;
          if (n.classList.contains('modal-backdrop')){
            // Let the modal render fully, then patch it
            setTimeout(() => patchGameCompleteModal(n), 0);
          }
        }
      }
    });
  } catch(_) {}
})();

// Patch Player Stats hub modal to inject a PROGRESSION button after STATS
(function () {
  if (window.__playerStatsProgressionPatch) return;
  window.__playerStatsProgressionPatch = true;

  function tryPatchPlayerStatsModal(root) {
    try {
      const modal = root.querySelector('.modal');
      if (!modal) return;

      const titleEl = modal.querySelector('h3');
      if (!titleEl) return;
      const titleText = (titleEl.textContent || '').trim();

      // Only touch Player Stats modals
      if (!/^Player Stats\s*[\u2013\u2014-]/i.test(titleText)) return;

      // Find GAMES and STATS buttons
      const buttons = Array.from(modal.querySelectorAll('button'));
      const gamesBtn = buttons.find(
        b => (b.textContent || '').trim().toUpperCase() === 'GAMES'
      );
      const statsBtn = buttons.find(
        b => (b.textContent || '').trim().toUpperCase() === 'STATS'
      );

      if (!gamesBtn || !statsBtn) return;

      // If PROGRESSION already exists, do nothing
      const existingProg = buttons.find(
        b => (b.textContent || '').trim().toUpperCase() === 'PROGRESSION'
      );
      if (existingProg) return;

      // Clone STATS style to keep look identical
      const progBtn = statsBtn.cloneNode(true);
      progBtn.textContent = 'PROGRESSION';
      if (progBtn.dataset) {
        progBtn.dataset.view = 'progression';
      }

      // Insert immediately after STATS
      if (statsBtn.parentNode) {
        statsBtn.parentNode.insertBefore(progBtn, statsBtn.nextSibling);
      }
    } catch (e) {
      console.error('Player Stats progression patch failed', e);
    }
  }

  try {
    window.__sqUIMutationBus?.on((muts) => {
      for (const m of (muts || [])) {
        for (const n of (m.addedNodes || [])) {
          if (!(n instanceof HTMLElement)) continue;

          // Modal added directly
          if (n.classList.contains('modal-backdrop')) {
            tryPatchPlayerStatsModal(n);
          } else if (n.querySelector) {
            // Or nested within some other added node
            const backdrop = n.querySelector('.modal-backdrop');
            if (backdrop) tryPatchPlayerStatsModal(backdrop);
          }
        }
      }
    });
  } catch (_) {}
})();

// Patch High Score League modal 'Back' button to return to League / Rankings
(function () {
  if (window.__hsLeagueBackPatch) return;
  window.__hsLeagueBackPatch = true;

  function tryPatchHsLeagueModal(root) {
    try {
      const modal = root.querySelector
        ? root.querySelector('.modal')
        : null;
      if (!modal) return;

      const titleEl = modal.querySelector('h3');
      if (!titleEl) return;

      const titleText = (titleEl.textContent || '').toLowerCase();
      // Only touch "High Scores" modals that look like the league/match view,
      // and skip anything clearly labeled as "Round High Scores".
      if (!titleText.includes('high') || !titleText.includes('score')) return;
      if (titleText.includes('round')) return;
      if (!titleText.includes('league') && !titleText.includes('match')) return;

      const buttons = Array.from(modal.querySelectorAll('button'));
      const backBtn = buttons.find(
        b => (b.textContent || '').trim().toLowerCase() === 'back'
      );
      if (!backBtn) return;

      backBtn.onclick = () => {
        let backdrop = root;
        if (!(backdrop instanceof HTMLElement) || !backdrop.classList.contains('modal-backdrop')) {
          backdrop = modal.closest('.modal-backdrop') || backdrop;
        }
        if (backdrop && backdrop.classList) {
          try { backdrop.classList.add('hidden'); } catch (_) {}
          try { backdrop.remove(); } catch (_) {}
        }
        // Return behaviour: if we're in admin context, go back to Admin Hub; otherwise League / Rankings
        if (window.__sqNavContext === 'admin' && typeof window.openAdminHub === 'function') {
          try { if (window.__sqLeagueOverlay && window.__sqLeagueOverlay.remove) window.__sqLeagueOverlay.remove(); } catch(_) {}
          try { window.openAdminHub(); } catch (_) {}
        } else if (typeof window.openLeagueRankingsDialog === 'function') {
          try { window.openLeagueRankingsDialog(); } catch (_) {}
        }
      };
    } catch (e) {
      try { console.error('HS League back patch failed', e); } catch (_) {}
    }
  }

  try {
    window.__sqUIMutationBus?.on((muts) => {
      for (const m of (muts || [])) {
        for (const n of (m.addedNodes || [])) {
          if (!(n instanceof HTMLElement)) continue;
          if (n.classList.contains('modal-backdrop')) {
            tryPatchHsLeagueModal(n);
          } else if (n.querySelector) {
            const backdrop = n.querySelector('.modal-backdrop');
            if (backdrop) tryPatchHsLeagueModal(backdrop);
          }
        }
      }
    });
  } catch (_) {}
})();

// >>> PATCH:power-league-rounds START â€” treat full game as 14 rounds
(function(){
  if (window.__powerLeagueRoundsPatch) return;
  window.__powerLeagueRoundsPatch = true;

  // Interpret recorded rounds (10â€“20 only) as part of a 14â€‘round game (10â€“20 + D + T + Bull)
  const RAW_ROUNDS_PER_GAME   = 11;
  const FULL_ROUNDS_PER_GAME  = 14;
  const SCALE = FULL_ROUNDS_PER_GAME / RAW_ROUNDS_PER_GAME;

  function rescaleRow(row){
    if (!row) return row;
    const raw = Number(row.rounds || 0);
    if (!raw || !Number.isFinite(raw)) return row;

    const scaled = Math.round(raw * SCALE);
    if (!scaled || !Number.isFinite(scaled)) return row;

    const next = Object.assign({}, row);

    // Try to preserve the original total by adjusting the average
    const avgKeys = ['avg_per_round','avgPerRound','avgRound','avg'];
    let totalScore = null;
    let avgKeyUsed = null;

    for (const k of avgKeys){
      if (!(k in next)) continue;
      const val = Number(next[k]);
      if (!Number.isFinite(val) || val <= 0) continue;
      totalScore = val * raw;
      avgKeyUsed = k;
      break;
    }

    next.rounds = scaled;
    if (avgKeyUsed && totalScore != null && scaled > 0){
      next[avgKeyUsed] = totalScore / scaled;
    }

    return next;
  }

  const orig = window.computePowerLeagueRows;
  if (typeof orig === 'function'){
    window.computePowerLeagueRows = async function(){
      const rows = await orig();
      if (!Array.isArray(rows)) return rows;
      return rows.map(rescaleRow);
    };
  }
})();
// >>> PATCH:power-league-rounds END


// === Player Summary Stats dialog (cloud-only, extended aggregate) ===
// Temporary stub so the game runs while this feature is unfinished.
window.openPlayerSummaryStatsDialog = async function openPlayerSummaryStatsDialog(playerName, mode){
  console.warn('openPlayerSummaryStatsDialog is not implemented yet.', { playerName, mode });
};

// === Player Progression dialog (per-game line graph) ===
window.openPlayerProgressionDialog = async function openPlayerProgressionDialog(playerName, mode) {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';
  const modal = document.createElement('div');
  modal.className = 'modal sq-wide-modal';
  const title = document.createElement('h3');
  const body = document.createElement('div');
  body.className = 'modal-body';
  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const isPractice = (mode === 'practice' || mode === true);
  const labelMode = isPractice ? 'Practice' : 'Official';
  const safeName = playerName || 'Unknown';

  title.textContent = `Progression â€” ${safeName} (${labelMode})`;

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  modal.tabIndex = 0;
  modal.focus();

  const close = () => { overlay.remove(); };

  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = close;

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn sq-pill';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = close;

  footer.append(backBtn, closeBtn);

  // Top controls + chart area
body.innerHTML = `
  <div class="row" style="gap:8px; margin-bottom:8px;">
    <button class="btn primary" data-metric="score">Game Score</button>
    <button class="btn" data-metric="avg">5 Game Average</button>
    <button class="btn" data-metric="target">Target %</button>
  </div>
  <p class="tag" id="progHint">Vertical: Score / %, Horizontal: Games (1, 2, 3, â€¦)</p>
`;

  const metricButtons = Array.from(body.querySelectorAll('button[data-metric]'));
  const canvas = body.querySelector('#progChartCanvas');
  const ctx = canvas && canvas.getContext ? canvas.getContext('2d') : null;

  if (!ctx) {
    const wrap = body.querySelector('#progChartWrap');
    if (wrap) wrap.innerHTML = '<p>Canvas not supported in this browser.</p>';
    return;
  }

  // ---- Fetch per-game data for this player ----
  async function loadData() {
    try {
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) {
        return { labels: [], scores: [], avgs: [], targetPct: [] };
      }
    } catch (_) {}

    const tableName = (typeof TABLE_PLAYER_GAMES !== 'undefined' && TABLE_PLAYER_GAMES)
      ? TABLE_PLAYER_GAMES
      : 'player_games_union';

    let games = [];
    try {
      const { data, error } = await sb
        .from(tableName)
        .select('sheet_id, player, score, rounds, ts, is_practice')
        .eq('player', safeName)
        .eq('is_practice', !!isPractice)
        .order('ts', { ascending: true })
        .limit(200);
      if (error) throw error;
      games = (data || []).filter(Boolean);
    } catch (e) {
      console.error('Progression: games fetch failed', e);
      return { labels: [], scores: [], avgs: [], targetPct: [] };
    }

    if (!games.length) {
      return { labels: [], scores: [], avgs: [], targetPct: [] };
    }

    // x-axis: game index 1..N
    const labels = games.map((_, idx) => idx + 1);

// Fixed Y-axis (same across all modes) + overall average of all games
const avgAll = scores.length ? (scores.reduce((s,v)=>s+v,0) / scores.length) : 0;
const baseMaxScore = scores.length ? Math.max(...scores) : 0;
const FIXED_Y_MAX = Math.max(25, Math.ceil(baseMaxScore / 25) * 25);

const scores = games.map(g => Number(g.score || 0));

// 5 Game Average: only at games 5, 10, 15â€¦
// game 5 = avg of game 1â€“5, game 10 = avg of 6â€“10, etc.
const avgs = scores.map((_, idx) => {
  const gameNo = idx + 1;          // 1-based game index
  if (gameNo % 5 !== 0) return NaN; // only plot at 5, 10, 15, ...
  const start = idx - 4;           // start of the 5-game block
  if (start < 0) return NaN;
  let sum = 0;
  for (let i = start; i <= idx; i++) {
    sum += Number(scores[i] || 0);
  }
  return sum / 5;
});

    // Overall target hit % per game (all darts)
    let targetPct = new Array(games.length).fill(0);

    try {
      const gameIds = games.map(g => g.sheet_id).filter(Boolean);
      if (gameIds.length && typeof TABLE_GAME_THROWS !== 'undefined') {
        const { data: throwsRaw, error: tErr } = await sb
          .from(TABLE_GAME_THROWS)
          .select('game_id, points')
          .in('game_id', gameIds)
          .eq('player', safeName);
        if (!tErr && Array.isArray(throwsRaw)) {
          const byGame = new Map();
          throwsRaw.forEach(row => {
            const gid = row.game_id;
            if (!gid) return;
            let agg = byGame.get(gid);
            if (!agg) {
              agg = { hits: 0, attempts: 0 };
              byGame.set(gid, agg);
            }
            agg.attempts += 1;
            const pts = Number(row.points || 0);
            if (pts > 0) agg.hits += 1;
          });

          targetPct = games.map(g => {
            const agg = byGame.get(g.sheet_id);
            if (!agg || !agg.attempts) return 0;
            return (agg.hits * 100) / agg.attempts;
          });
        }
      }
    } catch (e) {
      console.error('Progression: target% fetch failed', e);
    }

    return { labels, scores, avgs, targetPct };
  }

  const data = await loadData();

  if (!data.labels.length) {
    const wrap = body.querySelector('#progChartWrap');
    if (wrap) wrap.innerHTML = '<p>No games found for this player/mode.</p>';
    return;
  }

  function setActiveMetricButton(metric) {
    metricButtons.forEach(btn => {
      const m = btn.getAttribute('data-metric');
      if (m === metric) btn.classList.add('primary');
      else btn.classList.remove('primary');
    });
  }

  function drawLineChart(values, metric) {
    const labels = data.labels;
    const W = canvas.width;
    const H = canvas.height;
    const paddingLeft = 40;
    const paddingRight = 10;
    const paddingTop = 10;
    const paddingBottom = 28;

    ctx.clearRect(0, 0, W, H);

    if (!labels.length || !values.length) return;

const finiteVals = values.filter(v => Number.isFinite(v));
if (!finiteVals.length) return;
const maxValRaw = Math.max(...finiteVals);
const maxVal = maxValRaw > 0 ? maxValRaw : 1;

    const xMin = 0;
    const xMax = labels.length > 1 ? labels.length - 1 : 1;

    const plotW = W - paddingLeft - paddingRight;
    const plotH = H - paddingTop - paddingBottom;

    function xForIndex(i) {
      if (xMax === xMin) return paddingLeft + plotW / 2;
      return paddingLeft + ((i - xMin) / (xMax - xMin)) * plotW;
    }
    function yForValue(v) {
      const clamped = v < 0 ? 0 : v;
      return paddingTop + (1 - clamped / maxVal) * plotH;
    }

    // Axes
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 1;

    // Y-axis
    ctx.beginPath();
    ctx.moveTo(paddingLeft, paddingTop);
    ctx.lineTo(paddingLeft, H - paddingBottom);
    ctx.stroke();

    // X-axis
    ctx.beginPath();
    ctx.moveTo(paddingLeft, H - paddingBottom);
    ctx.lineTo(W - paddingRight, H - paddingBottom);
    ctx.stroke();

    // Y ticks
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.font = '10px system-ui';
    const steps = 4;
    for (let i = 0; i <= steps; i++) {
      const v = (maxVal * i) / steps;
      const y = yForValue(v);
      ctx.beginPath();
      ctx.moveTo(paddingLeft - 3, y);
      ctx.lineTo(W - paddingRight, y);
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.fillText(metric === 'target' ? v.toFixed(0) + '%' : v.toFixed(0), 4, y + 3);
    }

    // X labels
    for (let i = 0; i < labels.length; i++) {
      const x = xForIndex(i);
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.fillText(String(labels[i]), x - 4, H - paddingBottom + 14);
    }
// Average line across the chart for the current metric (finite values only)
const sum = values.reduce((acc, v) => acc + (Number.isFinite(v) ? v : 0), 0);
const mean = finiteVals.length ? (sum / finiteVals.length) : 0;
const yMean = yForValue(mean);

ctx.save();
ctx.strokeStyle = 'rgba(255,255,255,0.35)';
ctx.lineWidth = 1;
ctx.setLineDash([4, 4]);
ctx.beginPath();
ctx.moveTo(paddingLeft, yMean);
ctx.lineTo(W - paddingRight, yMean);
ctx.stroke();
ctx.restore();

// Line (skip positions without data, e.g. non-5th games for 5 Game Average)
ctx.strokeStyle = '#7bdcff';
ctx.lineWidth = 2;
ctx.beginPath();
let started = false;
values.forEach((v, i) => {
  if (!Number.isFinite(v)) return;
  const x = xForIndex(i);
  const y = yForValue(v);
  if (!started) {
    ctx.moveTo(x, y);
    started = true;
  } else {
    ctx.lineTo(x, y);
  }
});
if (started) ctx.stroke();

// Points
ctx.fillStyle = '#8cff9e';
values.forEach((v, i) => {
  if (!Number.isFinite(v)) return;
  const x = xForIndex(i);
  const y = yForValue(v);
  ctx.beginPath();
  ctx.arc(x, y, 3, 0, Math.PI * 2);
  ctx.fill();
});
  }

 function render(metric) {
  let values = data.scores;
  if (metric === 'target') values = data.targetPct;
  setActiveMetricButton(metric);
  drawLineChart(values, metric);
}

  // Wire metric buttons
  metricButtons.forEach(btn => {
    const metric = btn.getAttribute('data-metric');
    btn.onclick = () => render(metric);
  });

  // Initial render
  render('score');
};

// Player Stats overlay: wire the STATS tab via global click delegation
(function wirePlayerStatsStatsButton(){
  if (window.__playerStatsStatsWired) return;
  window.__playerStatsStatsWired = true;

  document.addEventListener('click', function(e){
    try {
      const btn = e.target.closest('button, .btn');
      if (!btn) return;
      const label = (btn.textContent || '').trim().toLowerCase();
      if (label !== 'stats') return;

      // Only act if this STATS control lives inside a Player Stats modal
      const modal = btn.closest('.modal');
      if (!modal) return;
      const h3 = modal.querySelector('h3');
      if (!h3 || !/player stats/i.test((h3.textContent || ''))) return;

      const titleText = h3.textContent || '';
      let playerName = '';

      // Extract the bit after "Player Stats â€“" / "Player Stats â€”" / "Player Stats -"
      const m = titleText.match(/player stats\s*[\u2013\u2014-]\s*(.+)$/i);
      if (m && m[1]) {
        playerName = m[1].trim();
      }

      // Fallback: strip the "Player Stats" prefix if present
      if (!playerName) {
        playerName = titleText.replace(/player stats/i, '').trim();
      }

      if (typeof window.openPlayerSummaryStatsDialog === 'function'){
        window.openPlayerSummaryStatsDialog(playerName || '');
      }
    } catch(err){
      console.error('wirePlayerStatsStatsButton error', err);
    }
  }, true); // capture so we see it before other handlers
})();

      console.log('SQ build: script wrapped OK');
if (!window.buildStartTicker) { window.buildStartTicker = async function(){}; }

// Start PB annotation on load (safe to call multiple times)
document.addEventListener('DOMContentLoaded', () => {
  try { setupRoundScoreObserver(); } catch(_) {}
  try { wireTopRowButtons(); } catch(_) {}
  try { initSetupSteppers(); } catch(_) {}
});

// --- Top row buttons: compatibility wiring for new + legacy IDs ---
function _showPageSafe(id){
  // Prefer existing app router, else do a minimal local switch
  if (typeof window.showPage === 'function') { try { window.showPage(id); return; } catch(_){ } }
  const sections = ['details','players','game','leaderboard'];
  sections.forEach(sid => {
    const sec = document.getElementById(sid);
    if (sec) {
      if (sid === id) sec.classList.remove('hidden');
      else sec.classList.add('hidden');
    }
  });
  try { document.body.dataset.page = id; } catch(_){}
}

function navigateToStartScreen(){
  _showPageSafe('details');
}

function restartGameSafe(){
  // Try known hooks if they exist, else reload as a last resort
  const candidates = ['restartGame', 'startNewGame', 'initMatch', 'beginNewGame'];
  for (const name of candidates){
    const fn = window[name];
    if (typeof fn === 'function'){
      try { fn(); return; } catch(_){}
    }
  }
  // Fallback: hard reset
  location.reload();
}

function openStatsHubSafe(){
  const candidates = ['openStatsHub', 'openStatsHubDialog', 'openStatsMenu', 'openStats', 'showStatsHub'];
  for (const name of candidates){
    const fn = window[name];
    if (typeof fn === 'function'){
      try { fn(); return; } catch(_){}
    }
  }
  if (typeof toast === 'function') toast('Stats panel not available on this build');
}
function wireTopRowButtons(){
  // Support both the new IDs and legacy IDs if they exist
  const startIds   = [
    'startScreenBtnFromGame',
    'startScreenBtnFromLB',
    'startScreenBtnLB',
    'startScreenBtnGame'
  ];
  const restartIds = [
    'restartGameBtnFromGame',
    'restartGameBtnFromLB',
    'restartGameBtnLB',
    'restartGameBtnGame'
  ];
  const statsIds   = [
    'statsHubBtnFromGame',
    'statsHubBtnFinal',
    'statsHubBtnLB',
    'statsHubBtnGame'
  ];

  startIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.onclick = navigateToStartScreen;
  });
  restartIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.onclick = restartGameSafe;
  });
  statsIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.onclick = openStatsHubSafe;
  });
}

// --- Stepper bootstrap (must exist before any DOMContentLoaded references) ---
(function(){
  if (typeof window.initSetupSteppers === 'function') return;
  window.initSetupSteppers = function initSetupSteppers(){
    const steppers = document.querySelectorAll('.setup-stepper');
    steppers.forEach(stepper => {
      const selectId = stepper.getAttribute('data-select-id');
      const suffix   = stepper.getAttribute('data-suffix') || '';
      const select   = document.getElementById(selectId);
      const numEl    = stepper.querySelector('.stepper-number');
      const sufEl    = stepper.querySelector('.stepper-suffix');
      if (sufEl) sufEl.textContent = suffix;
      if (!select || !numEl) return;
      

/* === Admin â†’ Button + Password Popup (final) === */
(function adminButton(){
  const expected = (window.ADMIN_PASSWORD || 'hownowbrowncow'); // change if needed

  // 1) Ensure we have a single Admin button
  const row = document.getElementById('adminCodeRow');
  let btn = document.getElementById('adminCodeBtn');

  function ensureButton() {
    if (!btn) {
      btn = document.createElement('button');
      btn.id = 'adminCodeBtn';
      btn.className = 'btn';
      if (row) { row.innerHTML = ''; row.appendChild(btn); }
      else document.body.appendChild(btn); // fallback (shouldnâ€™t be used)
    }
    btn.textContent = 'Admin';
    btn.title = 'Admin';
    btn.setAttribute('aria-label', 'Admin');
    btn.onclick = openAdminPasswordModal;
  }

  // 2) Remove any standalone "Admin Code" heading/label left in the markup
  function removeStandaloneLabel(){
    const candidates = Array.from(document.querySelectorAll(
      '#details h1, #details h2, #details h3, #details h4, #details .muted, #details label'
    ));
    candidates.forEach(el => {
      const t = (el.textContent || '').trim();
      if (/^admin\s*code$/i.test(t)) el.remove();
    });
  }

  // 3) Password popup â†’ on success open the standard Admin panel
  function openAdminPasswordModal(){
    const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
    const modal   = document.createElement('div'); modal.className = 'modal';

    const title = document.createElement('h3'); title.textContent = 'Admin Login';
    const body  = document.createElement('div'); body.className = 'modal-body';

    const label = document.createElement('label');
    label.textContent = 'Enter password:';
    label.className = 'muted';
    label.style.display = 'block';
    label.style.marginBottom = '6px';

    const input = document.createElement('input');
    input.type = 'password';
    input.className = 'input';
    input.autocomplete = 'current-password';
    input.placeholder = 'Password';
    input.style.minWidth = '220px';

    body.append(label, input);

    const footer = document.createElement('div'); footer.className = 'modal-footer';
    const cancel = document.createElement('button'); cancel.className = 'btn';         cancel.textContent = 'Cancel';
    const enter  = document.createElement('button'); enter.className  = 'btn primary'; enter.textContent  = 'Enter';

    function close(){ overlay.remove(); }
    function deny(){
      if (typeof toast === 'function') toast('Incorrect password');
      else alert('Incorrect password');
      input.focus(); input.select();
    }
    function grant(){
      window.__sqAdminAuthed = true;
      close();
      // Call the ungated hub if available to avoid recursion
      if (typeof window.__openAdminHubUnsafe === 'function') window.__openAdminHubUnsafe();
      else if (typeof window.openAdminHub === 'function') window.openAdminHub();
      else if (typeof openAdminHub === 'function') openAdminHub();
    }
    function submit(){
      const v = (input.value || '').trim();
      if (!expected || v === expected) grant(); else deny();
    }

    cancel.onclick = close;
    enter.onclick  = submit;
    input.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') submit(); });

    footer.append(cancel, enter);
    modal.append(title, body, footer);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    modal.tabIndex = 0; modal.focus();
    overlay.addEventListener('click', e => { if (e.target === overlay) close(); });
    overlay.addEventListener('keydown', e => { if (e.key === 'Escape') close(); });

    setTimeout(()=> input.focus(), 0);
  }
    // Export for other wiring (e.g. start-screen Admin button)
    window.openAdminPasswordModal = openAdminPasswordModal;

// Ensure ALL admin entrypoints are password-gated (including any legacy buttons calling openAdminHub directly)
(function(){
  if (window.__sqAdminGateWrapped) return;
  window.__sqAdminGateWrapped = true;
  if (window.__sqAdminAuthed == null) window.__sqAdminAuthed = false;

  function tryWrap(){
    if (typeof window.openAdminPasswordModal !== 'function') return false;
    if (typeof window.openAdminHub !== 'function') return false;
    if (window.openAdminHub.__sqIsGated) return true;

    const unsafe = window.openAdminHub;
    window.__openAdminHubUnsafe = unsafe;

    window.openAdminHub = function(){
      if (window.__sqAdminAuthed) return unsafe();
      return window.openAdminPasswordModal();
    };
    window.openAdminHub.__sqIsGated = true;

    // Capture-click safety net (covers markup onclick + nested icons)
    document.addEventListener('click', (e)=>{
      const el = e.target && e.target.closest ? e.target.closest('#adminBtn,#adminCodeBtn,button,a') : null;
      if (!el) return;
      const id = (el.id||'').toLowerCase();
      const label = String(el.textContent||'').trim().toLowerCase();
      const isAdmin = (id==='adminbtn' || id==='admincodebtn' || label==='admin' || label==='admin hub' || label==='admin code');
      if (!isAdmin) return;
      if (!window.__sqAdminAuthed){
        e.preventDefault();
        e.stopPropagation();
        window.openAdminPasswordModal();
      }
    }, true);
    return true;
  }

  let tries = 0;
  const iv = setInterval(()=>{
    tries++;
    if (tryWrap() || tries > 30) clearInterval(iv);
  }, 200);
})();


  removeStandaloneLabel();
  ensureButton();
})();

// Start screen: simple High Scores hub (two choices)
function openHighScoresHubDialog(){
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
   const modal   = document.createElement('div'); modal.className   = 'modal sq-wide-modal';
  modal.style.maxWidth = '980px';
  modal.style.width = '94vw';
  modal.style.maxHeight = '90vh';
  modal.style.overflow = 'hidden';
  const title   = document.createElement('h3');  title.textContent = 'High Scores';
  const body    = document.createElement('div'); body.className = 'modal-body';
  const col     = document.createElement('div'); col.className = 'column'; col.style.gap = '8px';

  const btnMatch = document.createElement('button');
  btnMatch.className = 'btn big';
  btnMatch.textContent = 'High Scores (Match)';
  btnMatch.onclick = () => {
    try {
      if (typeof openHighScoresMenuDialog === 'function') openHighScoresMenuDialog(false);
      else if (typeof openHighScoresMenu === 'function') openHighScoresMenu(false);
      else if (typeof openHighScoresDialog === 'function') openHighScoresDialog(false);
      else if (typeof toast === 'function') toast('Match high scores not available');
      else alert('Match high scores not available');
    } finally { overlay.remove(); }
  };

  const btnRound = document.createElement('button');
  btnRound.className = 'btn big';
  btnRound.textContent = 'High Scores (Round)';
  btnRound.onclick = () => {
    try {
      if (typeof openRoundHighScoresDialog === 'function') openRoundHighScoresDialog();
      else if (typeof toast === 'function') toast('Round high scores not available');
      else alert('Round high scores not available');
    } finally { overlay.remove(); }
  };

  col.append(btnMatch, btnRound);
  body.appendChild(col);

  const footer = document.createElement('div'); footer.className = 'modal-footer';
  const close  = document.createElement('button'); close.className = 'btn'; close.textContent = 'Close';
  close.onclick = () => overlay.remove();
  footer.appendChild(close);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  modal.tabIndex = 0; modal.focus();

  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', (e) => { if (e.key === 'Escape') overlay.remove(); });
}

      // Prevent duplicate bindings (which caused skipping: 1â†’3â†’5â€¦)
      if (stepper.dataset.bound === '1') return;
      stepper.dataset.bound = '1';

      // Determine min/max from the select's option values
      const values = [...select.options].map(o => parseInt(o.value, 10)).filter(n => !Number.isNaN(n));
      const minVal = Math.min(...values);
      const maxVal = Math.max(...values);

      function syncFromSelect(){
        const val = parseInt(select.value, 10);
        if (!Number.isNaN(val)) {
          numEl.textContent = String(val);
        } else {
          const opt = select.options[select.selectedIndex];
          const txt = opt ? opt.textContent : '';
          const m = txt && txt.match(/\d+/);
          numEl.textContent = m ? m[0] : txt;
        }
      }

      function setTo(v){
        const targetIdx = [...select.options].findIndex(o => parseInt(o.value, 10) === v);
        if (targetIdx >= 0) {
          select.selectedIndex = targetIdx;
          select.dispatchEvent(new Event('change', { bubbles: true }));
          syncFromSelect();
        }
      }

      // Bind buttons using `onclick` (overwrites any prior handlers)
      stepper.querySelectorAll('.stepper-btn').forEach(btn => {
        const delta = parseInt(btn.getAttribute('data-delta') || '0', 10);
        btn.onclick = () => {
          const cur = parseInt(select.value, 10);
          const next = Math.min(maxVal, Math.max(minVal, cur + (delta > 0 ? 1 : -1)));
          setTo(next);
        };
      });

      select.addEventListener('change', syncFromSelect);
      syncFromSelect();
    });

    // Ensure initial player rows render to match default "players" count
    try { if (typeof drawPsRows === 'function') drawPsRows(); } catch(_) {}
  };
})();
/**********************
 * CONFIG: Supabase
 **********************/
const SUPABASE_URL = "https://vvfqumgtasuacpggdmxx.supabase.co";
const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ2ZnF1bWd0YXN1YWNwZ2dkbXh4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5NTk0MDMsImV4cCI6MjA3ODUzNTQwM30.8NblWOwEsY1FP1hxvO6isQ908NyxkTgntnZZiXIFPHE";

// IMPORTANT: do NOT hard-crash the entire app if Supabase CDN is blocked (e.g., some online previewers).
// We initialise lazily in ensureCloudInit() instead.
let sb = null;
try {
  if (window.supabase && typeof window.supabase.createClient === 'function') {
    sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);
    window.sb = sb;
  }
} catch (e) {
  console.warn('Supabase client init deferred/failed', e);
  sb = null;
}

// Keep table constants below
// View/table that lists every player's game across Official + Practice.
const TABLE_PLAYER_GAMES = 'player_games_union';
const TABLE_HS_LEAGUE = "high_scores";
const TABLE_HS_PRACTICE = "high_scores_sp";
const TABLE_LEAGUE_LOW_SCORES = "league_low_scores";
const TABLE_GAME_THROWS = "game_throws";

// Feature flag: the per-dart throws table/view (game_throws) is optional.
// If your Supabase schema doesn't include it, keep this false to avoid noisy 404s.
const FEATURE_CLOUD_THROWS = false;

// PB/WR storage (targets for the backfill)
const TABLE_PB_ROUNDS = 'player_pb_rounds';    // columns: player, cat, val, game_id, ridx, ts
const TABLE_WR_ROUNDS = 'world_record_rounds'; // columns: cat, val, player, game_id, ridx, ts

// Extra tables used for cloud-backed stats
const TABLE_GAMES   = "games";
const TABLE_MATCHES = "matches";

/* >>> PATCH:CLOUD_TABLE_MISSING_GUARD START */
const CLOUD_TABLE_MISSING = Object.create(null);
const CLOUD_ONCE = Object.create(null);
function cloudIsTableMissing(tableName){
  return !!(tableName && CLOUD_TABLE_MISSING[tableName]);
}
function cloudMarkTableMissing(tableName, err){
  if (!tableName) return false;
  if (CLOUD_TABLE_MISSING[tableName]) return true;
  const code = err && (err.code || err.error_code);
  const status = err && (err.status || err.statusCode);
  const msg = String((err && (err.message || err.error_description || err.details)) || '');
  const isMissing = code === 'PGRST205' || status === 404 || /\b404\b/.test(msg) || /does not exist/i.test(msg) || /not found/i.test(msg);
  if (!isMissing) return false;
  CLOUD_TABLE_MISSING[tableName] = true;
  const onceKey = 'missing:' + tableName;
  if (!CLOUD_ONCE[onceKey]){
    CLOUD_ONCE[onceKey] = true;
    console.warn('Cloud table missing/blocked; disabling related calls:', tableName, err);
  }
  return true;
}
/* <<< PATCH:CLOUD_TABLE_MISSING_GUARD END */


/**********************
 * SAFETY + TOAST
 **********************/
(function(){
  window.addEventListener('error', function(e){
    var b=document.getElementById('__err_banner')||document.createElement('div');
    b.id='__err_banner';
    b.style.cssText='position:fixed;left:0;right:0;top:0;background:#7a2e3f;color:#fff;padding:8px 12px;z-index:999999;font-weight:800';
    b.textContent='JS error: ' + (e.message||'(open console)');
    document.body.appendChild(b);
  });
  if(!window.toast){
    window.toast=function(msg){
      var d=document.createElement('div');
      d.textContent=msg;
      d.style.cssText='position:fixed;left:50%;top:16px;transform:translateX(-50%);background:#121735;border:1px solid #2b3050;color:#e7e9f5;padding:8px 12px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.35);z-index:110000';
      document.body.appendChild(d); setTimeout(function(){d.remove();},1700);
    };
  }
})();

/*****************
 * CORE HELPERS
 *****************/
const byId = id => document.getElementById(id);
const STORAGE_KEY='shateki_quest_scorer_v6';
const HS_KEY='shateki_quest_highscores_v1';       // kept for backward-compat local
const HS_KEY_SP='shateki_quest_highscores_sp_v1'; // kept for backward-compat local
// Long-term history logs (not cleared when a match ends)
const GAMES_LOG_KEY   = 'shateki_quest_games_log_v1';
const MATCHES_LOG_KEY = 'shateki_quest_matches_log_v1';
const safeSave=(k,o)=>{try{localStorage.setItem(k,JSON.stringify(o));}catch(e){}};
const safeLoad=k=>{try{const r=localStorage.getItem(k);return r?JSON.parse(r):null;}catch(e){return null;}};
const safeClear=k=>{try{localStorage.removeItem(k);}catch(e){}};

function syncStartTitleWidth(){
  const t = document.getElementById('appTitle');
  if (!t) return;
  const w = Math.ceil(t.getBoundingClientRect().width);
  document.documentElement.style.setProperty('--title-w', w + 'px');
  
}

// Return matches for official mode, merging local + cloud
async function getMatchesOfficial(){
  const localMatches = getMatchLog() || [];
  let cloudMatches = [];
  try { cloudMatches = await cloudFetchAllMatchesAsLocal(); } catch(_) {}

  const map = new Map();
  const stableKey = (m) => {
    const players = (m.players || [])
      .map(p => (p && p.name) ? String(p.name).trim().toLowerCase() : '')
      .join(',');
    return [m.ts || '', players].join('|');
  };
  [...cloudMatches, ...localMatches].forEach(m => {
    if (!m) return;
    const key = stableKey(m);
    if (!map.has(key)) map.set(key, m);
  });
  return [...map.values()];
}

// Build per-target counters for one player
function accumulateTargetCounters(playerName, games){
  const keys = {};
  // init keys 10..20, 'D','T','B'
  for (let n=10;n<=20;n++) keys[String(n)] = { thrown:0, hits:0, dHits:0, tHits:0 };
  keys.D = { thrown:0, hits:0 };
  keys.T = { thrown:0, hits:0 };
  keys.B = { thrown:0, hits:0, inner:0, outer:0 };

  games.forEach(g=>{
    if (!g || !Array.isArray(g.players) || !g.board) return;
    const pIdx = g.players.findIndex(p=>p && eqName(p.name, playerName));
    if (pIdx === -1) return;
    const board = g.board[pIdx]; if (!board) return;

    for (let r=0; r<MAX_ROUNDS; r++){
      const rd  = ROUNDS[r];
      const ent = board[r]; if (!ent || !ent.darts) continue;
      const darts = ent.darts;

      if (rd.type === 'number'){
        const key = String(rd.target);
        darts.forEach(d=>{
          if (!d) return;
          keys[key].thrown++;
          if ((d.points||0) > 0) keys[key].hits++;
          if (d.kind==='Double' || d.kind==='D') keys[key].dHits++;
          if (d.kind==='Triple' || d.kind==='T') keys[key].tHits++;
        });
      } else if (rd.type === 'doubles'){
        darts.forEach(d=>{
          if (!d) return;
          keys.D.thrown++;
          if ((d.points||0) > 0) keys.D.hits++;
        });
      } else if (rd.type === 'triples'){
        darts.forEach(d=>{
          if (!d) return;
          keys.T.thrown++;
          if ((d.points||0) > 0) keys.T.hits++;
        });
      } else if (rd.type === 'bull'){
        darts.forEach(d=>{
          if (!d) return;
          keys.B.thrown++;
          if (d.kind==='Bull'){
            keys.B.hits++;
            if (d.bull==='Inner') keys.B.inner++;
            else keys.B.outer++;
          }
        });
      }
    }
  });

  return keys;
}
// Put this at top-level (outside any function)
function openScoreSheetFromHistory(gIndex){
  const game = state.match.history[gIndex];
  if (!game || !game.board) { toast('No score sheet for that game.'); return; }
  const local = { ts: null, players: state.players.map(p=>({name:p.name})), board: game.board };
  openSingleGameScoreSheet(local, -1);
}

/* ===== PB / GR from Supabase (Saved Players + official games only; 10â€“20 + D/T/B) ===== */
(function(){
  const PBGR = {
    ready:false, fetching:false, fetchedAt:0,
    byPlayer:new Map(),           // player(lower) -> { [key]: best }
    byPlayerMeta:new Map(),       // player(lower) -> { [key]: {val, game_id, ridx, ts} }
    byTarget:{},                  // key -> best value (global)
    byTargetMeta:{}               // key -> { val, player, game_id, ridx, ts }
  };

  (function initGlobals(){
    for (let n=10;n<=20;n++) { PBGR.byTarget[n]=0; PBGR.byTargetMeta[n]={val:0,player:'',game_id:null,ridx:null,ts:null}; }
    ['D','T','B'].forEach(k=>{ PBGR.byTarget[k]=0; PBGR.byTargetMeta[k]={val:0,player:'',game_id:null,ridx:null,ts:null}; });
  })();

  const toNameKey = n => String(n||'').trim().toLowerCase();
  const toTarget  = t => {
    if (t==null) return null;
    if (typeof t === 'number') return t;
    const m = String(t).match(/\d+/);
    return m ? parseInt(m[0],10) : null;
  };

  async function fetchSavedPlayerNames(){
    try{
      const { data, error } = await sb.from(TABLE_PLAYERS).select('name').order('name');
      if (error) throw error;
      return (data||[]).map(r => String(r.name)).filter(Boolean);
    }catch(e){
      console.error('Saved players fetch failed', e);
      return [];
    }
  }
  async function findOfficialGameIds(){
    try{
      const { data, error } = await sb
        .from(TABLE_GAMES)
        .select('id, state')
        .limit(100000);
      if (error) throw error;

      const ids = new Set();
      for (const g of (data||[])){
        if (!g || !g.id) continue;
        let st = g.state;
        if (typeof st === 'string'){
          try { st = JSON.parse(st); } catch(_) {}
        }
        const players = st && Array.isArray(st.players) ? st.players : null;
        const n = players ? players.length : 0;
        if (n >= 2) ids.add(g.id);
      }
      return ids;
    }catch(e){
      console.warn('Could not read official game IDs from GAMES; will try is_practice on throws', e);
      return null;
    }
  }

  async function fetchPBGRFromCloud(limit = 100000){
    if (PBGR.fetching) return;
    PBGR.fetching = true;

    // PB/GR cloud fetch depends on a per-dart throws table/view (game_throws).
    // Keep disabled unless your Supabase project provides that schema.
    if (!FEATURE_CLOUD_THROWS) {
      PBGR.ready = true;
      PBGR.fetchedAt = Date.now();
      PBGR.fetching = false;
      return;
    }

    // If the per-dart throws table/view is not available in this Supabase project,
    // disable PB/GR cloud fetch silently so gameplay is unaffected.
    if (cloudIsTableMissing(TABLE_GAME_THROWS)) {
      PBGR.ready = true;
      PBGR.fetchedAt = Date.now();
      PBGR.fetching = false;
      return;
    }

    try{
      const savedNames = await fetchSavedPlayerNames();
      if (!savedNames.length){
        PBGR.byPlayer = new Map();
        PBGR.byPlayerMeta = new Map();
        PBGR.ready = true;
        PBGR.fetchedAt = Date.now();
        return;
      }

      const officialIds = await findOfficialGameIds();
      let rows = [];
      try{
        let q = sb.from(TABLE_GAME_THROWS)
          .select('player, game_id, round_index, target, points, round_total, ts, is_practice')
          .in('player', savedNames)
          .limit(limit);

        if (officialIds && officialIds.size){
          q = q.in('game_id', Array.from(officialIds));
        } else {
          q = q.eq('is_practice', false);
        }

        const { data, error } = await q;
        if (error) throw error;
        rows = data || [];
      }catch(e1){
        console.error('Primary throws fetch failed; falling back to saved players only', e1);
        if (cloudMarkTableMissing(TABLE_GAME_THROWS, e1)) {
          PBGR.ready = true;
          PBGR.fetchedAt = Date.now();
          PBGR.fetching = false;
          return;
        }
        if (cloudIsTableMissing(TABLE_GAME_THROWS)) {
          PBGR.ready = true;
          PBGR.fetchedAt = Date.now();
          PBGR.fetching = false;
          return;
        }
        const { data } = await sb.from(TABLE_GAME_THROWS)
          .select('player, game_id, round_index, target, points, round_total, ts')
          .in('player', savedNames)
          .limit(limit);
        rows = data || [];
      }

      const bestPerPlayerVal  = new Map();  // key: name|key -> val
      const bestPerPlayerMeta = new Map();  // key: name|key -> {val, game_id, ridx, ts}
      const bestGlobalVal     = { ...PBGR.byTarget };
      const bestGlobalMeta    = JSON.parse(JSON.stringify(PBGR.byTargetMeta));

      const bucket = new Map(); // key: game|name|ridx -> { ridx, target, total, ts }

      for (const row of (rows||[])){
        const nameKey = toNameKey(row.player || row.name);
        if (!nameKey) continue;

        const ridx = (typeof row.round_index === 'number') ? row.round_index : (row.round_index!=null ? Number(row.round_index) : null);
        const tNum = toTarget(row.target);
        const rt   = (row.round_total != null) ? Number(row.round_total) : null;
        const ts   = row.ts || null;

        function catFrom(ridxLocal, tLocal){
          if (tLocal!=null && tLocal>=10 && tLocal<=20) return tLocal;
          if (ridxLocal==null) return null;
          if (ridxLocal === 11) return 'D';
          if (ridxLocal === 12) return 'T';
          if (ridxLocal === 13) return 'B';
          if (ridxLocal>=0 && ridxLocal<=10) return 10 + ridxLocal;
          return null;
        }

        if (rt != null){
          const key = catFrom(ridx, tNum);
          if (key==null) continue;
          const val = rt;
          const pKey = `${nameKey}|${key}`;

          if (val > (bestPerPlayerVal.get(pKey) || 0)){
            bestPerPlayerVal.set(pKey, val);
            bestPerPlayerMeta.set(pKey, { val, game_id: row.game_id || null, ridx, ts });
          }
          if (val > (bestGlobalVal[key] || 0)){
            bestGlobalVal[key] = val;
            bestGlobalMeta[key] = { val, player: nameKey, game_id: row.game_id || null, ridx, ts };
          }
        } else {
          const gId = row.game_id || row.game || '';
          if (!gId || ridx==null) continue;
          const k = `${gId}|${nameKey}|${ridx}`;
          const cur = bucket.get(k) || { ridx, target: (tNum!=null ? tNum : null), total: 0, ts: ts };
          cur.total += Number(row.points || 0);
          if (cur.target==null && tNum!=null) cur.target = tNum;
          if (!cur.ts && ts) cur.ts = ts;
          bucket.set(k, cur);
        }
      }

      for (const [k, obj] of bucket){
        const [gId, nameKey, ridxStr] = k.split('|');
        const ridx = Number(ridxStr);
        const key  = (obj.target!=null && obj.target>=10 && obj.target<=20)
          ? obj.target
          : (ridx===11 ? 'D' : ridx===12 ? 'T' : ridx===13 ? 'B' : (ridx>=0 && ridx<=10 ? 10+ridx : null));
        if (key==null) continue;
        const val  = Number(obj.total || 0);
        const ts   = obj.ts || null;
        const pKey = `${nameKey}|${key}`;

        if (val > (bestPerPlayerVal.get(pKey) || 0)){
          bestPerPlayerVal.set(pKey, val);
          bestPerPlayerMeta.set(pKey, { val, game_id: gId, ridx, ts });
        }
        if (val > (bestGlobalVal[key] || 0)){
          bestGlobalVal[key] = val;
          bestGlobalMeta[key] = { val, player: nameKey, game_id: gId, ridx, ts };
        }
      }

      const byPlayer = new Map();
      const byPlayerMeta = new Map();
      for (const [key, v] of bestPerPlayerVal){
        const idx = key.lastIndexOf('|');
        const pKey = key.slice(0, idx);
        const cat  = key.slice(idx+1);
        const isNum = /^\d+$/.test(cat);
        const normKey = isNum ? parseInt(cat,10) : cat;
        if (!byPlayer.has(pKey)) byPlayer.set(pKey, {});
        if (!byPlayerMeta.has(pKey)) byPlayerMeta.set(pKey, {});
        byPlayer.get(pKey)[normKey] = v;
        byPlayerMeta.get(pKey)[normKey] = bestPerPlayerMeta.get(key);
      }

      PBGR.byPlayer     = byPlayer;
      PBGR.byPlayerMeta = byPlayerMeta;
      PBGR.byTarget     = bestGlobalVal;
      PBGR.byTargetMeta = bestGlobalMeta;
      PBGR.ready        = true;
      PBGR.fetchedAt    = Date.now();
    }catch(e){
      console.error('PBGR cloud build failed', e);
      PBGR.ready = false;
    }finally{
      PBGR.fetching = false;
    }
  }

  async function ensurePBGRCache(){
    if (PBGR.ready && Date.now() - PBGR.fetchedAt < 5*60*1000) return;
    await fetchPBGRFromCloud();
  }

  window.updatePBGRBadges = async function updatePBGRBadges(){
    if (document.body.getAttribute('data-page') !== 'game') return;
    await ensurePBGRCache();
    if (!PBGR.ready) return;
    try{
      for (let p=0; p<(state.players||[]).length; p++){
        const nameKey = toNameKey(state.players[p]?.name);
        const rounds  = state.score?.[p] || [];
        const pbMap   = PBGR.byPlayer.get(nameKey) || {};
        for (let r=0; r<Math.min(rounds.length, MAX_ROUNDS); r++){
          const rdDef = ROUNDS[r];
          if (!rdDef) continue;
          let key = null;
          if (rdDef.type === 'number')  key = rdDef.target;
          if (rdDef.type === 'doubles') key = 'D';
          if (rdDef.type === 'triples') key = 'T';
          if (rdDef.type === 'bull')    key = 'B';
          if (key==null) continue;
          const rt = Number(rounds[r]?.roundTotal||0);
          if (!rt) continue;
          const priorPB = Number(pbMap[key] || 0);
          const priorGR = Number(PBGR.byTarget[key] || 0);
          const isPB = rt > priorPB;
          const isGR = rt > priorGR;
          const tbody = document.getElementById('tbody'); if (!tbody) continue;
          const tr = tbody.rows?.[r]; if (!tr) continue;
          const td = tr.children?.[p+1]; if (!td) continue;
          const sub = td.querySelector('.cell-sub') || td;
          sub.querySelectorAll('.pbgr').forEach(n => n.remove());
          if (isPB){
            const b = document.createElement('span');
            b.className = 'pbgr pb'; b.textContent = ' (PB)'; sub.appendChild(b);
          }
          if (isGR){
            const g = document.createElement('span');
            g.className = 'pbgr gr'; g.textContent = ' (GR)'; sub.appendChild(g);
          }
        }
      }
    }catch(_){}
  };

  window.refreshPBGRCloud = async function(){
    PBGR.ready=false;
    await ensurePBGRCache();
    await window.updatePBGRBadges();
  };

  // Expose a read-only snapshot for admin UI
  window.getPBGRSnapshot = async function(){
    await ensurePBGRCache();
    return {
      byTarget: Object.assign({}, PBGR.byTarget),
      byTargetMeta: JSON.parse(JSON.stringify(PBGR.byTargetMeta)),
      byPlayer: new Map(PBGR.byPlayer),
      byPlayerMeta: new Map(PBGR.byPlayerMeta)
    };
  };
})();

// Percent helper
function pctStr(num, den){
  if (!den) return 'â€”';
  return Math.round((num/den)*100) + '%';
}

function isOfficialGame(g){
  if (!g) return false;

  // Explicit flags always win
  if (g.mode === 'practice' || g.is_practice === true || g.isPractice === true) return false;

  // Cloud truth: games table uses match_id = null for practice, non-null for official
  const hasMatch = !!(g.matchId || g.match_id);
  if (hasMatch) return Array.isArray(g.players) && g.players.length >= 2;

  // If explicitly marked official, accept
  if (g.mode === 'official' || g.is_practice === false) return Array.isArray(g.players) && g.players.length >= 2;

  // Otherwise: treat unknown/no match_id as NOT official (prevents swapping)
  return false;
}
function isPracticeGame(g){
  if (!g) return false;

  // Explicit flags
  if (g.mode === 'practice' || g.is_practice === true || g.isPractice === true) return true;

  const hasMatch = !!(g.matchId || g.match_id);
  if (hasMatch) return false;

  // Explicit official flag blocks practice
  if (g.mode === 'official' || g.is_practice === false) return false;

  // Fallback: no match_id means practice (covers guest games + old rows)
  const players = Array.isArray(g.players) ? g.players : [];
  return players.length >= 1;
}
function filterByMode(games, matches, mode){
  const gm = (games || []).filter(mode === 'official' ? isOfficialGame : isPracticeGame);
  const mm = (mode === 'official') ? (matches || []) : []; // practice ignores matches
  return { games: gm, matches: mm };
}

// Case/whitespace-insensitive player name compare
function eqName(a, b){
  return String(a || '').trim().toLowerCase() === String(b || '').trim().toLowerCase();
}

// Legacy log keys (fallback/migration)
const LEGACY_GAME_KEYS  = ['shateki_quest_games_log', 'shateki_quest_games_log_v0'];
const LEGACY_MATCH_KEYS = ['shateki_quest_matches_log', 'shateki_quest_matches_log_v0'];

// UUID v4 for Supabase match IDs (uuid column)
function genUuidV4() {
  const a = crypto.getRandomValues(new Uint8Array(16));
  a[6] = (a[6] & 0x0f) | 0x40;  // version
  a[8] = (a[8] & 0x3f) | 0x80;  // variant
  const h = [...a].map(b => b.toString(16).padStart(2,'0')).join('');
  return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
}

// Backdate (applies to the NEXT cloud save only)
let _tsOverride = null;

function setBackdateInteractive() {
  const v = prompt('Enter local date/time for *next* cloud save (YYYY-MM-DD HH:MM)');
  if (!v) return;
  const m = v.trim().replace(' ', 'T');
  const dt = new Date(m);
  if (isNaN(dt.getTime())) { toast('Bad date/time'); return; }
  _tsOverride = dt.toISOString();
  toast('Backdate set for next save');
}
function clearBackdate(){ _tsOverride = null; }

// ---------- CORE STATE ----------
const baseState = {
  players: [],
  score: [],
  currentRound: 0,
  currentPlayer: 0,
  currentDart: 0,
  history: [],
  finished: false,
  suddenDeath: { active: false, participants: [], turnIndex: 0, throws: [], round: 1 },
  match: {
    id: null,
    targetWins: 4,      // default "first to 4 wins" â€“ overwritten when you start a match
    gameNumber: 1,
    wins: [],
    history: [],
    completedLogged: false
  },
  matchAgg: null,
  gameAwarded: false
};

let state = JSON.parse(JSON.stringify(baseState));
const COLOR_PALETTE=['#7bdcff','#8cff9e','#ffcc66','#ff9bd6','#f8d66d','#a6b3ff','#7fffd4','#ffb27b','#ffd166','#06d6a0','#118ab2','#ef476f'];
function assignUniqueColors(arr){ for(let i=0;i<arr.length;i++){ arr[i].color = COLOR_PALETTE[i % COLOR_PALETTE.length]; } }

// Cloud status indicator
const cloudStatusEl     = byId('cloudStatus');
const cloudStatusTextEl = byId('cloudStatusText');

function setCloudStatus(mode, text) {
  if (!cloudStatusEl || !cloudStatusTextEl) return;
  cloudStatusEl.classList.remove('ok', 'error', 'checking');
  cloudStatusEl.classList.add(mode);
  cloudStatusTextEl.textContent = text;
}

function markCloudOk() {
  setCloudStatus('ok', 'Cloud: connected');
}
function openGameCompleteDialog() {
  const totals = state.players.map((_, i) => totalScoreForPlayer(i));
  if (!totals.length) return;
  
  const max = Math.max(...totals);
  const winnerIdx = [];
  totals.forEach((t, i) => {
    if (t === max) winnerIdx.push(i);
  });

  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Game Complete';
  title.style.textAlign = 'center';
  title.style.fontSize = '1.6rem';
  title.style.marginBottom = '10px';

  const body = document.createElement('div');
  body.className = 'modal-body';

  // BIG winner line in the centre
  const winnerP = document.createElement('p');
  winnerP.style.fontWeight = '900';
  winnerP.style.fontSize = '1.8rem';
  winnerP.style.textAlign = 'center';
  winnerP.style.margin = '4px 0 12px';
  winnerP.style.letterSpacing = '0.03em';

  const winnerNames = winnerIdx.map(i => state.players[i].name);
  if (winnerNames.length === 1) {
    winnerP.textContent = `${winnerNames[0]} WINS (${max})`;
  } else {
    winnerP.textContent = `JOINT WINNERS: ${winnerNames.join(' Â· ')} (${max})`;
  }
  body.appendChild(winnerP);

  // Ranked list underneath
  const list = document.createElement('ol');
  list.style.paddingLeft = '20px';
  list.style.margin = '0';

  const ranking = totals
    .map((score, index) => ({ index, score }))
    .sort((a, b) => b.score - a.score);

  ranking.forEach(row => {
    const li = document.createElement('li');
    const name = state.players[row.index].name;
    li.textContent = `${name} â€“ ${row.score}`;
    list.appendChild(li);
  });

  body.appendChild(list);

 const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const returnBtn = document.createElement('button');
  returnBtn.textContent = 'Close';
returnBtn.onclick = () => overlay.remove();

  footer.appendChild(returnBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });

  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });
}

function markCloudError(err) {
  console.error('[Supabase]', err);
  setCloudStatus('error', 'Cloud: problem â€“ using local');
}

function show(id){
  ['details','players','game','leaderboard'].forEach(x=>byId(x)?.classList.add('hidden'));
  byId(id)?.classList.remove('hidden');
  document.body.setAttribute('data-page', id);
  updatePadSpacer();
  try{ bindFHCollapseScroll(); updateFHCollapse(id); }catch(e){}
  const fh=byId('floatHead');
  if(fh) fh.classList.toggle('hidden', id!=='game');
  buildPad();
  if (id === 'players') { try{ __msUpdateStartEnabled(); }catch(_){} }
  if (id === 'details') {
    try {
      if (typeof window.buildStartTicker === 'function') { window.buildStartTicker(); }
    } catch(e) { console.error(e); }
  }
  if (id === 'game') {
    // Reverted: rely on default scoreboard rendering.
    if (window.__marksKick) { clearInterval(window.__marksKick); window.__marksKick = null; }
    try { if (typeof scanForTripleHatAndCelebrate === 'function') scanForTripleHatAndCelebrate(); } catch(_) {}
  try { if (typeof updatePBGRBadges === 'function') updatePBGRBadges(); } catch(_) {}
  }
}
const padBar = byId('padBar');
const pad     = byId('pad');
const padHint = byId('padHint');
function updatePadSpacer(){
  try{
    const h = padBar ? padBar.getBoundingClientRect().height : 148;
    document.documentElement.style.setProperty('--pad-h', h + 'px');

    // Ensure the last scoreboard row can scroll above the fixed pad bar (classic scroll mode).
    const page = document.body.getAttribute('data-page') || '';
    const wrap = document.querySelector('.wrap');
    if (wrap){
      if (page === 'game') {
        wrap.style.paddingBottom = Math.max(20, Math.round(h + 18)) + 'px';
      } else {
        wrap.style.paddingBottom = '';
      }
    }
  }catch(e){}
  try{
    const topRow = document.getElementById('gameTopRow');
    if(topRow){
      const rh = Math.ceil(topRow.getBoundingClientRect().height);
      document.documentElement.style.setProperty('--fhMenuH', rh + 'px');
      window.__sqFHMenuH = rh;
    }
  }catch(e){}
}

// Keep the in-header top buttons (B1) collapsible on scroll.
let __sqFHScrollBound = false;
function updateFHCollapse(forcePage){
  try{
    const page = forcePage || document.body.getAttribute('data-page') || '';
    const wrap = document.querySelector('.wrap');
    const mh = (window.__sqFHMenuH != null ? window.__sqFHMenuH : 48);

    if (page !== 'game' || !wrap){
      document.documentElement.style.setProperty('--fhCollapse', '0px');
      document.documentElement.style.setProperty('--fhScrollGate', '0px');
      return;
    }

    const s = Math.max(0, wrap.scrollTop || 0);
    const c = Math.max(0, Math.min(s, mh));

    // Phase gate:
    //  - While B1 is collapsing (s < mh), prevent A2/D content from moving under the sticky header.
    //    We cancel BOTH the scroll movement and the header-height shrink by offsetting 2*c.
    //  - Once B1 is fully gone (s >= mh), release the content to scroll normally.
    const gate = (s < mh) ? (2 * c) : mh;

    document.documentElement.style.setProperty('--fhCollapse', c + 'px');
    document.documentElement.style.setProperty('--fhScrollGate', gate + 'px');
  }catch(e){}
}
function bindFHCollapseScroll(){
  if (__sqFHScrollBound) return;
  const wrap = document.querySelector('.wrap');
  if (!wrap) return;
  wrap.addEventListener('scroll', () => {
    if (document.body.getAttribute('data-page') !== 'game') return;
    updateFHCollapse();
    // keep animated bars aligned during menu collapse / scroll (no animation on scroll)
    requestAnimationFrame(() => {
      try{ updateTurnBar(false); }catch(_){ }
      try{ updateRoundBar(false, true); }catch(_){ }
    });
  }, { passive:true });
  __sqFHScrollBound = true;
}
window.addEventListener('load', bindFHCollapseScroll, { passive:true });

addEventListener('resize', updatePadSpacer, { passive:true });
addEventListener('orientationchange', updatePadSpacer, { passive:true });
window.addEventListener('load', syncStartTitleWidth, { passive: true });

/*****************
 * GAME & STATE
 *****************/
const ROUNDS = (()=>{ const a=[]; for(let i=0;i<11;i++) a.push({type:'number',target:10+i}); a.push({type:'doubles'},{type:'triples'},{type:'bull'}); return a; })();
function labelForRound(def){
  if (!def) return '';
  if (def.type === 'number')  return String(def.target);
  if (def.type === 'doubles') return 'D';
  if (def.type === 'triples') return 'T';
  if (def.type === 'bull')    return 'B';
  return '';
}
const MAX_ROUNDS=ROUNDS.length;
const totalScoreForPlayer = i => (state.score[i]||[]).reduce((s,row)=>s+(row?.roundTotal||0),0);
const save = () => {
  safeSave(STORAGE_KEY, state);
  try { if (typeof onStateSaved === 'function') onStateSaved(); } catch(_) {}
};
function ensureMatchAgg(){ if(state.matchAgg && state.matchAgg.hits) return; state.matchAgg={ hits:Array.from({length:state.players.length},()=>({})), totals60:Array.from({length:state.players.length},()=>0), totals100:Array.from({length:state.players.length},()=>0), totals140:Array.from({length:state.players.length},()=>0) }; }

function getGameLog() {
  const v1 = safeLoad(GAMES_LOG_KEY);
  if (Array.isArray(v1) && v1.length) return v1;

  // Fallback to legacy keys; if found, migrate to v1 for future reads
  for (const k of (LEGACY_GAME_KEYS || [])) {
    const v = safeLoad(k);
    if (Array.isArray(v) && v.length) {
      setGameLog(v);
      return v;
    }
  }
  return [];
}

function setGameLog(arr) {
  safeSave(GAMES_LOG_KEY, arr || []);
}

function getMatchLog() {
  const v1 = safeLoad(MATCHES_LOG_KEY);
  if (Array.isArray(v1) && v1.length) return v1;

  for (const k of (LEGACY_MATCH_KEYS || [])) {
    const v = safeLoad(k);
    if (Array.isArray(v) && v.length) {
      setMatchLog(v);
      return v;
    }
  }
  return [];
}

function setMatchLog(arr) {
  safeSave(MATCHES_LOG_KEY, arr || []);
}

function logCompletedGame(totals, winners, boardClone) {
  const games  = getGameLog();
  const nowIso = _tsOverride || new Date().toISOString();

  // Build a single game record object we can reuse
  const gameRecord = {
    id: `g-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
    ts: nowIso,
    matchId: state.match.id || null,
    players: state.players.map(p => ({ name: p.name })),
    totals: totals.slice(),
    winners: winners.slice(),
    board: boardClone,
    mode: (__sqComputeGameMode ? __sqComputeGameMode() : (((state.players||[]).length>=2)?'official':'practice')),
    is_practice: (__sqComputeGameMode ? (__sqComputeGameMode() === 'practice') : ((state.players||[]).length===1))
  };

  games.push(gameRecord);
  setGameLog(games);
    // Persist each player's total as a High Score row (respects backdate)
  (async () => {
    try {
      await cloudSaveHighScoresForGame(totals, nowIso);
    } catch (e) {
      console.error('High score cloud save failed', e);
    }
  })();
};

function logCompletedMatch() {
  const matches = getMatchLog();
  const nowIso = new Date().toISOString();
  const gamesInMatch = state.match.history.length;

  const players = state.players.map(p => ({ name: p.name }));
  const wins    = (state.match.wins || []).slice();

  const matchTotals = state.players.map((_, idx) =>
    state.match.history.reduce((sum, g) => sum + (g.totals?.[idx] || 0), 0)
  );

  matches.push({
    id: state.match.id || `m-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
    ts: nowIso,
    players,
    wins,
    targetWins: state.match.targetWins || 1,
    games: gamesInMatch,
    matchTotals
  });

  setMatchLog(matches);
}

/*****************
 * SUPABASE HELPERS
 *****************/

// Safari-safe timestamp parsing.
// Accepts ISO strings, PostgREST timestamps like '2026-01-18 13:53:52.437+00', and epoch ms/seconds.
function parseMs(v){
  if (v == null) return null;
  if (typeof v === 'number') return v > 1e12 ? v : v * 1000;
  const s = String(v).trim();
  if (!s) return null;
  if (/^\d+$/.test(s)) {
    const n = Number(s);
    return n > 1e12 ? n : n * 1000;
  }
  // Convert 'YYYY-MM-DD HH:MM:SS(.ms)?+00' to ISO-like.
  const isoish = s.replace(' ', 'T');
  const ms = Date.parse(isoish);
  return Number.isFinite(ms) ? ms : null;
}


async function cloudSynthAllGamesFromHighScores(limit = 500) {
  const items = [];
  async function fetchTbl(tbl) {
    const { data, error } = await sb
      .from(tbl)
      .select('name, score, ts')
      .order('ts', { ascending: true })
      .limit(limit);
    if (error) throw error;
    return data || [];
  }
  try {
    const league   = await fetchTbl(TABLE_HS_LEAGUE);
    const practice = await fetchTbl(TABLE_HS_PRACTICE);
    [...league, ...practice].forEach(row => {
      items.push({
        ts: row.ts || null,
        players: [{ name: row.name }],
        totals:  [Number(row.score) || 0],
        board:   null
      });
    });
  } catch (e) {
    console.error('cloudSynthAllGamesFromHighScores failed', e);
  }
  return items;
}

// PLAYERS
// PLAYERS
async function cloudListPlayers(){
  // Cloud is canonical. Prefer to read initials if the column exists; fall back safely if not.
  let data = null;
  try{
    const r1 = await sb
      .from(TABLE_PLAYERS)
      .select('id, name, initials, nickname, first_name, last_name, created_at, deleted_at')
      .is('deleted_at', null)
      .order('name');
    if (r1.error) throw r1.error;
    data = r1.data || [];
    markCloudOk();
  }catch(e1){
    // Column may not exist yet on some deployments; fall back to the minimal schema.
    const msg = String(e1?.message || e1 || '');
    const code = String(e1?.code || '');
    const isSchemaMismatch = (code === '42703') || /(initials|deleted_at|nickname|first_name|last_name)/i.test(msg);
    if (!isSchemaMismatch){
      markCloudError(e1);
      throw e1;
    }
    const r2 = await sb
      .from(TABLE_PLAYERS)
      .select('id, name, created_at')
      .order('name');
    if (r2.error){ markCloudError(r2.error); throw r2.error; }
    data = (r2.data || []).map(p => ({ ...p, initials: __sqComputeInitialsFromName(p?.name) }));
    markCloudOk();
  }

  // Cache active player names/ids for light UI (ticker etc.)
  try {
    const list = Array.isArray(data) ? data : [];
    window.__sqPlayersList = list;
    const set = new Set(list.map(p => String(p?.name || '').trim().toLowerCase()).filter(Boolean));
    window.__sqActivePlayerNameSet = set;
    window.__sqIsActivePlayerName = (nm) => {
      const key = String(nm || '').trim().toLowerCase();
      return key ? (window.__sqActivePlayerNameSet?.has(key) === true) : false;
    };
  } catch (_) {}
  return data || [];
}


// Create / update a player by name only (no password)
async function cloudCreatePlayer(name, profile){
  const nm = String(name||'').trim();
  const p = (profile && typeof profile === 'object') ? profile : {};
  const initials = __sqNormalizeInitials(String(p.initials||''), nm);
  const row = {
    name: nm,
    initials,
    first_name: (p.first_name != null) ? String(p.first_name||'').trim() : undefined,
    last_name:  (p.last_name  != null) ? String(p.last_name ||'').trim() : undefined,
    nickname:   (p.nickname   != null) ? String(p.nickname  ||'').trim() : undefined,
  };

  // Try full schema; fall back if columns missing.
  try{
    const { error } = await sb
      .from(TABLE_PLAYERS)
      .upsert(row, { onConflict: 'name' });
    if (error) throw error;
    markCloudOk();
    return;
  }catch(e1){
    const msg = String(e1?.message || e1 || '');
    const code = String(e1?.code || '');
    const isMissingCols = (code === '42703') || /(initials|first_name|last_name|nickname)/i.test(msg);
    if (!isMissingCols){
      markCloudError(e1);
      throw e1;
    }
    // Minimal schema fallback
    try{
      const { error } = await sb
        .from(TABLE_PLAYERS)
        .upsert({ name: nm, initials }, { onConflict: 'name' });
      if (error) throw error;
      markCloudOk();
      return;
    }catch(e2){
      const msg2 = String(e2?.message || e2 || '');
      const code2 = String(e2?.code || '');
      const isMissingInitials = (code2 === '42703') || /initials/i.test(msg2);
      if (!isMissingInitials){ markCloudError(e2); throw e2; }
      const { error } = await sb
        .from(TABLE_PLAYERS)
        .upsert({ name: nm }, { onConflict: 'name' });
      if (error){ markCloudError(error); throw error; }
      markCloudOk();
    }
  }
}


// Update initials for a player (by id when available; by resolved name otherwise)
async function cloudUpdatePlayerInitials(playerOrName, initials){
  const obj = (playerOrName && typeof playerOrName === 'object') ? playerOrName : null;
  const nmIn = obj ? String(obj.name||'').trim() : String(playerOrName||'').trim();
  const id = obj && obj.id ? obj.id : null;
  if (!nmIn && !id) throw new Error('Update initials failed: missing player key');

  const init = __sqNormalizeInitials(initials, nmIn);
  try{
    let q = sb.from(TABLE_PLAYERS).update({ initials: init });
    if (id) {
      q = q.eq('id', id);
    } else {
      const resolved = await cloudResolvePlayerKeyByName(nmIn);
      const targetName = (resolved && resolved.name) ? resolved.name : nmIn;
      q = q.eq('name', targetName);
    }
    const { data, error } = await q.select('id, name, initials').maybeSingle();
    if (error) throw error;
    markCloudOk();
    return data || null;
  }catch(e1){
    const msg = String(e1?.message || e1 || '');
    const code = String(e1?.code || '');
    const isMissingInitials = (code === '42703') || /initials/i.test(msg);
    if (!isMissingInitials){
      markCloudError(e1);
      throw e1;
    }
    // Column doesn't exist yet: treat as no-op so UI doesn't break.
    markCloudOk();
    return null;
  }
}




async function cloudDeletePlayer(playerOrName){
  // "Delete" is now SAFE: archive snapshot (best effort) then soft-delete (preferred) with hard-delete fallback.
  const obj = (playerOrName && typeof playerOrName === 'object') ? playerOrName : null;
  const raw = obj ? (obj.id || obj.name || '') : String(playerOrName || '');
  const t = String(raw).trim();
  if (!t) return;

  if (!ensureCloudInit()) throw new Error('Cloud not ready');
  const sb = window.supabaseClient;

  const name = obj ? String(obj.name || '').trim() : (sqIsUuidLike(t) ? '' : t);
  let playerId = obj?.id ? String(obj.id).trim() : (sqIsUuidLike(t) ? t : null);

  if (!playerId && name){
    try{ playerId = await cloudResolvePlayerId(name); }catch(e){}
  }

  // Fetch player row for archive (best effort)
  let row = null;
  if (playerId){
    const r = await sb.from(TABLE_PLAYERS).select('*').eq('id', playerId).maybeSingle();
    if (!r.error) row = r.data || null;
  } else if (name){
    const r = await sb.from(TABLE_PLAYERS).select('*').ilike('name', name).limit(1).maybeSingle();
    if (!r.error) row = r.data || null;
    if (row?.id) playerId = row.id;
  }

  if (row) await cloudArchivePlayerSnapshot(row, 'admin_delete');

  // Prefer soft-delete (keeps history + allows restore)
  const deletedAt = new Date().toISOString();
  let softOk = false;

  if (playerId){
    const u = await sb.from(TABLE_PLAYERS).update({ deleted_at: deletedAt }).eq('id', playerId);
    softOk = !u.error;
  } else if (name){
    const u = await sb.from(TABLE_PLAYERS).update({ deleted_at: deletedAt }).ilike('name', name);
    softOk = !u.error;
  }

  // Fallback hard-delete only if soft-delete isn't available
  if (!softOk){
    if (playerId){
      const d = await sb.from(TABLE_PLAYERS).delete().eq('id', playerId);
      if (d.error) throw d.error;
    } else if (name){
      const d = await sb.from(TABLE_PLAYERS).delete().ilike('name', name);
      if (d.error) throw d.error;
    }
  }

  await cloudRefreshPlayerDirectory(true);
  window.dispatchEvent(new CustomEvent('sq:players-changed'));
}


// Fetch high scores from Supabase (league or practice)
async function cloudListHighScores(isPractice = false, limit = 500){
  const table = isPractice ? TABLE_HS_PRACTICE : TABLE_HS_LEAGUE;
  const { data, error } = await sb
    .from(table)
    .select('name, score, ts')
    .order('score', { ascending: false })  // highest first
    .order('ts',    { ascending: false })  // newest first tie-break
    .limit(limit);
  if (error) { markCloudError(error); throw error; }
  markCloudOk();
  return (data || []).map(r => ({ name: r.name, score: Number(r.score) || 0, ts: r.ts }));
}

// Insert (name, score, ts) if not already present in the table
async function cloudInsertHighScoreIfMissing(table, name, score, ts){
  try {
    const { data, error } = await sb
      .from(table)
      .select('name', { count: 'exact' })
      .eq('name', name)
      .eq('score', score)
      .eq('ts', ts)
      .limit(1);
    if (error) { markCloudError(error); return false; }
    if (Array.isArray(data) && data.length) return false; // already exists
    const { error: insErr } = await sb.from(table).insert({ name, score, ts });
    if (insErr) { markCloudError(insErr); return false; }
    markCloudOk();
    return true;
  } catch (e){
    console.error('cloudInsertHighScoreIfMissing failed', e);
    return false;
  }
}

// From a finished game, write one HS row per player to the correct table
async function cloudSaveHighScoresForGame(totals, tsIso){
  try {
    const isPractice = (__sqComputeGameMode() === 'practice');
    const table = isPractice ? TABLE_HS_PRACTICE : TABLE_HS_LEAGUE;
    const when = tsIso || new Date().toISOString();

    for (let i = 0; i < (state.players || []).length; i++){
      const name  = state.players[i]?.name || '';
      const score = Number(totals?.[i] || 0);
      if (!name || score <= 0) continue;
      await cloudInsertHighScoreIfMissing(table, name, score, when);
    }
  } catch (e) {
    console.error('cloudSaveHighScoresForGame failed', e);
  }
}

// Simple initial Supabase connectivity check
async function initialCloudCheck() {
  try {
    setCloudStatus('checking', 'Checking cloudâ€¦');
    const { error } = await sb
      .from(TABLE_PLAYERS)
      .select('name', { head: true, count: 'exact' });
    if (error) throw error;
    markCloudOk();
  } catch (err) {
    markCloudError(err);
  }
}

// --- Bootstrap wiring once the DOM is ready ---
/* Fallback: define initSetupSteppers if missing */
if (typeof window.initSetupSteppers !== 'function') {
  window.initSetupSteppers = function initSetupSteppers(){
    const steppers = document.querySelectorAll('.setup-stepper');
    steppers.forEach(stepper => {
      const selectId = stepper.getAttribute('data-select-id');
      const suffix   = stepper.getAttribute('data-suffix') || '';
      const select   = document.getElementById(selectId);
      const numEl    = stepper.querySelector('.stepper-number');
      const sufEl    = stepper.querySelector('.stepper-suffix');
      if (sufEl) sufEl.textContent = suffix;
      if (!select || !numEl) return;

      // Prevent duplicate bindings (which caused skipping: 1â†’3â†’5â€¦)
      if (stepper.dataset.bound === '1') return;
      stepper.dataset.bound = '1';

      // Determine min/max from the select's option values
      const values = [...select.options].map(o => parseInt(o.value, 10)).filter(n => !Number.isNaN(n));
      const minVal = Math.min(...values);
      const maxVal = Math.max(...values);

      function syncFromSelect(){
        const val = parseInt(select.value, 10);
        if (!Number.isNaN(val)) {
          numEl.textContent = String(val);
        } else {
          const opt = select.options[select.selectedIndex];
          const txt = opt ? opt.textContent : '';
          const m = txt && txt.match(/\d+/);
          numEl.textContent = m ? m[0] : txt;
        }
      }

      function setTo(v){
        const targetIdx = [...select.options].findIndex(o => parseInt(o.value, 10) === v);
        if (targetIdx >= 0) {
          select.selectedIndex = targetIdx;
          select.dispatchEvent(new Event('change', { bubbles: true }));
          syncFromSelect();
        }
      }

      // Bind buttons using `onclick` (overwrites any prior handlers)
      stepper.querySelectorAll('.stepper-btn').forEach(btn => {
        const delta = parseInt(btn.getAttribute('data-delta') || '0', 10);
        btn.onclick = () => {
          const cur = parseInt(select.value, 10);
          const next = Math.min(maxVal, Math.max(minVal, cur + (delta > 0 ? 1 : -1)));
          setTo(next);
        };
      });

      select.addEventListener('change', syncFromSelect);
      syncFromSelect();
    });

    // Ensure initial player rows render to match default "players" count
    try { if (typeof drawPsRows === 'function') drawPsRows(); } catch(_) {}
  };
}
document.addEventListener('DOMContentLoaded', () => {
  try { if (typeof setupStartMenuButtons === 'function') setupStartMenuButtons(); } catch (e) { console.error(e); }
  try { if (typeof initSetupSteppers   === 'function') initSetupSteppers();   } catch (e) { console.error(e); }
  try { if (typeof initialCloudCheck   === 'function') initialCloudCheck();   } catch (e) { console.error(e); }
  try { updatePadSpacer(); } catch (e) {}
  try { bindScoreHeaderScrollSync(); } catch (e) {}
  // Build the rolling ticker on first load of the Start screen
  try { if (typeof window.buildStartTicker === 'function') { window.buildStartTicker(); } } catch (e) { console.error(e); }
});
// --- Period filter helper (Today / 1 Week / 1 Month / All Time) ---
function periodStartIso(key){
  const now = new Date();
  if (key === 'today') {
    const d = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    return d.toISOString();
  }
  if (key === 'week') {
    const d = new Date(now.getTime() - 7*24*60*60*1000);
    return d.toISOString();
  }
  if (key === 'month') {
    const d = new Date(now.getTime() - 30*24*60*60*1000);
    return d.toISOString();
  }
  return null; // all time
}
// --- Date formatter: dd/mm/yy @ 24h:mm ---
function fmtDdMmYyAtTime(d){
  const dd = String(d.getDate()).padStart(2,'0');
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const yy = String(d.getFullYear()).slice(-2);
  const hh = String(d.getHours()).padStart(2,'0');
  const mi = String(d.getMinutes()).padStart(2,'0');
  return `${dd}/${mm}/${yy} @ ${hh}:${mi}`;
}

// --- Start-screen rolling banner (last 10 completed games) ---
function _psHumanList(parts){
  if (!parts || !parts.length) return '';
  if (parts.length === 1) return parts[0];
  if (parts.length === 2) return parts[0] + ' and ' + parts[1];
  return parts.slice(0, -1).join(', ') + ' and ' + parts[parts.length - 1];
}

function _psFormatLine(game){
  try{
    const list = (game.players || []).map((p, i) => ({
      name: (p && p.name) ? String(p.name) : `Player ${i + 1}`,
      score: Number(Array.isArray(game.totals) ? (game.totals[i] || 0) : 0)
    }));
    if (!list.length) return '';
    list.sort((a,b)=> b.score - a.score);      // winner first
    const winner = list[0];
    const others = list.slice(1).map(o => `${o.name} (${o.score})`);
    return others.length
      ? `${winner.name} (${winner.score}) beats ${_psHumanList(others)}`
      : `${winner.name} (${winner.score}) wins`;
  }catch(_){ return ''; }
}

// Expose globally so `show()` can always reach it, even if the code is wrapped.
window.buildStartTicker = async function buildStartTicker(){
  const wrap1  = document.getElementById('psTicker');
  const track1 = wrap1 ? wrap1.querySelector('.track') : null;
  const wrap2  = document.getElementById('psTickerTop');
  const track2 = wrap2 ? wrap2.querySelector('.track') : null;

  if ((!wrap1 || !track1) && (!wrap2 || !track2)) { return; }

  function escHtml(s){
    return String(s || '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function parseJoined(v){
    if (!v) return 0;
    if (typeof v === 'number') return v;
    const t = Date.parse(v);
    return Number.isFinite(t) ? t : 0;
  }

  function getNewPlayers(days){
    const cutoff = Date.now() - (days * 86400000);
    const arr = (typeof getSavedPlayers === 'function') ? (getSavedPlayers() || []) : [];
    return arr
      .filter(p => p && p.name && parseJoined(p.joinedAt) >= cutoff)
      .sort((a,b) => parseJoined(b.joinedAt) - parseJoined(a.joinedAt))
      .map(p => p.name);
  }

  function setMarquee(track, msg, mode){
    const safe = escHtml(msg);
    // Bottom (yellow) ticker uses repeated spans for a seamless loop.
    // Top (new players) ticker uses a single span and a CSS pause between runs.
    if (mode === 'single'){
      track.innerHTML = `<div class="marquee"><span>${safe}</span></div>`;
      return;
    }
    track.innerHTML = `<div class="marquee"><span>${safe}</span><span aria-hidden="true">${safe}</span><span aria-hidden="true">${safe}</span></div>`;
  }

  try{
    // Ensure local cache includes cloud players so the ticker is consistent across devices.
    if (typeof syncSavedPlayersFromCloud === 'function') {
      try{ await syncSavedPlayersFromCloud(); }catch(_){ }
    }
    const names = getNewPlayers(14);
    const msg = names.length
      ? `NEW PLAYERS // ${names.join(', ')} // WELCOME TO SHATEKI'S QUEST`
      : `WELCOME TO SHATEKI'S QUEST`;

    if (track1) setMarquee(track1, msg, 'repeat');
    if (track2) setMarquee(track2, msg, 'single');
    if (wrap1) wrap1.classList.remove('hidden');
    if (wrap2) wrap2.classList.remove('hidden');
  }catch(e){
    console.error('buildStartTicker failed', e);
    if (wrap1) wrap1.classList.add('hidden');
    if (wrap2) wrap2.classList.add('hidden');
  }
};
// High Scores dialog â€” deduped + period buttons
async function openHighScoresDialog(isPractice = false, range = 'all') {
  // range helpers
  function rangePassFactory(r){
    const now = new Date();
    if (r==='today'){ const s=new Date(now); s.setHours(0,0,0,0); return d=>d>=s && d<=now; }
    if (r==='yesterday'){ const y0=new Date(now); y0.setDate(y0.getDate()-1); y0.setHours(0,0,0,0); const y1=new Date(y0); y1.setHours(23,59,59,999); return d=>d>=y0 && d<=y1; }
    if (r==='1w'){ const s=new Date(now); s.setDate(s.getDate()-7); return d=>d>=s && d<=now; }
    if (r==='1m'){ const s=new Date(now); s.setMonth(s.getMonth()-1); return d=>d>=s && d<=now; }
    if (r==='6m'){ const s=new Date(now); s.setMonth(s.getMonth()-6); return d=>d>=s && d<=now; }
    return _=>true;
  }

  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className='modal';
  const title   = document.createElement('h3');  title.textContent = `High Scores (${isPractice? 'Practice' : 'Official'})`;
  const body    = document.createElement('div'); body.className='modal-body';
  const footer  = document.createElement('div'); footer.className='modal-footer';
  modal.append(title, body, footer); overlay.appendChild(modal); document.body.appendChild(overlay);
  modal.tabIndex = 0; modal.focus();
  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); });

// --- Shotgun Leaderboard (3-dart avg over last 28 rounds = last 2 official games) ---
async function cloudListPlayerRecentOfficialGames(name, limitGames = 2){
  const { data, error } = await sb
    .from(TABLE_PLAYER_GAMES) // 'player_games_union'
    .select('player, score, rounds, ts, is_practice')
    .eq('player', name)
    .eq('is_practice', false) // official only
    .order('ts', { ascending: false })
    .limit(limitGames);
  if (error) { console.error(error); return []; }
  return data || [];
}
  async function render(){
    body.innerHTML = '';
    let rows = [], loadErr = null;
    try { rows = await cloudListHighScores(isPractice, 1000); }
    catch(e){ console.error(e); loadErr = e; rows = []; }

    if (loadErr){
      const p=document.createElement('p'); p.textContent='Failed to load high scores.'; body.appendChild(p); return;
    }

    // Robust client-side de-dup: one row per (name,score), keep original (earliest ts)
    rows = dedupeRowsByNameScoreKeepEarliest(rows);

    // Filter by requested window
    const pass = rangePassFactory(range);
    rows = rows.filter(r=> r?.ts ? pass(new Date(r.ts)) : true);

    // Sort: highest score first, then newest, then name
    rows.sort((a, b) => {
      const sa = Number(a?.score || 0);
      const sb = Number(b?.score || 0);
      if (sb !== sa) return sb - sa;
      const ta = a?.ts ? Date.parse(a.ts) : 0;
      const tb = b?.ts ? Date.parse(b.ts) : 0;
      if (tb !== ta) return tb - ta;
      const na = String(a?.name || '');
      const nb = String(b?.name || '');
      return na.localeCompare(nb);
    });

    if (!rows.length){
      const p=document.createElement('p'); p.textContent='No scores recorded for this period.'; body.appendChild(p); return;
    }

    const table=document.createElement('table'); table.className='hs-table';
    const thead=document.createElement('thead'); const trh=document.createElement('tr');
    ;['#','Player','Score','Avg / Round','When'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
    thead.appendChild(trh); table.appendChild(thead);
    const tb=document.createElement('tbody');

    rows.forEach((r, idx)=>{
      const tr=document.createElement('tr');
      const td1=document.createElement('td'); td1.textContent=String(idx+1);
      const td2=document.createElement('td'); td2.textContent=String(r.name||'');
      const td3=document.createElement('td'); td3.textContent=String(r.score);
      const td4=document.createElement('td');
      const avg=(typeof MAX_ROUNDS==='number'&&MAX_ROUNDS>0)?(Number(r.score||0)/MAX_ROUNDS):0; td4.textContent=avg.toFixed(1);
      const td5=document.createElement('td');
      const d=r.ts?new Date(r.ts):null; td5.textContent=(d&&!Number.isNaN(d.getTime()))? d.toLocaleString(undefined,{year:'2-digit',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit'}) : '';
      td5.style.fontSize='0.8rem';
      tr.append(td1,td2,td3,td4,td5);
      tb.appendChild(tr);
    });

    table.appendChild(tb); body.appendChild(table);
  }

  function mkBtn(lbl,val,primary=false){
    const b=document.createElement('button'); b.className='btn'; if(primary) b.classList.add('primary'); b.textContent=lbl;
    b.onclick=()=>{ if(val==='__back__'){ overlay.remove(); return; } range=val; render(); };
    return b;
  }
  footer.append(
    mkBtn('Today','today'),
    mkBtn('Yesterday','yesterday'),
    mkBtn('1 Week','1w'),
    mkBtn('1 Month','1m'),
    mkBtn('6 Month','6m'),
    mkBtn('All Time','all', true),
    mkBtn('Back','__back__',false)
  );

  await render();
}
/*****************
 * CLOUD STATS HELPERS (LEGACY ALIAS)
 *****************
 * NOTE: "Sprint League" has been renamed to "Power Rankings".
 * The old Sprint League view-based dialog has been removed to reduce code size
 * and prevent naming drift. This function now forwards to the canonical
 * Power Rankings dialog.
 *****************/

async function openSprintLeagueDialog(){
  try{
    if (typeof window.openPowerLeagueDialog === 'function') {
      return await window.openPowerLeagueDialog();
    }
    console.warn('Power Rankings dialog not available (openPowerLeagueDialog missing)');
    if (typeof toast === 'function') toast('Power Rankings not available');
  } catch(e){
    console.error('openSprintLeagueDialog failed', e);
    try { if (typeof toast === 'function') toast('Failed to open Power Rankings'); } catch(_) {}
  }
}

// Backwards-compatible no-op (legacy callers may still await this)
async function computeSprintLeagueAsync(){ return []; }

// (cloudSynthGamesFromHighScores remains unchanged)
// If a wrapper exists for openHighScoresMenuDialog, patch it to call the new dialog:
function openHighScoresMenuDialog(){ openHighScoresDialog(false, 'all'); }


/*****************
 * CLOUD MATCH HELPERS
 *****************/
async function upsertMatchToSupabase(createdAtOverride) {
  try {
    const payload = {
      id: state.match.id,                                                // uuid
      created_at: state.match.createdAtIso || createdAtOverride || new Date().toISOString(),
      total_games: state.match.history.length,
      players: state.players.map(p => ({ name: p.name })),               // [{name}]
      wins: (state.match.wins || []).slice(),
      history: state.match.history.map(g => ({ totals: (g?.totals || []).slice() }))
    };
    const { error } = await sb.from(TABLE_MATCHES).upsert(payload);
    if (error) throw error;
  } catch (e) {
    console.error('upsertMatchToSupabase failed', e);
  }
}

// Map Supabase -> local shapes the stats code already understands
function mapCloudGameRowToLocal(row){
  const rawPlayers = Array.isArray(row?.state?.players) ? row.state.players : [];

  const players = rawPlayers.map(p => {
    if (p == null) return { name: '' };
    if (typeof p === 'string') return { name: p };

    const id = p?.player_id ?? p?.playerId ?? p?.id ?? null;
    let name = (p?.name || '').toString().trim();

    const first = (p?.first_name || '').toString().trim();
    const last  = (p?.last_name  || '').toString().trim();
    const nick  = (p?.nickname   || '').toString().trim();

    if (!name && first){
      if (nick && last) name = (first + ' "' + nick + '" ' + last).trim();
      else if (nick)    name = (first + ' "' + nick + '"').trim();
      else if (last)    name = (first + ' ' + last).trim();
      else              name = first;
    }

    if (!name && id) name = String(id).trim();
    return { id, name };
  });
  const totals  = Array.isArray(row?.totals) ? row.totals.slice() : [];
  let max = -Infinity, winners = [];
  totals.forEach((t,i)=>{ if (t>max){max=t; winners=[i];} else if (t===max){ winners.push(i);} });

  // Carry cloud identity + mode hints through to local shape
  const matchId = row?.match_id ?? row?.matchId ?? row?.state?.match_id ?? row?.state?.matchId ?? null;
  const gameNumber = row?.game_number ?? row?.gameNumber ?? row?.state?.game_number ?? row?.state?.gameNumber ?? null;

  return {
    id: row?.id ?? null,
    ts: row?.created_at || null,
    players,
    totals,
    winners,
    board: row?.state?.board || null,
    match_id: matchId,
    matchId,
    game_number: gameNumber,
    gameNumber
  };
}
async function cloudFetchAllGamesAsLocal(){
  const { data, error } = await sb
    .from(TABLE_GAMES)
    .select('id,created_at,state,totals,match_id,game_number')
    .order('created_at', { ascending: true });
  if (error) throw error;
  return (data || []).map(mapCloudGameRowToLocal);
}

// Efficient: newestâ†’oldest, limited (used by home live printer)
async function cloudFetchLatestGamesAsLocal(limit = 10){
  const { data, error } = await sb
    .from(TABLE_GAMES)
    .select('id,created_at,state,totals,match_id,game_number')
    .order('created_at', { ascending: false })
    .limit(limit);
  if (error) throw error;
  return (data || []).map(mapCloudGameRowToLocal);
}

function mapCloudMatchRowToLocal(row){
  const playersArr = Array.isArray(row?.players) ? row.players : [];
  const players = playersArr.map(p => (typeof p === 'string') ? { name: p } : { name: p?.name });
  const wins = Array.isArray(row?.wins) ? row.wins.slice() : [];
  const games = row?.total_games || (Array.isArray(row?.history) ? row.history.length : 0);
  const matchTotals = [];
  if (Array.isArray(row?.history)) {
    row.history.forEach(g => {
      (g?.totals || []).forEach((v,i) => { matchTotals[i] = (matchTotals[i] || 0) + (Number(v)||0); });
    });
  }
  return { id: row?.id, ts: row?.created_at || null, players, wins, targetWins: null, games, matchTotals };
}
async function cloudFetchAllMatchesAsLocal(){
  const { data, error } = await sb
    .from(TABLE_MATCHES)
    .select('id,created_at,players,wins,history,total_games')
    .order('created_at', { ascending: true });
  if (error) throw error;
  return (data || []).map(mapCloudMatchRowToLocal);
}

async function computePlayerWindowStatsAsync(playerName, mode = 'official') {
  // 0) Load sources
  let cloudGames = [];
  let cloudMatches = [];
  try { cloudGames = await cloudFetchAllGamesAsLocal(); } catch (_) {}
  try { cloudMatches = await cloudFetchAllMatchesAsLocal(); } catch (_) {}

  const localGames   = getGameLog()   || [];
  const localMatches = getMatchLog()  || [];

  // 1) Merge (cloud first, then local) â€“ oldestâ†’newest order
  let games   = [...cloudGames, ...localGames];
  let matches = (mode === 'official') ? [...cloudMatches, ...localMatches] : [];

  // 2) Filter by mode
  const byMode = (g) => (mode === 'official' ? isOfficialGame(g) : isPracticeGame(g));
  games = games.filter(byMode);
  if (mode !== 'official') matches = [];

  // 3) If still no games for this player, synth from high_scores tables
  const hasAnyForPlayer = games.some(g => (g.players || []).some(p => p && eqName(p.name, playerName)));
  if (!hasAnyForPlayer) {
    try {
      const synth = await cloudSynthGamesFromHighScores(playerName);
      games = games.concat((synth || []).filter(byMode));
    } catch (_) {}
  }

  // 4) Windows
  const now = new Date();
  const out = {};
  STAT_WINDOWS.forEach(w => {
    const gWin = games.filter(g => g.ts && w.test(new Date(g.ts), now));
    const mWin = matches.filter(m => m.ts && w.test(new Date(m.ts), now));
    out[w.key] = computeSingleWindowStats(playerName, gWin, mWin, w, now);
  });
  out.life = computeSingleWindowStats(playerName, games, matches, { test: () => true }, now);
  return out;
}

// === Mode chooser (top-level) ===
function openModeChooser(onPick, onCancel){
  const ov = document.createElement('div'); ov.className='modal-backdrop';
  const m  = document.createElement('div'); m.className='modal';
  const h  = document.createElement('h3'); h.textContent='Choose Mode';
  const b  = document.createElement('div'); b.className='modal-body';
  const r  = document.createElement('div'); r.className='row';
  r.style.gap='8px'; r.style.justifyContent='center';

  const o  = document.createElement('button'); o.className='btn primary big'; o.textContent='Official';
  const p  = document.createElement('button'); p.className='btn big';         p.textContent='Practice';
  o.onclick = ()=>{ ov.remove(); onPick && onPick('official'); };
  p.onclick = ()=>{ ov.remove(); onPick && onPick('practice'); };
  r.append(o,p); b.appendChild(r);

  const f  = document.createElement('div'); f.className='modal-footer';
  const c  = document.createElement('button'); c.className='btn'; c.textContent='Return';
  c.onclick = ()=>{ ov.remove(); onCancel && onCancel(); };
  f.appendChild(c);

  m.append(h,b,f); ov.appendChild(m); document.body.appendChild(ov); m.tabIndex=0; m.focus();
  ov.addEventListener('click', e=>{ if(e.target===ov) ov.remove(); });
  ov.addEventListener('keydown', e=>{ if(e.key==='Escape'){ ov.remove(); onCancel && onCancel(); }});
}

// === Target Hit Rate ===
async function openTargetHitRateDialog(playerName, mode){
  const games = await getGamesForMode(mode);
  const counters = accumulateTargetCounters(playerName, games);

  const ov = document.createElement('div'); ov.className='modal-backdrop';
  const md = document.createElement('div'); md.className='modal';
  const h  = document.createElement('h3');  h.textContent = `Target Hit Rate â€“ ${playerName} (${mode==='official'?'Official':'Practice'})`;
  const body = document.createElement('div'); body.className='modal-body';

  const tbl = document.createElement('table'); tbl.className='hs-table';
  const thead=document.createElement('thead'); const trh=document.createElement('tr');
  ['Target','Thrown','Hits','Hit %'].forEach(s=>{ const th=document.createElement('th'); th.textContent=s; trh.appendChild(th); });
  thead.appendChild(trh); tbl.appendChild(thead);
  const tb = document.createElement('tbody');

  for (let n=10;n<=20;n++){
    const c = counters[String(n)];
    const tr=document.createElement('tr');
    tr.append(
      Object.assign(document.createElement('td'),{textContent:String(n)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:String(c.thrown)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:String(c.hits)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:pctStr(c.hits, c.thrown)})
    );
    tb.appendChild(tr);
  }

  [['D', counters.D], ['T', counters.T]].forEach(([label,c])=>{
    const tr=document.createElement('tr');
    tr.append(
      Object.assign(document.createElement('td'),{textContent:label}),
      Object.assign(document.createElement('td'),{className:'num', textContent:String(c.thrown)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:String(c.hits)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:pctStr(c.hits, c.thrown)})
    );
    tb.appendChild(tr);
  });

  // Bulls summary row
  {
    const c = counters.B;
    const tr=document.createElement('tr');
    tr.append(
      Object.assign(document.createElement('td'),{textContent:'B'}),
      Object.assign(document.createElement('td'),{className:'num', textContent:String(c.thrown)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:String(c.hits)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:`${pctStr(c.hits, c.thrown)} (I:${pctStr(c.inner,c.thrown)} Â· O:${pctStr(c.outer,c.thrown)})`})
    );
    tb.appendChild(tr);
  }

  tbl.appendChild(tb); body.appendChild(tbl);

  const ft = document.createElement('div'); ft.className='modal-footer';
  const back=document.createElement('button'); back.className='btn'; back.textContent='Return';
  back.onclick=()=>{ ov.remove(); openPlayerStatsModePicker(playerName); };
  ft.appendChild(back);

  md.append(h, body, ft); ov.appendChild(md); document.body.appendChild(ov);
  md.tabIndex=0; md.focus(); ov.addEventListener('click', e=>{ if(e.target===ov) ov.remove(); });
  ov.addEventListener('keydown', e=>{ if(e.key==='Escape') ov.remove(); });
}

// Official-only head-to-head summary
async function openH2HDialog(playerName){
  const games = await getGamesForMode('official');   // uses official games

  const vs = new Map(); // name -> aggregate
  for (const g of (games || [])) {
    if (!g || !Array.isArray(g.players) || !Array.isArray(g.totals)) continue;
    const me = g.players.findIndex(p => p && eqName(p.name, playerName));
    if (me === -1) continue;

    const myTotal = Number(g.totals[me] || 0);
    const dt = g.ts ? new Date(g.ts) : null;

    for (let j = 0; j < g.players.length; j++){
      if (j === me) continue;
      const oppName = (g.players[j]?.name || '').trim();
      if (!oppName) continue;

      const oppTotal = Number(g.totals[j] || 0);
      const rec = vs.get(oppName) || { opp: oppName, games: 0, wins: 0, losses: 0, for: 0, against: 0, last: null };
      rec.games++;
      if (myTotal > oppTotal) rec.wins++; else if (myTotal < oppTotal) rec.losses++;
      rec.for += myTotal; rec.against += oppTotal;
      if (dt && (!rec.last || dt > rec.last)) rec.last = dt;
      vs.set(oppName, rec);
    }
  }

  const rows = [...vs.values()].map(r => ({
    name: r.opp,
    gp: r.games,
    w: r.wins,
    l: r.losses,
    winPct: r.games ? (r.wins / r.games * 100) : 0,
    avgDiff: r.games ? ((r.for - r.against) / r.games) : 0,
    last: r.last
  })).sort((a,b)=> (b.gp - a.gp) || (b.winPct - a.winPct) || a.name.localeCompare(b.name));

  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal';
  const title   = document.createElement('h3');  title.textContent = `Head-to-Head â€” ${playerName}`;
  const body    = document.createElement('div'); body.className    = 'modal-body';

  if (!rows.length) {
    const p = document.createElement('p'); p.textContent = 'No head-to-head data (official games only).'; body.appendChild(p);
  } else {
    const ineligible = rows.filter(r => (Number(r.gp) || 0) < 4)
      .sort((a,b)=> (b.gp - a.gp) || a.name.localeCompare(b.name));
    const eligible = rows.filter(r => (Number(r.gp) || 0) >= 4)
      .sort((a,b)=> (b.gp - a.gp) || (b.winPct - a.winPct) || a.name.localeCompare(b.name));

    // Ineligible opponents (shown at top, NOT in league format)
    if (ineligible.length) {
      const cap = document.createElement('div');
      cap.className = 'muted';
      cap.style.margin = '2px 0 10px';
      cap.textContent = 'Opponents need 4+ games to enter the H2H league table.';
      body.appendChild(cap);

      const t0 = document.createElement('table'); t0.className = 'hs-table';
      const th0 = document.createElement('thead'); const tr0 = document.createElement('tr');
      ['Opponent','GP'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; tr0.appendChild(th); });
      th0.appendChild(tr0); t0.appendChild(th0);

      const tb0 = document.createElement('tbody');
      ineligible.forEach(r=>{
        const tr = document.createElement('tr');
        tr.style.opacity = '0.45';
        const td = (t,c)=>Object.assign(document.createElement('td'),{textContent:t, className:c||''});
        tr.append(td(r.name), td(String(r.gp),'num'));
        tb0.appendChild(tr);
      });
      t0.appendChild(tb0);
      body.appendChild(t0);

      const rule = document.createElement('div');
      rule.style.height='1px';
      rule.style.background='rgba(255,255,255,0.08)';
      rule.style.margin='12px 0';
      body.appendChild(rule);
    }

    // Eligible opponents: league format
    if (!eligible.length) {
      const p = document.createElement('p');
      p.className = 'muted';
      p.textContent = 'No eligible opponents yet (need 4+ games).';
      body.appendChild(p);
    } else {
      const table = document.createElement('table'); table.className = 'hs-table';
      const thead = document.createElement('thead'); const trh = document.createElement('tr');
      ['Opponent','GP','W','L','Win %','Avg Diff','Last'].forEach(h=>{
        const th = document.createElement('th'); th.textContent = h; trh.appendChild(th);
      });
      thead.appendChild(trh); table.appendChild(thead);

      const tbody = document.createElement('tbody');
      eligible.forEach(r=>{
        const tr = document.createElement('tr');
        const td = (t,c)=>Object.assign(document.createElement('td'),{textContent:t, className:c||''});
        tr.append(
          td(r.name),
          td(String(r.gp),'num'),
          td(String(r.w),'num'),
          td(String(r.l),'num'),
          td(r.winPct.toFixed(1)+'%','num'),
          td((r.avgDiff>=0?'+':'')+r.avgDiff.toFixed(1),'num'),
          td(r.last && !Number.isNaN(r.last.getTime())
            ? r.last.toLocaleDateString(undefined,{year:'2-digit',month:'short',day:'2-digit'})
            : 'â€”')
        );
        tbody.appendChild(tr);
      });
      table.appendChild(tbody); body.appendChild(table);
    }
  }

  const footer = document.createElement('div'); footer.className = 'modal-footer';
  const back   = document.createElement('button'); back.className='btn'; back.textContent='Return';
 back.onclick = () => {
  overlay.remove();
  if (typeof openPlayerStatsModePicker === 'function') {
    openPlayerStatsModePicker(playerName);
  } else {
    // safe fallback: go to the player lookup
    if (typeof openPlayerStatsLookupDialog === 'function') {
      openPlayerStatsLookupDialog();
    }
  }
};
  const close  = document.createElement('button'); close.className='btn'; close.textContent='Close';
  close.onclick = () => overlay.remove();
  footer.append(back, close);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  modal.tabIndex = 0; modal.focus();
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}

// === T-D-B ===
async function openTDHDialog(playerName, mode){
  const games = await getGamesForMode(mode);
  const counters = accumulateTargetCounters(playerName, games);

  const ov = document.createElement('div'); ov.className='modal-backdrop';
  const md = document.createElement('div'); md.className='modal';
  const h  = document.createElement('h3');  h.textContent = `T-D-B â€“ ${playerName} (${mode==='official'?'Official':'Practice'})`;
  const body = document.createElement('div'); body.className='modal-body';

  const tbl = document.createElement('table'); tbl.className='hs-table';
  const thead=document.createElement('thead'); const trh=document.createElement('tr');
  ['Target','Thrown','Treble %','Double %'].forEach(s=>{
    const th=document.createElement('th'); th.textContent=s; trh.appendChild(th);
  });
  thead.appendChild(trh); tbl.appendChild(thead);

  const tb = document.createElement('tbody');
  for (let n=10;n<=20;n++){
    const c = counters[String(n)];
    const tr=document.createElement('tr');
    tr.append(
      Object.assign(document.createElement('td'),{textContent:String(n)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:String(c.thrown)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:pctStr(c.tHits, c.thrown)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:pctStr(c.dHits, c.thrown)})
    );
    tb.appendChild(tr);
  }
  tbl.appendChild(tb); body.appendChild(tbl);

  const ft = document.createElement('div'); ft.className='modal-footer';
  const back=document.createElement('button'); back.className='btn'; back.textContent='Return';
  back.onclick=()=>{ ov.remove(); openPlayerStatsModePicker(playerName); };
  ft.appendChild(back);

  md.append(h, body, ft); ov.appendChild(md); document.body.appendChild(ov);
  md.tabIndex=0; md.focus();
  ov.addEventListener('click', e=>{ if(e.target===ov) ov.remove(); });
  ov.addEventListener('keydown', e=>{ if(e.key==='Escape') ov.remove(); });
}

/*****************
 * DETAILS PAGE (page 1)
 *****************/
const resumeBtn=byId('resumeBtn');
function getSavedState(){ 
  try{
    const raw=localStorage.getItem(STORAGE_KEY); 
    if(!raw) return null; 
    const saved=JSON.parse(raw); 
    if(!saved||!Array.isArray(saved.players)||!saved.players.length) return null; 
    return saved;
  }catch(e){ 
    return null; 
  } 
}
function setupStartMenuButtons(){ 
  const saved   = getSavedState(); 
  const hasSaved = !!saved; 

  
  // Tournament button (placeholder)
  const tournamentBtn = byId("tournamentBtn");
  if (tournamentBtn) {
    tournamentBtn.disabled = false;
    tournamentBtn.title = "Tournament mode is coming soon";
    tournamentBtn.onclick = () => toast("Tournament mode; for 4 / 8 players - Coming soon!");
  }

  // Only show Resume if we actually have an in-progress saved match
  resumeBtn.style.display = hasSaved ? '' : 'none';
  resumeBtn.disabled = !hasSaved;
  resumeBtn.title    = hasSaved ? 'Resume last match' : 'No saved match';
if (hasSaved){ 
    resumeBtn.onclick = () => { 
      Object.assign(state, saved); 
      show('game'); 
      assignUniqueColors(state.players); 
      buildEverything(); 
      updateUI(); 
      toast('Resumed last match'); 
    }; 
  } else { 
    resumeBtn.onclick = null; 
  }

  const hsMainBtn = byId('hsMainBtn');
  if (hsMainBtn) {
    hsMainBtn.onclick = openHighScoresMenuDialog;
  }

  const leagueBtn = byId('leagueRankingsBtn');
  if (leagueBtn) leagueBtn.onclick = openLeagueRankingsDialog;

// === Player Stats: simple name-only picker (no PIN) ===
async function openPlayerStatsLookupDialog() {
  // Create basic modal shell
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Player Stats \u2013 Select Player';

  const body = document.createElement('div');
  body.className = 'modal-body';

  // Player name dropdown
  const nameWrap = document.createElement('div');
  nameWrap.className = 'stack';

  const nameLabel = document.createElement('label');
  nameLabel.className = 'tag';
  nameLabel.textContent = 'Player Name';

  const nameSelect = document.createElement('select');
  nameSelect.id = 'statsPlayerSelect';
  nameSelect.style.width = '100%';

  nameWrap.append(nameLabel, nameSelect);
  body.append(nameWrap);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'btn';
  cancelBtn.textContent = 'Cancel';
  cancelBtn.type = 'button';
  cancelBtn.onclick = () => overlay.remove();

  const viewBtn = document.createElement('button');
  viewBtn.className = 'btn primary';
  viewBtn.textContent = 'View Stats';
  viewBtn.type = 'button';

  footer.append(cancelBtn, viewBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });

  // Populate players: cloud first, then local saved players
  nameSelect.innerHTML = '<option value="">Select a saved player...</option>';
  let anyPlayers = false;

  try {
    if (typeof cloudListPlayers === 'function') {
      const cloudPlayers = await cloudListPlayers();
      (cloudPlayers || []).forEach(p => {
        if (!p || !p.name) return;
        const opt = document.createElement('option');
        opt.value = p.name;
        opt.textContent = p.name;
        nameSelect.appendChild(opt);
        anyPlayers = true;
      });
    }
  } catch (err) {
    console.error('Stats: cloudListPlayers failed', err);
  }

  if (!anyPlayers && typeof getSavedPlayers === 'function') {
    const local = getSavedPlayers();
    (local || []).forEach(p => {
      if (!p || !p.name) return;
      const opt = document.createElement('option');
      opt.value = (p.id != null && String(p.id).trim()) ? String(p.id).trim() : p.name;
      opt.textContent = __sqPlayerOptionLabel(p) || p.name;
      nameSelect.appendChild(opt);
      anyPlayers = true;
    });
  }

  if (!anyPlayers) {
    body.innerHTML = '<p>No saved players found. Save a player from the Player Select screen first.</p>';
    viewBtn.disabled = true;
    return;
  }

  // Confirm: open stats for selected player, no PIN check
  viewBtn.onclick = () => {
    const name = nameSelect.value;
    if (!name) {
      if (typeof toast === 'function') toast('Select a saved player');
      return;
    }

    overlay.remove();

    if (typeof openPlayerStatsModePicker === 'function') {
      openPlayerStatsModePicker(name);
    } else {
      console.warn('openPlayerStatsModePicker is not defined; cannot show stats for', name);
    }
  };
}

// === Player Stats: simple name-only picker (no PIN) ===
async function openPlayerStatsLookupDialog() {
  // Create basic modal shell
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Player Stats â€“ Select Player';

  const body = document.createElement('div');
  body.className = 'modal-body';

  // Player name dropdown
  const nameWrap = document.createElement('div');
  nameWrap.className = 'stack';

  const nameLabel = document.createElement('label');
  nameLabel.className = 'tag';
  nameLabel.textContent = 'Player Name';

  const nameSelect = document.createElement('select');
  nameSelect.id = 'statsPlayerSelect';
  nameSelect.style.width = '100%';

  nameWrap.append(nameLabel, nameSelect);
  body.append(nameWrap);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'btn';
  cancelBtn.textContent = 'Cancel';
  cancelBtn.type = 'button';
  cancelBtn.onclick = () => overlay.remove();

  const viewBtn = document.createElement('button');
  viewBtn.className = 'btn primary';
  viewBtn.textContent = 'View Stats';
  viewBtn.type = 'button';

  footer.append(cancelBtn, viewBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });

  // Populate players: cloud first, then local saved players
  nameSelect.innerHTML = '<option value="">Select a saved player...</option>';
  let anyPlayers = false;

  try {
    if (typeof cloudListPlayers === 'function') {
      const cloudPlayers = await cloudListPlayers();
      (cloudPlayers || []).forEach(p => {
        if (!p || !p.name) return;
        const opt = document.createElement('option');
        opt.value = p.name;
        opt.textContent = p.name;
        nameSelect.appendChild(opt);
        anyPlayers = true;
      });
    }
  } catch (err) {
    console.error('Stats: cloudListPlayers failed', err);
  }

  if (!anyPlayers && typeof getSavedPlayers === 'function') {
    const local = getSavedPlayers();
    (local || []).forEach(p => {
      if (!p || !p.name) return;
      const opt = document.createElement('option');
      opt.value = (p.id != null && String(p.id).trim()) ? String(p.id).trim() : p.name;
      opt.textContent = __sqPlayerOptionLabel(p) || p.name;
      nameSelect.appendChild(opt);
      anyPlayers = true;
    });
  }

  if (!anyPlayers) {
    body.innerHTML = '<p>No saved players found. Save a player from the Player Select screen first.</p>';
    viewBtn.disabled = true;
    return;
  }

  // Confirm: open stats for selected player, no PIN check
  viewBtn.onclick = () => {
    const name = nameSelect.value;
    if (!name) {
      if (typeof toast === 'function') toast('Select a saved player');
      return;
    }

    overlay.remove();

    if (typeof openPlayerStatsModePicker === 'function') {
      openPlayerStatsModePicker(name);
    } else {
      console.warn('openPlayerStatsModePicker is not defined; cannot show stats for', name);
    }
  };
}

  const playerStatsBtn = byId('playerStatsBtn');
  if (playerStatsBtn) {
    playerStatsBtn.onclick = openPlayerStatsLookupDialog;
  }
}

window.__sqSelectedMode = window.__sqSelectedMode || 'official';
const questBtnEl = byId('questBtn');
if (questBtnEl) questBtnEl.addEventListener('click', ()=>{
  window.__sqSelectedMode = 'official';
  show('players');
});
['startScreenBtn', 'startScreenBtnLB', 'backToDetailsBtn'].forEach(id => {
  document.querySelectorAll('#' + id).forEach(btn => {
    btn.addEventListener('click', () => show('details'));
  });
});

/*****************
 * PLAYER SELECT (page 2) â€” MATCH SETUP FLOW
 *
 * Desired flow:
 * 1) Players screen: add players (registered/guest). No match length here.
 * 2) Start Match -> Match Length modal (1â€“5 games)
 * 3) Start Match (Match Length) -> Throwing Order dialog -> game
 *****************/
const msPlayersList = byId('msPlayersList');
const msAddRegisteredBtn = byId('msAddRegisteredBtn');
const msAddGuestBtn = byId('msAddGuestBtn');
const msRegisterPlayerBtn = byId('msRegisterPlayerBtn');
const msMinHint = byId('msMinHint');

let __msPlayers = []; // { type:'registered'|'guest', name:'' }

function __msNormalizeName(name, fallback){
  const s = (name || '').trim();
  return s || fallback || '';
}

function __msRenderPlayers(){
  if (!msPlayersList) return;
  msPlayersList.innerHTML = '';

  __msPlayers.forEach((p, i) => {
    const row = document.createElement('div');
    row.className = 'ms-player-row';
    row.dataset.index = String(i);

    const left = document.createElement('div');
    left.className = 'ms-player-left';

    if (p.type === 'guest') {
      const inp = document.createElement('input');
      inp.className = 'ms-player-input';
      inp.type = 'text';
      inp.placeholder = 'Guest player name';
      inp.value = p.name || '';
      inp.addEventListener('input', () => {
        __msPlayers[i].name = inp.value;
        __msUpdateStartEnabled();
      });
      left.appendChild(inp);
    } else {
      const chip = document.createElement('div');
      chip.className = 'ms-player-chip';
      chip.textContent = (__sqNormalizeInitials(p.initials, p.name) || 'R');
      const name = document.createElement('div');
      name.className = 'ms-player-name';
      name.textContent = (__sqPlayerPretty(p) || p.name || 'â€”');
      left.appendChild(chip);
      left.appendChild(name);
    }

    const remove = document.createElement('button');
    remove.className = 'btn small ms-remove';
    remove.type = 'button';
    remove.textContent = 'âœ•';
    remove.onclick = () => {
      __msPlayers.splice(i, 1);
      __msRenderPlayers();
      __msUpdateStartEnabled();
    };

    row.appendChild(left);
    row.appendChild(remove);
    msPlayersList.appendChild(row);
  });

  __msUpdateStartEnabled();
}

function __msValidPlayerCount(){
  const nonEmpty = __msPlayers.filter(p => __msNormalizeName(p.name,'') !== '');
  return nonEmpty.length;
}

function __msMinPlayersRequired(){
  // Practice allows 1â€“6 players. Match Play requires 2â€“6.
  const mode = (window.__sqSelectedMode || 'match');
  return (mode === 'practice') ? 1 : 2;
}


function __msApplyModeStyling(){
  const mode = (window.__sqSelectedMode || 'match');
  const startBtn = byId('startMatchBtn');
  const regBtn = byId('msRegisterPlayerBtn');

  // Practice: remove Save New Player from this flow
  if (regBtn) regBtn.style.display = (mode === 'practice') ? 'none' : '';

  // Practice: blue primary CTA
  if (startBtn) {
    startBtn.classList.remove('ms-primary','ms-primary-blue','ms-primary-blueLight');
    startBtn.classList.add(mode === 'practice' ? 'ms-primary-blue' : 'ms-primary');
  }
}

function __msUpdateStartEnabled(){
  try{ __msApplyModeStyling(); }catch(_){ }
  const n = __msValidPlayerCount();
  const startBtn = byId('startMatchBtn');
  const minP = __msMinPlayersRequired();
  if (startBtn) startBtn.disabled = n < minP;

  if (msMinHint) {
    const mode = (window.__sqSelectedMode || 'match');
    const needTxt = (mode === 'practice') ? 'ADD 1+ PLAYER TO START PRACTICE' : 'ADD 2+ PLAYERS TO START MATCH';
    if (msMinHint.textContent !== needTxt) msMinHint.textContent = needTxt;
    msMinHint.style.opacity = (n < minP) ? '1' : '0';
    msMinHint.style.pointerEvents = 'none';
    msMinHint.style.height = (n < minP) ? '' : '0px';
    msMinHint.style.marginTop = (n < minP) ? '' : '0px';
  }
}

function __msAddGuest(){
  __msPlayers.push({ type:'guest', name:'' });
  __msRenderPlayers();
}

if (msAddRegisteredBtn) msAddRegisteredBtn.addEventListener('click', async () => {
  await showSelectPlayerDialog(0); // index==0 => add to list
});

if (msAddGuestBtn) msAddGuestBtn.addEventListener('click', __msAddGuest);

// Register Player: open the Add Player modal but do not bind to a row (index==0)
if (msRegisterPlayerBtn) {
  msRegisterPlayerBtn.addEventListener('click', async () => {
    await showAddPlayerDialog(0);
  });
}

/* ===== Match Length modal ===== */
const matchLengthModal = byId('matchLengthModal');
const mlGrid = byId('mlGrid');
const mlStartBtn = byId('mlStartBtn');
const mlBackBtn = byId('mlBackBtn');

let __mlSelectedGames = 0;

function __mlBuildGrid(){
  if (!mlGrid) return;
  mlGrid.innerHTML = '';
  const opts = [1,2,3,4,5];

  opts.forEach(n => {
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'ml-tile';
    b.dataset.value = String(n);
    b.innerHTML = `
      <div class="ml-n">${n}</div>
      <div class="ml-lab">${n === 1 ? 'GAME' : 'GAMES'}</div>
    `;
    b.onclick = () => {
      __mlSelectedGames = n;
      [...mlGrid.querySelectorAll('.ml-tile')].forEach(x => x.classList.toggle('selected', x === b));
      if (mlStartBtn) mlStartBtn.disabled = false;
    };
    mlGrid.appendChild(b);
  });

  // default selection: 3 games (matches old default)
  const def = mlGrid.querySelector('.ml-tile[data-value="3"]');
  if (def) def.click();
}

function __mlOpen(){
  if (!matchLengthModal) return;

  const mode = (window.__sqSelectedMode || 'match');
  if (mlStartBtn) {
    if (mode === 'practice') {
      mlStartBtn.className = 'btn ms-start ms-primary-blueLight practice-cta';
      mlStartBtn.innerHTML = 'SELECT THROWING ORDER <span class="ms-arrow">â–¶</span>';
    } else {
      // Match Play: keep CTA styling consistent with Match Setup
      mlStartBtn.className = 'btn ms-start ms-primary';
      mlStartBtn.innerHTML = 'THROW ORDER <span class="ms-arrow">â–¶</span>';
    }
    mlStartBtn.disabled = true;
  }

  __mlBuildGrid();
  matchLengthModal.classList.remove('hidden');
}

function __mlClose(){
  if (!matchLengthModal) return;
  matchLengthModal.classList.add('hidden');
}

if (mlBackBtn) mlBackBtn.onclick = __mlClose;

// Start Match (players screen) -> open match length modal
const psStartMatchBtn = byId('startMatchBtn');
if (psStartMatchBtn) {
  psStartMatchBtn.addEventListener('click', () => {
    const minP = __msMinPlayersRequired();
    if (__msValidPlayerCount() < minP) {
      toast(minP === 1 ? 'Add 1+ player' : 'Add 2+ players');
      return;
    }
    __mlOpen();
  });
}

// Match Length -> Start Match -> Throwing Order -> Game
if (mlStartBtn) {
  mlStartBtn.addEventListener('click', () => {
    const games = parseInt(__mlSelectedGames, 10) || 1;

    // Build players from __msPlayers (trim empties) and carry profile fields through.
    const built = [];
    __msPlayers.forEach((p) => {
      const nm = __msNormalizeName(p.name, '');
      if (!nm) return;
      built.push({
        type: p.type || 'guest',
        id: p.id != null ? p.id : null,
        name: nm,
        first_name: p.first_name || '',
        last_name: p.last_name || '',
        nickname: p.nickname || '',
        initials: p.initials || ''
      });
    });

    const minP = __msMinPlayersRequired();
    if (built.length < minP) {
      toast(minP === 1 ? 'Add 1+ player' : 'Add 2+ players');
      return;
    }

    // Attach full profile (cloud-synced) when available; fallback to name parsing.
    state.players = built.map(p => {
      const meta = (p.type === 'registered')
        ? (p.first_name || p.last_name || p.nickname || p.initials ? p : (__sqFindSavedPlayerMetaByName(p.name) || p))
        : (__sqFindSavedPlayerMetaByName(p.name) || p);

      const parts = __sqNameParts(p.name);
      const first = String(meta.first_name || '').trim() || parts.first;
      const last  = String(meta.last_name  || '').trim() || parts.last;
      const nick  = String(meta.nickname   || '').trim();
      const init  = __sqNormalizeInitials(meta.initials, p.name);

      return {
        name: p.name,
        first_name: first,
        last_name: last,
        nickname: nick,
        initials: init,
        color: null
      };
    });
    assignUniqueColors(state.players);

    const __selMode = (window.__sqSelectedMode || 'official');
    state.match = {
      id: genUuidV4(),
      mode: __selMode,
      forcePractice: (__selMode === 'practice'),
      createdAtIso: _tsOverride || new Date().toISOString(),
      targetWins: games,
      gameNumber: 1,
      wins: Array.from({ length: state.players.length }, () => 0),
      history: [],
      completedLogged: false
    };

    state.matchAgg = null;
    ensureMatchAgg();

    __mlClose();

    // Open throw-order dialog first, then start game on confirm
    startNewGame(false);
    setupStartMenuButtons();
    save();
  });
}

/* ---- Saved players helpers (shared by Add + Select modals) ---- */
function getSavedPlayers(){
  try { return JSON.parse(localStorage.getItem('shateki_players') || '[]'); }
  catch(e){ return []; }
}
function setSavedPlayers(arr){
  try { localStorage.setItem('shateki_players', JSON.stringify(arr)); }
  catch(e){}
}

// Keep local saved players in sync with Supabase (cloud is canonical).
async function syncSavedPlayersFromCloud(){
  if (typeof cloudListPlayers !== 'function') return false;
  try{
    const cloud = await cloudListPlayers(); // [{id,name,created_at,initials,first_name,last_name,nickname}]
    const cloudArr = (cloud || [])
      .filter(p => p && p.name)
      .map(p => ({
        id: (p.id != null ? String(p.id).trim() : null),
        name: String(p.name),
        first_name: (p.first_name != null ? String(p.first_name) : ''),
        last_name: (p.last_name != null ? String(p.last_name) : ''),
        nickname: (p.nickname != null ? String(p.nickname) : ''),
        initials: __sqNormalizeInitials(p.initials, p.name),
        joinedAt: p.created_at ? new Date(p.created_at).toISOString() : null,
        _src: 'cloud'
      }))
      .sort((a,b)=> String(a.name).localeCompare(String(b.name)));

    if (cloudArr.length){
      setSavedPlayers(cloudArr);
      return true;
    }
    return false;
  }catch(e){
    console.error('syncSavedPlayersFromCloud failed', e);
    return false;
  }
}

function populateSavedPlayersSelects(arrOverride){
  const arr = Array.isArray(arrOverride) ? arrOverride : getSavedPlayers();
  const sel1 = document.getElementById('existingPlayers');      // (legacy) some screens
  const sel2 = document.getElementById('existingPlayerSelect'); // Select Player modal

  [sel1, sel2].forEach(sel => {
    if (!sel) return;
    sel.innerHTML = '<option value="">Select a saved player...</option>';
    (arr || []).forEach(p => {
      if (!p) return;
      const v = (p.id != null && String(p.id).trim()) ? String(p.id).trim() : String(p.name || '').trim();
      const label = __sqPlayerOptionLabel(p) || String(p.name || '').trim();
      if (!v || !label) return;
      const opt = document.createElement('option');
      opt.value = v;
      opt.textContent = label;
      sel.appendChild(opt);
    });
  });
}


// Best-effort: sync at startup so all devices converge.
document.addEventListener('DOMContentLoaded', function(){
  try{
    syncSavedPlayersFromCloud().then(()=>{
      try{
        populateSavedPlayersSelects(getSavedPlayers());
        if (typeof window.buildStartTicker === 'function') {
          try{ window.buildStartTicker(); }catch(_){ }
        }
      }catch(_){}
    });
  }catch(_){}
});



// Nickname generator pool (non-pro style, darts vibe) â€” no repeats until exhausted.
const __sqNicknamePool = ["The Quiet Checkout", "Captain Double", "The Split Fixer", "Bullseye Bandit", "The Oche Operator", "Double Dealer", "Treble Tactician", "The Wire Whisperer", "The Flight Surgeon", "The Dart Doctor", "Checkout Chief", "The Board Whisper", "The Angle Artist", "The Scoring Sentry", "The Bull Butler", "The Nickel Navigator", "The Treble Clerk", "The Double Clerk", "The Oche Enforcer", "The Marker", "The Point Professor", "The Segment Sniper", "The Ring Rattler", "The 180 Tease", "The Inside Man", "Outer Bull Baron", "Inner Bull Boss", "The Finishing Foreman", "The Calm Closer", "The Rhythm Rack", "The Aim Assistant", "The Line Judge", "The Split Specialist", "The Lane Lifter", "The Dart Librarian", "The Checkout Courier", "The Trouble Trebler", "The Double Dispatcher", "The Oche Accountant", "The Treble Broker", "The Scoring Steward", "The Board Barista", "The Flight Captain", "The Wire Walker", "The Calm Calculator", "The Segment Surgeon", "The Bull Runner", "The Finish Inspector", "The Tempo Technician", "The Pressure Plumber"];
let __sqNicknameBag = [];
function __sqRefillNicknameBag(){
  __sqNicknameBag = Array.isArray(__sqNicknamePool) ? __sqNicknamePool.slice() : [];
  // Fisherâ€“Yates
  for (let i = __sqNicknameBag.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = __sqNicknameBag[i];
    __sqNicknameBag[i] = __sqNicknameBag[j];
    __sqNicknameBag[j] = tmp;
  }
}
function __sqPickNickname(){
  if (!__sqNicknameBag.length) __sqRefillNicknameBag();
  return __sqNicknameBag.pop() || '';
}
function __sqAutoInitials(first, last){
  return __sqComputeInitials(first, last);
}
function __sqBuildFullName(first, last){
  const f = String(first||'').trim();
  const l = String(last||'').trim();
  return (f + (l ? ' ' + l : '')).trim();
}

// Add / Save Player â€“ now supports First/Last/Initials/Nickname. (No PIN.)
// index==0 means "register only" (do not inject into any row).
async function showAddPlayerDialog(index){
  const modal = byId('addPlayerModal');
  if (!modal) { toast('Add Player modal missing'); return; }

  // Ensure cloud is ready â€” players should not diverge device-locally.
  try{ if (typeof ensureCloudInit === 'function') ensureCloudInit(); }catch(_){ }

  const firstEl = byId('newPlayerFirst');
  const lastEl  = byId('newPlayerLast');
  const initEl  = byId('newPlayerInitials');
  const nickEl  = byId('newPlayerNickname');
  const genBtn  = byId('genNicknameBtn');
  const saveBtn = byId('savePlayerBtn');
  const backBtn = byId('npBackBtn');
  const closeBtn= byId('npCloseBtn');

  let chosenName = '';
  let manualInitials = false;

  const setSaveEnabled = () => {
    const ok = !!String(firstEl?.value || '').trim();
    const cloudOk = !!(window.sb && typeof window.sb.from === 'function');
    if (saveBtn) saveBtn.disabled = !(ok && cloudOk);
  };

  const maybeAutoInitials = () => {
    if (!initEl) return;
    if (manualInitials) return;
    const val = __sqAutoInitials(firstEl?.value, lastEl?.value);
    initEl.value = val || '';
  };

  const reset = () => {
    if (firstEl) firstEl.value = '';
    if (lastEl)  lastEl.value  = '';
    if (nickEl)  nickEl.value  = __sqPickNickname();
    if (initEl)  initEl.value  = '';
    manualInitials = false;
    maybeAutoInitials();
    setSaveEnabled();
  };

  const finish = (msg) => {
    const idx = parseInt(modal.dataset.playerIndex || '0', 10) || 0;
      const metaFinal = meta || meta2;

    // idx>0 => legacy: inject into old #psPlayerFields row (if it exists)
    if (idx > 0) {
      const row =
        document.querySelector(`#psPlayerFields .pf[data-index="${idx}"]`) ||
        document.querySelector(`.pf[data-index="${idx}"]`);
      const input = row?.querySelector('input[data-role="display"]');
      if (input) input.value = chosenName || '';
    }

    modal.classList.add('hidden');
    reset();
    toast(msg);
  };

  // Wire buttons (avoid stacking listeners)
  if (backBtn)  backBtn.onclick  = () => { modal.classList.add('hidden'); reset(); };
  if (closeBtn) closeBtn.onclick = () => { modal.classList.add('hidden'); reset(); };

  if (genBtn && nickEl){
    genBtn.onclick = () => {
      nickEl.value = __sqPickNickname();
    };
  }

  if (initEl){
    initEl.addEventListener('input', () => {
      manualInitials = !!String(initEl.value||'').trim();
      setSaveEnabled();
    }, { passive:true });
  }
  if (firstEl){
    firstEl.addEventListener('input', () => { setSaveEnabled(); maybeAutoInitials(); }, { passive:true });
  }
  if (lastEl){
    lastEl.addEventListener('input', () => { maybeAutoInitials(); }, { passive:true });
  }

  // Open
  modal.dataset.playerIndex = index ? String(index) : '0';
  modal.classList.remove('hidden');
  reset();
  try{ firstEl?.focus(); }catch(_){ }

  // Save
  if (saveBtn) {
    saveBtn.onclick = async () => {
      const first = String(firstEl?.value || '').trim();
      const last  = String(lastEl?.value  || '').trim();
      if (!first){ toast('Enter a first name'); return; }

      const fullName = __sqBuildFullName(first, last);
      const initials = __sqNormalizeInitials(String(initEl?.value || '').trim(), fullName);
      const nickname = String(nickEl?.value || '').trim();

      chosenName = fullName;

      try {
        await cloudCreatePlayer(fullName, { initials, nickname, first_name: first, last_name: last });
        try{ if (typeof window.__homeLivePrinterInjectLine === 'function') window.__homeLivePrinterInjectLine(`ðŸš¨ NEW PLAYER - ${fullName} - Welcome to Shateki Quest ðŸŽ¯`); }catch(_e){}
        await syncSavedPlayersFromCloud();
        try{ populateSavedPlayersSelects(); }catch(_){ }
        try{ if (typeof window.buildStartTicker === 'function') window.buildStartTicker(); }catch(_){ }
        try{ document.dispatchEvent(new Event('sq:savedPlayersUpdated')); }catch(_){ }
      } catch (e) {
        console.error('cloudCreatePlayer failed', e);
        toast('Save failed');
        return;
      }

      finish('Player saved');
    };
  }
}


// Select a saved player for match.
// index==0 => add to Match Setup list.
async function showSelectPlayerDialog(index){
  const select = byId('existingPlayerSelect');
  if (!select) { toast('Select list missing'); return; }
  select.innerHTML = '<option value="">Select a saved player...</option>';

  let any = false;
  let resolvedList = [];

  // Prefer cloud
  try {
    const cloudList = await cloudListPlayers();
    (cloudList || []).forEach(p => {
      if (!p || !p.name) return;
      const opt = document.createElement('option');
      opt.value = (p.id != null && String(p.id).trim()) ? String(p.id).trim() : p.name;
      opt.textContent = __sqPlayerOptionLabel(p) || p.name;
      select.appendChild(opt);

      // keep full record so confirm can resolve id -> profile safely
      resolvedList.push({
        id: (p.id != null ? String(p.id).trim() : null),
        name: String(p.name),
        first_name: (p.first_name != null ? String(p.first_name) : ''),
        last_name: (p.last_name != null ? String(p.last_name) : ''),
        nickname: (p.nickname != null ? String(p.nickname) : ''),
        initials: __sqNormalizeInitials(p.initials, p.name)
      });
    });
    any = !!(cloudList && cloudList.length);
  } catch (err) {
    console.error('cloudListPlayers failed', err);
  }

  // Fallback: local
  if (!any) {
    const local = getSavedPlayers();
    (local || []).forEach(p => {
      if (!p || !p.name) return;
      const opt = document.createElement('option');
      opt.value = (p.id != null && String(p.id).trim()) ? String(p.id).trim() : p.name;
      opt.textContent = __sqPlayerOptionLabel(p) || p.name;
      select.appendChild(opt);

      resolvedList.push({
        id: (p.id != null ? String(p.id).trim() : null),
        name: String(p.name),
        first_name: (p.first_name != null ? String(p.first_name) : ''),
        last_name: (p.last_name != null ? String(p.last_name) : ''),
        nickname: (p.nickname != null ? String(p.nickname) : ''),
        initials: __sqNormalizeInitials(p.initials, p.name)
      });
    });
    any = !!(local && local.length);
  }

  if (!any) { toast('No saved players found'); return; }

  const modal = byId('selectPlayerModal');
  if (!modal) { toast('Select Player modal missing'); return; }
  modal.dataset.playerIndex = String(index || 0);
  modal.classList.remove('hidden');

  let cancelBtn  = byId('cancelSelectPlayerBtn');
  let confirmBtn = byId('confirmSelectPlayerBtn');

  // Strip old listeners (defensive)
  if (cancelBtn) {
    const clone = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(clone, cancelBtn);
    cancelBtn = clone;
  }
  if (confirmBtn) {
    const clone = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(clone, confirmBtn);
    confirmBtn = clone;
  }

  if (cancelBtn) {
    cancelBtn.textContent = 'Cancel';
    cancelBtn.onclick = () => {
      select.value = '';
      modal.classList.add('hidden');
    };
  }

  if (confirmBtn) {
    confirmBtn.textContent = 'Enter';
    confirmBtn.onclick = () => {
      const selVal = String(select.value || '').trim();
      if (!selVal) { toast('Select a saved player'); return; }

      // Resolve selected player (prefer id match, else name match)
      const meta = (resolvedList || []).find(p => p && (String(p.id||'').trim() === selVal || String(p.name||'').trim() === selVal)) || null;
      const resolvedName = meta && meta.name ? String(meta.name).trim() : selVal;
      // Defensive: if we somehow only got an id value, try resolve from cached saved players too
      const meta2 = (!meta && selVal && selVal.includes('-')) ? (getSavedPlayers() || []).find(p => p && String(p.id||'').trim()===selVal) : null;
      const resolvedFinal = meta2 && meta2.name ? String(meta2.name).trim() : resolvedName;

      const idx = parseInt(modal.dataset.playerIndex || '0', 10) || 0;
      const metaFinal = meta || meta2;

      if (idx === 0) {
        // Add to Match Setup list
        __msPlayers.push({
          type: 'registered',
          id: metaFinal && metaFinal.id != null ? metaFinal.id : null,
          name: resolvedFinal,
          first_name: metaFinal && metaFinal.first_name ? metaFinal.first_name : '',
          last_name: metaFinal && metaFinal.last_name ? metaFinal.last_name : '',
          nickname: metaFinal && metaFinal.nickname ? metaFinal.nickname : '',
          initials: metaFinal && metaFinal.initials ? metaFinal.initials : ''
        });
        __msRenderPlayers();
      } else {
        // Legacy injection (if old rows exist)
        const row =
          document.querySelector(`#psPlayerFields .pf[data-index="${idx}"]`) ||
          document.querySelector(`.pf[data-index="${idx}"]`);
        const input = row?.querySelector('input[data-role="display"]');
        if (input) input.value = resolvedFinal;
      }

      select.value = '';
      modal.classList.add('hidden');
      toast('Player selected');
    };
  }
}

// Init
__msRenderPlayers();
__msUpdateStartEnabled();


/*****************
 * BUILDERS
 *****************/
const thead=byId('thead'), tbody=byId('tbody');
const statsThead=byId('statsThead'), statsTbody=byId('statsTbody');
const mstatsThead=byId('mstatsThead'), mstatsTbody=byId('mstatsTbody');
const floatThead=byId('floatThead');

function buildScoreHeader(){ 
  // Main scoreboard header: spacer row used to keep column widths aligned.
  // Match progress (wins) lives in the floating header now.
  thead.innerHTML = '';

  const tr = document.createElement('tr');

  // Left column header above "10s" (leave blank)
  const thRound = document.createElement('th');
  thRound.textContent = '';
  tr.appendChild(thRound);

  // Per-player header cells: blank (width alignment only)
  for (let i = 0; i < state.players.length; i++) {
    const th = document.createElement('th');
    th.className = 'player';
    th.style.color = state.players[i].color;
    th.textContent = '';
    tr.appendChild(th);
  }

  thead.appendChild(tr);
}

function buildScoreBody(){ 
  tbody.innerHTML = ''; 

  for (let r = 0; r < MAX_ROUNDS; r++) {
    const tr = document.createElement('tr'); 

    // Left-hand round label
    const th = document.createElement('th'); 
    th.className = 'round-label';
    th.id = `roundth-${r}`;
    th.textContent = (
      ROUNDS[r].type === 'number'
        ? (ROUNDS[r].target + 's')
        : (ROUNDS[r].type === 'doubles'
            ? "D's"
            : (ROUNDS[r].type === 'triples' ? "T's" : 'Bull'))
    );
    tr.appendChild(th); 

    // Cells: now have main (rolling total) + sub (round total)
    for (let p = 0; p < state.players.length; p++) { 
      const td = document.createElement('td'); 
      td.className = 'center num player'; 
      td.id = `cell-${p}-${r}`;
      td.innerHTML = `
        <div class="cell-wrap">
          <div class="cell-main" id="cell-main-${p}-${r}">â€“</div>
          <div class="cell-sub" id="cell-sub-${p}-${r}"></div>
        </div>
      `;
      tr.appendChild(td);
    } 

    tbody.appendChild(tr);
  } 
}

function buildFloatingHeader(){ 
  floatThead.innerHTML = '';

  // Apply player-count classes for responsive sizing
  try {
    floatHead.classList.remove('players-5','players-6');
    if (state.players.length === 5) floatHead.classList.add('players-5');
    if (state.players.length === 6) floatHead.classList.add('players-6');
  } catch(_) {}

  // A) Target (left) spans B/C rows
  const trNames = document.createElement('tr');

  const thRound = document.createElement('th');
  thRound.id = 'froundlabel';
  thRound.rowSpan = 2;          // B, C rows
  thRound.textContent = '';     // filled by updateUI()
  trNames.appendChild(thRound);

  // B) Player names + match progress
  for (let i = 0; i < state.players.length; i++) { 
    const th = document.createElement('th'); 
    th.className = 'player'; 
    th.style.color = state.players[i].color; 

    const wrap = document.createElement('div'); 
    wrap.className = 'th-wrap'; 

    const wins = document.createElement('div');
    wins.className = 'th-wins';
    wins.id = 'fwins-' + i;
    wins.textContent = '';

    const name = document.createElement('div'); 
    name.className = 'th-name'; 
    name.textContent = __sqHeaderLabelForPlayer(state.players[i]); 

    wrap.append(wins, name);
    th.appendChild(wrap); 
    trNames.appendChild(th);
  }  

  // C) Totals + diff + throw indicator (single row; no separate D row)
  const trTotals = document.createElement('tr');
  for (let i = 0; i < state.players.length; i++) { 
    const th = document.createElement('th'); 
    th.className = 'player';
    th.id = 'fcoltot-' + i; 

    const total = document.createElement('div'); 
    total.className = 'th-total num'; 
    total.id = 'ftotal-' + i; 
    total.textContent = '0'; 

    const diff = document.createElement('div'); 
    diff.className = 'th-diff'; 
    diff.id = 'fdiff-' + i; 
    diff.textContent = '0';
    th.append(total, diff);
trTotals.appendChild(th);
  }  

  floatThead.append(trNames, trTotals);
}


// Darts display (D row)
function dartHeaderSymbol(dart){
  if (!dart) return { text: 'âž¤', cls: 'dart-empty' };

  const k = dart.kind;

  if (k === 'Miss') return { text: 'X', cls: 'dart-miss' };
  if (k === 'S' || k === 'D' || k === 'T') return { text: k, cls: 'dart-' + k.toLowerCase() };
  if (k === 'Double') return { text: 'D', cls: 'dart-d' };
  if (k === 'Triple') return { text: 'T', cls: 'dart-t' };
  if (k === 'Bull') return { text: (dart.bull === 'Outer' ? 'OB' : 'B'), cls: (dart.bull === 'Outer' ? 'dart-ob' : 'dart-b') };

  return { text: '?', cls: 'dart-unk' };
}
function renderDartsHeaderHTML(pIdx){
  const now = Date.now();

  // Expire last-go hold
  if (state.uiLastGo && now >= state.uiLastGo.showUntil) {
    state.uiLastGo = null;
  }

  const isActive = (!state.finished && pIdx === state.currentPlayer);
  const showLast = (!!state.uiLastGo && state.uiLastGo.player === pIdx);

  let darts = [];
  if (isActive) {
    const entry = state.score?.[pIdx]?.[state.currentRound];
    darts = entry?.darts || [];
  } else if (showLast) {
    darts = state.uiLastGo.darts || [];
  }

  let html = '';
  for (let k = 0; k < 3; k++) {
    let d = null;

    if (isActive) {
      // Only show darts already thrown this go (currentDart is the NEXT dart index)
      d = (k < state.currentDart) ? darts[k] : null;
    } else if (showLast) {
      // Show completed go for 1s after 3rd dart
      d = darts[k] || null;
    }

    const sym = dartHeaderSymbol(d);
    html += `<span class="dart-slot ${sym.cls}">${sym.text}</span>`;
  }
  return html;
}

// Shared go indicator (single 3-slot display under TARGET)
function renderSharedGoIndicatorHTML(){
  const now = Date.now();

  // expire any hold
  if (state.uiLastGo && now >= state.uiLastGo.showUntil) {
    state.uiLastGo = null;
  }

  // If the next player has already started throwing, don't keep showing previous go
  if (state.uiLastGo && state.currentPlayer !== state.uiLastGo.player && state.currentDart > 0) {
    state.uiLastGo = null;
  }

  const isHoldingPrev = (!!state.uiLastGo && state.currentPlayer !== state.uiLastGo.player && state.currentDart === 0);

  let darts = [];
  if (isHoldingPrev) {
    darts = state.uiLastGo.darts || [];
  } else {
    const entry = state.score?.[state.currentPlayer]?.[state.currentRound];
    darts = entry?.darts || [];
  }

  let html = '';
  for (let k = 0; k < 3; k++) {
    let d = null;
    if (isHoldingPrev) {
      d = darts[k] || null;           // hold completed go for 1s
    } else {
      d = (k < state.currentDart) ? (darts[k] || null) : null; // show only thrown darts for active player
    }
    const sym = dartHeaderSymbol(d);
    html += `<span class="dart-slot ${sym.cls}">${sym.text}</span>`;
  }
  return html;
}


function formatTop3Inline(list){
  if (!Array.isArray(list) || !list.length) return 'â€”';
  const pick = i => list[i] || 'â€”';
  return `1st ${pick(0)} | 2nd ${pick(1)} | 3rd ${pick(2)}`;
}

/*****************
 * STATS (modal compute)
 *****************/
const METRICS = [
  { key: 'miss',         label: '% Miss',           fmt: v => v + '%' },
  { key: 'single',       label: '% Singles',        fmt: v => v + '%' },
  { key: 'double',       label: '% Doubles',        fmt: v => v + '%' },
  { key: 'treble',       label: '% Trebles',        fmt: v => v + '%' },
  { key: 'bulls',        label: '% Bulls (I+O)',    fmt: v => v + '%' },

  { key: 'sixtyPlus',    label: '60+ Rounds',       fmt: v => String(v) },
  { key: 'hundredPlus',  label: '100+ Rounds',      fmt: v => String(v) },
  { key: 'oneFortyPlus', label: '140+ Rounds',      fmt: v => String(v) },

  { key: 'avg9',         label: 'Avg (last 9)',     fmt: v => v.toFixed(1) },
  { key: 'avgRound',     label: 'Avg (round)',      fmt: v => v.toFixed(1) },
  { key: 'avgGame',      label: 'Avg (throw)',      fmt: v => v.toFixed(1) },
  { key: 'singleStreak', label: 'Single Streak',    fmt: v => String(v) },
  { key: 'roundStreak',  label: 'Round Streak',     fmt: v => String(v) },

  // NEW: top-3 lists
  { key: 'bestNumbers',  label: 'Best Numbers',     fmt: formatTop3Inline },
  { key: 'worstNumbers', label: 'Worst Numbers',    fmt: formatTop3Inline },
];

// What the popups actually render
const DISPLAY_METRICS = [
  { key: 'wins',          label: 'Game Wins',              kind: 'wins' },
  { sep: true },

  { key: 'miss',          label: 'Miss %',                 fmt: v => v + '%' },
  { key: 'single',        label: 'Single %',               fmt: v => v + '%' },
  { key: 'double',        label: 'Double %',               fmt: v => v + '%' },
  { key: 'treble',        label: 'Trebles %',              fmt: v => v + '%' },
  { key: 'bulls',         label: 'Bulls % (I+O)',          fmt: v => v + '%' },
  { sep: true },

  { key: 'sixtyPlus',     label: '60+ Round',              fmt: v => String(v) },
  { key: 'hundredPlus',   label: '100+ Round',             fmt: v => String(v) },
  { key: 'oneFortyPlus',  label: '140+ Round',             fmt: v => String(v) },
  { sep: true },

  { key: 'avgGame',       label: 'Avg Throw',              fmt: v => v.toFixed(1) },
  { key: 'avgRound',      label: 'Avg Round',              fmt: v => v.toFixed(1) },
  { key: 'avg9',          label: 'Avg Last 9',             fmt: v => v.toFixed(1) },
  { sep: true },

  { key: 'singleStreak',  label: 'Single Streak',          fmt: v => String(v) },
  { key: 'roundStreak',   label: 'Round Streak',           fmt: v => String(v) },
  { sep: true },

  // NEW: multi-line rows rendered specially in the popups
  { key: 'bestNumbers',   label: 'Best Numbers',           multi: true },
  { key: 'worstNumbers',  label: 'Worst Numbers',          multi: true },
];

function computeStatsFromBoards(boards, pIdx) {
  // Flatten darts (in order) and collect per-round info
  const dartsFlat = [];
  const perRoundHit = [];          // boolean per round (any scoring dart)
  let rounds60 = 0, rounds100 = 0, rounds140 = 0;
  let completedRounds = 0, completedPoints = 0;

  // Weighted-hit tracking for 10..20 (S=1, D=2, T=3); bulls excluded
  const numAttempts = {};       // total darts aimed at that number
  const numWeightedHits = {};   // sum of weights of successful hits

  function addAttempt(n){ numAttempts[n] = (numAttempts[n] || 0) + 1; }
  function addWeighted(n,w){ numWeightedHits[n] = (numWeightedHits[n] || 0) + w; }

  (boards || []).forEach(board => {
    const playerBoard = board?.[pIdx];
    if (!playerBoard) return;

    for (let r = 0; r < MAX_ROUNDS; r++) {
      const roundDef = ROUNDS[r];
      const entry = playerBoard[r];
      const darts = entry?.darts || [];
      const rt = entry?.roundTotal || 0;

      if (rt > 0) { completedRounds++; completedPoints += rt; }
      if (rt >=  60) rounds60++;
      if (rt >= 100) rounds100++;
      if (rt >= 140) rounds140++;

      let anyHit = false;

      darts.forEach(d => {
        if (!d) return;
        dartsFlat.push({ dart: d, roundDef });
        const points = d.points || 0;
        if (points > 0) anyHit = true;

        // Attempts/weighted hits by number (10..20)
        if (roundDef.type === 'number') {
          const n = roundDef.target;
          if (n >= 10 && n <= 20) {
            addAttempt(n);
            if (points > 0) {
              const w = (d.kind === 'T' || d.kind === 'Triple') ? 3 :
                        (d.kind === 'D' || d.kind === 'Double') ? 2 : 1;
              addWeighted(n, w);
            }
          }
        } else if ((roundDef.type === 'doubles' || roundDef.type === 'triples') && d.sector) {
          const n = d.sector;
          if (n >= 10 && n <= 20) {
            addAttempt(n); // only count when we know the sector
            if (points > 0) addWeighted(n, roundDef.type === 'doubles' ? 2 : 3);
          }
        }
        // Bulls are ignored for best/worst number calc (by design)
      });

      perRoundHit.push(anyHit);
    }
  });

  const n = dartsFlat.length;
  let miss=0, single=0, double=0, treble=0, bulls=0, pts=0;
  let curHitStreak=0, bestHitStreak=0;

  dartsFlat.forEach(({ dart }) => {
    const p = dart.points || 0;
    pts += p;
    if (p > 0) { curHitStreak++; bestHitStreak = Math.max(bestHitStreak, curHitStreak); }
    else curHitStreak = 0;

    if (dart.kind === 'Miss') miss++;
    else if (dart.kind === 'Bull') bulls++;
    else if (dart.kind === 'S' || dart.kind === 'Single') single++;
    else if (dart.kind === 'D' || dart.kind === 'Double') double++;
    else if (dart.kind === 'T' || dart.kind === 'Triple') treble++;
  });

  const pct = v => n ? Math.round((v / n) * 100) : 0;

  // Avg of last 9 throws
  const last9 = dartsFlat.slice(-9);
  const sum9  = last9.reduce((a, x) => a + (x.dart.points || 0), 0);
  const avg9  = last9.length ? (sum9 / last9.length) : 0;

  const avgGame  = n ? (pts / n) : 0;
  const avgRound = completedRounds ? (completedPoints / completedRounds) : 0;

  // Round streak (consecutive rounds with any score)
  let curR = 0, bestR = 0;
  perRoundHit.forEach(hit => {
    if (hit) { curR++; bestR = Math.max(bestR, curR); } else curR = 0;
  });

  // Best / Worst numbers by weighted hit % (10..20 only)
  const scored = [];
  for (let num = 10; num <= 20; num++) {
    const att = numAttempts[num] || 0;
    if (!att) continue;
    const p = (numWeightedHits[num] || 0) / (3 * att); // 0..1
    scored.push({ num, pct: p });
  }
  scored.sort((a, b) => b.pct - a.pct);
  const best3  = scored.slice(0, 3).map(x => `${x.num} (${Math.round(x.pct * 100)}%)`);
  const worst3 = scored.slice(-3).reverse().map(x => `${x.num} (${Math.round(x.pct * 100)}%)`);

  return {
    miss: pct(miss),
    single: pct(single),
    double: pct(double),
    treble: pct(treble),
    bulls: pct(bulls),

    sixtyPlus:    rounds60,
    hundredPlus:  rounds100,
    oneFortyPlus: rounds140,

    avg9,
    avgRound,
    avgGame,

    singleStreak: bestHitStreak,
    roundStreak:  bestR,

    // top-3 lists + backward-compat single value
    bestNumber:   best3[0] || 'â€”',
    worstNumber:  worst3[0] || 'â€”',
    bestNumbers:  best3,
    worstNumbers: worst3,

    totalThrows:  n,
    totalHits:    n - miss,
    totalMisses:  miss
  };
}


// Per-game stats (current board only)
function computeStatsForPlayerGame(pIdx) {
  return computeStatsFromBoards([state.score], pIdx);
}

// Per-match stats (all finished games + current game)
function computeStatsForPlayerMatch(pIdx) {
  const boards = [];

  if (state.match && Array.isArray(state.match.history)) {
    state.match.history.forEach(g => {
      if (g && Array.isArray(g.board)) boards.push(g.board);
    });
  }

  if (state.score && state.score[pIdx]) {
    boards.push(state.score);
  }

  if (!boards.length) {
    return computeStatsFromBoards([], pIdx);
  }
  return computeStatsFromBoards(boards, pIdx);
}
function buildStatsHeader(){ 
  statsThead.innerHTML = '';
  const tr = document.createElement('tr');

  const thLabel = document.createElement('th');
  thLabel.textContent = 'Game Stats';
  tr.appendChild(thLabel);

  // one column per player (we keep header blank â€“ names are in the popup)
  for (let i = 0; i < state.players.length; i++) {
    const th = document.createElement('th');
    th.className = 'player';
    tr.appendChild(th);
  }

  statsThead.appendChild(tr);
}

function buildStatsBody(){ 
  statsTbody.innerHTML = '';

  METRICS.forEach(m => {
    const tr = document.createElement('tr');

    const th = document.createElement('th');
    th.className = 'stats-th';
    th.textContent = m.label;
    tr.appendChild(th);

    for (let p = 0; p < state.players.length; p++) {
      const td = document.createElement('td');
      td.className = 'center num player';
      td.id = `stat-${m.key}-${p}`;    // used by updateStatsRows()
      td.textContent = 'â€”';
      tr.appendChild(td);
    }

    statsTbody.appendChild(tr);
  });
}

function buildMatchStatsHeader(){ 
  mstatsThead.innerHTML = '';
  const tr = document.createElement('tr');

  const thLabel = document.createElement('th');
  thLabel.textContent = 'Match Stats';
  tr.appendChild(thLabel);

  for (let i = 0; i < state.players.length; i++) {
    const th = document.createElement('th');
    th.className = 'player';
    tr.appendChild(th);
  }

  mstatsThead.appendChild(tr);
}

function buildMatchStatsBody(){ 
  mstatsTbody.innerHTML = '';

  METRICS.forEach(m => {
    const tr = document.createElement('tr');

    const th = document.createElement('th');
    th.className = 'stats-th';
    th.textContent = m.label;
    tr.appendChild(th);

    for (let p = 0; p < state.players.length; p++) {
      const td = document.createElement('td');
      td.className = 'center num player';
      td.id = `mstat-${m.key}-${p}`;   // used by updateMatchStats()
      td.textContent = 'â€”';
      tr.appendChild(td);
    }

    mstatsTbody.appendChild(tr);
  });
}

// Fill the hidden match-stats table so widths stay in sync and data is there if needed
function updateMatchStats(){ 
  for (let i = 0; i < state.players.length; i++) {
    const v = computeStatsForPlayerMatch(i);
    for (const m of METRICS) {
      const td = byId(`mstat-${m.key}-${i}`);
      if (td) td.textContent = m.fmt(v[m.key]);
    }
  }
}

// Keep the score table focused on the most recent rounds (show 4 rows: current + previous 3)
function autoScrollScoreboard(){
  const scoreWrap = document.getElementById('scoreWrap');
  const tbodyEl = document.getElementById('tbody');
  if (!tbodyEl) return;

  // Decide which element actually scrolls:
  // - If scoreWrap is internally scrollable (overflow-y auto/scroll), use it.
  // - Otherwise (classic mode), the page scroller is ".wrap".
  let scroller = null;
  try{
    const oy = scoreWrap ? getComputedStyle(scoreWrap).overflowY : '';
    const internalScrollable = !!(scoreWrap && (oy === 'auto' || oy === 'scroll') && scoreWrap.scrollHeight > scoreWrap.clientHeight + 2);
    scroller = internalScrollable ? scoreWrap : (document.querySelector('body[data-page="game"] .wrap') || document.querySelector('.wrap'));
  }catch(_){
    scroller = document.querySelector('body[data-page="game"] .wrap') || document.querySelector('.wrap') || scoreWrap;
  }
  if (!scroller) return;

  // Measure the fixed throw pad height (so the last round never hides behind it)
  let padH = 0;
  try{
    const padEl = document.getElementById('pad');
    if (padEl){
      padH = Math.max(0, Math.round(padEl.getBoundingClientRect().height || 0));
    }
  }catch(_){}

  // Ensure the scroller has enough bottom space to scroll the last row above the pad.
  // (Safari especially needs explicit padding on the real scrolling element.)
  try{
    const extra = 18;
    const want = Math.max(0, padH + extra);
    const cur = parseInt((scroller.style.paddingBottom || '0').replace('px',''), 10) || 0;
    if (want > cur) scroller.style.paddingBottom = want + 'px';
  }catch(_){}

  // Allow user scroll without snapping back (1500ms guard)
  try{
    if (!scroller.__sqScrollGuard) {
      scroller.__sqScrollGuard = true;
      scroller.addEventListener('scroll', () => {
        scroller.__sqUserScrollUntil = Date.now() + 1500;
      }, { passive: true });
    }
    if (scroller.__sqUserScrollUntil && Date.now() < scroller.__sqUserScrollUntil) return;
  }catch(_){ }

  const rows = tbodyEl.rows;
  if (!rows || !rows.length) return;

  const endIdx = Math.min(state.currentRound, rows.length - 1);
  if (endIdx < 0) return;

  // Keep previous 3 rounds + current round visible.
  if (endIdx < 3) return;
  const startIdx = Math.max(0, endIdx - 3);
  const targetRow = rows[startIdx];
  const endRow = rows[endIdx];
  if (!targetRow || !endRow) return;

  // Compute desired scrollTop inside chosen scroller (anchor to startIdx row)
  let desiredTop = 0;
  try{
    const rowRect = targetRow.getBoundingClientRect();
    const scRect  = scroller.getBoundingClientRect();
    desiredTop = (rowRect.top - scRect.top) + scroller.scrollTop;
    desiredTop = Math.max(0, Math.min(desiredTop, scroller.scrollHeight - scroller.clientHeight));
  }catch(_){
    // Fallback for older browsers: use offsetTop when possible
    desiredTop = Math.max(0, Math.min(targetRow.offsetTop, scroller.scrollHeight - scroller.clientHeight));
  }

  // If the current round is still clipped by the throw pad at the bottom, nudge down.
  try{
    const endRect = endRow.getBoundingClientRect();
    const scRect  = scroller.getBoundingClientRect();
    const bottomLimit = scRect.bottom - Math.max(0, padH) - 10; // 10px breathing room
    if (endRect.bottom > bottomLimit){
      desiredTop += (endRect.bottom - bottomLimit);
      desiredTop = Math.max(0, Math.min(desiredTop, scroller.scrollHeight - scroller.clientHeight));
    }
  }catch(_){}

  if (Math.abs((scroller.scrollTop || 0) - desiredTop) > 2) {
    try{
      scroller.scrollTo({ top: desiredTop, behavior: 'smooth' });
    }catch(_){
      scroller.scrollTop = desiredTop;
    }
  }
}
/*****************
 * UI UPDATE
 *****************/
function buildPad(){ 
  if (!pad) return; 
  pad.innerHTML = ''; 

  const page = document.body.getAttribute('data-page');

  // Leaderboard: no throw pad content
  if (page === 'leaderboard') {
    padHint.textContent = '';
    return;
  }

  // Other non-game pages: no pad
  if (page !== 'game') {
    padHint.textContent = '';
    return;
  }

  // Game page
  padHint.textContent = state.finished ? 'Game finished.' : '';

  if (!state.finished) {
    const r = ROUNDS[state.currentRound];
    if (!r) return;

    // ----- NUMBER ROUNDS (10â€“20) -----
    if (r.type === 'number') {
      const topRow = document.createElement('div');
      topRow.style.display = 'flex';
      topRow.style.gap = '8px';
      topRow.style.width = '100%';

      ['S','D','T'].forEach(k => {
  const b = document.createElement('button');
  b.className = 'btn primary letter-throw';
  b.textContent = k;
        b.style.flex = '1 1 0';
        b.style.minWidth = '0';
        b.onclick = () => recordThrow({ kind: k });
        topRow.appendChild(b);
      });

      pad.appendChild(topRow);

      const bottomRow = document.createElement('div');
bottomRow.style.display = 'flex';
bottomRow.style.gap = '8px';
bottomRow.style.width = '100%';

const miss = document.createElement('button');
miss.className = 'btn danger letter-throw';
miss.textContent = 'Miss';
miss.style.flex = '1 1 0';
miss.style.minWidth = '0';
miss.onclick = () => recordThrow({ kind: 'Miss' });
bottomRow.appendChild(miss);

const undoBtn = document.createElement('button');
undoBtn.className = 'btn warn letter-throw';
undoBtn.textContent = 'Undo';
undoBtn.style.flex = '1 1 0';
undoBtn.style.minWidth = '0';
undoBtn.onclick = undo;
bottomRow.appendChild(undoBtn);

const missGoBtn = document.createElement('button');
missGoBtn.className = 'btn letter-throw';
missGoBtn.textContent = 'Skip Go';
missGoBtn.style.flex = '1 1 0';
missGoBtn.style.minWidth = '0';
missGoBtn.onclick = missGo;
bottomRow.appendChild(missGoBtn);

      pad.appendChild(bottomRow);
      return;
    }

            // ----- DOUBLES / TRIPLES ROUNDS -----
    if (r.type === 'doubles' || r.type === 'triples') {
      padHint.textContent = "";

      const dtWrap = document.createElement('div');
      dtWrap.className = 'dtPadWrap';
      dtWrap.style.width = '100%';
      dtWrap.style.boxSizing = 'border-box';
      dtWrap.style.display = 'grid';
      dtWrap.style.gridTemplateColumns = 'clamp(96px, 18vw, 132px) minmax(0,1fr)';
      dtWrap.style.gap = '8px';
      dtWrap.style.alignItems = 'stretch';
      dtWrap.style.justifyItems = 'stretch';

      // Force D/T pad to use the full width of the scorepad (mirror number-round flex rows)
      try{
        const w = pad && pad.getBoundingClientRect ? pad.getBoundingClientRect().width : 0;
        if (w && Number.isFinite(w)) {
          dtWrap.style.width = w + 'px';
          dtWrap.style.maxWidth = 'none';
          dtWrap.style.marginLeft = '0';
          dtWrap.style.marginRight = '0';
          dtWrap.style.alignSelf = 'stretch';
          dtWrap.style.justifySelf = 'stretch';
        }
      }catch(_){}

      const x3 = document.createElement('button');
      x3.className = 'dtX3';
      x3.type = 'button';

      function missCountForCurrentThrow(){
        try{
          const dart = (typeof state !== 'undefined' && state && typeof state.currentDart === 'number') ? state.currentDart : 0;
          const remaining = 3 - dart;
          return Math.max(1, Math.min(3, remaining));
        }catch(_){
          return 3;
        }
      }
      function setX3Label(){
        const n = missCountForCurrentThrow();
        x3.textContent = `MISS\nx${n}`;
        x3.dataset.missN = String(n);
      }
      async function pressMissN(n){
        for (let i=0;i<n;i++){
          recordThrow({ kind: 'Miss' });
          // eslint-disable-next-line no-await-in-loop
          await new Promise(r=>setTimeout(r,70));
        }
      }
      x3.onclick = ()=>{ const n = Number(x3.dataset.missN||'3')||3; pressMissN(n); };
      setX3Label();

      const right = document.createElement('div');
      right.className = 'dtRight';
      right.style.width = '100%';

      const scroller = document.createElement('div');
      scroller.className = 'dtScroller';
      scroller.style.width = '100%';
      scroller.style.display = 'flex';
      scroller.style.gap = '8px';
      scroller.style.overflowX = 'auto';
      scroller.style.overflowY = 'hidden';
      scroller.style.WebkitOverflowScrolling = 'touch';
      scroller.style.scrollSnapType = 'x mandatory';
      scroller.style.paddingBottom = '2px';

      for (let s = 1; s <= 20; s++) {
        const b = document.createElement('button');
        b.className = 'dtNumBtn';
        b.textContent = String(s);
        // 6 visible at once (account for 5 gaps of 8px)
        b.style.flex = '0 0 calc((100% - 40px) / 6)';
        b.style.scrollSnapAlign = 'start';
        b.onclick = () => recordThrow({ sector: s });
        scroller.appendChild(b);
      }

      const actions = document.createElement('div');
      actions.className = 'dtActions';
      actions.style.width = '100%';

      const mkAct = (cls, icon, label, onClick) => {
        const b = document.createElement('button');
        b.className = `dtActBtn ${cls}`;
        b.type = 'button';
        b.innerHTML = `<div class="dtIcon">${icon}</div><div class="dtLbl">${label}</div>`;
        b.onclick = onClick;
        return b;
      };

      actions.appendChild(mkAct('miss', 'âŠ˜', 'MISS', () => recordThrow({ kind: 'Miss' })));
      actions.appendChild(mkAct('undo', 'â†¶', 'UNDO', undo));
      actions.appendChild(mkAct('skip', 'â–¶', 'SKIP', missGo));

      right.appendChild(scroller);
      right.appendChild(actions);

      dtWrap.appendChild(x3);
      dtWrap.appendChild(right);
      pad.appendChild(dtWrap);

      // Keep x3 label in sync as darts progress
      try { window.__sqUIMutationBus?.on(()=>setX3Label()); } catch(_) {}
      return;
    }

// ----- BULL ROUND -----
    if (r.type === 'bull') {
      padHint.textContent = '';

      const bWrap = document.createElement('div');
      bWrap.className = 'dtPadWrap';
      bWrap.style.width = '100%';
      bWrap.style.boxSizing = 'border-box';
      bWrap.style.display = 'grid';
      bWrap.style.gridTemplateColumns = 'clamp(96px, 18vw, 132px) minmax(0,1fr)';
      bWrap.style.gap = '8px';
      bWrap.style.alignItems = 'stretch';
      bWrap.style.justifyItems = 'stretch';

      // Force Bull pad to use the full width of the scorepad (mirror number-round flex rows)
      try{
        const w = pad && pad.getBoundingClientRect ? pad.getBoundingClientRect().width : 0;
        if (w && Number.isFinite(w)) {
          bWrap.style.width = w + 'px';
          bWrap.style.maxWidth = 'none';
          bWrap.style.marginLeft = '0';
          bWrap.style.marginRight = '0';
          bWrap.style.alignSelf = 'stretch';
          bWrap.style.justifySelf = 'stretch';
        }
      }catch(_){}

      const x3 = document.createElement('button');
      x3.className = 'dtX3';
      x3.type = 'button';

      function missCountForCurrentThrow(){
        try{
          const dart = (typeof state !== 'undefined' && state && typeof state.currentDart === 'number') ? state.currentDart : 0;
          const remaining = 3 - dart;
          return Math.max(1, Math.min(3, remaining));
        }catch(_){
          return 3;
        }
      }
      function setX3Label(){
        const n = missCountForCurrentThrow();
        x3.textContent = `MISS\nx${n}`;
        x3.dataset.missN = String(n);
      }
      async function pressMissN(n){
        for (let i=0;i<n;i++){
          recordThrow({ kind: 'Miss' });
          // eslint-disable-next-line no-await-in-loop
          await new Promise(r=>setTimeout(r,70));
        }
      }
      x3.onclick = ()=>{ const n = Number(x3.dataset.missN||'3')||3; pressMissN(n); };
      setX3Label();

      const right = document.createElement('div');
      right.className = 'dtRight';
      right.style.width = '100%';

      const bullRow = document.createElement('div');
      bullRow.className = 'dtBullRow';
      bullRow.style.width = '100%';

      const outerBtn = document.createElement('button');
      outerBtn.className = 'dtBullBtn';
      outerBtn.type = 'button';
      outerBtn.textContent = 'OUTER BULL';
      outerBtn.onclick = () => recordThrow({ bull: 'Outer' });
      bullRow.appendChild(outerBtn);

      const innerBtn = document.createElement('button');
      innerBtn.className = 'dtBullBtn inner';
      innerBtn.type = 'button';
      innerBtn.textContent = 'INNER BULL';
      innerBtn.onclick = () => recordThrow({ bull: 'Inner' });
      bullRow.appendChild(innerBtn);

      const actions = document.createElement('div');
      actions.className = 'dtActions';
      actions.style.width = '100%';

      const mkAct = (cls, icon, label, onClick) => {
        const b = document.createElement('button');
        b.className = `dtActBtn ${cls}`;
        b.type = 'button';
        b.innerHTML = `<div class="dtIcon">${icon}</div><div class="dtLbl">${label}</div>`;
        b.onclick = onClick;
        return b;
      };

      actions.appendChild(mkAct('miss', 'âŠ˜', 'MISS', () => recordThrow({ kind: 'Miss' })));
      actions.appendChild(mkAct('undo', 'â†¶', 'UNDO', undo));
      actions.appendChild(mkAct('skip', 'â–¶', 'SKIP', missGo));

      right.appendChild(bullRow);
      right.appendChild(actions);

      bWrap.appendChild(x3);
      bWrap.appendChild(right);
      pad.appendChild(bWrap);

      try { window.__sqUIMutationBus?.on(()=>setX3Label()); } catch(_) {}
      return;
    }
  }

// Finished game: show button to go to leaderboard
  const finishBtn = document.createElement('button');
  finishBtn.className = 'btn good';
  finishBtn.style.minWidth = '220px';
  finishBtn.textContent = 'Finish Game â†’ Leaderboard';
  finishBtn.onclick = async () => {
    state.finished = false;
    await awardAndShowLeaderboard();
  };
  pad.appendChild(finishBtn);
}

/*****************
 * DIALOGS (Stats / Race / High Scores)
 *****************/

function openStatsHubDialog(){
  try{ if (typeof __sqSetStatsOrigin==='function') __sqSetStatsOrigin('ingame'); }catch(_){ }
  try{ console.debug('[Popup]', window.__sqStatsDebugName || 'In Game Player Stats'); }catch(_){ }
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth='520px';
  modal.style.width='94vw';

  const header = (typeof __sqStatsHeader==='function')
    ? __sqStatsHeader('Player Stats', 'Choose a stats view')
    : (()=>{ const h=document.createElement('h3'); h.textContent='Player Stats'; return h; })();

  const body = document.createElement('div');
  body.className = 'modal-body';
  body.style.display='flex';
  body.style.flexDirection='column';
  body.style.alignItems='center';
  body.style.gap='12px';
  body.style.paddingTop='10px';

  const mk = (label, cls, fn) => {
    const b = document.createElement('button');
    b.type='button';
    b.className = `sq-navBtn ${cls||''}`.trim();
    b.textContent = label;
    b.onclick = () => { overlay.remove(); fn(); };
    return b;
  };

  // Keep existing actions; just re-skin.
  body.appendChild(mk('GAME RACE', 'navOrange', openGameRaceDialog));
  body.appendChild(mk('GAME STATS', 'navBlue', openGameStatsDialog));
  body.appendChild(mk('MATCH STATS', 'navBlue', openMatchStatsDialog));
  body.appendChild(mk('HIGH SCORES (Official)', 'navGreen', openHighScoresDialog));
  body.appendChild(mk('LOW SCORES (Official)', 'navGreen', openLowScoresDialog));

  const footer = document.createElement('div');
  footer.className = 'modal-footer';
  footer.style.justifyContent='flex-start';
  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn sq-pill';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();
  footer.appendChild(closeBtn);

  modal.append(header, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}

function openGameStatsDialog(){
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Game Stats';

  const body = document.createElement('div');
  body.className = 'modal-body';

  const table = document.createElement('table');
  table.className = 'hs-table';

  const thead = document.createElement('thead');
  const trh   = document.createElement('tr');

  const metricTh = document.createElement('th');
  metricTh.textContent = 'Metric';
  trh.appendChild(metricTh);

  state.players.forEach(p => {
    const th = document.createElement('th');
    th.textContent = p.name;
    th.style.textAlign = 'center';
    trh.appendChild(th);
  });

  thead.appendChild(trh);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  const statsByPlayer = state.players.map((_, i) => computeStatsForPlayerGame(i));
  const winsArr = (state.match?.wins || []).slice();

  DISPLAY_METRICS.forEach(m => {
    if (m.sep) {
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 1 + state.players.length;
      td.textContent = '';
      tr.appendChild(td);
      tbody.appendChild(tr);
      return;
    }

    // Collect raw numeric values (for highlighting)
    const rowNumeric = state.players.map((_, idx) => {
      if (m.kind === 'wins') return winsArr[idx] || 0;
      const v = statsByPlayer[idx][m.key];
      return (typeof v === 'number') ? v : Number.isFinite(Number(v)) ? Number(v) : -Infinity;
    });
    const maxVal = Math.max(...rowNumeric);

    const tr = document.createElement('tr');
    const th = document.createElement('th');
    th.className = 'stats-th';
    th.textContent = m.label;
    tr.appendChild(th);

    state.players.forEach((_, idx) => {
      const td = document.createElement('td');
      td.className = 'center num';

      if (m.multi) {
        const list = statsByPlayer[idx][m.key] || [];
        td.innerHTML = `
          <div>1st ${list[0] || 'â€”'}</div>
          <div>2nd ${list[1] || 'â€”'}</div>
          <div>3rd ${list[2] || 'â€”'}</div>
        `;
      } else {
        let val;
        if (m.kind === 'wins') {
          val = winsArr[idx] || 0;
        } else {
          const v = statsByPlayer[idx][m.key];
          val = m.fmt ? m.fmt(v) : String(v);
        }
        td.textContent = val;
      }

      // Highlight highest numeric value(s) in the row
      const raw = (m.kind === 'wins') ? (winsArr[idx] || 0) : rowNumeric[idx];
      if (!m.multi && raw === maxVal && maxVal !== -Infinity) {
        td.style.color = 'var(--accent-2)';
        td.style.fontWeight = '800';
      }

      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  });

  table.appendChild(tbody);
  body.appendChild(table);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = () => {
    overlay.remove();
    openStatsHubDialog();
  };

  footer.appendChild(backBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0; modal.focus();

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}

function openMatchStatsDialog(){
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Match Stats';

  const body = document.createElement('div');
  body.className = 'modal-body';

  const table = document.createElement('table');
  table.className = 'hs-table';

  const thead = document.createElement('thead');
  const trh   = document.createElement('tr');

  const metricTh = document.createElement('th');
  metricTh.textContent = 'Metric';
  trh.appendChild(metricTh);

  state.players.forEach(p => {
    const th = document.createElement('th');
    th.textContent = p.name;
    th.style.textAlign = 'center';
    trh.appendChild(th);
  });

  thead.appendChild(trh);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  const vByP  = state.players.map((_, i) => computeStatsForPlayerMatch(i));
  const winsArr = (state.match?.wins || []).slice();

  DISPLAY_METRICS.forEach(m => {
    if (m.sep) {
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 1 + state.players.length;
      td.textContent = '';
      tr.appendChild(td);
      tbody.appendChild(tr);
      return;
    }

    // Gather raw numeric values for leader highlight
    const rowNumeric = state.players.map((_, idx) => {
      if (m.kind === 'wins') return winsArr[idx] || 0;
      const v = vByP[idx][m.key];
      return (typeof v === 'number') ? v : Number.isFinite(Number(v)) ? Number(v) : -Infinity;
    });
    const maxVal = Math.max(...rowNumeric);

    const tr = document.createElement('tr');

    const th = document.createElement('th');
    th.textContent = m.label;
    th.className   = 'stats-th';
    tr.appendChild(th);

    state.players.forEach((_, idx) => {
      const td = document.createElement('td');
      td.className = 'center num';

      if (m.multi) {
        const list = vByP[idx][m.key] || [];
        td.innerHTML = `
          <div>1st ${list[0] || 'â€”'}</div>
          <div>2nd ${list[1] || 'â€”'}</div>
          <div>3rd ${list[2] || 'â€”'}</div>
        `;
      } else {
        let val;
        if (m.kind === 'wins') {
          val = winsArr[idx] || 0;
        } else {
          const v = vByP[idx][m.key];
          val = m.fmt ? m.fmt(v) : String(v);
        }
        td.textContent = val;
      }

      // Leader highlight
      const raw = (m.kind === 'wins') ? (winsArr[idx] || 0) : rowNumeric[idx];
      if (!m.multi && raw === maxVal && maxVal !== -Infinity) {
        td.style.color = 'var(--accent-2)';
        td.style.fontWeight = '800';
      }

      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  });

  table.appendChild(tbody);
  body.appendChild(table);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = () => overlay.remove();
  footer.appendChild(backBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}
function openHighScoresMenuDialog() {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'High Scores';

  const body = document.createElement('div');
  body.className = 'modal-body';
  body.style.display = 'flex';
  body.style.flexDirection = 'column';
  body.style.alignItems = 'center';
  body.style.gap = '8px';

  const W = 'min(420px, 92vw)';
  const mkBtn = (label, extraClass, onClick) => {
    const b = document.createElement('button');
    b.className = `btn big ${extraClass || ''}`.trim();
    b.textContent = label;
    b.style.width = W;
    b.onclick = () => { overlay.remove(); onClick(); };
    return b;
  };

  body.appendChild(mkBtn('Official (League)', 'primary', openHighScoresDialog));
  body.appendChild(mkBtn('Practice (Single)', '',        openHighScoresDialogSP));
  body.appendChild(mkBtn('Lowest (League)',  'warn',     openLowScoresDialog));
  
  // Practice (Single) High Scores dialog
function openHighScoresDialogSP(){ 
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal';
  const title   = document.createElement('h3');  title.textContent = 'High Scores (Practice)';
  const body    = document.createElement('div'); body.className    = 'modal-body';

  let period = 'all';

  async function render(){
    body.innerHTML = '';
    try{
      const since = periodStartIso(period);
      const list  = await cloudListHighScores(true, 20, since);

      if (!list.length){
        const p = document.createElement('p');
        p.textContent = 'No high scores in this period.';
        body.appendChild(p);
        return;
      }

      const table = document.createElement('table'); table.className='hs-table';
      const thead = document.createElement('thead'); const trh=document.createElement('tr');
      ['#','Player','Score','Avg / Round','When'].forEach(h=>{
        const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);
      });
      thead.appendChild(trh); table.appendChild(thead);

      const tb = document.createElement('tbody');
      list.forEach((row, idx) => {
        const tr = document.createElement('tr');

        const td1 = document.createElement('td'); td1.textContent = String(idx + 1);
        const td2 = document.createElement('td'); td2.textContent = row.name;
        const td3 = document.createElement('td'); td3.textContent = String(row.score);

        const td4 = document.createElement('td');
        const avgRound = (typeof MAX_ROUNDS === 'number' && MAX_ROUNDS > 0)
          ? (Number(row.score || 0) / MAX_ROUNDS) : 0;
        td4.textContent = avgRound.toFixed(1);

        const td5 = document.createElement('td');
        const d = new Date(row.ts);
        td5.textContent = !Number.isNaN(d.getTime())
          ? d.toLocaleString(undefined, {
              year:'2-digit', month:'short', day:'2-digit',
              hour:'2-digit', minute:'2-digit'
            })
          : '';
        td5.style.fontSize = '0.8rem';

        tr.append(td1, td2, td3, td4, td5);

        // click â†’ score sheet (PRACTICE)
        tr.style.cursor = 'pointer';
        tr.title = 'Open score sheet';
        tr.onclick = () => openScoreSheetFromHighScore(row, /* isPractice */ true);

        tb.appendChild(tr);
      });

      table.appendChild(tb);
      body.appendChild(table);
    }catch(err){
      console.error(err);
      const p=document.createElement('p');
      p.textContent='Failed to load high scores.';
      body.appendChild(p);
    }
  }

  const footer = document.createElement('div'); footer.className='modal-footer';
  const backBtn=document.createElement('button'); backBtn.className='btn sq-pill'; backBtn.textContent='Back';
  backBtn.onclick = () => overlay.remove();
  footer.appendChild(backBtn);

  const periods = [
    { key:'today', label:'Today' },
    { key:'week',  label:'1 Week' },
    { key:'month', label:'1 Month' },
    { key:'all',   label:'All Time' },
  ];

  const periodBtns = periods.map(p=>{
    const b = document.createElement('button');
    b.className='btn';
    b.textContent = p.label;
    b.dataset.period = p.key;
    b.onclick = async () => { period = p.key; setActive(); await render(); };
    footer.appendChild(b);
    return b;
  });

  function setActive(){
    periodBtns.forEach(b=>{
      if (b.dataset.period === period) b.classList.add('primary');
      else b.classList.remove('primary');
    });
  }

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0; modal.focus();
  overlay.addEventListener('click', e=>{ if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if (e.key === 'Escape') overlay.remove(); });

  setActive();
  render();
}

  const footer = document.createElement('div');
  footer.className = 'modal-footer';
  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn sq-pill';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();
  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0; modal.focus();
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}
// List all games for a specific player, filtered by optional period
async function cloudListPlayerGames(playerName, sinceIso = null, limit = 200) {
  let q = sb.from(TABLE_PLAYER_GAMES)
    .select('sheet_id, player, score, position, ts, is_practice, rounds')
    .eq('player', playerName)
    .order('ts', { ascending: false })
    .limit(limit);

  if (sinceIso) q = q.gte('ts', sinceIso);

  const { data, error } = await q;
  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
  return data || [];
}

// Single, top-level definition only
async function openPlayerGamesDialog(playerName) {
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal';
  const title   = document.createElement('h3');  title.textContent = `Games â€“ ${playerName}`;
  const body    = document.createElement('div'); body.className    = 'modal-body';

  let period = 'all';

  async function render(){
    body.innerHTML = '';
    try {
      const since = periodStartIso(period);
      const rows  = await cloudListPlayerGames(playerName, since);

      if (!rows.length){
        const p = document.createElement('p');
        p.textContent = 'No games in this period.';
        body.appendChild(p);
        return;
      }

      const table = document.createElement('table'); table.className='hs-table';
      const thead = document.createElement('thead'); const trh = document.createElement('tr');
      ['#','Pos','Score','Avg / Round','Date'].forEach(h=>{
        const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);
      });
      thead.appendChild(trh); table.appendChild(thead);

      const tb = document.createElement('tbody');
      rows.forEach((row, idx) => {
        const tr = document.createElement('tr');
        if (row.is_practice) tr.classList.add('row-practice');

        const tdIdx   = document.createElement('td'); tdIdx.textContent   = String(idx + 1);
        const tdPos   = document.createElement('td'); tdPos.textContent   = row.position ?? '';
        const tdScore = document.createElement('td'); tdScore.textContent = String(row.score ?? '');

        const rounds = Number(row.rounds || MAX_ROUNDS || 0);
        const avg    = rounds ? (Number(row.score || 0) / rounds) : 0;
        const tdAvg  = document.createElement('td'); tdAvg.textContent = avg.toFixed(1);

        const d = new Date(row.ts);
        const tdWhen = document.createElement('td');
        tdWhen.textContent = Number.isNaN(d.getTime()) ? '' : fmtDdMmYyAtTime(d);
        tdWhen.style.fontSize = '0.8rem';

        tr.append(tdIdx, tdPos, tdScore, tdAvg, tdWhen);

        // Open the scorecard
        tr.style.cursor = 'pointer';
        tr.title = 'Open scorecard';
        tr.onclick = () => openScoreSheetFromHighScore({ sheet_id: row.sheet_id }, !!row.is_practice);

        tb.appendChild(tr);
      });

      table.appendChild(tb);
      body.appendChild(table);
    } catch (err){
      console.error(err);
      const p = document.createElement('p');
      p.textContent = 'Failed to load games.';
      body.appendChild(p);
    }
  }

  const footer = document.createElement('div'); footer.className = 'modal-footer';
  const backBtn = document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  backBtn.onclick = () => overlay.remove();
  footer.appendChild(backBtn);

  const periods = [
    { key:'today', label:'Today' },
    { key:'week',  label:'1 Week' },
    { key:'month', label:'1 Month' },
    { key:'all',   label:'All Time' },
  ];
  const periodBtns = periods.map(p => {
    const b = document.createElement('button');
    b.className = 'btn';
    b.textContent = p.label;
    b.dataset.period = p.key;
    b.onclick = async () => { period = p.key; setActive(); await render(); };
    footer.appendChild(b);
    return b;
  });
  function setActive(){
    periodBtns.forEach(b => {
      if (b.dataset.period === period) b.classList.add('primary');
      else b.classList.remove('primary');
    });
  }

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0; modal.focus();
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });

  setActive();
  await render();
}

async function openHighScoresDialog(){ 
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal';
  const title   = document.createElement('h3');  title.textContent = 'High Scores (Official)';
  const body    = document.createElement('div'); body.className    = 'modal-body';

  let period = 'all';

  async function render(){
    body.innerHTML = '';
    try {
      // Compute lower-bound timestamp for this period.
      // For "yesterday" we still query since the start of yesterday, but we then
      // filter rows client-side to keep only that calendar day.
      let since;
      if (period === 'yesterday') {
        const today  = new Date();
        const startY = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 1);
        since = startY.toISOString();
      } else {
        since = periodStartIso(period);
      }

      let list = await cloudListHighScores(false, 20, since);

      // If "Yesterday", filter to scores from that day only (local time)
      if (period === 'yesterday') {
        const today   = new Date();
        const startY  = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 1);
        const endY    = new Date(today.getFullYear(), today.getMonth(), today.getDate());
        list = (list || []).filter(row => {
          const d = new Date(row.ts);
          if (Number.isNaN(d.getTime())) return false;
          return d >= startY && d < endY;
        });
      }

      if (!list.length){
        const p = document.createElement('p');
        p.textContent = 'No high scores in this period.';
        body.appendChild(p);
        return;
      }

      const table = document.createElement('table'); table.className='hs-table';
      const thead = document.createElement('thead'); const trh = document.createElement('tr');
      ['#','Player','Score','Avg / Round','When'].forEach(h=>{
        const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);
      });
      thead.appendChild(trh); table.appendChild(thead);

      const tb = document.createElement('tbody');
      list.forEach((row, idx) => {
        const tr  = document.createElement('tr');

        const td1 = document.createElement('td'); td1.textContent = String(idx + 1);
        const td2 = document.createElement('td'); td2.textContent = row.name;
        const td3 = document.createElement('td'); td3.textContent = String(row.score);

        const td4 = document.createElement('td');
        const avgRound = (typeof MAX_ROUNDS === 'number' && MAX_ROUNDS > 0)
          ? (Number(row.score || 0) / MAX_ROUNDS) : 0;
        td4.textContent = avgRound.toFixed(1);

        const td5 = document.createElement('td');
        const d = new Date(row.ts);
        td5.textContent = !Number.isNaN(d.getTime())
          ? d.toLocaleString(undefined, { year:'2-digit', month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit' })
          : '';
        td5.style.fontSize = '0.8rem';

        tr.append(td1, td2, td3, td4, td5);

        // click â†’ score sheet (OFFICIAL)
        tr.style.cursor = 'pointer';
        tr.title = 'Open score sheet';
        tr.onclick = () => openScoreSheetFromHighScore(row, /* isPractice */ false);

        tb.appendChild(tr);
      });

      table.appendChild(tb);
      body.appendChild(table);
    } catch (err) {
      console.error(err);
      const p = document.createElement('p');
      p.textContent = 'Failed to load high scores.';
      body.appendChild(p);
    }
  }

  const footer = document.createElement('div');
  footer.className = 'modal-footer';
  footer.style.display = 'flex';
  footer.style.alignItems = 'center';
  footer.style.justifyContent = 'space-between';

  // Three flex regions: left spacer, centred period buttons, right-aligned Back
  const leftRegion = document.createElement('div');
  leftRegion.style.flex = '1';

  const centerRegion = document.createElement('div');
  centerRegion.style.display = 'flex';
  centerRegion.style.gap = '8px';
  centerRegion.style.justifyContent = 'center';

  const rightRegion = document.createElement('div');
  rightRegion.style.flex = '1';
  rightRegion.style.display = 'flex';
  rightRegion.style.justifyContent = 'flex-end';

  footer.append(leftRegion, centerRegion, rightRegion);

  // Period buttons (including Yesterday)
  const periods = [
    { key:'today',     label:'Today' },
    { key:'yesterday', label:'Yesterday' },
    { key:'week',      label:'1 Week' },
    { key:'month',     label:'1 Month' },
    { key:'all',       label:'All Time' },
  ];

  const periodBtns = periods.map(p => {
    const b = document.createElement('button');
    b.className = 'btn';
    b.textContent = p.label;
    b.dataset.period = p.key;
    b.onclick = async () => { period = p.key; setActive(); await render(); };
    centerRegion.appendChild(b);
    return b;
  });

  function setActive(){
    periodBtns.forEach(b => {
      if (b.dataset.period === period) b.classList.add('primary');
      else b.classList.remove('primary');
    });
  }

  // Back button on the right-hand side
  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = () => overlay.remove();
  rightRegion.appendChild(backBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0; modal.focus();
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });

  setActive();
  await render();

}
async function openLowScoresDialog(){ 
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop'; 

  const modal = document.createElement('div');
  modal.className = 'modal'; 

  const title = document.createElement('h3');
  title.textContent = 'Low Scores (Official)'; 

  const body = document.createElement('div');
  body.className = 'modal-body'; 

  try {
    // League low scores = official high_scores table sorted ASCENDING
    const { data, error } = await sb
      .from(TABLE_HS_LEAGUE)
      .select('name, score, ts')
      .order('score', { ascending: true })   // lowest first
      .order('ts',    { ascending: true })   // oldest first for ties
      .limit(20);                            // bottom 20

    if (error) throw error;

    const list = data || [];

    if (!list.length) { 
      const p = document.createElement('p'); 
      p.textContent = 'No scores recorded yet.'; 
      body.appendChild(p); 
    } else {
      const table = document.createElement('table'); 
      table.className = 'hs-table';

      const thead = document.createElement('thead'); 
      const trh   = document.createElement('tr');

      ['#','Player','Score','Avg / Round','When'].forEach(h => {
        const th = document.createElement('th'); 
        th.textContent = h; 
        trh.appendChild(th);
      }); 

      thead.appendChild(trh); 
      table.appendChild(thead);

      const tb = document.createElement('tbody');

      list.forEach((row, idx) => { 
        const tr = document.createElement('tr'); 

        const td1 = document.createElement('td'); 
        td1.textContent = String(idx + 1);

        const td2 = document.createElement('td'); 
        td2.textContent = row.name;

        const td3 = document.createElement('td'); 
        td3.textContent = String(row.score);

        const td4 = document.createElement('td');
        const avgRound = MAX_ROUNDS
          ? (Number(row.score || 0) / MAX_ROUNDS)
          : 0;
        td4.textContent = avgRound.toFixed(1);

        const td5 = document.createElement('td'); 
        const d = new Date(row.ts);
        td5.textContent = !Number.isNaN(d.getTime())
          ? d.toLocaleString(undefined, {
              year: '2-digit',
              month: 'short',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit'
            })
          : '';
        td5.style.fontSize = '0.8rem';

        tr.append(td1, td2, td3, td4, td5); 
        tb.appendChild(tr);
      });

      table.appendChild(tb); 
      body.appendChild(table);
    }
  } catch (err) { 
    console.error(err); 
    const p = document.createElement('p'); 
    p.textContent = 'Failed to load low scores.'; 
    body.appendChild(p); 
  }

  const footer = document.createElement('div'); 
  footer.className = 'modal-footer'; 

  const closeBtn = document.createElement('button'); 
  closeBtn.className = 'btn sq-pill'; 
  closeBtn.textContent = 'Close'; 
  closeBtn.onclick = () => overlay.remove(); 

  footer.appendChild(closeBtn); 

  modal.append(title, body, footer); 
  overlay.appendChild(modal); 
  document.body.appendChild(overlay); 

  modal.tabIndex = 0; 
  modal.focus(); 

  overlay.addEventListener('click', e => { 
    if (e.target === overlay) overlay.remove();
  }); 

  overlay.addEventListener('keydown', e => { 
    if (e.key === 'Escape') overlay.remove();
  });
}

// ===== @JS:UI:ANIM_INDICATORS =====
let __sqLastTurnPlayer = null;
let __sqLastRound = null;
let __sqRoundBarScrollBound = false;

function updateTurnBar(animateOverride){
  const bar  = byId('turnBar');
  const wrap = byId('floatWrap');
  if (!bar || !wrap) return;

  bar.style.opacity = '1';

  if (state.finished) {
    bar.style.width = '0px';
    return;
  }

  const pIdx = state.currentPlayer ?? 0;
  const cell = byId('fcoltot-' + pIdx);
  if (!cell) return;

  const head = byId('floatHead');
  const headRect = (head || wrap).getBoundingClientRect();
  const cellRect = cell.getBoundingClientRect();

  const left = cellRect.left - headRect.left;
  const width = cellRect.width;
  const barH = (bar.getBoundingClientRect().height || 3);
  const top = (cellRect.bottom - headRect.top) - barH + 1; // flush to bottom of B3

  const animate = (animateOverride != null)
    ? !!animateOverride
    : (__sqLastTurnPlayer !== null && __sqLastTurnPlayer !== pIdx);

  if (!animate) bar.style.transition = 'none';
  else bar.style.transition = 'transform 260ms ease, width 260ms ease';
    bar.style.width = `${Math.max(0, width)}px`;
  bar.style.transform = `translate(${left}px, ${top}px)`;

  if (!animate) requestAnimationFrame(() => {
    bar.style.transition = 'transform 260ms ease, width 260ms ease';
  });

  __sqLastTurnPlayer = pIdx;
}

function updateRoundBar(animateOverride, fromScroll=false){
  const bar  = byId('roundBar');
  const wrap = byId('scoreWrap');
  if (!bar || !wrap) return;

  const rIdx = state.currentRound ?? 0;
  const th = byId('roundth-' + rIdx);
  if (!th) return;

  // Bind scroll tracker once so the bar stays aligned during manual scroll
  if (!__sqRoundBarScrollBound) {
    wrap.addEventListener('scroll', () => {
      // No animation while user scrolls
      updateRoundBar(false, true);
      try{
        const mh = (window.__sqFHMenuH != null ? window.__sqFHMenuH : 48);
        const c = Math.max(0, Math.min(wrap.scrollTop, mh));
        document.documentElement.style.setProperty('--fhCollapse', c + 'px');
      }catch(e){}
    }, { passive:true });
    __sqRoundBarScrollBound = true;
  }

  const wrapRect = wrap.getBoundingClientRect();

  // The "round indicator" is the boundary between the round label column (left)
  // and Player 1's cell (right). Use Player 1 cell's left edge as the anchor.
  let left = null, y = null, h = null;
  const tdP1 = byId('cell-0-' + rIdx);
  if (tdP1) {
    const tdRect = tdP1.getBoundingClientRect();
    left = (tdRect.left - wrapRect.left) - 2; // center the 2px bar on the seam
    y = (tdRect.top - wrapRect.top);
    h = tdRect.height;
  } else {
    // Fallback: right edge of the round header cell
    const thRect = th.getBoundingClientRect();
    left = (thRect.right - wrapRect.left) - 2;
    y = (thRect.top - wrapRect.top);
    h = thRect.height;
  }

  const animate = (animateOverride != null)
    ? !!animateOverride
    : (!fromScroll && __sqLastRound !== null && __sqLastRound !== rIdx);

  if (!animate) bar.style.transition = 'none';
  else bar.style.transition = 'transform 260ms ease, height 260ms ease';

  bar.style.height = `${Math.max(0, h)}px`;
  bar.style.transform = `translate(${left}px, ${y}px)`;

  if (!animate) requestAnimationFrame(() => {
    bar.style.transition = 'transform 260ms ease, height 260ms ease';
  });

  __sqLastRound = rIdx;
}

function updateUI() {
  if (!tbody) return;

  // Clear previous highlights
  document.querySelectorAll('.current-cell, .current-col').forEach(el => {
    el.classList.remove('current-cell', 'current-col');
  });

  // Active round label (left column): big + bold only for current round
  try {
    for (let r = 0; r < MAX_ROUNDS; r++) {
      const th = document.getElementById(`roundth-${r}`);
      if (!th) continue;
      th.classList.remove('active-round-label');
    }
    const cr = state.currentRound;
    const thActive = document.getElementById(`roundth-${cr}`);
    if (thActive) thActive.classList.add('active-round-label');
    try{ updateRoundBar(); }catch(_){ }
  } catch(_) {}
// --- Precompute per-round totals to find best round per row ---
  const roundTotals    = Array.from({ length: MAX_ROUNDS }, () => Array(state.players.length).fill(0));
  const roundHasScore  = Array.from({ length: MAX_ROUNDS }, () => Array(state.players.length).fill(false));

  for (let p = 0; p < state.players.length; p++) {
    for (let r = 0; r < MAX_ROUNDS; r++) {
      const entry   = state.score?.[p]?.[r];
      const hasDart = !!(entry && entry.darts && entry.darts.some(d => d));

      if (!entry || !hasDart) continue;

      const rt = entry.roundTotal || 0;
      roundTotals[r][p]   = rt;
      roundHasScore[r][p] = true;
    }
  }

  const maxRoundTotals = roundTotals.map(row =>
    row.length ? Math.max(...row) : 0
  );

  // --- Fill cells: rolling total + (round score) + best-round highlight ---
  for (let p = 0; p < state.players.length; p++) {
    let running = 0;

    for (let r = 0; r < MAX_ROUNDS; r++) {
      const td = byId(`cell-${p}-${r}`);
      if (!td) continue;

      const entry      = state.score?.[p]?.[r];
      const hasDart    = roundHasScore[r][p];
      const roundTotal = hasDart ? (entry?.roundTotal || 0) : 0;

      const mainEl = byId(`cell-main-${p}-${r}`);
      const subEl  = byId(`cell-sub-${p}-${r}`);

      if (hasDart) {
        running += roundTotal;
        if (mainEl) mainEl.textContent = String(running);
        if (subEl) {
          subEl.textContent = `(${roundTotal})`;
          subEl.classList.remove('sub-win');
          if (roundTotal > 0 && roundTotal === maxRoundTotals[r]) {
            // highest round score this row â€“ green
            subEl.classList.add('sub-win');
          }
        }
      } else {
        if (mainEl) mainEl.textContent = 'â€“';
        if (subEl) {
          subEl.textContent = '';
          subEl.classList.remove('sub-win');
        }
      }

      td.classList.remove('current-cell', 'current-col');
      if (p === state.currentPlayer) {
        td.classList.add('current-col');
      }
    }
  }

  // Highlight the current cell (round + player)
  const cp = state.currentPlayer;
  const cr = state.currentRound;

  // B2 name color: white by default, Shateki orange for current player's go
  try{
    const nameCells = document.querySelectorAll('#floatThead tr:first-child th.player');
    nameCells.forEach((th, idx) => th.classList.toggle('is-go', idx === cp));
  }catch(_){}
  const currentCell = byId(`cell-${cp}-${cr}`);
  if (currentCell) {
    currentCell.classList.add('current-cell');
    currentCell.classList.add('current-col');
  }
  
 // Current round label in floating header (single column)
const roundLabelEl = byId('froundlabel');
if (roundLabelEl) {
  const lbl = labelForRound(ROUNDS[state.currentRound]) || '';
  roundLabelEl.innerHTML = `
    <div class="round-now">
      <div class="rn-label">TARGET</div>
      <div class="rn-value">${lbl}</div>
      <div id="fgoDarts" class="go-darts" aria-label="Current go"></div>
    </div>
  `;
  try{
    const goEl = byId('fgoDarts');
    if (goEl) goEl.innerHTML = renderSharedGoIndicatorHTML();

    // Animated C underline (slides between players)
    updateTurnBar();

  } catch(_) {}
}

  // --- update floating header (wins, totals, diffs, turn arrow, throws remaining) ---
  const totals = state.players.map((_, i) => totalScoreForPlayer(i));
  const max    = totals.length ? Math.max(...totals) : 0;
  const targetWins = state.match.targetWins || 1;
  for (let i = 0; i < state.players.length; i++) {
    
    // Totals
    const totalEl = byId('ftotal-' + i);
    if (totalEl) {
      totalEl.textContent = String(totals[i] || 0);
      totalEl.classList.remove('leader-total');
      if (max > 0 && totals[i] === max) {
        // overall leader(s) â€“ green total
        totalEl.classList.add('leader-total');
      }
    }

    // Diff
    const diffEl = byId('fdiff-' + i);
    if (diffEl) {
      const diff = totals[i] - max;
      diffEl.textContent = String(diff);
    }
    // Match progress (wins) â€“ stars for wins, circles for remaining games
    const winsEl = byId('fwins-' + i);
    if (winsEl) {
      const wins = state.match?.wins?.[i] || 0;
      const firstTo = state.match?.targetWins || 1;
      let html = "";
      for (let k = 0; k < firstTo; k++) {
        html += (k < wins) ? "<span class=\"win-star\">â˜…<\/span>" : "<span class=\"win-circle\">â—‹<\/span>";
      }
      winsEl.innerHTML = html;
}
  }

  // --- end-of-game banner ---
 const banner = byId('endBanner');
  if (banner) {
    banner.classList.add('hidden');
    banner.textContent = '';
  }

  // --- match stats table (hidden but kept in sync) ---
  try {
    updateMatchStats();
  } catch (e) {
    console.error(e);
  }

  // --- auto-scroll scoreboard to keep last 4 rounds visible ---
  try { autoScrollScoreboard(); } catch(_){}

  // --- rebuild throw pad + layout + save ---
  buildPad();
  updatePadSpacer();

  // Keep collapsing header + animated indicators aligned even when the user doesn't scroll
  try {
    updateFHCollapse('game');
    requestAnimationFrame(() => {
      try { updateTurnBar(null); } catch(_){ }
      try { updateRoundBar(null, false); } catch(_){ }
    });
  } catch(_){ }

  save();
}


/* >>> INSERT THESE TWO NEW FUNCTIONS <<< */
function recordThrow(spec){
  // Ignore input if game is finished or in sudden death
  if (state.finished || state.suddenDeath.active) return;

  const rIndex    = state.currentRound;
  const pIndex    = state.currentPlayer;
  const dartIndex = state.currentDart;

  if (rIndex < 0 || rIndex >= MAX_ROUNDS) return;
  if (pIndex < 0 || pIndex >= state.players.length) return;
  if (dartIndex < 0 || dartIndex > 2) return;

  const wasFinished = state.finished;

  const board = state.score[pIndex];
  if (!board) return;
  const entry = board[rIndex];
  if (!entry) return;
  if (!entry.darts) entry.darts = [null, null, null];

  const roundDef = ROUNDS[rIndex];

  let points = 0;
  let hitKey = null;
  let dartObj;

  if (spec.kind === 'Miss') {
    dartObj = { kind: 'Miss', points: 0 };
  } else if (roundDef.type === 'number') {
    const base = roundDef.target;
    if (spec.kind === 'S')      points = base;
    else if (spec.kind === 'D') points = base * 2;
    else if (spec.kind === 'T') points = base * 3;

    dartObj = { kind: spec.kind, points };
    hitKey  = String(base);
  } else if (roundDef.type === 'doubles' || roundDef.type === 'triples') {
    const sector = spec.sector || 0;
    if (!sector) {
      dartObj = { kind: 'Miss', points: 0 };
    } else {
      const mult = roundDef.type === 'doubles' ? 2 : 3;
      points = sector * mult;
      dartObj = {
        kind: roundDef.type === 'doubles' ? 'Double' : 'Triple',
        sector,
        points
      };
      hitKey = String(sector);
    }
  } else if (roundDef.type === 'bull') {
    const bull = spec.bull || 'Outer';
    points = bull === 'Inner' ? 50 : 25;
    dartObj = { kind: 'Bull', bull, points };
    hitKey  = 'Bull';
  } else {
    dartObj = { kind: 'Miss', points: 0 };
  }

  // Write dart
  entry.darts[dartIndex] = dartObj;
  entry.roundTotal =
    (entry.darts[0]?.points || 0) +
    (entry.darts[1]?.points || 0) +
    (entry.darts[2]?.points || 0);

  // flag if we just completed the 3rd dart in this round (used for GIF triggers)
  const __completedRoundNow = (state.currentDart === 2);

  // UI: hold the completed go's dart symbols for 1s, then reset to arrows for the next player's go
  if (dartIndex === 2) {
    try {
      state.uiLastGo = {
        player: pIndex,
        darts: (entry.darts || []).slice(0, 3),
        showUntil: Date.now() + 1000
      };
      state.__uiLastGoToken = (state.__uiLastGoToken || 0) + 1;
      const __tok = state.__uiLastGoToken;
      setTimeout(() => {
        try {
          if (state.__uiLastGoToken === __tok) updateUI();
        } catch(_) {}
      }, 1050);
    } catch(_) {}
  }

  // History (for Undo)
  state.history.push({
    player:    pIndex,
    round:     rIndex,
    dartIndex: dartIndex,
    throw:     dartObj
  });

  // Match aggregates
  ensureMatchAgg();

  if (hitKey && points > 0) {
    const hitsMap =
      state.matchAgg.hits[pIndex] ||
      (state.matchAgg.hits[pIndex] = {});
    hitsMap[hitKey] = (hitsMap[hitKey] || 0) + 1;
  }

  // Recompute 60+/100+/140+ for this player
  recomputeMatchAggTotalsForPlayer(pIndex);

{
  }
  // Advance dart / player / round
  if (state.currentDart < 2) {
    state.currentDart++;
  } else {
    state.currentDart = 0;
    if (state.currentPlayer < state.players.length - 1) {
      state.currentPlayer++;
    } else {
      state.currentPlayer = 0;
      if (state.currentRound < MAX_ROUNDS - 1) {
        state.currentRound++;
      } else {
        // Game done â€“ completion dialog will open
        state.finished = true;
      }
    }
  }

  updateUI();

  if (!wasFinished && state.finished) {
    openGameCompleteDialog();
  }
}
function recomputeMatchAggTotalsForPlayer(pIdx){
  ensureMatchAgg();

  let c60  = 0;
  let c100 = 0;
  let c140 = 0;

  for (let r = 0; r < MAX_ROUNDS; r++) {
    const rt =
      state.score?.[pIdx]?.[r]?.roundTotal ||
      0;

    if (rt >= 60)  c60++;
    if (rt >= 100) c100++;
    if (rt >= 140) c140++;
  }

  state.matchAgg.totals60[pIdx]  = c60;
  state.matchAgg.totals100[pIdx] = c100;
  state.matchAgg.totals140[pIdx] = c140;
}
function recomputeMatchAggHitsForPlayer(pIdx){
  ensureMatchAgg();

  const map = {};

  for (let r = 0; r < MAX_ROUNDS; r++) {
    const roundDef = ROUNDS[r];
    const entry = state.score?.[pIdx]?.[r];
    if (!entry) continue;

    const darts = entry.darts || [];
    darts.forEach(dart => {
      if (!dart || !(dart.points > 0)) return;

      let key = null;

      if (roundDef.type === 'number') {
        key = String(roundDef.target);
      } else if (roundDef.type === 'doubles' || roundDef.type === 'triples') {
        if (dart.sector) key = String(dart.sector);
      } else if (roundDef.type === 'bull') {
        key = 'Bull';
      }

      if (key) {
        map[key] = (map[key] || 0) + 1;
      }
    });
  }

  state.matchAgg.hits[pIdx] = map;
}

function undo(){
  if (!state.history.length) {
    toast('Nothing to undo');
    return;
  }

  const last = state.history.pop();
  const { player, round, dartIndex } = last;

  const entry = state.score?.[player]?.[round];
  if (!entry) {
    updateUI();
    return;
  }

  state.currentPlayer = player;
  state.currentRound  = round;
  state.currentDart   = dartIndex;
  state.finished      = false;

  entry.darts[dartIndex] = null;
  entry.roundTotal =
    (entry.darts[0]?.points || 0) +
    (entry.darts[1]?.points || 0) +
    (entry.darts[2]?.points || 0);

  recomputeMatchAggHitsForPlayer(player);
  recomputeMatchAggTotalsForPlayer(player);

  updateUI();
}

function missGo(){
  if (state.finished || state.suddenDeath.active) return;

  const startPlayer = state.currentPlayer;
  const startRound  = state.currentRound;

  while (
    !state.finished &&
    !state.suddenDeath.active &&
    state.currentPlayer === startPlayer &&
    state.currentRound === startRound &&
    state.currentDart < 3
  ) {
    recordThrow({ kind: 'Miss' });
  }
}
  /*****************
   * TENOR GIF OVERLAY (plays once, then cleans up)
   *****************/
  function ensureTenorOverlayStyles(){
    if (document.getElementById('tenorOverlayStyles')) return;
    const st = document.createElement('style');
    st.id = 'tenorOverlayStyles';
    st.textContent = `
      .gif-overlay{
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        z-index: 9999;
        background: transparent;
      }
      .gif-overlay .tenor-gif-embed{
        max-width: 80vw;
        width: 60vw;
        pointer-events: none;
      }
      @media (max-width: 600px){
        .gif-overlay .tenor-gif-embed{ width: 88vw; }
      }
    `;
    document.head.appendChild(st);
  }

  // Inject a Tenor embed DIV and (re)load Tenor's script so it renders even when added dynamically.
  function showTenorOnce(postId, durationMs = 2600){
    try{
      ensureTenorOverlayStyles();
      const overlay = document.createElement('div');
      overlay.className = 'gif-overlay';
      overlay.innerHTML = `
        &lt;div class="tenor-gif-embed"
             data-postid="${postId}"
             data-share-method="host"
             data-aspect-ratio="1.777"
             data-width="100%"&gt;&lt;/div&gt;`;
      document.body.appendChild(overlay);

      // Force Tenor to parse the newly injected embed by adding a fresh script tag.
      const s = document.createElement('script');
      s.src = 'https://tenor.com/embed.js';
      s.async = true;
      s.onload = () => {
        setTimeout(() => {
          try { overlay.remove(); } catch(_) {}
          try { s.remove(); } catch(_) {}
        }, durationMs);
      };
      document.body.appendChild(s);
    } catch (e){
      console.warn('showTenorOnce error', e);
    }
  }

function __sqComputeGameMode(){
  try {
    const players = state.players || [];
    const forcePractice = !!(state.match && (state.match.forcePractice === true || state.match.mode === 'practice'));
    let allRegistered = true;
    try {
      allRegistered = players.length ? players.every(p => !!__sqFindSavedPlayerMetaByName(p && p.name)) : false;
    } catch(_) { allRegistered = false; }

    if (forcePractice) return 'practice';
    if (players.length === 1) return 'practice';
    if (players.length >= 2 && !allRegistered) return 'practice';
    if (players.length >= 2 && allRegistered) return 'official';
    return 'practice';
  } catch(_) {
    return ((state.players?.length || 0) >= 2) ? 'official' : 'practice';
  }
}

// --- GAME LOGGING TO SUPABASE (real) + HIGH SCORES ---
async function recordFullGameToSupabase(createdAtOverride) {
  try {
    const isOfficial = (state.players?.length || 0) >= 2;

    // Prefer caller-provided timestamp, then global backdate (if present), else now.
    const ts =
      (typeof createdAtOverride !== 'undefined' && createdAtOverride) ? createdAtOverride :
      (typeof _tsOverride       !== 'undefined' && _tsOverride)       ? _tsOverride       :
      new Date().toISOString();

    if (isOfficial) {
      try {
        await upsertMatchToSupabase(ts);
      } catch (e) {
        console.warn('match upsert failed', e);
      }
    }

    const totals     = state.players.map((_, i) => totalScoreForPlayer(i));
    const boardClone = JSON.parse(JSON.stringify(state.score || []));

    const payload = {
      match_id:   isOfficial ? (state.match?.id || null) : null, // null for practice
      game_number: state.match?.history?.length ? state.match.history.length : 1,
      created_at: ts, // finish time (or backdated override)
      state:      { players: state.players.map(p => ({ name: p.name })), board: boardClone },
      totals,
      finished:   true
    };

    const { error } = await sb.from(TABLE_GAMES).insert(payload);
    if (error) throw error;
  } catch (e) {
    console.error('recordFullGameToSupabase failed', e);
    throw e;
  }
}

// Multi-player -> League (TABLE_HS_LEAGUE), single-player -> Practice (TABLE_HS_PRACTICE).
async function recordGameToHighScores() {
  if (!state.players || !state.players.length) return;

  const totals   = state.players.map((_, i) => totalScoreForPlayer(i));
  const __m = __sqComputeGameMode();
  const isPractice = (__m === 'practice');

  const tasks = [];

  for (let i = 0; i < state.players.length; i++) {
    const name  = state.players[i].name || `Player ${i + 1}`;
    const score = totals[i] || 0;

    // Donâ€™t log ghost/zero scores
    if (!name || score <= 0) continue;

    tasks.push(
      cloudInsertHighScore(name, score, isPractice).catch(err => {
        console.error('High score insert failed', err);
      })
    );
  }

  await Promise.all(tasks);
}

async function awardAndShowLeaderboard(){
  // prevent double-award if called twice for same game
  if (state.gameAwarded) {
    showLeaderboard();
    return;
  }
  state.gameAwarded = true;

  const totals  = state.players.map((_,i)=> totalScoreForPlayer(i));
  const max     = Math.max(...totals);
  const winners = totals.map((t,i)=> t===max?i:null).filter(x=>x!==null);

// before recordFullGameToSupabase();
if ((state.players?.length || 0) >= 2) {
  try { await upsertMatchToSupabase(); } catch (e) { console.warn(e); }
}

  // Ensure wins array exists
  if (!state.match.wins || state.match.wins.length !== state.players.length) {
    state.match.wins = Array.from({length: state.players.length}, () => 0);
  }
  winners.forEach(i => state.match.wins[i]++);

  // Snapshot board for history/stats
  const boardClone = JSON.parse(JSON.stringify(state.score));
  state.match.history.push({ totals: totals.slice(), board: boardClone });

  // Long-term local logs
  logCompletedGame(totals, winners, boardClone);

  const targetWins = state.match.targetWins || 1;
  const maxWins    = state.match.wins.length ? Math.max(...state.match.wins) : 0;
  const matchDone  = maxWins >= targetWins;

  if (matchDone && !state.match.completedLogged) {
    logCompletedMatch();
    state.match.completedLogged = true;
  }

  // Cloud writes (best-effort)
  try { await recordFullGameToSupabase(); } catch (e) {
    console.error(e); toast('Game saved to local only (cloud failed)');
  }
  try { await recordGameToHighScores(); } catch (e) {
    console.error(e);
  }

  state.match.gameNumber = state.match.history.length + 1;

  save();
  showLeaderboard();
}
// next line should exist already in your file:
const lbTable = byId('lbTable');
const lbTHead = lbTable ? lbTable.querySelector('thead') : null;
const lbTBody = lbTable ? lbTable.querySelector('tbody') : null;
const lbMatchInfo = byId('lbMatchInfo');
const nextGameBtn=byId('nextGameBtn'); 
const gameScoresBtn=byId('gameScoresBtn'); 
const newMatchBtn=byId('newMatchBtn'); 
const gamesRemainTag=byId('gamesRemainTag');

const lbGameStatsBtn  = byId('lbGameStatsBtn');
const lbMatchStatsBtn = byId('lbMatchStatsBtn');
const lbGameRaceBtn   = byId('lbGameRaceBtn');

function updateLeaderboardTable(){
  if (!lbTable || !lbTHead || !lbTBody) return;
  lbTHead.innerHTML = '';
  lbTBody.innerHTML = '';

  const gamesPlayed = state.match.history.length;

  /* ---------- measure Player column to fit largest name ---------- */
  function measureNameColWidthPx(){
    const labels = ['Player', ...state.players.map(p => p.name || '')];
    const cs = getComputedStyle(lbTable);
    const font = `${cs.fontWeight} ${cs.fontSize} ${cs.fontFamily}`;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = font;

    let max = 0;
    for (const t of labels){
      const w = ctx.measureText(t).width;
      if (w > max) max = w;
    }
    const padding = 24;  // left+right cell padding
    const border  = 1;   // right border separator
    // clamp to something sensible
    const px = Math.ceil(max + padding + border);
    return Math.min(Math.max(px, 100), 320);
  }
  const nameColWidth = measureNameColWidthPx();

  /* ---------- define column grid ---------- */
  let colgroup = lbTable.querySelector('colgroup');
  if (!colgroup) {
    colgroup = document.createElement('colgroup');
    lbTable.insertBefore(colgroup, lbTable.firstChild);
  }
  colgroup.innerHTML = '';

  // Player (exact width to longest name)
  const cName = document.createElement('col');
  cName.style.width = nameColWidth + 'px';
  colgroup.appendChild(cName);

  // G1..Gn
  for (let g = 0; g < gamesPlayed; g++) {
    const c = document.createElement('col');
    c.style.width = 'var(--lb-num-w)';
    colgroup.appendChild(c);
  }

 // Distinct columns for Match %, Match Total, Win â€“ same width
const rightW = 'var(--lb-right-w)';
const cPct   = document.createElement('col'); cPct.style.width   = rightW; colgroup.appendChild(cPct);
const cTotal = document.createElement('col'); cTotal.style.width = rightW; colgroup.appendChild(cTotal);
const cWin   = document.createElement('col'); cWin.style.width   = rightW; colgroup.appendChild(cWin);

  /* ---------- header ---------- */
  const trh = document.createElement('tr');

  const thName = document.createElement('th');
  thName.scope = 'col';
  thName.textContent = 'Player';
  trh.appendChild(thName);

  for (let g = 0; g < gamesPlayed; g++) {
    const th = document.createElement('th');
    th.scope = 'col';
    th.className = 'center gcol' + (g === gamesPlayed - 1 ? ' after-games-sep' : '');
    th.textContent = 'G' + (g + 1);
    th.style.cursor = 'pointer';
    th.title = 'Open Game ' + (g + 1) + ' score sheet';
    th.onclick = () => openScoreSheetFromHistory(g);
    trh.appendChild(th);
  }

  const thPct = document.createElement('th');
  thPct.scope = 'col';
  thPct.className = 'center';
  thPct.textContent = 'Match %';
  trh.appendChild(thPct);

  const thTotal = document.createElement('th');
  thTotal.scope = 'col';
  thTotal.className = 'center';
  thTotal.textContent = 'Match Total';
  trh.appendChild(thTotal);

  const thWin = document.createElement('th');
  thWin.scope = 'col';
  thWin.className = 'center';
  thWin.textContent = 'Win';
  trh.appendChild(thWin);

  lbTHead.appendChild(trh);

  /* ---------- gather data ---------- */
  let bestMatchTotal = -Infinity;
  const perPlayerTotals = state.players.map((_, idx) => {
    let mt = 0;
    const perGame = [];
    for (let g = 0; g < gamesPlayed; g++) {
      const t = (state.match.history[g]?.totals?.[idx]) || 0;
      perGame.push(t);
      mt += t;
    }
    bestMatchTotal = Math.max(bestMatchTotal, mt);
    return { perGame, matchTotal: mt };
  });

  function dartsThrownForMatch(pIdx){
    let n = 0;
    for (let g = 0; g < gamesPlayed; g++) {
      const board = state.match.history[g]?.board?.[pIdx];
      if (!board) continue;
      for (let r = 0; r < MAX_ROUNDS; r++) {
        const darts = board[r]?.darts || [];
        darts.forEach(d => { if (d !== null) n++; });
      }
    }
    return n;
  }

  /* ---------- rows ---------- */
  state.players.forEach((player, idx) => {
    const tr = document.createElement('tr');

    // Player
    const nameTd = document.createElement('td');
    nameTd.textContent = player.name;
    nameTd.style.color = player.color;
    tr.appendChild(nameTd);

    // G1..Gn
    perPlayerTotals[idx].perGame.forEach((val, g) => {
      const td = document.createElement('td');
      td.className = 'center num gcol' + (g === gamesPlayed - 1 ? ' after-games-sep' : '');
      td.textContent = String(val);
      tr.appendChild(td);
    });

    // Match % (three-dart average across the whole match)
    const thrown = dartsThrownForMatch(idx);
    const total  = perPlayerTotals[idx].matchTotal;
    const avg3   = thrown ? (total / thrown) * 3 : 0;

    const pctTd = document.createElement('td');
    pctTd.className = 'center num';
    pctTd.textContent = avg3.toFixed(1);
    tr.appendChild(pctTd);

    // Match Total (highlight leader)
    const totalTd = document.createElement('td');
    totalTd.className = 'center num';
    totalTd.textContent = String(total);
    if (total === bestMatchTotal && bestMatchTotal > 0) {
      totalTd.classList.add('leader-total');
    }
    tr.appendChild(totalTd);

    // Win
    const winsTd = document.createElement('td');
    winsTd.className = 'center num';
    winsTd.textContent = String(state.match.wins[idx] || 0);
    tr.appendChild(winsTd);

    lbTBody.appendChild(tr);
  });
}

function showLeaderboard() {
  // Build table
  updateLeaderboardTable();

  // Decide which CTA to show
  const targetWins = state.match?.targetWins || 1;
  const winsArr    = state.match?.wins || [];
  const maxWins    = winsArr.length ? Math.max(...winsArr) : 0;
  const matchDone  = maxWins >= targetWins;

  // NEXT GAME button
  if (nextGameBtn) {
    nextGameBtn.classList.toggle('hidden', matchDone);
    nextGameBtn.onclick = () => {
      state.finished = false;
      startNewGame();      // opens throw-order dialog, then goes to Game
    };
  }

  // END MATCH button
  if (newMatchBtn) {
    newMatchBtn.classList.toggle('hidden', !matchDone);
    newMatchBtn.onclick = () => {
      // reset to start a fresh match
      state = JSON.parse(JSON.stringify(baseState));
      save();
      show('players');     // or: show('details');
      try { if (typeof drawPsRows === 'function') drawPsRows(); } catch(_e) {}
    };
  }

  // Optional info line
  if (lbMatchInfo) {
    const gamesPlayed = state.match?.history?.length || 0;
    const toWin = Math.max(0, targetWins - maxWins);
    lbMatchInfo.textContent = matchDone
      ? `Match complete â€” first to ${targetWins}`
      : `Games: ${gamesPlayed} Â· First to ${targetWins} Â· ${toWin} to win`;
    lbMatchInfo.parentElement?.classList.remove('hidden');
  }

  // Show the screen
  show('leaderboard');
}

function openGameScoresDialog() {
  if (!state.match || !Array.isArray(state.match.history) || !state.match.history.length) {
    toast('No completed games yet.');
    return;
  }

  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Game Scores';

  const body = document.createElement('div');
  body.className = 'modal-body';

  state.match.history.forEach((game, idx) => {
    const heading = document.createElement('h4');
    heading.textContent = `Game ${idx + 1}`;
    heading.style.margin = '8px 0 4px';
    body.appendChild(heading);

    const wrap = document.createElement('div');
    wrap.className = 'table-wrap';
    wrap.style.marginBottom = '8px';

    const table = document.createElement('table');
    table.className = 'hs-table';

    // Header row: Round + each player
    const thead = document.createElement('thead');
    const trHead = document.createElement('tr');

    const thRound = document.createElement('th');
    thRound.textContent = 'Round';
    trHead.appendChild(thRound);

    state.players.forEach(p => {
      const th = document.createElement('th');
      th.textContent = p.name;
      th.style.textAlign = 'center';
      trHead.appendChild(th);
    });

    thead.appendChild(trHead);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    const board = game.board || [];
    const runningTotals = state.players.map(() => 0);

    for (let r = 0; r < MAX_ROUNDS; r++) {
      const tr = document.createElement('tr');

      const roundDef = ROUNDS[r];
      const roundTh = document.createElement('th');
      roundTh.textContent =
        roundDef.type === 'number'
          ? (roundDef.target + 's')
          : (roundDef.type === 'doubles'
              ? "D's"
              : (roundDef.type === 'triples' ? "T's" : 'Bull'));
      tr.appendChild(roundTh);

      for (let p = 0; p < state.players.length; p++) {
        const td = document.createElement('td');
        td.className = 'center num';

        const entry = board[p]?.[r];
        const hasDarts = entry && entry.darts && entry.darts.some(d => d);
        const rt = entry?.roundTotal || 0;

        if (hasDarts) {
          runningTotals[p] += rt;

          const main = document.createElement('div');
          main.className = 'cell-main';
          main.textContent = String(runningTotals[p]);

          const sub = document.createElement('div');
          sub.className = 'cell-sub';
          sub.textContent = rt ? `(${rt})` : '';

          td.appendChild(main);
          td.appendChild(sub);
        } else {
          td.textContent = 'â€“';
        }

        tr.appendChild(td);
      }

      tbody.appendChild(tr);
    }

    table.appendChild(tbody);
    wrap.appendChild(table);
    body.appendChild(wrap);
  });

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn sq-pill';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();

  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });
}

if (gameScoresBtn) gameScoresBtn.addEventListener('click', openGameScoresDialog);

/*****************
 * SCROLL SYNC (keeps columns aligned)
 *****************/
let _scrollSyncSet=false; 
function setupScrollSync(){ 
  if(_scrollSyncSet) return; 
  const sw=byId('scoreWrap'), st=byId('statsWrap'), fh=byId('floatWrap'), ms=byId('mstatsWrap'); 
  if(!sw||!st||!fh||!ms) return; 
  let syncing=false; 
  function mirror(from){ 
    if(syncing) return; syncing=true; 
    const x=from.scrollLeft; [sw,st,fh,ms].forEach(el=>{ if(el!==from) el.scrollLeft=x; }); syncing=false; 
  } 
  [sw,st,fh,ms].forEach(el=> el.addEventListener('scroll',()=>mirror(el),{passive:true})); 
  _scrollSyncSet=true; 
  requestAnimationFrame(()=>{ 
    // Safely resolve header elements even if global refs (thead, statsThead, floatThead) are undefined
    const thead      = document.querySelector('#scoreWrap thead')  || document.querySelector('#scoreTable thead') || window.thead      || null;
    const statsThead = document.querySelector('#statsWrap thead')  || window.statsThead  || null;
    const floatThead = document.querySelector('#floatWrap thead')  || window.floatThead  || null;
    const sRow=thead?.querySelector('tr'), tRow=statsThead?.querySelector('tr'), fRow=floatThead?.querySelector('tr'); 
    if(!sRow||!tRow||!fRow) return; 
    const sCells=sRow.children, tCells=tRow.children, fCells=fRow.children; 
    const leftW=sCells[0].getBoundingClientRect().width; 
    document.documentElement.style.setProperty('--left-col-w', leftW+'px'); 
    const n=Math.min(sCells.length,tCells.length,fCells.length); 
    for(let i=1;i<n;i++){ 
      const w=sCells[i].getBoundingClientRect().width; 
      [tCells[i], fCells[i]].forEach(cell=>{ if(cell){ cell.style.width=w+'px'; cell.style.minWidth=w+'px'; cell.style.maxWidth=w+'px'; } }); 
    } 
  }); 
}

/*****************
 * START/RESET + ORDER DIALOG
 *****************/
function buildEverything(){ 
  buildScoreHeader(); 
  buildScoreBody(); 
  buildFloatingHeader(); 
  buildStatsHeader(); 
  buildStatsBody(); 
  buildMatchStatsHeader(); 
  buildMatchStatsBody(); 
  setupScrollSync(); 
}

// GLOBAL â€” record pace (#1 league high score) from Supabase only
async function buildRecordPaceSeries(roundsCount) {
  try {
    // 1) Get #1 league high score from Supabase
    const list = await cloudListHighScores(false, 1);
    if (!list || !list.length) return null;

    const top = list[0];
    const target = Number(top.score) || 0;

    // 2) Try to find the exact game for that row using our cloud-first resolver
    let found = null;
    try {
      if (typeof findGameForHighScoreCloudFirst === 'function') {
        found = await findGameForHighScoreCloudFirst(
          { name: top.name, score: target, ts: top.ts },
          /* isPractice */ false
        );
      }
    } catch (e) {
      console.error('findGameForHighScoreCloudFirst failed', e);
    }

    // 3) If not found, fall back to scanning cloud games we have locally
    if (!found) {
      let games = [];
      try {
        games = await cloudFetchAllGamesAsLocal();
      } catch (_) {
        console.error('cloudFetchAllGamesAsLocal failed in buildRecordPaceSeries');
        games = [];
      }

      if (games && games.length) {
        const candidates = games
          .filter(isOfficialGame)
          .map(g => {
            const pIdx = (g.players || []).findIndex(p => p && eqName(p.name, top.name));
            if (pIdx === -1) return null;
            if ((g.totals?.[pIdx] || 0) !== target) return null;

            const delta =
              (top.ts && g.ts)
                ? Math.abs(new Date(g.ts) - new Date(top.ts))
                : Number.MAX_SAFE_INTEGER;

            return { game: g, playerIndex: pIdx, delta };
          })
          .filter(Boolean)
          .sort((a, b) => a.delta - b.delta)[0];

        if (candidates && candidates.game) {
          found = candidates;
        }
      }
    }

    // 4) If still not found or missing board, bail
    if (!found || !found.game || !Array.isArray(found.game.board?.[found.playerIndex])) {
      console.warn('No board data for top record game; skipping record pace line');
      return null;
    }

    // 5) Build true round-by-round cumulative totals for that player
    const data = [];
    let running = 0;
    const board = found.game.board[found.playerIndex];

    for (let r = 0; r < roundsCount; r++) {
      const rt = board?.[r]?.roundTotal || 0;
      running += rt;
      data.push(running);
    }

    return {
      name: `Record: ${top.name} (${target})`,
      color: '#ffffff',
      data,
      dotted: true
    };
  } catch (e) {
    console.error('buildRecordPaceSeries failed', e);
    return null;
  }
}
async function openGameRaceDialog() {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Game Race';

  const body = document.createElement('div');
  body.className = 'modal-body';

  const info = document.createElement('p');
  info.textContent = 'Round-by-round cumulative scores. Dotted line shows the #1 high score pace.';
  info.style.fontSize = '0.82rem';
  info.style.color = '#a8acc3';
  info.style.marginBottom = '6px';
  body.appendChild(info);

  const canvas = document.createElement('canvas');
  canvas.width  = 640;
  canvas.height = 320;
  canvas.style.width  = '100%';
  canvas.style.height = 'auto';
  body.appendChild(canvas);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = () => {
    overlay.remove();
    openStatsHubDialog();
  };

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn sq-pill';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();

  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });

  // --- Build series for current game ---
  const roundsCount = MAX_ROUNDS;
  const series = [];

  for (let p = 0; p < state.players.length; p++) {
    const player = state.players[p];
    const data = [];
    let running = 0;

    for (let r = 0; r < roundsCount; r++) {
      const entry = state.score?.[p]?.[r];
      const rt = entry ? (entry.roundTotal || 0) : 0;
      running += rt;
      data.push(running);
    }

    series.push({
      name: player.name,
      color: player.color || '#7bdcff',
      data,
      dotted: false
    });
  }
// --- Add dotted #1 high score line using the actual round-by-round board ---
const recordSeries = await buildRecordPaceSeries(roundsCount);
if (recordSeries) {
  series.push(recordSeries);
} else {
  info.textContent = 'Round-by-round cumulative scores.'; // no fake line
}

  // If no data at all, just bail
  const anyPoints = series.some(s => s.data.some(v => v > 0));
  if (!anyPoints) {
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#a8acc3';
    ctx.font = '12px system-ui';
    ctx.fillText('No scoring data yet for this game.', 20, 40);
    return;
  }

  // --- Draw chart ---
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  const marginLeft = 40;
  const marginRight = 10;
  const marginTop = 20;
  const marginBottom = 30;

  ctx.clearRect(0, 0, w, h);

  const maxY = Math.max(
    ...series.flatMap(s => s.data),
    10
  );

  const plotW = w - marginLeft - marginRight;
  const plotH = h - marginTop - marginBottom;

  function xForRound(r) {
    if (roundsCount <= 1) return marginLeft;
    const t = r / (roundsCount - 1);
    return marginLeft + t * plotW;
  }

  function yForScore(v) {
    const t = v / maxY;
    return marginTop + (1 - t) * plotH;
  }

  // Grid + axes
  ctx.strokeStyle = '#2b3050';
  ctx.lineWidth = 1;
  ctx.setLineDash([]);

  // Y-axis
  ctx.beginPath();
  ctx.moveTo(marginLeft, marginTop);
  ctx.lineTo(marginLeft, marginTop + plotH);
  ctx.stroke();

  // X-axis
  ctx.beginPath();
  ctx.moveTo(marginLeft, marginTop + plotH);
  ctx.lineTo(marginLeft + plotW, marginTop + plotH);
  ctx.stroke();

  ctx.fillStyle = '#a8acc3';
  ctx.font = '10px system-ui';

  // Y labels (4 ticks)
  for (let i = 0; i <= 4; i++) {
    const v = (maxY / 4) * i;
    const y = yForScore(v);
    ctx.fillText(String(Math.round(v)), 4, y + 3);

    ctx.strokeStyle = 'rgba(43,48,80,0.4)';
    ctx.beginPath();
    ctx.moveTo(marginLeft, y);
    ctx.lineTo(marginLeft + plotW, y);
    ctx.stroke();
  }

  // X labels (rounds)
  ctx.textAlign = 'center';
  for (let r = 0; r < roundsCount; r++) {
    const x = xForRound(r);
    const label = ROUNDS[r].type === 'number'
      ? String(ROUNDS[r].target)
      : (ROUNDS[r].type === 'doubles'
          ? 'D'
          : (ROUNDS[r].type === 'triples' ? 'T' : 'Bull'));
    ctx.fillText(label, x, marginTop + plotH + 12);
  }
  ctx.textAlign = 'left';

  // Lines
  series.forEach(s => {
    if (!s.data || !s.data.length) return;

    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.setLineDash(s.dotted ? [5, 4] : []);

    // pick line colour
    ctx.strokeStyle = s.color || '#7bdcff';

    s.data.forEach((v, idx) => {
      const x = xForRound(idx);
      const y = yForScore(v);
      if (idx === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });

    ctx.stroke();
  });

  // Legend
  let legendX = marginLeft;
  let legendY = marginTop - 6;

  series.forEach(s => {
    ctx.setLineDash(s.dotted ? [5, 4] : []);
    ctx.strokeStyle = s.color || '#7bdcff';
    ctx.lineWidth = 2;

    const lineW = 24;
    ctx.beginPath();
    ctx.moveTo(legendX, legendY);
    ctx.lineTo(legendX + lineW, legendY);
    ctx.stroke();

    ctx.setLineDash([]);
    ctx.fillStyle = '#e7e9f5';
    ctx.font = '10px system-ui';
    ctx.fillText(' ' + s.name, legendX + lineW + 4, legendY + 3);

    legendY += 14;
  });
}

// Throw order selection
function showPlayerOrderDialog() {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';
  const modal = document.createElement('div');
  modal.className = 'modal modal-throworder';

  const top = document.createElement('div');
  top.className = 'to-top';

  const titleWrap = document.createElement('div');
  titleWrap.className = 'to-titles';

  const h = document.createElement('div');
  h.className = 'to-title';
  h.textContent = 'THROW ORDER';

  const sub = document.createElement('div');
  sub.className = 'to-subtitle';
  // match length is already chosen; show current game index if available
  const gnum = (state && typeof state.gameNumber === 'number' && state.gameNumber > 0) ? state.gameNumber : 1;
  sub.textContent = 'DECIDE THE LINEUP FOR GAME ' + gnum;

  titleWrap.append(h, sub);
  top.append(titleWrap);

  const body = document.createElement('div');
  body.className = 'to-body';

  const list = document.createElement('div');
  list.className = 'to-list';

  function initialsForPlayer(p){
    return __sqNormalizeInitials(p && p.initials, p && p.name);
  }

  function render(){
    list.innerHTML = '';
    state.players.forEach((p, i) => {
      const row = document.createElement('div');
      row.className = 'to-row';

      const rank = document.createElement('div');
      rank.className = 'to-rank';
      rank.textContent = '#' + (i+1);

      const badge = document.createElement('div');
      badge.className = 'to-badge';
      badge.textContent = initialsForPlayer(p) || (String(p.name||'').trim().slice(0,2).toUpperCase());

      const meta = document.createElement('div');
      meta.className = 'to-meta';

      const nm = document.createElement('div');
      nm.className = 'to-name';
      nm.textContent = (__sqPlayerPretty(p) || String(p.name || '').trim() || ('Player ' + (i+1)));

      const small = document.createElement('div');
      small.className = 'to-small';
      small.textContent = (i === 0) ? 'THROWS FIRST' : '';

      meta.append(nm, small);

      const arrows = document.createElement('div');
      arrows.className = 'to-arrows';

      const up = document.createElement('button');
      up.className = 'to-arrow-btn';
      up.type = 'button';
      up.innerHTML = 'â†‘';
      up.disabled = (i === 0);

      const down = document.createElement('button');
      down.className = 'to-arrow-btn';
      down.type = 'button';
      down.innerHTML = 'â†“';
      down.disabled = (i === state.players.length - 1);

      up.onclick = () => { if (i > 0) { swapPlayers(i, i-1); render(); } };
      down.onclick = () => { if (i < state.players.length - 1) { swapPlayers(i, i+1); render(); } };

      arrows.append(up, down);

      row.append(rank, badge, meta, arrows);
      list.appendChild(row);
    });
  }

  render();
  body.appendChild(list);

  const actions = document.createElement('div');
  actions.className = 'to-actions';

  const startBtn = document.createElement('button');
  const __mode = (window.__sqSelectedMode || 'match');
  // Match Setup CTA sizing/typography consistency
  startBtn.className = (__mode === 'practice') ? 'btn to-start to-blueLight practice-cta' : 'btn to-start practice-cta';
  startBtn.type = 'button';
  startBtn.innerHTML = 'START GAME <span class="to-start-ic">â–¶</span>';
  startBtn.onclick = () => { overlay.remove(); startNewGame(true); };

  const backBtn = document.createElement('button');
  backBtn.className = 'btn to-back';
  backBtn.type = 'button';
  backBtn.textContent = 'â† BACK';
  backBtn.onclick = () => overlay.remove();

  actions.append(startBtn, backBtn);

  modal.append(top, body, actions);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
  modal.tabIndex = 0; modal.focus();
}

function startNewGame(setOrder=false){
  if(!setOrder){ showPlayerOrderDialog(); return; }
  state.score = Array.from({length:state.players.length},
    ()=>Array.from({length:MAX_ROUNDS},()=>({darts:[null,null,null],roundTotal:0})));
  state.currentRound = 0;
  state.currentPlayer = 0;
  state.currentDart = 0;
  state.history = [];
  state.finished = false;
  state.suddenDeath = {active:false,participants:[],turnIndex:0,throws:[],round:1};
  state.gameAwarded = false;
  ensureMatchAgg();
  show('game'); buildEverything(); updateUI(); save();
}

function restartGame() {
  if (!confirm('Are you sure you want to restart this game? All progress will be lost.')) return;
  state.finished = false;
  state.suddenDeath = {active:false, participants:[], turnIndex:0, throws:[], round:1};
  startNewGame();
  show('game'); updateUI();
}

function swapPlayers(i, j) {
  // Swap players themselves
  [state.players[i], state.players[j]] = [state.players[j], state.players[i]];

  // Swap match wins
  if (state.match && Array.isArray(state.match.wins)) {
    [state.match.wins[i], state.match.wins[j]] =
      [state.match.wins[j], state.match.wins[i]];
  }

  // Swap per-game totals already stored
  if (state.match && Array.isArray(state.match.history)) {
    state.match.history.forEach(g => {
      if (g && Array.isArray(g.totals)) {
        [g.totals[i], g.totals[j]] = [g.totals[j], g.totals[i]];
      }
    });
  }

  // Swap matchAgg stats so favourites / 60+ / 100+ / 140+ stay with the player
  if (state.matchAgg) {
    if (Array.isArray(state.matchAgg.hits)) {
      [state.matchAgg.hits[i], state.matchAgg.hits[j]] =
        [state.matchAgg.hits[j], state.matchAgg.hits[i]];
    }
    ['totals60', 'totals100', 'totals140'].forEach(key => {
      if (Array.isArray(state.matchAgg[key])) {
        [state.matchAgg[key][i], state.matchAgg[key][j]] =
          [state.matchAgg[key][j], state.matchAgg[key][i]];
      }
    });
  }
}
/*****************
 * ADMIN HUB + ADMIN PANELS
 *****************/
 function findGameForHighScore(row) {
  const games = getGameLog();
  if (!games || !games.length) return null;

  const targetName  = row.name;
  const targetScore = Number(row.score) || 0;
  const targetTs    = row.ts ? new Date(row.ts).getTime() : null;
  const windowMs    = 5 * 60 * 1000; // 5 minutes either side

  for (const g of games) {
    if (!g || !Array.isArray(g.players) || !Array.isArray(g.totals)) continue;

    const pIdx = g.players.findIndex(p => p && p.name === targetName);
    if (pIdx === -1) continue;

    const scoreHere = Number(g.totals[pIdx] || 0);
    if (scoreHere !== targetScore) continue;

    if (targetTs && g.ts) {
      const gt = new Date(g.ts).getTime();
      if (Math.abs(gt - targetTs) > windowMs) continue;
    }

    // Found a matching game + player index
    return { game: g, playerIndex: pIdx };
  }

  return null;
}
 
 function deleteLocalStatsForHighScore(row) {
  const games = getGameLog();
  if (!games || !games.length) return;

  const targetName  = row.name;
  const targetScore = Number(row.score) || 0;
  const targetTs    = row.ts ? new Date(row.ts).getTime() : null;
  const windowMs    = 5 * 60 * 1000; // 5 minutes either side

  const filtered = [];

  for (const g of games) {
    let matches = false;

    if (g && Array.isArray(g.players) && Array.isArray(g.totals)) {
      g.players.forEach((p, idx) => {
        if (!p) return;
        if (p.name !== targetName) return;

        const scoreHere = Number(g.totals[idx] || 0);
        if (scoreHere !== targetScore) return;

        if (targetTs && g.ts) {
          const gt = new Date(g.ts).getTime();
          if (Math.abs(gt - targetTs) <= windowMs) {
            matches = true;
          }
        } else {
          matches = true;
        }
      });
    }

    if (!matches) filtered.push(g);
  }

  if (filtered.length !== games.length) {
    setGameLog(filtered);
  }
}
// ------- High Score â†’ Score Sheet (cloud-first) -------

// Try to find the exact game in Supabase by timestamp Â±10min + name + score.
// Falls back to local getGameLog() via findGameForHighScore().
async function findGameForHighScoreCloudFirst(row, isPractice = false){
  const ts = row?.ts ? new Date(row.ts) : null;

  // 1) Cloud window query
  if (ts && window.sb) {
    const pad = 10 * 60 * 1000; // Â±10 min
    const fromIso = new Date(ts.getTime() - pad).toISOString();
    const toIso   = new Date(ts.getTime() + pad).toISOString();

    try {
      const { data, error } = await sb
        .from(TABLE_GAMES)
        .select('created_at, state, totals, match_id')
        .gte('created_at', fromIso)
        .lte('created_at', toIso)
        .order('created_at', { ascending: true })
        .limit(100);

      if (error) throw error;

      const candidates = (data || []);
      for (const g of candidates) {
        const players = (g?.state?.players || []).map(p => (typeof p === 'string' ? { name:p } : p));
        const totals  = Array.isArray(g?.totals) ? g.totals : [];

        // Practice vs Official sanity check (optional but helps)
        const isSingle = players.length === 1 || !g.match_id;
        if (isPractice && !isSingle) continue;
        if (!isPractice && isSingle) continue;

        const pIdx = players.findIndex(p => p && eqName(p.name, row.name));
        if (pIdx === -1) continue;
        if (Number(totals[pIdx] || 0) !== Number(row.score || 0)) continue;

        // Convert to local shape the rest of the code expects
        const local = {
          ts: g.created_at || null,
          players,
          totals: totals.slice(),
          winners: [], // not needed for the sheet
          board: g?.state?.board || null
        };
        return { game: local, playerIndex: pIdx };
      }
    } catch (e) {
      console.error('cloud lookup for high-score row failed', e);
    }
  }

  // 2) Local fallback
  const local = findGameForHighScore(row);
  if (local) return { game: local.game, playerIndex: local.playerIndex };

  return null;
}

// Render a single game's score sheet (round-by-round) in a modal.
// Optionally highlight one player's column (e.g. the high-score row owner).
function openSingleGameScoreSheet(game, highlightIdx = -1){
  if (!game || !Array.isArray(game.players) || !game.board) {
    toast('Score sheet not available for this row yet.');
    return;
  }

  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  const when  = game.ts ? new Date(game.ts).toLocaleString() : '';
  title.textContent = `Score Sheet${when ? ' â€” ' + when : ''}`;

  const body = document.createElement('div');
  body.className = 'modal-body';

  const wrap = document.createElement('div');
  wrap.className = 'table-wrap';

  const table = document.createElement('table');
  table.className = 'hs-table';

  // Header
  const thead = document.createElement('thead');
  const trh = document.createElement('tr');
  const thRound = document.createElement('th');
  thRound.textContent = 'Round';
  trh.appendChild(thRound);

  game.players.forEach((p, idx) => {
    const th = document.createElement('th');
    th.textContent = p.name;
    th.style.textAlign = 'center';
    if (idx === highlightIdx) {
      th.style.color = 'var(--accent-2)';
      th.style.fontWeight = '900';
    }
    trh.appendChild(th);
  });
  thead.appendChild(trh);
  table.appendChild(thead);

  // Body
  const tbody = document.createElement('tbody');
  const runningTotals = game.players.map(() => 0);

  for (let r = 0; r < MAX_ROUNDS; r++) {
    const tr = document.createElement('tr');

    const roundDef = ROUNDS[r];
    const roundTh = document.createElement('th');
    roundTh.textContent =
      roundDef.type === 'number'
        ? (roundDef.target + 's')
        : (roundDef.type === 'doubles' ? "D's" : (roundDef.type === 'triples' ? "T's" : 'Bull'));
    tr.appendChild(roundTh);

    for (let p = 0; p < game.players.length; p++) {
      const td = document.createElement('td');
      td.className = 'center num';

      const entry = game.board?.[p]?.[r];
      const hasDarts = entry && entry.darts && entry.darts.some(d => d);
      const rt = entry?.roundTotal || 0;

      if (hasDarts) {
        runningTotals[p] += rt;
        const main = document.createElement('div');
        main.className = 'cell-main';
        main.textContent = String(runningTotals[p]);

        const sub = document.createElement('div');
        sub.className = 'cell-sub';
        sub.textContent = rt ? `(${rt})` : '';

        td.appendChild(main);
        td.appendChild(sub);
      } else {
        td.textContent = 'â€“';
      }

      tr.appendChild(td);
    }

    tbody.appendChild(tr);
  }

  table.appendChild(tbody);
  wrap.appendChild(table);
  body.appendChild(wrap);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';
  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn sq-pill';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();
  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}



// ===== Public High Scores (League / Practice) =====
if (typeof window.openScoreSheetFromHighScore !== 'function') {
  window.openScoreSheetFromHighScore = async function(row, isPractice){
    try{
      const match = await findGameForHighScoreCloudFirst(row, isPractice);
      if (match && match.game) {
        openSingleGameScoreSheet(match.game, match.playerIndex);
      } else {
        toast('Score sheet not available for this row yet.');
      }
    }catch(e){
      console.error('openScoreSheetFromHighScore failed', e);
      toast('Could not open score sheet.');
    }
  };
}

async function openHighScoresMenuDialog(){
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className='modal';
  const title   = document.createElement('h3');  title.textContent='High Scores';
  const body    = document.createElement('div'); body.className='modal-body';
  const footer  = document.createElement('div'); footer.className='modal-footer';

  // Tabs
  const tabs = document.createElement('div');
  tabs.style.display = 'flex';
  tabs.style.gap = '8px';
  tabs.style.marginBottom = '10px';

  const leagueBtn   = document.createElement('button'); leagueBtn.className='btn primary'; leagueBtn.textContent='League';
  const practiceBtn = document.createElement('button'); practiceBtn.className='btn';           practiceBtn.textContent='Practice';
  tabs.append(leagueBtn, practiceBtn);

  const status = document.createElement('div');
  status.className = 'muted';
  status.style.fontSize = '0.85rem';
  status.style.margin = '6px 0 8px 0';

  body.append(tabs, status);

  const tableHost = document.createElement('div'); tableHost.className='table-wrap';
  body.appendChild(tableHost);

  async function render(isPractice){
    tableHost.innerHTML = '';
    status.textContent = '';

    // visual tabs
    leagueBtn.className   = isPractice ? 'btn' : 'btn primary';
    practiceBtn.className = isPractice ? 'btn primary' : 'btn';

    try{
      if (!ensureCloudInit()){
        status.textContent = 'Cloud not initialised â€” check keys or network.';
        return;
      }
    }catch(_){}

    let list = [];
    try{
      list = await cloudListHighScores(!!isPractice, 50);
    }catch(e){
      console.error('cloudListHighScores failed', e);
      status.textContent = (e && e.message) ? `Failed to load: ${e.message}` : 'Failed to load high scores.';
      return;
    }

    if (!list || !list.length){
      const p=document.createElement('p');
      p.textContent='No high scores yet.';
      tableHost.appendChild(p);
      return;
    }

    const table=document.createElement('table'); table.className='hs-table';
    const thead=document.createElement('thead'); const trh=document.createElement('tr');
    ['#','Player','Score','Avg / Round','When'].forEach(h=>{
      const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);
    });
    thead.appendChild(trh); table.appendChild(thead);

    const tb=document.createElement('tbody');
    list.forEach((row, idx) => {
      const tr=document.createElement('tr');

      const td1=document.createElement('td'); td1.textContent=String(idx+1);
      const td2=document.createElement('td'); td2.textContent=String(row.name || '');
      const td3=document.createElement('td'); td3.textContent=String(row.score || 0);
      const td4=document.createElement('td');
      const avgRound = MAX_ROUNDS ? (Number(row.score||0)/MAX_ROUNDS) : 0;
      td4.textContent = avgRound.toFixed(1);

      const td5=document.createElement('td');
      const d=new Date(row.ts);
      td5.textContent = !Number.isNaN(d.getTime())
        ? d.toLocaleString(undefined,{year:'2-digit',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit'})
        : '';

      tr.append(td1,td2,td3,td4,td5);

      tr.style.cursor='pointer';
      tr.title='Open score sheet';
      tr.onclick = ()=> window.openScoreSheetFromHighScore(row, !!isPractice);

      tb.appendChild(tr);
    });

    table.appendChild(tb);
    tableHost.appendChild(table);
  }

  // footer
  const backBtn=document.createElement('button'); backBtn.className='btn sq-pill'; backBtn.textContent='Back';
  backBtn.onclick=()=> overlay.remove();
  const closeBtn=document.createElement('button'); closeBtn.className='btn sq-pill'; closeBtn.textContent='Close';
  closeBtn.onclick=()=> overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); });
  modal.tabIndex=0; modal.focus();

  // wire tabs
  leagueBtn.onclick   = ()=> render(false);
  practiceBtn.onclick = ()=> render(true);

  // initial
  await render(false);
}

async function openHighScoresAdminDialog(single=false){ 
  const overlay = document.createElement('div'); overlay.className='modal-backdrop'; 
  const modal   = document.createElement('div'); modal.className='modal'; 
  const title   = document.createElement('h3'); title.textContent=`High Scores â€” Admin (${single?'Practice':'League'})`; 
  const body    = document.createElement('div'); body.className='modal-body'; 
  const footer  = document.createElement('div'); footer.className='modal-footer';

  async function render(){
    body.innerHTML = '';
    try{
      const list = await cloudListHighScores(single, 50);
      if(!list.length){
        const p=document.createElement('p'); p.textContent='No high scores.'; body.appendChild(p); return;
      }

      const table=document.createElement('table'); table.className='hs-table compact';
      const thead=document.createElement('thead'); const trh=document.createElement('tr');
      ['#','Player','Score','Avg / Round','When','Actions'].forEach(h=>{
        const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);
      });
      thead.appendChild(trh); table.appendChild(thead);

      const tb=document.createElement('tbody');
      list.forEach((row, idx) => {
        const tr=document.createElement('tr');

        const td1=document.createElement('td'); td1.textContent=String(idx+1);
        const td2=document.createElement('td'); td2.textContent=row.name;
        const td3=document.createElement('td'); td3.textContent=String(row.score);

        const td4=document.createElement('td');
        const avgRound = MAX_ROUNDS ? (Number(row.score||0)/MAX_ROUNDS) : 0;
        td4.textContent = avgRound.toFixed(1);

        const td5=document.createElement('td');
        const d=new Date(row.ts);
        td5.textContent = !Number.isNaN(d.getTime())
          ? d.toLocaleString(undefined,{year:'2-digit',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit'})
          : '';
        td5.style.fontSize='0.8rem';

        const td6=document.createElement('td'); td6.className='center';
        const del=document.createElement('button'); del.className='btn small danger'; del.textContent='Delete';
        del.onclick = async () => {
          if (!confirm('Delete this high score?')) return;
          try { await cloudDeleteHighScore(row, single); await render(); }
          catch(e){ console.error(e); toast('Delete failed'); }
        };
        td6.appendChild(del);

        tr.append(td1,td2,td3,td4,td5,td6);

        // click â†’ score sheet
        tr.style.cursor='pointer';
        tr.title='Open score sheet';
        tr.onclick = (e)=> {
          if (e.target === del) return;           // donâ€™t open when pressing Delete
          openScoreSheetFromHighScore(row, single);
        };

        tb.appendChild(tr);
      });

      table.appendChild(tb); 
      body.appendChild(table);
    } catch(err){
      console.error(err);
      const p=document.createElement('p'); p.textContent='Failed to load.'; body.appendChild(p);
    }
  }

  await render();

  const backBtn=document.createElement('button');
  backBtn.className='btn';
  backBtn.textContent='Back';
  backBtn.onclick=()=>{ overlay.remove(); openAdminHub(); };
  const closeBtn=document.createElement('button'); 
  closeBtn.className='btn'; 
  closeBtn.textContent='Exit'; 
  closeBtn.onclick=()=>overlay.remove(); 
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer); 
  overlay.appendChild(modal); 
  document.body.appendChild(overlay); 

  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); }); 
  modal.tabIndex=0; modal.focus(); 
}
// League Low Scores â€” Admin dialog
async function openLeagueLowsAdminDialog(){
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className='modal';
  const title   = document.createElement('h3');  title.textContent='League Low Scores â€” Admin';
  const body    = document.createElement('div'); body.className='modal-body';
  const footer  = document.createElement('div'); footer.className='modal-footer';

  async function render(){
    body.innerHTML = '';

    try{
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()){
        const p = document.createElement('p');
        p.textContent = 'Cloud not initialised.';
        body.appendChild(p);
        return;
      }
    }catch(_){}

      // >>> PATCH:MOT3_2_LLS_FILTER_SAVED START
  let __llsSavedSet = null;
  try{
    const __ps = await (typeof cloudListPlayers === 'function' ? cloudListPlayers() : []);
    __llsSavedSet = new Set((__ps||[]).map(p=>String(p?.name||'').trim().toLowerCase()).filter(Boolean));
  }catch(_){ __llsSavedSet = null; }
  // <<< PATCH:MOT3_2_LLS_FILTER_SAVED END

// Derived low scores from official games (no dedicated table required)
    let rows = [];
    try{
      const games = await cloudFetchAllGamesAsLocal();
      (games||[]).filter(isOfficialGame).forEach(g=>{
        const ts = g.ts || g.created_at || g.inserted_at || (g.meta && (g.meta.ts || g.meta.date)) || null;
        const players = Array.isArray(g.players) ? g.players : [];
        const totals  = Array.isArray(g.totals)  ? g.totals  : [];
        players.forEach((p,i)=>{
          const name = (typeof p==='string') ? p : (p && p.name) ? p.name : '';
          if (!name) return;
          const __k = String(name).trim().toLowerCase();
          const __savedSet = (typeof __llsSavedSet !== "undefined" ? __llsSavedSet : (window.__llsSavedSet || null));
          if (__savedSet && !__savedSet.has(__k)) return;
          rows.push({ name, score: Number(totals[i]||0), ts, __game: g });
        });
      });
      rows.sort((a,b)=> (a.score-b.score) || (Date.parse(a.ts||'')-Date.parse(b.ts||'')));
      rows = rows.slice(0, 50);
    }catch(e){
      console.error('League low scores derived fetch failed', e);
      const p = document.createElement('p');
      p.textContent = 'Failed to load league low scores.';
      body.appendChild(p);
      return;
    }

    if (!rows.length){
      const p = document.createElement('p');
      p.textContent = 'No league low scores found.';
      body.appendChild(p);
      return;
    }

    const table = document.createElement('table'); table.className='hs-table compact';
    const thead = document.createElement('thead'); const trh=document.createElement('tr');
    ['#','Player','Score','When','Actions'].forEach(h=>{
      const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);
    });
    thead.appendChild(trh); table.appendChild(thead);

    const tb = document.createElement('tbody');

    rows.forEach((row, idx) => {
      const tr = document.createElement('tr');

      const td1 = document.createElement('td'); td1.textContent = String(idx+1);
      const td2 = document.createElement('td'); td2.textContent = row.name || '';
      const td3 = document.createElement('td'); td3.textContent = String(row.score ?? '');

      const td4 = document.createElement('td');
      const d   = new Date(row.ts);
      td4.textContent = !Number.isNaN(d.getTime())
        ? d.toLocaleString(undefined,{year:'2-digit',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit'})
        : '';
      td4.style.fontSize = '0.8rem';

      const td5 = document.createElement('td'); td5.className='center';
      const del = document.createElement('button'); del.className='btn small danger'; del.textContent='Delete';
      del.onclick = async (e) => {
        e.stopPropagation();
        if (!confirm(`Delete ${row.name}'s low score of ${row.score}?`)) return;
        try{
          const tableName = (typeof TABLE_LEAGUE_LOW_SCORES !== 'undefined' && TABLE_LEAGUE_LOW_SCORES)
            ? TABLE_LEAGUE_LOW_SCORES
            : 'league_low_scores';

          // Derived list: delete the underlying game instead
          if (!row.__game) throw new Error('Missing game for delete');
          await cloudDeleteGameCascade(Object.assign({}, row.__game, { ts: row.ts }));// >>> PATCH:MOT3_2_LLS_DELETE_TS

          if (typeof toast === 'function') toast('Deleted');
          await render();
        }catch(err){
          console.error('Delete league low score failed', err);
          if (typeof toast === 'function') toast('Delete failed');
        }
      };
      td5.appendChild(del);

      tr.append(td1, td2, td3, td4, td5);
      tb.appendChild(tr);
    });

    table.appendChild(tb);
    body.appendChild(table);
  }

  await render();

  const backBtn  = document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  backBtn.onclick = ()=>{ overlay.remove(); if (typeof openAdminHub === 'function') openAdminHub(); };
  const closeBtn = document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Exit';
  closeBtn.onclick = ()=> overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); });
  modal.tabIndex=0; modal.focus();
}

// All Games dialog (cloud-only, with Delete and re-render)
async function openAllGamesDialog(){
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className='modal';
  const title   = document.createElement('h3');  title.textContent='All Games';
  const body    = document.createElement('div'); body.className='modal-body';
  const footer  = document.createElement('div'); footer.className='modal-footer';

  // >>> PATCH:MOT3_2_ALLGAMES_TOTS START
  const toTS = (g)=>{
    const t = g?.ts || g?.created_at || g?.inserted_at || (g?.meta && (g.meta.ts || g.meta.date)) || null;
    const n = t ? Date.parse(t) : NaN;
    return Number.isFinite(n) ? n : 0;
  };
  // <<< PATCH:MOT3_2_ALLGAMES_TOTS END


  // Header with filter controls (top-right)
  const header = document.createElement('div');
  header.style.cssText = 'display:flex; align-items:center; justify-content:space-between; gap:8px;';
  const controls = document.createElement('div');
  controls.style.cssText = 'display:flex; gap:6px;';
  const officialBtn = document.createElement('button'); officialBtn.className='btn primary'; officialBtn.textContent='Official';
  const practiceBtn = document.createElement('button'); practiceBtn.className='btn';          practiceBtn.textContent='Practice';
  controls.append(officialBtn, practiceBtn);
  header.append(title, controls);

  // Filter state + saved players cache
  let filterMode = 'official';
  let savedSet = null;
  async function getSavedSet(){
    try{
      if (savedSet) return savedSet;
      const players = await (typeof cloudListPlayers === 'function' ? cloudListPlayers() : []);
      savedSet = new Set((players||[]).map(p => String(p?.name || '').trim().toLowerCase()).filter(Boolean));
      return savedSet;
    }catch(_){
      savedSet = new Set();
      return savedSet;
    }
  }

  // Wire filter buttons
  officialBtn.onclick = async ()=>{
    filterMode = 'official';
    officialBtn.className = 'btn primary';
    practiceBtn.className = 'btn';
    await render();
  };
  practiceBtn.onclick = async ()=>{
    filterMode = 'practice';
    practiceBtn.className = 'btn primary';
    officialBtn.className = 'btn';
    await render();
  };

  async function render(){
    body.innerHTML = '';

    // Build list (cloud games only; no synthetic backfill here to avoid duplicates)
    let cloudGames = [];
    try { cloudGames = await cloudFetchAllGamesAsLocal(); } catch(e){ console.error(e); cloudGames = []; }

    // >>> PATCH:MOT3_3_ALLGAMES_FILTER_ACTIVE_START
    const saved = await getSavedSet();
    const isActiveName = (nm)=>{
      const k = String(nm||'').trim().toLowerCase();
      return (!saved || !saved.size) ? true : saved.has(k);
    };
    const gameHasOnlyActivePlayers = (g)=>{
      const pls = Array.isArray(g?.players) ? g.players : [];
      if (!pls.length) return false;
      return pls.every(p=>{
        const nm = (typeof p === 'string') ? p : (p && p.name) ? p.name : '';
        return nm ? isActiveName(nm) : false;
      });
    };

    let gamesAll = (cloudGames || []).filter(Boolean).sort((a,b)=> toTS(b) - toTS(a));
    let games = gamesAll.filter(g => (filterMode === 'official') ? isOfficialGame(g) : isPracticeGame(g));
    if (saved && saved.size) games = games.filter(gameHasOnlyActivePlayers);

    // If there are no practice games in TABLE_GAMES, synth from practice high-scores table.
    if (filterMode === 'practice' && !games.length) {
      try {
        if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) throw new Error('Cloud not initialised');
        const practiceTbl = (typeof TABLE_HS_PRACTICE !== 'undefined' ? TABLE_HS_PRACTICE : 'high_scores_sp');
        const { data, error } = await sb
          .from(practiceTbl)
          .select('name, score, ts')
          .order('ts', { ascending: false })
          .limit(500);
        if (error) throw error;
        const synth = (data || []).map(r => ({
          ts: r.ts || null,
          players: [{ name: r.name }],
          totals: [Number(r.score) || 0],
          board: null,
          __synth: true
        }));
        games = synth.sort((a,b)=> toTS(b) - toTS(a));
        if (saved && saved.size) games = games.filter(gameHasOnlyActivePlayers);
      } catch (e) {
        console.error('All Games practice synth failed', e);
      }
    }
    // <<< PATCH:MOT3_3_ALLGAMES_FILTER_ACTIVE_END

    if (!games.length){
      const p=document.createElement('p'); p.textContent='No games found.'; body.appendChild(p); return;
    }

    const table=document.createElement('table'); table.className='hs-table';

    // Column layout: # | When | Players | Totals | Actions
    const colgroup = document.createElement('colgroup');
    const cIdx = document.createElement('col'); cIdx.style.width = '3ch'; colgroup.appendChild(cIdx); // #
    colgroup.appendChild(document.createElement('col')); // When
    colgroup.appendChild(document.createElement('col')); // Players
    colgroup.appendChild(document.createElement('col')); // Totals
    const cAct = document.createElement('col'); cAct.style.width = '88px'; colgroup.appendChild(cAct); // Actions
    table.appendChild(colgroup);

    const thead=document.createElement('thead'); const trh=document.createElement('tr');
    ['#','When','Players','Totals',''].forEach((h,i)=>{
      const th=document.createElement('th'); th.textContent=h;
      if(i===0) th.style.width='3ch';   // # column
      if(i===4) th.style.width='88px';  // actions column
      trh.appendChild(th);
    });
    thead.appendChild(trh); table.appendChild(thead);

    const tb=document.createElement('tbody');
    games.forEach((g, idx)=>{
      const tr=document.createElement('tr');

      const td1=document.createElement('td'); td1.textContent=String(idx+1); td1.style.width='3ch';
      const td2 = document.createElement('td');
      const tsVal = g.ts || g.created_at || g.inserted_at || (g.meta && (g.meta.ts || g.meta.date)) || null;
      td2.textContent = (window.fmtWhen && tsVal) ? window.fmtWhen(tsVal) : '';
      const td3=document.createElement('td'); td3.textContent=(g.players||[]).map(p=> (typeof p==='string'?p:(p&&p.name)||'')).filter(Boolean).join(', ');
      const td4=document.createElement('td'); td4.textContent=(g.totals||[]).join(' Â· ');

      // Delete button as last column
      const tdDel=document.createElement('td'); tdDel.className='center';
      const delBtn=document.createElement('button'); delBtn.className='btn small danger'; delBtn.textContent='Delete';
      delBtn.title='Delete this game';
      delBtn.onclick = async (e) => {
        e.stopPropagation();
        if (!confirm('Delete this game from cloud (and related high-score rows)?')) return;
        try { await cloudDeleteGameCascade(g); toast('Game deleted'); await render(); }
        catch(err){ console.error(err); toast('Delete failed'); }
      };
      tdDel.appendChild(delBtn);

      tr.style.cursor='pointer';
      tr.title='Open score sheet';
      tr.onclick=()=>{ if (typeof openSingleGameScoreSheet === 'function') openSingleGameScoreSheet(g); };

      tr.append(td1, td2, td3, td4, tdDel); tb.appendChild(tr);
    });

    table.appendChild(tb); body.appendChild(table);
  }

  // Footer
  const backBtn=document.createElement('button'); backBtn.className='btn sq-pill'; backBtn.textContent='Back';
  backBtn.onclick=()=>{ overlay.remove(); if (typeof openAdminHub==='function') openAdminHub(); };
  const closeBtn=document.createElement('button'); closeBtn.className='btn sq-pill'; closeBtn.textContent='Close';
  closeBtn.onclick=()=> overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(header, body, footer); overlay.appendChild(modal); document.body.appendChild(overlay);
  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); });
  modal.tabIndex=0; modal.focus();

  await render();
}

async function openRoundHighScoresDialog(){
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className='modal sq-wide-modal';
  const title   = document.createElement('h3');  title.textContent='Round High Scores';
  const body    = document.createElement('div'); body.className='modal-body';
  const footer  = document.createElement('div'); footer.className='modal-footer';

  async function render(){
    body.innerHTML = '';
    try{
      const snap = await (typeof getPBGRSnapshot === 'function' ? getPBGRSnapshot() : Promise.resolve({ byTargetMeta: {} }));
      const order = [...Array.from({length:11},(_,i)=>10+i), 'D','T','B'];

      const table = document.createElement('table'); table.className='hs-table';
      const thead = document.createElement('thead'); const trh=document.createElement('tr');
      ['Round','WR','Darts','Holder'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
      thead.appendChild(trh); table.appendChild(thead);

      const tbody = document.createElement('tbody'); table.appendChild(tbody);
      const pending = [];

      order.forEach(key=>{
        const meta = (snap.byTargetMeta && snap.byTargetMeta[key]) ? snap.byTargetMeta[key] : { val:0, player:'', game_id:null, ridx:null };
        const tr   = document.createElement('tr');

        const tdR  = document.createElement('td'); tdR.textContent = String(key);
        const tdV  = document.createElement('td'); tdV.textContent = String(meta.val || 0);
        const tdD  = document.createElement('td'); tdD.textContent = 'â€”'; // filled async
        const tdN  = document.createElement('td'); tdN.textContent = meta.player ? meta.player : 'â€”';

        tr.append(tdR, tdV, tdD, tdN);
        tbody.appendChild(tr);

        if (meta && meta.game_id != null && meta.player && (meta.ridx || meta.ridx === 0)){
          pending.push(
            fetchRoundPattern(meta.game_id, meta.player, meta.ridx).then(pat=>{
              tdD.textContent = pat || 'â€”';
            }).catch(()=>{ tdD.textContent = 'â€”'; })
          );
        }
      });

      if (pending.length){ try{ await Promise.allSettled(pending); }catch(_){ /* ignore */ } }
      body.appendChild(table);
    }catch(e){
      console.error('Round High Scores render failed', e);
      const p=document.createElement('p'); p.textContent='Unable to load right now.'; body.appendChild(p);
    }
  }

  const backBtn=document.createElement('button'); backBtn.className='btn sq-pill'; backBtn.textContent='Back';
  backBtn.onclick=()=> overlay.remove();
  const closeBtn=document.createElement('button'); closeBtn.className='btn sq-pill'; closeBtn.textContent='Close';
  closeBtn.onclick=()=> overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); });
  modal.tabIndex=0; modal.focus();

  await render();
}

// Delete a game (by timestamp) and its related high-score rows from Supabase
async function cloudDeleteGameCascade(g){
  if (!ensureCloudInit()) throw new Error('Cloud not initialised');
  const ts = g?.ts;
  if (!ts) throw new Error('Missing timestamp for delete');

  // 1) Delete the game row by exact timestamp
  try {
    const { error } = await sb.from(TABLE_GAMES).delete().eq('created_at', ts);
    if (error) throw error;
  } catch (e) {
    // Try a fallback range delete Â±2min if exact equality fails
    try {
      const pad = 2 * 60 * 1000;
      const fromIso = new Date(new Date(ts).getTime() - pad).toISOString();
      const toIso   = new Date(new Date(ts).getTime() + pad).toISOString();
      const { error } = await sb.from(TABLE_GAMES).delete().gte('created_at', fromIso).lte('created_at', toIso);
      if (error) throw error;
    } catch (ee) {
      console.error('Delete games failed', ee); throw ee;
    }
  }

  // 2) Delete related high-score rows (practice/league)
  const isSingle = (g?.players || []).length === 1;
  const players = g?.players || [];
  const totals  = g?.totals  || [];
  const tasks = players.map((p,i)=>{
    const row = { name: p?.name || '', score: Number(totals[i]||0), ts };
    return cloudDeleteHighScore(row, isSingle).catch(()=>{});
  });
  await Promise.all(tasks);
}

  /*****************
   * CLOUD INIT HELPER
   *****************/
  // ===== @JS:CLOUD:SUPABASE_INIT =====
function ensureCloudInit(){
    try {
      // Library present?
      if (typeof window.supabase !== 'object' || !window.supabase.createClient) {
        try { setCloudStatus && setCloudStatus('error', 'Cloud not initialised'); } catch(_) {}
        return false;
      }
      // Keys present?
      if (typeof SUPABASE_URL === 'undefined' || typeof SUPABASE_ANON === 'undefined' || !SUPABASE_URL || !SUPABASE_ANON) {
        try { setCloudStatus && setCloudStatus('error', 'Cloud keys missing'); } catch(_) {}
        return false;
      }
      // Make client if missing
      if (!window.sb) {
        try { window.sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON); sb = window.sb; }
        catch (e) {
          console.error('supabase createClient failed', e);
          try { setCloudStatus && setCloudStatus('error', 'Cloud not initialised'); } catch(_) {}
          return false;
        }
      }
      if (!sb && window.sb) sb = window.sb;
      return true;
    } catch (e) {
      console.error('ensureCloudInit failed', e);
      try { setCloudStatus && setCloudStatus('error', 'Cloud not initialised'); } catch(_) {}
      return false;
    }
  }

/*** CLOUD HIGH SCORES API â€” safe fallback implementations ***/
(function(){
  // Insert (or keep existing) â†’ create only if missing to avoid duplicates
  if (typeof window.cloudInsertHighScore !== 'function') {
    window.cloudInsertHighScore = async function(name, score, isPractice){
      if (!ensureCloudInit()) throw new Error('Cloud not initialised');
      const table = isPractice
        ? (typeof TABLE_HS_PRACTICE !== 'undefined' ? TABLE_HS_PRACTICE : 'high_scores_practice')
        : (typeof TABLE_HS_LEAGUE   !== 'undefined' ? TABLE_HS_LEAGUE   : 'high_scores');

      const row = {
        name: String(name || '').trim(),
        score: Number(score || 0),
        // Prefer server default if your table has one; otherwise send a timestamp
        ts: new Date().toISOString()
      };

      // basic guards; don't write empty rows
      if (!row.name || row.score <= 0) return false;

      const { error } = await sb.from(table).insert(row);
      if (error) throw error;
      return true;
    };
  }
if (typeof window.cloudInsertHighScoreIfMissing !== 'function') {
  window.cloudInsertHighScoreIfMissing = async function(table, name, score, ts){
    if (!ensureCloudInit()) throw new Error('Cloud not initialised');
    const n = String(name || '').trim();
    const s = Number(score || 0);
    if (!n || s <= 0) return false;

    // Does a matching row already exist? (exact name/score; if ts is given, use Â±2 min window)
    async function existsQuery() {
      try {
        if (ts) {
          const pad = 2 * 60 * 1000;
          const fromIso = new Date(new Date(ts).getTime() - pad).toISOString();
          const toIso   = new Date(new Date(ts).getTime() + pad).toISOString();
          const { count, error } = await sb
            .from(table)
            .select('name,score,ts', { count: 'exact', head: true })
            .gte('ts', fromIso).lte('ts', toIso)
            .eq('name', n).eq('score', s)
            .limit(1);
          if (error) throw error;
          return !!(count && count > 0);
        } else {
          const { count, error } = await sb
            .from(table)
            .select('name,score,ts', { count: 'exact', head: true })
            .eq('name', n).eq('score', s)
            .limit(1);
          if (error) throw error;
          return !!(count && count > 0);
        }
      } catch {
        // Fallback: non-head select
        try {
          if (ts) {
            const pad = 2 * 60 * 1000;
            const fromIso = new Date(new Date(ts).getTime() - pad).toISOString();
            const toIso   = new Date(new Date(ts).getTime() + pad).toISOString();
            const { data } = await sb
              .from(table).select('name,score,ts')
              .gte('ts', fromIso).lte('ts', toIso)
              .eq('name', n).eq('score', s).limit(1);
            return Array.isArray(data) && data.length > 0;
          } else {
            const { data } = await sb
              .from(table).select('name,score,ts')
              .eq('name', n).eq('score', s).limit(1);
            return Array.isArray(data) && data.length > 0;
          }
        } catch {
          return false;
        }
      }
    }

    if (await existsQuery()) return false;

    const row = { name: n, score: s, ts: ts || new Date().toISOString() };
    const { error } = await sb.from(table).insert(row);
    if (error) throw error;
    return true;
  };
}

  if (typeof window.cloudListHighScores !== 'function') {
    window.cloudListHighScores = async function(isPractice, limit = 50){
      if (!ensureCloudInit()) throw new Error('Cloud not initialised');
      const table = isPractice
        ? (typeof TABLE_HS_PRACTICE !== 'undefined' ? TABLE_HS_PRACTICE : 'high_scores_practice')
        : (typeof TABLE_HS_LEAGUE   !== 'undefined' ? TABLE_HS_LEAGUE   : 'high_scores');

      const { data, error } = await sb
        .from(table)
        .select('name, score, ts')
        .order('score', { ascending: false })
        .order('ts',    { ascending: true })
        .limit(limit);

      if (error) throw error;
      return data || [];
    };
  }

  if (typeof window.cloudDeleteHighScore !== 'function') {
    window.cloudDeleteHighScore = async function(row, isPractice){
      if (!ensureCloudInit()) throw new Error('Cloud not initialised');
      const table = isPractice
        ? (typeof TABLE_HS_PRACTICE !== 'undefined' ? TABLE_HS_PRACTICE : 'high_scores_practice')
        : (typeof TABLE_HS_LEAGUE   !== 'undefined' ? TABLE_HS_LEAGUE   : 'high_scores');

      // Try exact match (including ts if provided)
      try {
        let q = sb.from(table).delete()
          .eq('name', String(row?.name || ''))
          .eq('score', Number(row?.score || 0));
        if (row?.ts) q = q.eq('ts', row.ts);
        const { error } = await q;
        if (error) throw error;
        return;
      } catch (e) {
        // Fallback: delete on small time window if exact ts equality fails
        if (!row?.ts) throw e;
        const pad = 2 * 60 * 1000;
        const fromIso = new Date(new Date(row.ts).getTime() - pad).toISOString();
        const toIso   = new Date(new Date(row.ts).getTime() + pad).toISOString();
        const { error } = await sb.from(table).delete()
          .gte('ts', fromIso).lte('ts', toIso)
          .eq('name', String(row.name || ''))
          .eq('score', Number(row.score || 0));
        if (error) throw error;
      }
    };
  }
})();
// Toggle for writing per-player game rows to a table.
// Your project uses a view (`player_games_union`), so writes should be disabled.
const ENABLE_PLAYER_GAMES_WRITES = false;

/*****************
 * CLOUD-ONLY READS (force consistency across devices)
 *****************/
const READS_CLOUD_ONLY = true; // all reads come from Supabase

// If cloud-only reads are enabled, neutralise local log accessors so UI never reads from them
if (READS_CLOUD_ONLY) {
  window.getGameLog = function(){ return []; };
  window.setGameLog = function(){ /* no-op */ };
  window.logCompletedGame = function(){ /* no-op (we persist to cloud in recordFullGameToSupabase) */ };
  window.getMatchLog = function(){ return []; };
  window.setMatchLog = function(){ /* no-op */ };
  window.logCompletedMatch = function(){ /* no-op */ };
}

/* NEW: shared date formatter â†’ "DD/MM/YY @ HH:MM" (24h) */
if (typeof window.fmtWhen !== 'function') {
  window.fmtWhen = function fmtWhen(ts){
    const d = new Date(ts);
    if (Number.isNaN(d.getTime())) return '';
    const dd = String(d.getDate()).padStart(2,'0');
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const yy = String(d.getFullYear()).slice(-2);
    const HH = String(d.getHours()).padStart(2,'0');
    const MI = String(d.getMinutes()).padStart(2,'0');
    return `${dd}/${mm}/${yy} @ ${HH}:${MI}`;
  };
}

// Helpers (define only if missing)
if (typeof window.eqName !== 'function') {
  window.eqName = (a,b) => String(a||'').trim().toLowerCase() === String(b||'').trim().toLowerCase();
}
if (typeof window.isOfficialGame !== 'function') {
  window.isOfficialGame = g => Array.isArray(g?.players) && g.players.length >= 2;
}
if (typeof window.isPracticeGame !== 'function') {
  window.isPracticeGame = g => Array.isArray(g?.players) && g.players.length === 1;
}

// Override readers to fetch **only** from cloud and dedupe by a stable key
window.getGamesForMode = async function getGamesForMode(mode){
  try {
    let cloudGames = await cloudFetchAllGamesAsLocal();
    cloudGames = Array.isArray(cloudGames) ? cloudGames : [];

    // Filter by mode
    const filtered = cloudGames.filter(g =>
      mode === 'official' ? isOfficialGame(g) : isPracticeGame(g)
    );

    // De-dup by stable key (ts | players(lowercased) | totals)
    const map = new Map();
    const stableKey = (g) => {
      const players = (g.players || [])
        .map(p => (p && p.name) ? String(p.name).trim().toLowerCase() : '')
        .join(',');
      return [g.ts || '', players, (g.totals || []).join(',')].join('|');
    };
    for (const g of filtered) {
      const key = stableKey(g);
      if (!map.has(key)) map.set(key, g);
    }
    return [...map.values()];
  } catch (e) {
    console.error('getGamesForMode (cloud-only) failed', e);
    return [];
  }
};

window.getMatchesOfficial = async function getMatchesOfficial(){
  try {
    const cloudMatches = await cloudFetchAllMatchesAsLocal();
    const list = Array.isArray(cloudMatches) ? cloudMatches : [];

    // De-dup by ts | players(lowercased)
    const map = new Map();
    const stableKey = (m) => {
      const players = (m.players || [])
        .map(p => (p && p.name) ? String(p.name).trim().toLowerCase() : '')
        .join(',');
      return [m.ts || '', players].join('|');
    };
    for (const m of list) {
      const key = stableKey(m);
      if (!map.has(key)) map.set(key, m);
    }
    return [...map.values()];
  } catch (e) {
    console.error('getMatchesOfficial (cloud-only) failed', e);
    return [];
  }
};

// Recover missing High Scores by scanning cloud Games for a recent window (default 24h).
async function recoverHighScoresFromCloudWindow(hours = 24){
  if (!ensureCloudInit()) { toast('Cloud not initialised'); return { inserted:0, scanned:0, skipped:0 }; }
  const now = Date.now();
  const fromIso = new Date(now - (hours * 60 * 60 * 1000)).toISOString();
  const toIso   = new Date(now + (5 * 60 * 1000)).toISOString(); // small future skew for device time drift

  let scanned = 0, inserted = 0, skipped = 0;
  let rows = [];
  try {
    const { data, error } = await sb
      .from(TABLE_GAMES)
      .select('created_at, state, totals')
      .gte('created_at', fromIso)
      .lte('created_at', toIso)
      .order('created_at', { ascending: true });
    if (error) throw error;
    rows = data || [];
  } catch (e) {
    console.error('recover HS: fetch games failed', e);
    toast('Recover HS failed: could not fetch games');
    return { inserted, scanned, skipped };
  }

  for (const g of rows) {
    scanned++;
    const players = (g?.state?.players || [])
      .map(p => (typeof p === 'string') ? { name: p } : p)
      .filter(Boolean);
    const totals = Array.isArray(g?.totals) ? g.totals : [];
    const ts = g?.created_at || new Date().toISOString();
    const isSingle = players.length === 1;
    const table = isSingle
      ? (typeof TABLE_HS_PRACTICE !== 'undefined' ? TABLE_HS_PRACTICE : 'high_scores_practice')
      : (typeof TABLE_HS_LEAGUE   !== 'undefined' ? TABLE_HS_LEAGUE   : 'high_scores');

    for (let i = 0; i < players.length; i++) {
      const name  = players[i]?.name || '';
      const score = Number(totals[i] || 0);
      if (!name || score <= 0) continue;
      try {
        const ok = await cloudInsertHighScoreIfMissing(table, name, score, ts);
        if (ok) inserted++; else skipped++;
      } catch (e) {
        console.error('recover HS: insert failed', e);
        skipped++;
      }
    }
  }

  return { inserted, scanned, skipped };
}

/*****************
 * BACKFILL: Sync all local data â†’ Supabase
 *****************/
  async function backfillLocalGamesToCloud() {
    const games = (typeof getGameLog === 'function') ? (getGameLog() || []) : [];
    let inserted = 0, hs = 0, playerRows = 0;
    for (const g of games) {
      try {
        const players = (g.players || []).map(p => typeof p === 'string' ? { name:p } : p).filter(Boolean);
        const totals  = Array.isArray(g.totals) ? g.totals : [];
        const isSingle = players.length === 1;
        const ts = g.ts || new Date().toISOString();

        // --- games table
        if (typeof TABLE_GAMES !== 'undefined') {
          const payload = {
            created_at: ts,
            state: { players, board: g.board || null },
            totals,
            finished: true,
            match_id: g.match_id || null
          };
          try {
            const { error } = await sb.from(TABLE_GAMES).insert(payload);
            if (!error) inserted++;
          } catch (e) {
            // attempt upsert on conflict(created_at) if supported
            try {
              const { error } = await sb.from(TABLE_GAMES).upsert(payload);
              if (!error) inserted++;
            } catch(_) {}
          }
        }

        // --- high scores tables
        if (typeof cloudInsertHighScore === 'function') {
          for (let i = 0; i < players.length; i++) {
            const name = players[i]?.name || `Player ${i+1}`;
            const score = Number(totals[i] || 0);
            if (!name || score <= 0) continue;
            try { await cloudInsertHighScore(name, score, isPractice); hs++; } catch(_) {}
          }
        }

        // --- player_games (optional; skipped when using a view like `player_games_union`)
        if (ENABLE_PLAYER_GAMES_WRITES && typeof TABLE_PLAYER_GAMES !== 'undefined' && players.length) {
          const sorted = totals.map((t,i)=>({t:Number(t||0),i})).sort((a,b)=>b.t-a.t);
          const posByIdx = Array(players.length).fill(null);
          sorted.forEach((o,rank)=>{ posByIdx[o.i] = rank+1; });
          for (let i=0;i<players.length;i++){
            const row = {
              sheet_id: g.sheet_id || null,
              player: players[i]?.name || `Player ${i+1}`,
              score: Number(totals[i] || 0),
              position: posByIdx[i] || null,
              ts,
              is_practice: isSingle,
              rounds: (typeof MAX_ROUNDS === 'number' ? MAX_ROUNDS : null)
            };
            try {
              const { error } = await sb.from(TABLE_PLAYER_GAMES).insert(row);
              if (!error) playerRows++;
            } catch(_) {}
          }
        }
      } catch (e) {
        console.error('Backfill game failed', e);
      }
    }
    return { inserted, hs, playerRows, scanned: games.length };
  }
  
  async function backfillLocalMatchesToCloud() {
    const matches = (typeof getMatchLog === 'function') ? (getMatchLog() || []) : [];
    if (typeof TABLE_MATCHES === 'undefined') return { inserted: 0, scanned: matches.length };
    let inserted = 0;
    for (const m of matches) {
      try {
        const payload = {
          id: m.id || null,
          created_at: m.ts || new Date().toISOString(),
          players: (m.players || []).map(p => typeof p === 'string' ? { name:p } : p),
          wins: m.wins || [],
          total_games: m.games || (Array.isArray(m.history) ? m.history.length : null),
          history: (m.history || []).map(g => ({ totals: g.totals || [] }))
        };
        try {
          const { error } = await sb.from(TABLE_MATCHES).insert(payload);
          if (!error) inserted++;
        } catch(_) {
          try {
            const { error } = await sb.from(TABLE_MATCHES).upsert(payload);
            if (!error) inserted++;
          } catch(e) { console.warn('match upsert failed', e); }
        }
      } catch (e) {
        console.error('Backfill match failed', e);
      }
    }
    return { inserted, scanned: matches.length };
  }
  
  async function runBackfillAll(){
    if (!ensureCloudInit()) { toast('Cloud not initialised'); return; }
    const btn = document.getElementById('backfillAllBtn');
    if (btn) { btn.disabled = true; btn.textContent = 'Backdatingâ€¦'; }
    toast('Starting backdate â€” syncing local â†’ cloud');
    try {
      const gamesRes   = await backfillLocalGamesToCloud();
      const matchesRes = await backfillLocalMatchesToCloud();
      const msg = `Backdate done.
  Games: ${gamesRes.inserted}/${gamesRes.scanned} to cloud
  High scores rows: ${gamesRes.hs}
  Player-game rows: ${gamesRes.playerRows}
  Matches: ${matchesRes.inserted}/${matchesRes.scanned}`;
      console.log(msg.replace(/\\n/g,' '));
      toast('Backdate complete âœ”');
    } catch (e) {
      console.error(e);
      toast('Backdate failed â€” see console');
    } finally {
      if (btn) { btn.disabled = false; btn.textContent = 'BACKDATE: Sync Local â†’ Cloud'; }
      try { await initialCloudCheck(); } catch(_) {}
    }
  }

// === Player Summary Stats dialog (cloud-only, simple aggregate) ===
window.openPlayerSummaryStatsDialog = async function openPlayerSummaryStatsDialog(playerName, mode){
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal';
  const title   = document.createElement('h3');
  const body    = document.createElement('div'); body.className    = 'modal-body';
  const footer  = document.createElement('div'); footer.className  = 'modal-footer';

  const isPractice = (mode === 'practice' || mode === true);

  title.textContent = 'Player Stats â€” ' + (playerName || 'Unknown') + (isPractice ? ' (Practice)' : ' (Official)');

  async function render(){
    body.innerHTML = '';

    try{
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()){
        const p = document.createElement('p');
        p.textContent = 'Cloud not initialised.';
        body.appendChild(p);
        return;
      }
    } catch(_){}

    // Fetch all games for this player/mode from the cloud view
    let rows = [];
    try{
      const tableName = (typeof TABLE_PLAYER_GAMES !== 'undefined' && TABLE_PLAYER_GAMES)
        ? TABLE_PLAYER_GAMES
        : 'player_games_union';

      const query = sb
        .from(tableName)
        .select('score, position, ts, is_practice, rounds')
        .eq('player', playerName || '')
        .eq('is_practice', !!isPractice)
        .order('ts', { ascending: false })
        .limit(5000);

      const { data, error } = await query;
      if (error) throw error;
      rows = data || [];
    }catch(e){
      console.error('Player summary stats fetch failed', e);
      const p = document.createElement('p');
      p.textContent = 'Failed to load stats.';
      const d = document.createElement('p');
      d.className = 'tag';
      d.textContent = (e && e.message) ? e.message : 'Unknown error';
      body.append(p, d);
      return;
    }

    if (!rows.length){
      const p = document.createElement('p');
      p.textContent = 'No games found for this player in this mode.';
      body.appendChild(p);
      return;
    }

    // Basic aggregates
    const games = rows.length;
    const scores = rows.map(r => Number(r.score || 0));
    const wins   = rows.filter(r => Number(r.position || 0) === 1).length;
    const best   = Math.max(...scores);
    const worst  = Math.min(...scores);
    const total  = scores.reduce((s,v)=> s + v, 0);
    const avg    = total / games;

    const last   = rows[0];
    const lastScore = Number(last.score || 0);
    const lastWhen  = (window.fmtWhen && last.ts) ? window.fmtWhen(last.ts) : (last.ts || '');

    // Build a compact two-column table of stats
    const table = document.createElement('table');
    table.className = 'hs-table compact';

    const tbody = document.createElement('tbody');
    function addRow(label, value){
      const tr = document.createElement('tr');
      const tdL = document.createElement('td'); tdL.textContent = label;
      const tdV = document.createElement('td'); tdV.textContent = value;
      tr.append(tdL, tdV);
      tbody.appendChild(tr);
    }

    const winPct = games ? ((wins / games) * 100).toFixed(1) + '%' : '0%';
    addRow('Games Played', String(games));
    addRow('Wins',        `${wins} (${winPct})`);
    addRow('Best Score',  String(best));
    addRow('Worst Score', String(worst));
    addRow('Average Score', avg.toFixed(1));
    addRow('Last Game Score', String(lastScore));
    addRow('Last Game When',  lastWhen || 'â€”');

    table.appendChild(tbody);
    body.appendChild(table);
  }

  await render();

  const backBtn  = document.createElement('button'); backBtn.className  = 'btn sq-pill'; backBtn.textContent  = 'Return';
  const closeBtn = document.createElement('button'); closeBtn.className = 'btn sq-pill'; closeBtn.textContent = 'Close';
backBtn.onclick  = () => {
  overlay.remove();
  try { 
    if (typeof window.openPlayerStatsModePicker === 'function') {
      window.openPlayerStatsModePicker(name || pretty || playerName);
    }
  } catch(_) {}
};  closeBtn.onclick = () => overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
  modal.tabIndex = 0; modal.focus();
};

// === SHARED: Official Power Rankings calculator =============================
// Returns [{ player, rounds, avgRound, qualifies }] sorted by avgRound desc
// Rules: practice excluded, rounds = 10..20 + D + T + B, last 56 rounds window,
//        qualifies with >= 28 rounds (2 games)
window.getOfficialPowerRows = async function getOfficialPowerRows(){
  const MIN_ROUNDS = 28, WINDOW = 56;
  const INACTIVE_MS = 14 * 24 * 60 * 60 * 1000;
  const nowMs = Date.now();

  // Prefer DB-derived Power Rankings (Supabase view) for correctness + speed.
  try{
    if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) throw new Error('cloud not ready');
    if (typeof sb === 'undefined' || !sb || !sb.from) throw new Error('sb missing');

    const VIEW = 'sprint_league_last5'; // legacy name, now last 4 games (56 rounds)
    let data = null;

    // Attempt with last_played_at (if present); fallback gracefully if the column isn't in the view.
    try{
      const q = await sb.from(VIEW)
        .select('player, rounds_used, avg_per_round, total_points, last_played_at')
        .order('avg_per_round', { ascending: false })
        .limit(300);
      if (q.error) throw q.error;
      data = q.data || [];
    }catch(e1){
      const q = await sb.from(VIEW)
        .select('player, rounds_used, avg_per_round, total_points')
        .order('avg_per_round', { ascending: false })
        .limit(300);
      if (q.error) throw q.error;
      data = (q.data || []).map(r=>({ ...r, last_played_at: null }));
    }

    const rows = (data || []).map(r=>{
      const player = String(r.player || '').trim();
      const rounds = Number(r.rounds_used ?? 0);
      const avgRound = Number(r.avg_per_round ?? 0);
      const lastAt = r.last_played_at || null;
      const recentMs = lastAt ? new Date(lastAt).getTime() : 0;
      const qualifiesRounds = Number.isFinite(rounds) && rounds >= MIN_ROUNDS;
      const qualifiesRecent = lastAt ? (recentMs >= (nowMs - INACTIVE_MS)) : true; // if not available, don't block
      return { player, rounds, avgRound, recentMs, qualifiesRounds, qualifiesRecent };
    }).filter(r=>r.player);

    const out = rows
      .filter(r=> r.qualifiesRounds && r.qualifiesRecent)
      .sort((a,b)=>
        (b.avgRound - a.avgRound) ||
        (b.rounds   - a.rounds)   ||
        (b.recentMs - a.recentMs) ||
        String(a.player).localeCompare(String(b.player))
      );

    return out;
  }catch(_dbErr){
    // Fall through to client-side calculator (older pipeline) if DB view isn't available.
  }

  const allGames = (await __fetchOfficialGames(50000)).map(__normalizeGame)
    .filter(g => !g.is_practice && g.is_practice !== true);

  const gameTs = new Map();
  allGames.forEach(g=>{
    const gid = (g.raw && (g.raw.id||g.raw.game_id)) || g.id || g.game_id;
    if (gid) gameTs.set(gid, g.ts || null);
  });

  let allThrows = [];
  try {
    const ids = allGames.map(g => (g.raw && (g.raw.id||g.raw.game_id)) || g.id || g.game_id).filter(Boolean);
    allThrows = await __fetchThrowsForGames(ids);
  } catch(_) {}

  // fallback from boards if needed
  if (!allThrows.length){
    allGames.forEach(g=>{
      (g.players||[]).forEach(p=>{
        const rows = __throwsFromGamesForPlayer(p, [g]);
        if (rows && rows.length) allThrows.push(...rows);
      });
    });
  }

  // keep only proper rounds with finite points
  allThrows = allThrows.filter(t =>
    typeof t.round_index === 'number' && t.round_index >= 0 && t.round_index <= 13 &&
    Number.isFinite(Number(t.points))
  );

  // sum to per-player round objects (game+round)
  const roundsByPlayer = new Map(); // player -> [{key, ts, ri, sum}]
  allThrows.forEach(t=>{
    const p = String(t.player||'').trim(); if (!p) return;
    const gid = t.game_id;
    const ts  = gameTs.get(gid) || null;
    const ri  = Number(t.round_index||0);
    const pts = Number(t.points||0);
    const key = `${gid}|${ri}`;
    let list = roundsByPlayer.get(p); if (!list){ list=[]; roundsByPlayer.set(p,list); }
    let r = list.find(e=>e.key===key);
    if (!r){ r = { key, ts, ri, sum:0 }; list.push(r); }
    r.sum += pts;
  });

  // build rows (order rounds by time then round index)
  const rowsAll = Array.from(roundsByPlayer.entries()).map(([player,list])=>{
    list.sort((a,b)=>{
      const at=a.ts?new Date(a.ts).getTime():0, bt=b.ts?new Date(b.ts).getTime():0;
      return (at-bt) || (a.ri-b.ri);
    });
    const last = list.slice(-WINDOW);
    const n    = last.length;
    const pts  = last.reduce((s,r)=>s+Number(r.sum||0),0);
    const avgRound = n ? (pts/n) : 0;

    const lastTs = last.length ? (last[last.length-1].ts || null) : null;
    const recentMs = lastTs ? new Date(lastTs).getTime() : 0;

    const qualifiesRounds = n >= MIN_ROUNDS;
    const qualifiesRecent = recentMs >= (nowMs - INACTIVE_MS);

    return { player, rounds:n, avgRound, recentMs, qualifiesRounds, qualifiesRecent };
  });

  // Apply league rules: >= 28 rounds (2 games) AND played within last 14 days
  const rows = rowsAll
    .filter(r => r.qualifiesRounds && r.qualifiesRecent)
    .sort((a,b)=>
      (b.avgRound - a.avgRound) ||
      (b.rounds   - a.rounds)   ||
      (b.recentMs - a.recentMs) ||
      String(a.player).localeCompare(String(b.player))
    );

  return rows;
};

// === Player Progression dialog (perâ€‘game line graph for a player) ===
window.openPlayerProgressionDialog = async function openPlayerProgressionDialog(playerName, mode) {
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal sq-wide-modal';
  modal.style.maxWidth = '980px';
  modal.style.width = '94vw';
  modal.style.maxHeight = '90vh';
  modal.style.overflow = 'hidden';
  const title   = document.createElement('h3');
  const body    = document.createElement('div'); body.className    = 'modal-body';
  const footer  = document.createElement('div'); footer.className  = 'modal-footer';

  const isPractice = (mode === 'practice' || mode === true);
  const labelMode  = isPractice ? 'Practice' : 'Official';
  const safeName   = playerName || 'Unknown';

  title.textContent = `Progression â€” ${safeName} (${labelMode})`;

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  modal.tabIndex = 0;
  modal.focus();

  const close = () => { overlay.remove(); };

  const backBtn  = document.createElement('button');
  backBtn.className  = 'btn sq-pill';
  backBtn.textContent  = 'Back';
  backBtn.onclick  = close;

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn sq-pill';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = close;

  footer.append(backBtn, closeBtn);

  
  // Top controls + chart area
  body.innerHTML = `
    <div style="display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; margin:2px 0 10px;">
      <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <button data-win="all" class="sqPill isActive">All Games</button>
        <button data-win="5" class="sqPill">5 Game AV</button>
        <button data-win="10" class="sqPill">10 Game AV</button>
        <button data-win="20" class="sqPill">20 Game AV</button>
      </div>
      <div id="progHint" style="opacity:.55; font-size:12px; letter-spacing:.04em; text-transform:uppercase;">Bars = games â€¢ Line = selected average</div>
    </div>

    <div id="progChartWrap" style="position:relative; border:1px solid rgba(255,255,255,.08); border-radius:16px; overflow:hidden; background:rgba(5,7,16,.35);">
      <canvas id="progCanvas" width="1000" height="440" style="display:block; width:100%; height:auto;"></canvas>
      <div id="progNoData" style="display:none; position:absolute; inset:0; display:flex; align-items:center; justify-content:center; text-align:center; padding:18px; color:#c9ced8; opacity:.8;">
        No game history yet for this player.
      </div>
    </div>

    <style>
      .sqPill{ border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.04); color:#e7e9ee; padding:8px 12px; border-radius:999px; font-size:12px; letter-spacing:.06em; text-transform:uppercase; cursor:pointer; }
      .sqPill:hover{ background:rgba(255,255,255,.06); }
      .sqPill.isActive{ border-color: rgba(255,132,0,.35); box-shadow: 0 0 0 2px rgba(255,132,0,.12) inset; }
    </style>
  `;

  const winButtons = Array.from(body.querySelectorAll('button[data-win]'));
  const noDataEl = body.querySelector('#progNoData');
  const canvas = body.querySelector('#progCanvas');
  const ctx = canvas.getContext('2d');

  // Load player history (scores per game)
  const data = await loadData();
  if (!data || !data.scores || !data.scores.length) {
    noDataEl.style.display = 'flex';
    return;
  }

  function setActiveWin(key){
    winButtons.forEach(b => b.classList.toggle('isActive', b.getAttribute('data-win') === key));
  }

  function rollingAverage(values, windowSize){
    if (!windowSize) return [];
    const out = new Array(values.length).fill(null);
    let sum = 0;
    for (let i=0;i<values.length;i++){
      sum += values[i];
      if (i >= windowSize) sum -= values[i-windowSize];
      if (i >= windowSize-1) out[i] = sum / windowSize;
    }
    return out;
  }

  function drawProgressionBarChart(scores, mode){
    const W = canvas.width;
    const H = canvas.height;
    const padL = 54, padR = 18, padT = 18, padB = 46;

    ctx.clearRect(0,0,W,H);

    // Background wash to match "Game Race" feel
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.fillRect(0,0,W,H);

    const N = scores.length;
    const maxVal = Math.max(1, ...scores);
    const top = maxVal * 1.12;

    const plotW = W - padL - padR;
    const plotH = H - padT - padB;

    const xForIdx = (i) => padL + (i + 0.5) * (plotW / N);
    const yForVal = (v) => padT + (1 - (v / top)) * plotH;

    // Gridlines + y labels
    const steps = 8;
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillStyle = 'rgba(255,255,255,0.45)';

    for (let s=0;s<=steps;s++){
      const v = (top/steps)*s;
      const y = yForVal(v);
      ctx.beginPath();
      ctx.moveTo(padL, y);
      ctx.lineTo(W-padR, y);
      ctx.stroke();
      const label = Math.round(v);
      ctx.fillText(String(label), 8, y+4);
    }

    // Bars
    const cellW = plotW / N;
    const barW = Math.max(2, cellW * 0.68);
    for (let i=0;i<N;i++){
      const v = scores[i];
      const x = xForIdx(i) - barW/2;
      const y = yForVal(v);
      const h = (padT + plotH) - y;

      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      ctx.fillRect(x, y, barW, h);
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.strokeRect(x, y, barW, h);
    }

    // Average overlay
    const overallAvg = scores.reduce((a,b)=>a+b,0) / scores.length;
    if (mode === 'all'){
      // Overall average as a dashed line
      const y = yForVal(overallAvg);
      ctx.setLineDash([6,6]);
      ctx.strokeStyle = 'rgba(255,132,0,0.55)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padL, y);
      ctx.lineTo(W-padR, y);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = 'rgba(255,132,0,0.75)';
      ctx.fillText(`AVG ${overallAvg.toFixed(1)}`, W - padR - 86, y - 8);
    } else {
      const win = parseInt(mode, 10);
      const series = rollingAverage(scores, win);
      let started = false;
      ctx.strokeStyle = 'rgba(255,132,0,0.75)';
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      for (let i=0;i<N;i++){
        const av = series[i];
        if (av == null) continue;
        const x = xForIdx(i);
        const y = yForVal(av);
        if (!started){ ctx.moveTo(x,y); started = true; }
        else ctx.lineTo(x,y);
      }
      ctx.stroke();

      // Label at end
      const last = series[N-1];
      if (last != null){
        ctx.fillStyle = 'rgba(255,132,0,0.75)';
        ctx.fillText(`${win}G AV ${last.toFixed(1)}`, W - padR - 110, yForVal(last) - 8);
      }
    }

    // X labels (sparse)
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    const tickEvery = Math.max(1, Math.ceil(N / 10));
    for (let i=0;i<N;i+=tickEvery){
      const x = xForIdx(i);
      ctx.fillText(String(i+1), x-4, H - padB + 24);
    }

    // Axis captions
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.fillText('Game #', padL, H - 16);
    ctx.save();
    ctx.translate(16, padT + plotH/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('Score', 0, 0);
    ctx.restore();
  }

  function render(winKey){
    setActiveWin(winKey);
    const mode = (winKey === 'all') ? 'all' : winKey;
    drawProgressionBarChart(data.scores, mode);
  }

  winButtons.forEach(btn => {
    btn.addEventListener('click', () => render(btn.getAttribute('data-win')));
  });

  // Initial render
  render('all');
// Allow closing via ESC or click-outside
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
};

// === Patch Player Stats modal to wire PROGRESSION button ===
(function(){
  if (window.__playerProgressionPatch) return;
  window.__playerProgressionPatch = true;

  function attachProgression(root){
    try{
      const modal = root.querySelector('.modal');
      if (!modal) return;
      const h3 = modal.querySelector('h3');
      if (!h3) return;
      const title = (h3.textContent || '').trim();
      if (!/^Player Stats/i.test(title)) return;

      // Extract player name + mode from title: "Player Stats â€” Name (Practice)"
      let rest = title.replace(/^Player Stats\s*[\u2013\u2014\-]\s*/i, '');
      const isPractice = /\(practice\)/i.test(rest);
      rest = rest.replace(/\(.*\)\s*$/,'').trim();
      const playerName = rest || 'Unknown';

      const buttons = Array.from(modal.querySelectorAll('button'));
      const progBtn = buttons.find(b => (b.textContent || '').trim().toUpperCase() === 'PROGRESSION');
      if (!progBtn) return;

      // Avoid double-binding
      if (progBtn.dataset && progBtn.dataset.progressionBound === '1') return;
      if (progBtn.dataset) progBtn.dataset.progressionBound = '1';

      progBtn.onclick = () => {
        try{
          if (typeof window.openPlayerProgressionDialog === 'function'){
            window.openPlayerProgressionDialog(playerName, isPractice);
          }
        }catch(e){
          console.error('Progression button handler failed', e);
        }
      };
    }catch(e){
      console.error('attachProgression error', e);
    }
  }

  try {
    window.__sqUIMutationBus?.on((muts) => {
      for (const m of (muts || [])){
        for (const n of (m.addedNodes || [])){
          if (n.nodeType !== 1) continue;
          if (n.classList.contains('modal-backdrop')){
            setTimeout(() => attachProgression(n), 0);
          } else if (n.querySelector){
            const backdrop = n.querySelector('.modal-backdrop');
            if (backdrop) setTimeout(() => attachProgression(backdrop), 0);
          }
        }
      }
    });
  } catch(_) {}
})();

(function(){
  // >>> PATCH:game-utils START â€” shared game/time helpers for games lists
  if (window.__gameTimeUtilsPatched) return;
  window.__gameTimeUtilsPatched = true;

  // Canonical timestamp extractor for game rows
  window.getGameTimestamp = function getGameTimestamp(g){
    if (!g || typeof g !== 'object') return null;
    const tsVal = g.ts || g.created_at || g.inserted_at || (g.meta && (g.meta.ts || g.meta.date)) || null;
    if (!tsVal) return null;
    const d = new Date(tsVal);
    return Number.isNaN(d.getTime()) ? null : d;
  };

  // Canonical result line: "A 220 beat B 190 C 175" etc.
  window.formatGameResultLine = function formatGameResultLine(g){
    if (!g) return '';

    const alias = (typeof window !== 'undefined' && typeof window.__sqApplyPlayerAlias === 'function')
      ? window.__sqApplyPlayerAlias
      : (x)=>x;

    const players = (g.players || []).map(p => {
      const nm = (p && typeof p === 'object' && 'name' in p) ? p.name : String(p || '');
      return alias(nm);
    });
    const totals  = Array.isArray(g.totals) ? g.totals : [];

    const ordered = players
      .map((name, i) => ({ name, score: Number(totals[i] || 0) }))
      .filter(x => x.name)
      .sort((a, b) => b.score - a.score);

    let result = 'â€”';
    if (ordered.length >= 2){
      result = `${ordered[0].name} ${ordered[0].score} beat ${ordered[1].name} ${ordered[1].score}`;
      if (ordered.length > 2){
        result += ' ' + ordered.slice(2).map(o => `${o.name} ${o.score}`).join(' ');
      }
    } else if (ordered.length === 1){
      result = `${ordered[0].name} ${ordered[0].score}`;
    }

    return result;
  };

  // Canonical date/time formatter (Europe/London, DD/MM[/YY] HH:MM)
  window.fmtWhen = function fmtWhen(ts, opts){
    if (!ts) return '';
    const d = ts instanceof Date ? ts : new Date(ts);
    if (Number.isNaN(d.getTime())) return '';

    const dd = String(d.getDate()).padStart(2, '0');
    const mm = String(d.getMonth() + 1).padStart(2, '0');
    const yy = String(d.getFullYear()).slice(-2);
    const HH = String(d.getHours()).padStart(2, '0');
    const MI = String(d.getMinutes()).padStart(2, '0');

    if (opts && opts.omitYear) {
      return `${dd}/${mm} ${HH}:${MI}`;
    }
    return `${dd}/${mm}/${yy} ${HH}:${MI}`;
  };
})();
// >>> PATCH:game-utils END

// === Start-screen Vertical Game Ticker (Sky Sports-style) ===
(function(){
  if (window.__verticalGameTickerBootstrapped) return;
  window.__verticalGameTickerBootstrapped = true;

  const IN_MS   = 800;   // slower scroll in (bottom -> centre)
  const HOLD_MS = 3000;  // 3s pause while centred
  const OUT_MS  = 800;   // slower scroll out (centre -> top)

  function formatGameForTicker(g){
    if (!g) return '';

    const result = (typeof window.formatGameResultLine === 'function')
      ? window.formatGameResultLine(g)
      : (function fallbackResult(game){
          const players = (game.players || []).map(p =>
            (p && typeof p === 'object' && 'name' in p) ? p.name : String(p || '')
          );
          const totals  = Array.isArray(game.totals) ? game.totals : [];
          const ordered = players
            .map((name, i) => ({ name, score: Number(totals[i] || 0) }))
            .filter(x => x.name)
            .sort((a, b) => b.score - a.score);

          if (ordered.length >= 2){
            let r = `${ordered[0].name} ${ordered[0].score} beat ${ordered[1].name} ${ordered[1].score}`;
            if (ordered.length > 2){
              r += ' ' + ordered.slice(2).map(o => `${o.name} ${o.score}`).join(' ');
            }
            return r;
          } else if (ordered.length === 1){
            return `${ordered[0].name} ${ordered[0].score}`;
          }
          return 'â€”';
        })(g);

    let when = '';
    if (typeof window.getGameTimestamp === 'function' && typeof window.fmtWhen === 'function'){
      const d = window.getGameTimestamp(g);
      if (d) when = window.fmtWhen(d, { omitYear: true });
    }

    return when ? `${when}  ${result}` : result;
  }

  function startVerticalTicker(container, track, items){
    if (!container || !track || !items || !items.length) return;

    // Ensure only a single line is ever visible
    container.style.overflow = 'hidden';
    container.style.whiteSpace = 'nowrap';

    let idx = 0;

    function step(){
      if (!container.isConnected || !items.length) return;

      // Use container height if set, otherwise fall back to a reasonable line height
      const height = container.clientHeight || 28;

      // Pick the next single line to show
      const line = items[idx % items.length];
      idx = (idx + 1) % items.length;

      // Reset track content and position off-screen at the bottom
      track.style.transition = 'none';
      track.style.transform  = `translateY(${height}px)`;
      track.innerHTML = '';

      const div = document.createElement('div');
      div.textContent = line || '';
      div.style.whiteSpace = 'nowrap';
      track.appendChild(div);

      // Scroll into view (bottom -> centre)
      requestAnimationFrame(() => {
        track.style.transition = `transform ${IN_MS}ms linear`;
        track.style.transform  = 'translateY(0px)';
      });

      // After the hold, scroll out through the top and then show the next single line
      setTimeout(() => {
        track.style.transition = `transform ${OUT_MS}ms linear`;
        track.style.transform  = `translateY(${-height}px)`;
        setTimeout(step, OUT_MS);
      }, IN_MS + HOLD_MS);
    }

    container.classList.remove('hidden');
    step();
  }

  // Public bootstrap used on the Start (details) screen
  window.initVerticalGameTicker = async function initVerticalGameTicker(){
    const ticker = document.getElementById('psTicker');
    const track  = ticker && ticker.querySelector('.track');
    if (!ticker || !track) return;

    try{
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()){
        ticker.classList.add('hidden');
        return;
      }
    }catch(_){}

    let games = [];
    try{
      if (typeof cloudFetchAllGamesAsLocal === 'function'){
        games = await cloudFetchAllGamesAsLocal();
      }
    }catch(e){
      console.error('Vertical ticker: failed to fetch games', e);
    }

    if (!Array.isArray(games) || !games.length){
      ticker.classList.add('hidden');
      return;
    }

    const toTS = (g) => {
      const t = g?.ts || g?.created_at || g?.inserted_at || (g?.meta && (g.meta.ts || g.meta.date)) || null;
      const n = t ? Date.parse(t) : NaN;
      return Number.isFinite(n) ? n : 0;
    };

    games = games.filter(Boolean).sort((a,b)=> toTS(b) - toTS(a)).slice(0, 25);

    const items = games
      .map(formatGameForTicker)
      .filter(line => line && line.trim().length > 0);

    if (!items.length){
      ticker.classList.add('hidden');
      return;
    }

    startVerticalTicker(ticker, track, items);
  };
})();

// Simple High Scores picker for start screen: Match vs Round
window.openStartHighScoresMenu = function openStartHighScoresMenu(){
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal  = document.createElement('div');
  modal.className = 'modal';

  const title  = document.createElement('h3');
  title.textContent = 'High Scores';

  const body   = document.createElement('div');
  body.className = 'modal-body';

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  // Buttons for existing High Scores views
  const matchBtn = document.createElement('button');
  matchBtn.className = 'btn';
  matchBtn.type = 'button';
  matchBtn.textContent = 'High Scores (Match)';

  const roundBtn = document.createElement('button');
  roundBtn.className = 'btn';
  roundBtn.type = 'button';
  roundBtn.textContent = 'High Scores (Round)';

  // Stack vertically with a small gap
  const row1 = document.createElement('div');
  row1.className = 'row';
  row1.style.cssText = 'justify-content:center; gap:8px; flex-wrap:wrap; margin-top:4px;';
  row1.appendChild(matchBtn);

  const row2 = document.createElement('div');
  row2.className = 'row';
  row2.style.cssText = 'justify-content:center; gap:8px; flex-wrap:wrap; margin-top:8px;';
  row2.appendChild(roundBtn);

  body.append(row1, row2);

  // Footer actions
  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn sq-pill';
  closeBtn.type = 'button';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();
  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  // Wire through to existing dialogs, preserving previous behaviour
  matchBtn.onclick = () => {
    overlay.remove();
    if (typeof window.openHighScoresMenuDialog === 'function') {
      window.openHighScoresMenuDialog();
    }
  };

  roundBtn.onclick = () => {
    overlay.remove();
    if (typeof window.openRoundHighScoresDialog === 'function') {
      window.openRoundHighScoresDialog();
    }
  };

  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) overlay.remove();
  });

  overlay.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') overlay.remove();
  });

  modal.tabIndex = 0;
  modal.focus();
};

// --- Global modal helpers (some parts of the file define modal helpers in inner scopes) ---
// Keep these on window so start-screen / global handlers can always open/close modals safely.
window.openModal = window.openModal || function(id){
  const el = document.getElementById(id);
  if (el) el.classList.remove('hidden');
};
window.closeModal = window.closeModal || function(id){
  const el = document.getElementById(id);
  if (el) el.classList.add('hidden');
};

// === Start screen layout arranger (non-destructive; rebuilds start-actions) ===

function arrangeStartActions(){
  try{
    const host = document.querySelector('#details .start-actions.column') || document.querySelector('.start-actions.column');
    if (host){ host.style.alignItems = 'center'; host.style.textAlign = 'center'; }
    if (!host) return;
    try{ host.style.alignItems='center'; host.style.textAlign='center'; host.style.width='100%'; }catch(_){ }
    const doc = document;

    // helpers
    const mkRow = (btn) => {
      const row = doc.createElement('div');
      row.className = 'row';
      row.style.cssText = 'justify-content:center; gap:8px; flex-wrap:wrap; margin-top:8px;';
      row.appendChild(btn);
      return row;
    };
    const mkSpacer = (h) => {
      const d = doc.createElement('div');
      d.style.height = (h || 16) + 'px';
      return d;
    };
    const setSquareLabel = (btn, lines) => {
      const txt = (lines || []).join('\n');
      btn.textContent = txt;
      btn.style.whiteSpace = 'pre-line';
    };

    // ensure / find buttons
    const newBtn = document.getElementById('questBtn');
    if (newBtn) newBtn.textContent = 'NEW GAME';

    // New Home button: opens the Start Game modal
    let startGameBtn = document.getElementById('startGameBtn');
    if (!startGameBtn){
      startGameBtn = doc.createElement('button');
      startGameBtn.id = 'startGameBtn';
      startGameBtn.className = 'btn primary big';
      startGameBtn.type = 'button';
    }
    startGameBtn.innerHTML = '<span class="btnIcon">â–¶</span><span class="btnLabel">START GAME</span>';
    startGameBtn.onclick = () => openModal('startGameModal');

    const resumeBtn = document.getElementById('resumeBtn');
    if (resumeBtn) resumeBtn.textContent = 'Resume Game';

    // Latest Scores
    let latest = document.getElementById('latestScoresBtn');
    if (!latest){
      latest = doc.createElement('button');
      latest.id = 'latestScoresBtn';
      latest.className = 'btn';
      latest.type = 'button';
      latest.textContent = 'Latest Scores';
    }

    // League / Rankings -> footer square
    let league = document.getElementById('leagueRankingsBtn');
    if (!league){
      league = doc.createElement('button');
      league.id = 'leagueRankingsBtn';
      league.className = 'btn';
      league.type = 'button';
    }

    // Player Stats -> footer square
    let stats = document.getElementById('playerStatsBtn');
    if (!stats){
      stats = doc.createElement('button');
      stats.id = 'playerStatsBtn';
      stats.className = 'btn';
      stats.type = 'button';
    }

    // Admin
    let admin = document.getElementById('adminBtn') ||
                document.getElementById('adminCodeBtn') ||
                Array.from(document.querySelectorAll('#details button, button'))
                  .find(b => /admin code|^admin$/i.test((b.textContent || b.innerText || '').trim()));
    if (!admin){
      admin = doc.createElement('button');
      admin.id = 'adminBtn';
      admin.className = 'btn small';
      admin.type = 'button';
      admin.textContent = 'Admin';
    } else {
      admin.textContent = 'Admin';
    }
    // wire handlers (idempotent, safe if functions missing)
    if (typeof window.openLatestScoresDialog === 'function') latest.onclick = window.openLatestScoresDialog;
    if (typeof window.openLeagueRankingsDialog === 'function') league.onclick = window.openLeagueRankingsDialog;

    // STATS should always start at: Player Stats â€“ Select Player
    if (typeof openPlayerStatsSelectDialog === 'function') {
      stats.onclick = () => openPlayerStatsSelectDialog();
    } else if (typeof window.openPlayerStatsLookupDialog === 'function') {
      stats.onclick = window.openPlayerStatsLookupDialog;
    } else if (typeof window.openStatsHubDialog === 'function') {
      stats.onclick = window.openStatsHubDialog;
    }

    if (typeof window.openAdminPasswordModal === 'function') {
      admin.onclick = window.openAdminPasswordModal;
    } else if (typeof window.openAdminHub === 'function') {
      admin.onclick = window.openAdminHub;
    }

    // ===== START GAME MODAL OPTIONS =====
    const startGameBody = document.getElementById('startGameModalBody');
    if (startGameBody){
            const ICONS = {
        match: "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2'/><circle cx='8.5' cy='7' r='3'/><path d='M23 21v-2a4 4 0 0 0-3-3.87'/><path d='M16 3.13a3 3 0 0 1 0 5.74'/></svg>",
        tournament: "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M8 21h8'/><path d='M12 17v4'/><path d='M7 4h10v3a5 5 0 0 1-10 0V4z'/><path d='M5 6h2v2a4 4 0 0 1-2-2z'/><path d='M19 6h-2v2a4 4 0 0 0 2-2z'/></svg>",
        practice: "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='8'/><circle cx='12' cy='12' r='4'/><path d='M12 2v2'/><path d='M22 12h-2'/><path d='M12 22v-2'/><path d='M2 12h2'/></svg>",
        training: "<svg viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M2 12h2'/><path d='M20 12h2'/><path d='M6 9v6'/><path d='M18 9v6'/><path d='M6 12h12'/><path d='M4 10v4'/><path d='M20 10v4'/></svg>"
      };

      const makeOpt = (id, mode, title, desc, soon, enabled) => {
        let b = document.getElementById(id);
        if (!b){
          b = doc.createElement('button');
          b.id = id;
          b.type = 'button';
        }
        b.className = 'sg-opt sg-opt--' + mode + (enabled ? '' : ' disabled');
        b.disabled = false; // keep clickable for feedback
        b.setAttribute('aria-disabled', enabled ? 'false' : 'true');
        b.innerHTML =
          '<div class="sg-ico">' + (ICONS[mode] || '') + '</div>' +
          '<div class="sg-copy">' +
            '<div class="sg-opt-top">'+
              '<div class="sg-opt-title">'+ title +'</div>'+
              (soon ? '<div class="sg-opt-soon">'+ soon +'</div>' : '')+
            '</div>'+
            '<div class="sg-opt-desc">'+ desc +'</div>' +
          '</div>';
        if (!enabled){
          b.onclick = (e) => { e.preventDefault(); toast('Coming soon!'); };
        }
        return b;
      };

      // MATCH PLAY = the existing NEW GAME logic (questBtn)
      const matchPlay = document.getElementById('questBtn');
      if (matchPlay){
        matchPlay.className = 'sg-opt sg-opt--match';
        matchPlay.disabled = false;
        matchPlay.setAttribute('aria-disabled','false');
        matchPlay.innerHTML =
          '<div class="sg-ico">' + (ICONS.match || '') + '</div>' +
          '<div class="sg-copy">' +
            '<div class="sg-opt-top">'+
              '<div class="sg-opt-title">MATCH PLAY</div>'+
            '</div>'+
            '<div class="sg-opt-desc">GAMES BETWEEN 1 AND 6 PEOPLE</div>' +
          '</div>';
        if (!matchPlay.dataset.modeBound){
          matchPlay.dataset.modeBound = '1';
          matchPlay.addEventListener('click', ()=>{ window.__sqSelectedMode = 'match'; }, true);
        }
      }

      const tournament = makeOpt('tournamentBtn', 'tournament', 'TOURNAMENT', 'COMING SOON', 'COMING SOON', false);
      const practice  = makeOpt('practiceBtn', 'practice', 'PRACTICE', 'SCORES DO NOT COUNT TOWARDS HIGH SCORES OR STATS', '', true);
      // Practice uses the same flow as Match Play, but forces non-official logging.
      practice.onclick = (e)=>{
        e.preventDefault();
        window.__sqSelectedMode = 'practice';
        closeModal('startGameModal');
        show('players');
      };
      const training  = makeOpt('trainingBtn', 'training', 'TRAINING', 'HONE AND PRACTICE SPECIFIC SKILLS', 'COMING SOON', false);

      startGameBody.innerHTML = '';
      if (matchPlay) startGameBody.appendChild(matchPlay);
      startGameBody.appendChild(tournament);
      startGameBody.appendChild(practice);
      startGameBody.appendChild(training);
    }
// Close button in modal
    const closeStart = document.getElementById('closeStartGameModalBtn');
    if (closeStart) closeStart.onclick = () => closeModal('startGameModal');

    // Backdrop + Esc close (bind once)
    const startGameModal = document.getElementById('startGameModal');
    if (startGameModal && !startGameModal.dataset.bound){
      startGameModal.dataset.bound = '1';
      startGameModal.addEventListener('click', (e)=>{
        if (e.target === startGameModal) closeModal('startGameModal');
      });
      document.addEventListener('keydown', (e)=>{
        if (e.key === 'Escape' && !startGameModal.classList.contains('hidden')) closeModal('startGameModal');
      });
    }

    // Close modal when choosing an option (without overwriting existing handlers)
    if (newBtn && !newBtn.dataset.sgClose){
      newBtn.dataset.sgClose = '1';
      newBtn.addEventListener('click', () => closeModal('startGameModal'));
    }
// ===== HOME MAIN COLUMN =====
    // START GAME > (big)
    // Resume Game (big)
    // GAP
    // Latest Scores
    const frag = doc.createDocumentFragment();
    const hasSaved = (typeof getSavedState === 'function' && !!getSavedState());

    if (startGameBtn) frag.appendChild(startGameBtn);

    if (resumeBtn) {
      resumeBtn.innerHTML = '<span class="btnIcon">â†º</span><span class="btnLabel">RESUME GAME</span>';
      resumeBtn.classList.add('secondary');
      resumeBtn.style.display = hasSaved ? '' : 'none';
      if (hasSaved) frag.appendChild(resumeBtn);
    }

    // Latest Scores moved into League & Rankings
    // ===== HOME LIVE PRINTER =====
    let printer = document.getElementById('homeLivePrinter');
    if (!printer){
      printer = doc.createElement('div');
      printer.id = 'homeLivePrinter';
      printer.className = 'home-live-printer';
      printer.innerHTML = ''+
        '<div class="lp-top">'+
          '<span id="homeLpTopLine" class="lp-title">// LIVE UPDATES //</span>'+
          '<span class="lp-badge"><span class="lp-badgeText">TESTING</span><span class="lp-badgeSep">â€¢</span><span class="lp-badgeText">COMING SOON</span><span class="lp-dots"><i></i><i></i><i></i></span></span>'+
        '</div>'+
        '<div class="lp-rule"></div>'+
        '<div class="lp-mid lp-mid-hold">'+
          '<div class="home-hold-overlay" aria-hidden="true">'+
            '<div class="home-hold-title">TESTING</div>'+
            '<div class="home-hold-sub">COMING SOON</div>'+
            '<div class="home-hold-sim"><span></span><span></span><span></span></div>'+
          '</div>'+
          '<table class="lp-table" aria-label="Latest games">'+
            '<tbody id="homeLivePrinterRows"></tbody>'+
          '</table>'+
        '</div>'+
        '<div class="lp-rule"></div>';
    }
    frag.appendChild(printer);

    // (removed) NEW PLAYERS ticker in VIDE

    // Mini league panels under VIDE
    let mini = document.getElementById('homeMiniLeagues');
    if (!mini) {
      mini = document.createElement('div');
      mini.id = 'homeMiniLeagues';
      mini.className = 'home-mini-leagues';
      mini.innerHTML = `
        <div class="home-mini-printer" aria-label="High Score League">
          <div class="lp-top">
            <span class="lp-title">HIGH SCORE LEAGUE</span>
            <span class="lp-badge"><span class="lp-badgeText">TESTING</span><span class="lp-badgeSep">â€¢</span><span class="lp-badgeText">COMING SOON</span><span class="lp-dots"><i></i><i></i><i></i></span></span>
          </div>
          <div class="lp-rule"></div>
          <div class="lp-mid lp-mid-hold">
            <div class="home-hold-overlay home-hold-overlay-mini" aria-hidden="true">
              <div class="home-hold-title">TESTING</div>
              <div class="home-hold-sub">COMING SOON</div>
              <div class="home-hold-sim"><span></span><span></span><span></span></div>
            </div>
            <table class="mini-table mini-table-plain" aria-label="High Score League Top 5">
              <tbody id="homeHsLeagueRows">
                <tr class="mini-loading"><td colspan="3" class="home-mini-muted"><em>TESTINGâ€¦</em></td></tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="home-mini-printer" aria-label="Power Rankings">
          <div class="lp-top">
            <span class="lp-title">POWER RANKINGS</span>
            <span class="lp-badge"><span class="lp-badgeText">TESTING</span><span class="lp-badgeSep">â€¢</span><span class="lp-badgeText">COMING SOON</span><span class="lp-dots"><i></i><i></i><i></i></span></span>
          </div>
          <div class="lp-rule"></div>
          <div class="lp-mid lp-mid-hold">
            <div class="home-hold-overlay home-hold-overlay-mini" aria-hidden="true">
              <div class="home-hold-title">TESTING</div>
              <div class="home-hold-sub">COMING SOON</div>
              <div class="home-hold-sim"><span></span><span></span><span></span></div>
            </div>
            <table class="mini-table mini-table-plain" aria-label="Power Rankings Top 5">
              <tbody id="homePowerLeagueRows">
                <tr class="mini-loading"><td colspan="3" class="home-mini-muted"><em>TESTINGâ€¦</em></td></tr>
              </tbody>
            </table>
          </div>
        </div>
      `;
      frag.appendChild(mini);
    }

    host.innerHTML = '';
    host.appendChild(frag);

    // Push footer buttons (Player Hub / Stats / League / Admin) to the bottom of the screen
    try{
      const details = document.getElementById('details');
      const sr = document.querySelector('.start-secondary-row');
      if (details && sr){
        details.style.display = 'flex';
        details.style.flexDirection = 'column';
        details.style.minHeight = '100vh';
        let sp = document.getElementById('homeFlexSpacer');
        if (!sp){
          sp = doc.createElement('div');
          sp.id = 'homeFlexSpacer';
          sp.style.flex = '1';
          details.insertBefore(sp, sr);
        }
      }
    }catch(_e){}

    

async function updateHomeMiniLeagues(){
  await cloudRefreshPlayerDirectory(false);
  const hsBody = document.getElementById('homeHsLeagueRows');
  const prBody = document.getElementById('homePowerLeagueRows');
  if(!hsBody && !prBody) return;

  const esc = (typeof escHtml === 'function') ? escHtml : (s)=>String(s||'');
  const setMsg = (body, msg)=>{ if(body) body.innerHTML = `<tr class="mini-loading"><td colspan="3" class="home-mini-muted"><em>${esc(msg)}</em></td></tr>`; };

  if(hsBody) setMsg(hsBody,'Loadingâ€¦');
  if(prBody) setMsg(prBody,'Loadingâ€¦');

  try{
    // High Score League (best match score per player name)
if(hsBody){
  const unhold = (body)=>{
    try{
      const wrap = body?.closest?.('.home-mini-printer');
      if(!wrap) return;
      const mid = wrap.querySelector('.lp-mid');
      if(mid) mid.classList.remove('lp-mid-hold');
      const ov = wrap.querySelector('.home-hold-overlay');
      if(ov) ov.style.display = 'none';
      const badge = wrap.querySelector('.lp-badge');
      if(badge) badge.style.display = 'none';
    }catch(_e){}
  };

  let rows = [];
  try{
    rows = (typeof cloudListHighScores === 'function') ? (await cloudListHighScores(false, 500)) : [];
  }catch(e){
    rows = [];
  }

  // If the query executed (even if empty), this panel is no longer "testing".
  unhold(hsBody);

  const best = new Map(); // key: name lower
  for(const r of (rows || [])){
    if(!r) continue;
    const name = String(r.name || r.player || r.player_name || 'â€”').trim() || 'â€”';
    const key  = name.toLowerCase();
    const score = Number(r.score);
    if(!Number.isFinite(score)) continue;
    const ts = r.ts || r.created_at || r.event_ts || '';
    const prev = best.get(key);
    if(!prev || score > prev.score || (score === prev.score && String(ts) > String(prev.ts))){
      best.set(key, { name, score, ts });
    }
  }

  const list = Array.from(best.values())
    .sort((a,b)=> (b.score - a.score) || String(a.name).localeCompare(String(b.name)) );

  try{ const st = window.__homeLivePrinterState; if(st && list.length) st.globalMaxScore = Number(list[0].score)||0; }catch(_e){}

  const top = list.slice(0,5);
  if(!top.length){
    setMsg(hsBody,'No data');
  }else{
    hsBody.innerHTML = top.map((x,i)=>
      `<tr><td class="mini-rank">${i+1}</td><td class="mini-name">${esc(sqDisplayNameForPlayerField(x.name))}</td><td class="mini-val">${x.score}</td></tr>`
    ).join('');
  }
}

// Power Rankings (official; last 56 rounds; >=28 rounds (2 games); active in last 14 days)
    if(prBody){
      const unhold = (body)=>{
        try{
          const wrap = body?.closest?.('.home-mini-printer');
          if(!wrap) return;
          const mid = wrap.querySelector('.lp-mid');
          if(mid) mid.classList.remove('lp-mid-hold');
          const ov = wrap.querySelector('.home-hold-overlay');
          if(ov) ov.style.display = 'none';
          const badge = wrap.querySelector('.lp-badge');
          if(badge) badge.style.display = 'none';
        }catch(_e){}
      };

      let rows = [];
      try{ rows = (typeof getOfficialPowerRows === 'function') ? (await getOfficialPowerRows()) : []; }catch(e){ rows = []; }

      // If the query executed (even if empty), this panel is no longer "testing".
      unhold(prBody);

      const list = (rows || []).filter(r => r && r.player);
      const top = list.slice(0,5);

      if(!top.length){
        setMsg(prBody,'No data');
      }else{
        prBody.innerHTML = top.map((r,i)=>{
          const avg = Number(r.avgRound ?? r.avg ?? 0);
          return `<tr><td class="mini-rank">${i+1}</td><td class="mini-name">${esc(sqDisplayNameForPlayerField(r.player))}</td><td class="mini-val">${(Number.isFinite(avg) ? avg : 0).toFixed(2)}</td></tr>`;
        }).join('');
      }
    }
  }catch(e){
    if(hsBody) setMsg(hsBody,'Unavailable');
    if(prBody) setMsg(prBody,'Unavailable');
  }
}

// Kick mini leagues once on home render
    try{ updateHomeMiniLeagues && updateHomeMiniLeagues(); }catch(_e){}

    // Live-printer updater (bind once)
    try{
      if (!window.__homeLivePrinterState){
        window.__homeLivePrinterState = {
          dots: 0,
          lastSig: null,
          tick: 0,
          lastSyncMs: 0,
          syncing: false,
          forceFullEvery: 6, // every N syncs, hard refresh rows
          syncCount: 0
        };
      }
      const lpSig = (g) => {
        if (!g) return '';
        const ts = String(g.event_ts ?? g.ts ?? g.created_at ?? g.createdAt ?? '');
        const id = String(g.event_id ?? g.match_id ?? g.game_id ?? '');
        if (id && ts) return `${ts}::${id}`;
        if (id) return id;
        if (ts) return ts;
        return '';
      };

      const LP_BUFFER = 30;
      const LP_VISIBLE = 9;
      // Cloud availability helper (avoid ReferenceError on older builds)
      const lpCloudOK = () => {
        try {
          if (typeof ensureCloudInit === 'function') return !!ensureCloudInit();
          return !!window.sb;
        } catch(_e) { return !!window.sb; }
      };


      const lpPad2 = (n) => String(Number(n) || 0).padStart(2, '0');
      const lpFmtDT = (g) => {
        const ts = g.event_ts || g.ts || g.created_at || g.createdAt;
        const d = ts ? new Date(ts) : null;
        if (!d || isNaN(d.getTime())) return '--/-- / --:--';
        return `${lpPad2(d.getDate())}/${lpPad2(d.getMonth()+1)} / ${lpPad2(d.getHours())}:${lpPad2(d.getMinutes())}`;
      };
      const lpNormalizeBull = (s) => String(s || '')
        .replace(/\bSB(\d+)\b/g, 'OB$1')
        .replace(/\bDB(\d+)\b/g, 'IB$1')
        .replace(/\bB(\d+)\b/g, 'OB$1')
        .trim();

      const lpFmtRoundPB = (rest) => {
        // Expected source examples:
        // "ROUND PB / 18s â€” James (90) â€” S2 / D0 / T1"
        // "ROUND PB / 18s - James (90) - S2 / D0 / T1 / SB1"
        const r = String(rest || '').replace(/\s*_\s*/g, ' ').replace(/\s{2,}/g, ' ').trim();
        const m = r.match(/ROUND\s*PB\s*\/\s*(\d+)\s*s?\s*[â€“â€”-]\s*([^()â€“â€”-]+?)\s*\((\d+)\)\s*[â€“â€”-]\s*(.+)$/i);
        if (!m) return null;

        const secs = m[1];
        const name = String(m[2] || '').trim();
        const score = m[3];
        const countsRaw = String(m[4] || '').trim();

        const counts = lpNormalizeBull(countsRaw)
          .split(/\s*\/\s*/)
          .map(x => x.trim())
          .filter(Boolean)
          .join(' / ');

        return (`ROUND PB / ${name} - ${secs}s (${score}) ${counts}`.trim() + ' â­').trim();
      };

      const lpMaybeGameRecord = (rest) => {
        // If a GAME PB equals the current league-high score, treat it as a game record.
        try{
          const st = window.__homeLivePrinterState;
          const max = Number(st && st.globalMaxScore);
          if (!Number.isFinite(max) || max <= 0) return null;

          const r = String(rest || '').replace(/\s{2,}/g,' ').trim();
          if (!/^GAME\s*PB\b/i.test(r)) return null;

          const m = r.match(/^GAME\s*PB\s*(?:[\/\-â€“â€”]|â€”|â€“|-)+\s*([^()]+?)\s*\((\d+)\)/i);
          if (!m) return null;

          const name = String(m[1] || '').trim();
          const score = Number(m[2]);
          if (!Number.isFinite(score)) return null;

          if (score === max) {
            return `NEW GAME RECORD SCORE - ${name} - ${score} ðŸ¥‡`;
          }
        }catch(_e){}
        return null;
      };


      const lpFmtLine = (g) => {
        // Prefer server-provided line_text, but normalize formatting for UI.
        const raw = String((g && g.line_text) ? g.line_text : '').trim() || null;

        const buildFallback = () => {
          const dt = lpFmtDT(g);
          const winnerName = g.winner_name || '?';
          const winnerScore = (g.winner_score ?? '?');
          const opp = g.opponents_text || '';
          return `${dt} ${winnerName} (${winnerScore})${opp ? ' bts ' + opp : ''}`;
        };

        const src = raw || buildFallback();

        // Expect legacy format: "DD/MM _ HH:MM _ rest"
        const m = src.match(/^(\d{2}\/\d{2})\s*[_\-â€“â€”]\s*(\d{2}:\d{2})\s*[_\-â€“â€”]\s*(.+)$/);
        if (m) {
          const ddmm = m[1];
          const hhmm = m[2];
          let rest = String(m[3] || '').trim();

          // Normalize separators
          rest = rest.replace(/\s*_\s*/g, ' ').replace(/\s{2,}/g, ' ').trim();

                    // ALERT (under 100 etc) should not show date/time.
          const isUnder100 = (/under\s*100/i.test(rest) || /^ALERT\b/i.test(rest));
          if (isUnder100) {
            // Ensure it starts with ALERT, then prefix ðŸš¨
            if (!/^ALERT\b/i.test(rest)) rest = `ALERT - ${rest}`;
            rest = rest.replace(/^ALERT\s*[-â€“â€”]\s*/i, 'ALERT - ');
            return (`ðŸš¨ ${rest}`.trim());
          }

          // ROUND WR (highest round ever) should be highlighted.
          if (/\bROUND\s*(WR|WORLD\s*RECORD|RECORD)\b/i.test(rest)) {
            rest = rest.replace(/^\s*ðŸš¨\s*/,'');
            return (`ðŸš¨ ${rest}`.trim());
          }

// PB/WR lines should not show date/time, and need custom formatting.
          if (/(^|\b)(NEW\s*PB|ROUND\s*PB|PB|WR|WORLD\s*RECORD)\b/i.test(rest)) {
            // "NEW PB" -> "GAME PB"
            rest = rest.replace(/\bNEW\s*PB\b/i, 'GAME PB');

            const rec = lpMaybeGameRecord(rest);
            if (rec) return (`ðŸš¨ ${rec}`.replace(/^ðŸš¨\s*ðŸš¨\s*/,'ðŸš¨ ').trim());

            // Round PB reformat
            const roundPB = lpFmtRoundPB(rest);
            if (roundPB) return (`ðŸš¨ ${roundPB}`.trim());

            if (/^GAME PB\b/i.test(rest)) return (`ðŸš¨ ${(rest + ' ðŸŒŸ').trim()}`.trim());

            // World record / WR etc: just return line without timestamp
            return (`ðŸš¨ ${rest}`.replace(/^ðŸš¨\s*ðŸš¨\s*/,'ðŸš¨ ').trim());
          }

          // Normal match line: "DD/MM / HH:MM ..."
          return `${ddmm} / ${hhmm} ${rest}`;
        }

        // If it contains underscores but not the full pattern, clean them.
        let cleaned = src.replace(/\s*_\s*/g, ' ').replace(/\s{2,}/g,' ').trim();

        // PB/WR lines: strip any leading timestamp if present and normalize wording
        // ALERT (under 100 etc): strip timestamp and prefix ðŸš¨
        if (/under\s*100/i.test(cleaned) || /^ALERT\b/i.test(cleaned)) {
          cleaned = cleaned.replace(/^\d{2}\/\d{2}\s*\/\s*\d{2}:\d{2}\s*/,'').trim() || cleaned;
          if (!/^ALERT\b/i.test(cleaned)) cleaned = `ALERT - ${cleaned}`;
          cleaned = cleaned.replace(/^ALERT\s*[-â€“â€”]\s*/i, 'ALERT - ');
          return (`ðŸš¨ ${cleaned}`.trim());
        }

        // ROUND WR: highlight
        if (/\bROUND\s*(WR|WORLD\s*RECORD|RECORD)\b/i.test(cleaned)) {
          cleaned = cleaned.replace(/^\d{2}\/\d{2}\s*\/\s*\d{2}:\d{2}\s*/,'').trim() || cleaned;
          return (`ðŸš¨ ${cleaned.replace(/^\s*ðŸš¨\s*/,'')}`.trim());
        }

        if (/(^|\b)(NEW\s*PB|ROUND\s*PB|PB|WR|WORLD\s*RECORD)\b/i.test(cleaned)) {
          cleaned = cleaned.replace(/^\d{2}\/\d{2}\s*\/\s*\d{2}:\d{2}\s*/,'').trim() || cleaned;
          cleaned = cleaned.replace(/\bNEW\s*PB\b/i, 'GAME PB');
          const rec = lpMaybeGameRecord(cleaned);
          if (rec) return (`ðŸš¨ ${rec}`.replace(/^ðŸš¨\s*ðŸš¨\s*/,'ðŸš¨ ').trim());
          const roundPB = lpFmtRoundPB(cleaned);
          if (roundPB) return (`ðŸš¨ ${roundPB}`.trim());
          if (/^GAME PB\b/i.test(cleaned)) return (`ðŸš¨ ${(cleaned + ' ðŸŒŸ').trim()}`.trim());
          return cleaned;
        }

        return cleaned;
      };

const lpUpdateMeta = async (games) => {

        // VIDE: hide HIGH SCORES meta row
        return;
        const st = window.__homeLivePrinterState;
        if (!st) return;
        const hsEl = document.getElementById('homeLpHS');
        // High Scores Top 3 (League)
        try {
          const now = Date.now();
          if (!st.hsFetchedAt || (now - st.hsFetchedAt) > 30000) {
            if (typeof cloudListHighScores === 'function') {
              const top3 = await cloudListHighScores(false, 3);
              st.hsTop3 = (top3 || []).slice(0, 3);
              st.hsFetchedAt = now;
            }
          }
          if (hsEl) {
            const t = Array.isArray(st.hsTop3) ? st.hsTop3 : [];
            if (t.length) {
              const parts = t.map((r, i)=>`#${i+1} ${r.name} (${Number(r.score)||0})`);
              hsEl.textContent = parts.join('  |  ');
            } else {
              hsEl.textContent = 'â€”';
            }
          }
        } catch (_) {
          if (hsEl) hsEl.textContent = 'â€”';
        }
      };
      const lpType = (el, text, speedMs = 28) => {
        if (!el) return;
        el.textContent = '';
        let i = 0;
        const t = String(text || '');
        const max = Math.min(t.length, 240);
        const timer = setInterval(()=>{
          i++;
          el.textContent = t.slice(0, i);
          if (i >= max) clearInterval(timer);
        }, speedMs);
      };

      const lpStripBang = (s) => String(s || '').replace(/^ðŸš¨\s*/,'').trim();
      const lpIsRecordLine = (line) => /^NEW GAME RECORD SCORE\b/i.test(lpStripBang(line));
      const lpIsRoundPBLine = (line) => /^ROUND PB\b/i.test(lpStripBang(line));
      const lpIsGamePBLine  = (line) => /^GAME PB\b/i.test(lpStripBang(line));
      const lpIsAlertLine   = (line) => /^ðŸš¨\s*/.test(String(line || '').trim());

      const lpSmoothShiftUp = (tbody, rowH, durationMs, onDone) => {
        if (!tbody) {
          if (onDone) onDone();
          return;
        }
        let doneCalled = false;
        const finish = () => {
          if (doneCalled) return;
          doneCalled = true;
          try {
            // Reset first (no transition), then update content next frame.
            tbody.style.transition = '';
            tbody.style.transform = 'translateY(0)';
            tbody.style.willChange = '';
          } catch (_) {}
          if (onDone) requestAnimationFrame(onDone);
        };
        try {
          tbody.style.willChange = 'transform';
          tbody.style.transition = `transform ${durationMs}ms ease`;
          void tbody.offsetHeight;
          tbody.style.transform = `translateY(-${rowH}px)`;
          tbody.addEventListener('transitionend', (e) => {
            if (e && e.propertyName && e.propertyName !== 'transform') return;
            finish();
          }, { once: true });
          setTimeout(finish, durationMs + 120);
        } catch (_) {
          finish();
        }
      };

      const lpEnsureRows = (lines) => {
        const tbody = document.getElementById('homeLivePrinterRows');
        if (!tbody) return;
        tbody.innerHTML = '';
        (lines || []).slice(0, LP_VISIBLE).forEach((line) => {
          const tr = document.createElement('tr');
          tr.className = 'lp-row';
          const td = document.createElement('td');
          td.className = 'lp-line';
          const sp = document.createElement('span');
          sp.className = 'lp-ellipsis';
          sp.textContent = (line == null ? '' : String(line));
          tr.classList.toggle('lp-record', lpIsRecordLine(line));
          tr.classList.toggle('lp-roundpb', !lpIsRecordLine(line) && lpIsRoundPBLine(line));
          tr.classList.toggle('lp-gamepb', !lpIsRecordLine(line) && lpIsGamePBLine(line));
            tr.classList.toggle('lp-alert', lpIsAlertLine(line));
          tr.classList.toggle('lp-alert', lpIsAlertLine(line));
          td.appendChild(sp);
          tr.appendChild(td);
          tbody.appendChild(tr);
        });
        // pad to exactly LP_VISIBLE rows
        while (tbody.querySelectorAll('tr.lp-row').length < LP_VISIBLE) {
          const tr = document.createElement('tr');
          tr.className = 'lp-row';
          const td = document.createElement('td');
          td.className = 'lp-line';
          const sp = document.createElement('span');
          sp.className = 'lp-ellipsis';
          sp.textContent = '';
          td.appendChild(sp);
          tr.appendChild(td);
          tbody.appendChild(tr);
        }
      };

      // Allow other parts of the app to inject a one-off LIVE UPDATES line (e.g., NEW PLAYER)
      // Usage: window.__homeLivePrinterInjectLine('ðŸš¨ NEW PLAYER - Name - Welcome...')
      try{
        window.__homeLivePrinterInjectLine = (line) => {
          const st = window.__homeLivePrinterState;
          const l = String(line || '').replace(/\s+/g,' ').trim();
          if (!st || !l) return;
          // push into buffer
          st.bufLines = [l].concat(Array.isArray(st.bufLines) ? st.bufLines : []);
          st.bufLines = st.bufLines.slice(0, LP_BUFFER);
          // show immediately by shifting the visible window
          st.displayLines = Array.isArray(st.displayLines) ? st.displayLines : Array.from({ length: LP_VISIBLE }, () => '');
          st.displayLines = st.displayLines.slice(1).concat([l]);
          lpEnsureRows(st.displayLines);
        };
      }catch(_e){}


      const lpRenderWindow = (opts = {}) => {
        const st = window.__homeLivePrinterState;
        const tbody = document.getElementById('homeLivePrinterRows');
        if (!tbody || !st) return;
        const buf = Array.isArray(st.bufLines) ? st.bufLines : [];
        const start = Number(st.viewStart || 0) || 0;
        const win = buf.slice(start, start + LP_VISIBLE);
        const winDisp = win;
        const rows = Array.from(tbody.querySelectorAll('tr.lp-row'));
        if (rows.length !== LP_VISIBLE) { lpEnsureRows(win); return; }
        rows.forEach((tr, i) => {
          const sp = tr.querySelector('.lp-ellipsis');
          if (!sp) return;
          const line = winDisp[i] ?? 'â€”';
          if (!opts.skipLastType || i < LP_VISIBLE - 1) {
            sp.textContent = String(line);
            tr.classList.toggle('lp-record', lpIsRecordLine(line));
            tr.classList.toggle('lp-roundpb', !lpIsRecordLine(line) && lpIsRoundPBLine(line));
            tr.classList.toggle('lp-gamepb', !lpIsRecordLine(line) && lpIsGamePBLine(line));
            tr.classList.toggle('lp-alert', lpIsAlertLine(line));
          tr.classList.toggle('lp-alert', lpIsAlertLine(line));
          }
        });
      };
      const lpScrollStep = () => {
        const st = window.__homeLivePrinterState;
        const tbody = document.getElementById('homeLivePrinterRows');
        if (!st || !tbody) return;

        const buf = Array.isArray(st.bufLines) ? st.bufLines : [];
        if (!buf.length) return;

        // Ensure display model exists
        if (!st.lpStarted || !Array.isArray(st.displayLines) || st.displayLines.length !== LP_VISIBLE) {
          st.lpStarted = true;
          st.lpCursor = (Number.isFinite(st.lpCursor) ? st.lpCursor : 0) || 0;
          st.displayLines = Array.from({ length: LP_VISIBLE }, () => '');
          lpEnsureRows(st.displayLines);
        }

        const rows = Array.from(tbody.querySelectorAll('tr.lp-row'));
        const rowH = (rows[0] ? (rows[0].getBoundingClientRect().height || 20) : 20);

        // Pull next line (circular)
        const nextIdx = st.lpCursor % buf.length;
        const nextLine = String(buf[nextIdx] ?? '').trim();
        st.lpCursor = (st.lpCursor + 1) % buf.length;

        // Shift window (top drops, new line appears at bottom)
        try { st.displayLines.shift(); } catch(_e){ st.displayLines = st.displayLines.slice(1); }
        st.displayLines.push(nextLine);

        // Animate the physical shift, then repaint + type last line
        lpSmoothShiftUp(tbody, rowH, 520, () => {
          const rows2 = Array.from(tbody.querySelectorAll('tr.lp-row'));
          if (rows2.length !== LP_VISIBLE) {
            lpEnsureRows(st.displayLines);
            return;
          }

          // Reset non-last rows + text
          for (let i = 0; i < LP_VISIBLE - 1; i++) {
            rows2[i].classList.remove('lp-new');
            const sp = rows2[i].querySelector('.lp-ellipsis');
            if (sp) sp.textContent = String(st.displayLines[i] ?? '');
            rows2[i].classList.toggle('lp-record', lpIsRecordLine(st.displayLines[i]));
            rows2[i].classList.toggle('lp-roundpb', !lpIsRecordLine(st.displayLines[i]) && lpIsRoundPBLine(st.displayLines[i]));
            rows2[i].classList.toggle('lp-gamepb', !lpIsRecordLine(st.displayLines[i]) && lpIsGamePBLine(st.displayLines[i]));
          }

          // Last row stays dark green until it moves up (next step)
          const lastRow = rows2[LP_VISIBLE - 1];
          if (!lastRow) return;
          lastRow.classList.add('lp-new');
          lastRow.classList.toggle('lp-record', lpIsRecordLine(st.displayLines[LP_VISIBLE - 1]));
          lastRow.classList.toggle('lp-roundpb', !lpIsRecordLine(st.displayLines[LP_VISIBLE - 1]) && lpIsRoundPBLine(st.displayLines[LP_VISIBLE - 1]));
          lastRow.classList.toggle('lp-gamepb', !lpIsRecordLine(st.displayLines[LP_VISIBLE - 1]) && lpIsGamePBLine(st.displayLines[LP_VISIBLE - 1]));
          const lastSp = lastRow.querySelector('.lp-ellipsis');
          if (lastSp) {
            lastSp.textContent = '';
            // slower typing
            lpType(lastSp, String(st.displayLines[LP_VISIBLE - 1] ?? ''), 42);
          }
        });
      };
      const lpAnimateNewBottom = (bufLines) => {
        const tbody = document.getElementById('homeLivePrinterRows');
        if (!tbody) return;

        const rows = Array.from(tbody.querySelectorAll('tr.lp-row'));
        const rowH = (rows[0] ? (rows[0].getBoundingClientRect().height || 22) : 22);

        const buf = Array.isArray(bufLines) ? bufLines : [];
        const winNew = buf.slice(0, LP_VISIBLE);

        lpSmoothShiftUp(tbody, rowH, 460, () => {
          const rows2 = Array.from(tbody.querySelectorAll('tr.lp-row'));
          if (rows2.length !== LP_VISIBLE) {
            lpEnsureRows(winNew);
            return;
          }

          for (let i = 0; i < LP_VISIBLE - 1; i++) {
            const sp = rows2[i].querySelector('.lp-ellipsis');
            if (sp) sp.textContent = String(winNew[i] ?? 'â€”');
            rows2[i].classList.toggle('lp-record', lpIsRecordLine(winNew[i]));
            rows2[i].classList.toggle('lp-roundpb', !lpIsRecordLine(winNew[i]) && lpIsRoundPBLine(winNew[i]));
            rows2[i].classList.toggle('lp-gamepb', !lpIsRecordLine(winNew[i]) && lpIsGamePBLine(winNew[i]));
            rows2[i].classList.toggle('lp-alert', lpIsAlertLine(winNew[i]));
            rows2[i].classList.remove('lp-new');
          }

          const lastRow = rows2[LP_VISIBLE - 1];
          const lastSp = lastRow ? lastRow.querySelector('.lp-ellipsis') : null;
          if (lastSp) {
            lastRow.classList.add('lp-new');
            lastRow.classList.toggle('lp-record', lpIsRecordLine(winNew[LP_VISIBLE - 1]));
            lastRow.classList.toggle('lp-roundpb', !lpIsRecordLine(winNew[LP_VISIBLE - 1]) && lpIsRoundPBLine(winNew[LP_VISIBLE - 1]));
            lastRow.classList.toggle('lp-gamepb', !lpIsRecordLine(winNew[LP_VISIBLE - 1]) && lpIsGamePBLine(winNew[LP_VISIBLE - 1]));
            lastRow.classList.toggle('lp-alert', lpIsAlertLine(winNew[LP_VISIBLE - 1]));
            lastSp.textContent = '';
            lpType(lastSp, String(winNew[LP_VISIBLE - 1] ?? 'â€”'), 20);
            setTimeout(() => {
              try { lastRow.classList.remove('lp-new'); } catch (_) {}
            }, 900);
          }
        });
      };
      const lpSync = async (forceFull = false) => {
        const st = window.__homeLivePrinterState;
        if (!st || st.syncing) return;
        st.syncing = true;
        try {
          // 1) Prefer the consolidated printer events view (VIDE)
          let items = [];
          if (lpCloudOK() && window.sb) {
            try {
              const { data, error } = await window.sb
                .from('printer_events_v_all')
                .select('event_id,event_ts,kind_priority,event_kind,line_text')
                .order('event_ts', { ascending: false })
                .order('kind_priority', { ascending: false })
                .order('event_id', { ascending: false })
                .limit(LP_BUFFER);
              if (!error && Array.isArray(data)) items = data;
            } catch (_e) {
              // ignore
            }
          }

          // 2) Fallback: recent games (existing behaviour)
          if (!items.length) {
            let games = [];
            if (lpCloudOK()) {
              try { games = await cloudFetchLatestGamesAsLocal(LP_BUFFER); } catch (_e) { games = []; }
            // Normalize game rows for live printer formatting (avoid "?(?)" when winner fields are absent)
            if (Array.isArray(games) && games.length) {
              games = games.map(g => {
                try{
                  const ps = Array.isArray(g.players) ? g.players : [];
                  const ts = g.ts || g.created_at || g.createdAt || g.created_at || null;
                  const totals = Array.isArray(g.totals) ? g.totals : [];
                  const rows = ps.map((p,i)=>({
                    name: (p && p.name) ? String(p.name).trim() : '?',
                    score: Number(totals[i] ?? 0)
                  })).sort((a,b)=> (b.score - a.score) || String(a.name).localeCompare(String(b.name)));
                  const winner = rows[0] || { name:'?', score:'?' };
                  const opp = rows.slice(1).map(r => `${r.name} (${r.score})`).join(', ');
                  return { ts, winner_name: winner.name, winner_score: winner.score, opponents_text: opp };
                }catch(_e){
                  return { ts: g.ts || null, winner_name: '?', winner_score: '?', opponents_text: '' };
                }
              }).filter(Boolean);
            }
}
            if (!games || !games.length) {
              const ids = getSavedMatchIdsSorted();
              games = ids.slice(-LP_BUFFER).reverse().map(id => {
                const mm = getMatchState(id);
                if (!mm) return null;
                const rows = (mm.players || []).map(p => ({ name: p.name || '?', score: (p.totalScore ?? 0) }))
                  .sort((a,b)=> b.score - a.score || String(a.name).localeCompare(String(b.name)));
                const winner = rows[0] || { name: '?', score: '?' };
                const opp = rows.slice(1).map(r => `${r.name} (${r.score})`).join(', ');
                return {
                  match_id: id,
                  ts: mm.ts || mm.createdAt || mm.created_at || mm.updatedAt || mm.updated_at,
                  winner_name: winner.name,
                  winner_score: winner.score,
                  opponents_text: opp
                };
              }).filter(Boolean);
            }
            items = games;
          }

          const mid = document.querySelector('#homeLivePrinter .lp-mid');
          const hold = document.querySelector('#homeLivePrinter .home-hold-overlay');

          if (!items.length) {
            // Keep the hold overlay visible; show empty rows.
            try { if (mid) mid.classList.add('lp-mid-hold'); } catch(_e){}
            try { const p = document.getElementById('homeLivePrinter'); if (p) p.classList.remove('is-live'); } catch(_e){}
            lpEnsureRows(Array.from({length: LP_VISIBLE}, ()=>'â€”'));
            return;
          }

          // We have data â€” turn the printer "live" (hide the overlay).
          try { if (mid) mid.classList.remove('lp-mid-hold'); } catch(_e){}
          try { const p = document.getElementById('homeLivePrinter'); if (p) p.classList.add('is-live'); } catch(_e){}
          try { if (hold) hold.style.display = 'none'; } catch(_e){}

          const _lpGetTs = (g) => g.event_ts || g.ts || g.created_at || g.createdAt;
          const sorted = items.slice().sort((a,b) => (new Date(_lpGetTs(b))).getTime() - (new Date(_lpGetTs(a))).getTime());
          const HIDE_KINDS = new Set();
          const filtered = sorted.filter(it => !(it && it.event_kind && HIDE_KINDS.has(it.event_kind)));
          const lines = filtered.map(lpFmtLine);

          const sig0 = sorted[0] ? lpSig(sorted[0]) : '';
          const shouldRefresh = forceFull || (sig0 && sig0 !== st.lastSig) || !Array.isArray(st.bufLines);

          // Always keep the buffer for scrolling
          st.bufLines = lines.slice(0, LP_BUFFER);
          if (shouldRefresh) {
            st.lastSig = sig0 || st.lastSig;
          }

          // Start empty on first load; events scroll in from bottom one-by-one.
          if (!st.lpStarted) {
            st.lpStarted = true;
            st.lpCursor = 0;
            st.displayLines = Array.from({ length: LP_VISIBLE }, () => '');
            lpEnsureRows(st.displayLines);
          } else if (!Array.isArray(st.displayLines) || st.displayLines.length !== LP_VISIBLE) {
            st.displayLines = Array.from({ length: LP_VISIBLE }, () => '');
          }
        } finally {
          st.syncing = false;
        }
      };


      
      // Constant-speed marquee for NEW PLAYERS line (avoids slow/fast drift)
      function __startHomeLpMarquee(trackEl, msg){
        try{
          const wrap = trackEl && trackEl.parentElement;
          if (!trackEl || !wrap) return;
          const cleaned = String(msg||'').replace(/\s+/g,' ').trim();
          if (trackEl.dataset.lpMsg === cleaned && trackEl.__lpAnim) return;
          trackEl.dataset.lpMsg = cleaned;

          // Build a single message span (we'll animate across wrap width at constant px/s)
          trackEl.textContent = cleaned || 'NEW PLAYERS // â€”';

          // Cancel prior anim
          if (trackEl.__lpAnim) { try{ trackEl.__lpAnim.cancel(); }catch(_){} }

          // Measure and animate
          requestAnimationFrame(()=>{
            const cw = wrap.getBoundingClientRect().width || 0;
            const tw = trackEl.getBoundingClientRect().width || trackEl.scrollWidth || 0;
            const speed = 60; // px/sec
            const distance = cw + tw + 40;
            const duration = Math.max(8000, Math.round((distance / speed) * 1000));
            trackEl.__lpAnim = trackEl.animate(
              [
                { transform: `translateX(${cw}px)` },
                { transform: `translateX(-${tw + 40}px)` }
              ],
              { duration, iterations: Infinity, easing: 'linear' }
            );
          });
        }catch(_){}
      }
if (!window.__homeLivePrinterInterval){
        window.__homeLivePrinterInterval = setInterval(()=>{
          const st = window.__homeLivePrinterState;
          if (!st) return;
          st.tick++;

          // Top animation
          const topLine = document.getElementById('homeLpTopLine');
          if (topLine){
            topLine.textContent = '// LIVE UPDATES //';
          }


          // Bottom marquee mirrors NEW PLAYERS ticker
          try {
            const track = document.getElementById('homeLpBottomTrack');
            if (track) {
              const tTop = document.getElementById('psTickerTop');
              const tBot = document.getElementById('psTicker');
              let raw = (tTop && tTop.textContent) ? tTop.textContent : ((tBot && tBot.textContent) ? tBot.textContent : '');
              raw = String(raw || '').replace(/\s+/g, ' ').trim();
              raw = raw.replace(/^NEW\s*PLAYERS\s*\/\/\s*/i, '');
              const msg = `NEW PLAYERS // ${raw || 'â€”'}`;
              __startHomeLpMarquee(track, msg);
            }
          } catch (_) {}

          
          // Continuous feed: scroll through last 20 even when nothing new arrives
          try {
            if (st.tick % 5 === 0) lpScrollStep();
          } catch (_) {}
// Sync every ~3 seconds
          if (st.tick % 3 === 0) {
            st.syncCount++;
            const force = (st.syncCount % st.forceFullEvery) === 0;
            lpSync(force);
          }
        }, 1000);
        // initial fill
        lpSync(true);
      }
    }catch(_){ }

    // ===== HOME FOOTER NAV (above tickers) =====
    let footer = document.getElementById('homeFooterNav');
    const tickerTop = document.getElementById('psTickerTop') || document.getElementById('psTicker');
    if (!footer){
      footer = doc.createElement('div');
      footer.id = 'homeFooterNav';
      footer.className = 'home-footer-nav';
      // insert right before the ticker(s)
      if (tickerTop && tickerTop.parentNode) {
        tickerTop.parentNode.insertBefore(footer, tickerTop);
      } else {
        // fallback: append to details section
        const details = document.getElementById('details');
        if (details) details.appendChild(footer);
      }
    }
    // Footer is not fixed; keep in normal document flow
    try{ footer.style.bottom=''; footer.style.left=''; footer.style.right=''; }catch(_){}


    // Build 3x squares + Admin row
    footer.innerHTML = '';

    // Player HUB (coming soon)
    let hub = document.getElementById('playerHubBtn');
    if (!hub){
      hub = doc.createElement('button');
      hub.id = 'playerHubBtn';
      hub.type = 'button';
      hub.className = 'btn home-square-btn';
      hub.onclick = () => toast('Player HUB - Coming soon!');
    }

    // Square styling + labels
    
// Nav buttons (PLAYER HUB / STATS / LEAGUE & RANKS) â€” match main button styling
hub.className = 'btn secondary big navBtn navGreen';
stats.className = 'btn secondary big navBtn navBlue';
league.className = 'btn secondary big navBtn navOrange';

// Inline SVG icons (no external deps)
const svgUsers = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>';
const svgBar = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 19V5"/><path d="M10 19V9"/><path d="M16 19V13"/><path d="M22 19V7"/></svg>';
const svgTrophy = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M8 21h8"/><path d="M12 17v4"/><path d="M7 4h10v3a5 5 0 0 1-10 0V4Z"/><path d="M5 7H3V5h4"/><path d="M19 7h2V5h-4"/><path d="M5 7a5 5 0 0 0 5 5"/><path d="M19 7a5 5 0 0 1-5 5"/></svg>';
const svgLock = '<svg viewBox="0 0 24 24" aria-hidden="true"><rect x="5" y="11" width="14" height="10" rx="2"/><path d="M8 11V8a4 4 0 0 1 8 0v3"/></svg>';

hub.innerHTML   = `<span class="navIcon">${svgUsers}</span><span class="navLabel">PLAYER HUB</span>`;
stats.innerHTML = `<span class="navIcon">${svgBar}</span><span class="navLabel">PLAYER STATS</span>`;
league.innerHTML= `<span class="navIcon">${svgTrophy}</span><span class="navLabel">LEAGUE &amp; RANKS</span>`;

// Admin: clickable text + lock (no big button)
admin.className = 'adminLink';
admin.type = 'button';
admin.innerHTML = `<span class="adminLock">${svgLock}</span><span class="adminText">ADMIN</span>`;

// Row: 3 buttons aligned to the same outer edges as the 2 league boxes above
const navRow = doc.createElement('div');
navRow.className = 'home-nav-row';
navRow.appendChild(hub);
navRow.appendChild(stats);
navRow.appendChild(league);

const adminRow = doc.createElement('div');
adminRow.className = 'home-admin-row';
adminRow.appendChild(admin);

footer.appendChild(navRow);
footer.appendChild(adminRow);

  } catch(e){
    console.error('arrangeStartActions failed', e);
  }
}


/*****************
 * BOOT
 *****************/
document.addEventListener('DOMContentLoaded', () => {
  // Start on details screen
  show('details');
  updatePadSpacer();
  setupStartMenuButtons();
  initSetupSteppers();

  // Kick off initial cloud connectivity check
  if (ensureCloudInit()) initialCloudCheck();

// Restart buttons (Player Select + Game + Leaderboard)
  ['restartGameBtn', 'restartGameBtnLB', 'restartGameBtnGame'].forEach(id => {
    document.querySelectorAll('#' + id).forEach(btn => {
      btn.onclick = restartGame;
    });
  });

  // Stats buttons in top rows (game + final leaderboard)
  const statsHubBtnGame  = byId('statsHubBtnGame');    // game screen
  const statsHubBtnFinal = byId('statsHubBtnFinal');   // leaderboard screen

  if (statsHubBtnGame)  statsHubBtnGame.onclick  = openStatsHubDialog;
  if (statsHubBtnFinal) statsHubBtnFinal.onclick = openStatsHubDialog;
  const hsFinalBtn = byId('highScoresMenuBtnLB');
  if (hsFinalBtn) hsFinalBtn.onclick = openHighScoresMenuDialog;
  // Leaderboard buttons (guarded lookups)
  (function(){
    const map = [
      ['lbGameStatsBtn',   'openGameStatsDialog'],
      ['lbMatchStatsBtn',  'openMatchStatsDialog'],
      ['lbGameRaceBtn',    'openGameRaceDialog']
    ];
    map.forEach(([id, fn])=>{
      const el = byId(id);
      const handler = (typeof window[fn] === 'function') ? window[fn] : null;
      if (el && handler) el.onclick = handler;
    });
  })();

  // Global ESC/click-outside for add/select/admin modals
  document.addEventListener('click', function(event) {
    const addPlayerModal      = byId('addPlayerModal');
    const selectPlayerModal   = byId('selectPlayerModal');
    const adminHub            = byId('adminHubModal');
    const savedPlayersAdmin   = byId('savedPlayersAdminModal');

    if (addPlayerModal &&
        !addPlayerModal.classList.contains('hidden') &&
        event.target === addPlayerModal) {
      addPlayerModal.classList.add('hidden');
    }

    if (selectPlayerModal &&
        !selectPlayerModal.classList.contains('hidden') &&
        event.target === selectPlayerModal) {
      selectPlayerModal.classList.add('hidden');
    }

    if (adminHub &&
        !adminHub.classList.contains('hidden') &&
        event.target === adminHub) {
      adminHub.classList.add('hidden');
    }

    if (savedPlayersAdmin &&
        !savedPlayersAdmin.classList.contains('hidden') &&
        event.target === savedPlayersAdmin) {
      savedPlayersAdmin.classList.add('hidden');
    }
  });

  document.addEventListener('keydown', function(event) {
    if (event.key !== 'Escape') return;

    const addPlayerModal    = byId('addPlayerModal');
    const selectPlayerModal = byId('selectPlayerModal');
    const adminHub          = byId('adminHubModal');
    const savedPlayersAdmin = byId('savedPlayersAdminModal');

    if (addPlayerModal &&
        !addPlayerModal.classList.contains('hidden')) {
      addPlayerModal.classList.add('hidden');
    }

    if (selectPlayerModal &&
        !selectPlayerModal.classList.contains('hidden')) {
      selectPlayerModal.classList.add('hidden');
    }

    if (adminHub &&
        !adminHub.classList.contains('hidden')) {
      adminHub.classList.add('hidden');
    }

    if (savedPlayersAdmin &&
        !savedPlayersAdmin.classList.contains('hidden')) {
      savedPlayersAdmin.classList.add('hidden');
    }
  });
  

  try { arrangeStartActions(); } catch(_) {}
});

// ===== FINAL OVERRIDE: Cloud pill â€” dot-only indicator =====
// Replaces any previous setCloudStatus to remove text and show a single coloured dot.
window.setCloudStatus = function setCloudStatus(state, msg){
  var el = document.getElementById('cloudStatusPill') ||
           document.getElementById('cloudStatus') ||
           document.querySelector('.cloud-pill');
  if (!el) return;

  // Decide colour
  var root = getComputedStyle(document.documentElement);
  function pick(varName, fallback){ 
    try { 
      var v = root.getPropertyValue(varName); 
      return (v && v.trim()) ? v.trim() : fallback; 
    } catch(_) { return fallback; } 
  }
  var colour = pick('--muted', '#8a8fa6'); // default/checking
  if (state === 'ok' || state === 'connected' || state === 'online') {
    colour = pick('--good', '#7fffd4');
  } else if (state === 'warn' || state === 'checking') {
    colour = pick('--warn', '#ffcc66');
  } else if (state === 'error' || state === 'offline') {
    colour = pick('--danger', '#ff6b6b');
  }

  // Strip pill styling & content â†’ dot only
  el.innerHTML = '';
  el.style.padding = '0';
  el.style.minWidth = '0';
  el.style.background = 'transparent';
  el.style.boxShadow = 'none';
  el.style.border = 'none';
  el.style.display = 'inline-block';

  var dot = document.createElement('span');
  dot.style.display = 'inline-block';
  dot.style.width = '12px';
  dot.style.height = '12px';
  dot.style.borderRadius = '50%';
  dot.style.background = colour;
  dot.title = msg || (state || '');
  el.appendChild(dot);
};

// ===== Match Stats helpers (avg throw/round + perfect rounds) =====
(function(){
  if (window.__matchStatsHelpers) return; // prevent double insert
  window.__matchStatsHelpers = true;

  // Gather all rounds (completed games + current inâ€‘progress) for a player index
  function __iterateAllRoundsForPlayer(playerIdx){
    const acc = [];

    // Completed games in the current match
    const hist = (state && state.match && Array.isArray(state.match.history)) ? state.match.history : [];
    hist.forEach(g => {
      const board = g && g.board && g.board[playerIdx];
      if (!board) return;
      for (let r = 0; r < MAX_ROUNDS; r++){
        const ent = board[r];
        const rd  = ROUNDS[r];
        if (!ent || !rd) continue;
        const darts = Array.isArray(ent.darts) ? ent.darts : [];
        // If roundTotal missing, compute from darts
        const rt = Number(ent.roundTotal ?? darts.reduce((s,d)=> s + Number(d && d.points || 0), 0));
        acc.push({ rd, darts, roundTotal: rt });
      }
    });

    // Current (inâ€‘progress) game
    const curRows = (state && state.score && state.score[playerIdx]) ? state.score[playerIdx] : [];
    for (let r = 0; r < (curRows ? curRows.length : 0); r++){
      const ent = curRows[r];
      const rd  = ROUNDS[r];
      if (!ent || !rd) continue;
      const darts = Array.isArray(ent.darts) ? ent.darts : [];
      const rt = Number(ent.roundTotal ?? darts.reduce((s,d)=> s + Number(d && d.points || 0), 0));
      acc.push({ rd, darts, roundTotal: rt });
    }

    return acc;
  }

  // Public API used by the modal fixer
  window.computeMatchAverages = function computeMatchAverages(){
    const players = (state && Array.isArray(state.players)) ? state.players : [];
    return players.map((_, i) => {
      const rounds = __iterateAllRoundsForPlayer(i);
      let points = 0, throws = 0, perfect = 0;

      rounds.forEach(({ rd, darts, roundTotal }) => {
        const rt = Number(roundTotal || 0);
        points += rt;

        // Count darts actually thrown (includes misses)
        const taken = (darts || []).filter(d => d !== null).length;
        throws += taken;

        // Perfect round = 3 darts, all on the intended target for that round
        // number/doubles/triples: any scoring hit (points > 0) counts
        // bull: only darts with kind === 'Bull' count
        if (taken === 3){
          let allHit = false;
          if (rd.type === 'number' || rd.type === 'doubles' || rd.type === 'triples'){
            allHit = darts.every(d => d && Number(d.points || 0) > 0);
          } else if (rd.type === 'bull') {
            allHit = darts.every(d => d && d.kind === 'Bull');
          }
          if (allHit) perfect++;
        }
      });

      const avgThrow = throws ? (points / throws) : 0;
      const avgRound = avgThrow * 3;
      return { points, throws, avgThrow, avgRound, perfect };
    });
  };
})();
  
// ===== Match Stats modal fixer (remove Avg Last 9, fix avgs, add Perfect Rounds) =====
(function(){
  if (window.__matchStatsModalFixer) return;
  window.__matchStatsModalFixer = true;

  function applyMatchStatsFix(root){
    try{
      // Find a modal with title "Match Stats"
      const modal = root.querySelector('.modal');
      if (!modal) return;
      const h3 = modal.querySelector('h3');
      if (!h3 || !/match stats/i.test((h3.textContent || '').trim())) return;

      const table = modal.querySelector('table');
      const tbody = table && table.querySelector('tbody');
      if (!tbody) return;

      const players = (state && Array.isArray(state.players)) ? state.players : [];
      const P = players.length;
      const stats = (typeof computeMatchAverages === 'function') ? computeMatchAverages() : players.map(()=>({avgThrow:0,avgRound:0,perfect:0}));

      // helpers
      const rows = Array.from(tbody.querySelectorAll('tr'));
      const getRow = (label) => rows.find(tr => (tr.firstElementChild && (tr.firstElementChild.textContent || '').trim().toLowerCase()) === label.toLowerCase());
      const setRowVals = (tr, values, fmt = (v)=>String(v)) => {
        if (!tr) return;
        for (let i = 0; i < P; i++){
          const td = tr.children[1 + i]; // first col is label
          if (td) td.textContent = fmt(values[i] ?? 0);
        }
      };

      // Remove "Avg Last 9" (keep it in Game Stats only)
      const avg9 = getRow('Avg Last 9');
      if (avg9) avg9.remove();

      // Update Avg Throw / Avg Round from computed values
      const rAvgT = getRow('Avg Throw');
      const rAvgR = getRow('Avg Round');
      setRowVals(rAvgT, stats.map(s => s.avgThrow), v => (Number(v)||0).toFixed(1));
      setRowVals(rAvgR, stats.map(s => s.avgRound), v => (Number(v)||0).toFixed(1));

      // Insert "Perfect Rounds" after "Round Streak" (or at the end if not found)
      const afterRow = getRow('Round Streak') || rows[rows.length - 1];
      const existingPR = getRow('Perfect Rounds');
      const valuesPR = stats.map(s => s.perfect);

      if (existingPR) {
        // just update values if it already exists
        setRowVals(existingPR, valuesPR);
      } else {
        // create the row
        const tr = document.createElement('tr');
        const tdLabel = document.createElement('td');
        tdLabel.textContent = 'Perfect Rounds';
        tr.appendChild(tdLabel);
        for (let i = 0; i < P; i++){
          const td = document.createElement('td');
          td.textContent = String(valuesPR[i] || 0);
          tr.appendChild(td);
        }
        if (afterRow && afterRow.parentElement) {
          afterRow.insertAdjacentElement('afterend', tr);
        } else {
          tbody.appendChild(tr);
        }
      }
    } catch(e){
      console.error('applyMatchStatsFix error', e);
    }
  }

  // Observe for modal creation; patch when Match Stats dialog appears (via shared UI mutation bus)
  try {
    window.__sqUIMutationBus?.on((muts) => {
      for (const m of (muts || [])){
        for (const n of (m.addedNodes || [])){
          if (n.nodeType === 1 && n.classList.contains('modal-backdrop')){
            // let the dialog render, then patch
            setTimeout(() => applyMatchStatsFix(n), 0);
          }
        }
      }
    });
  } catch(_) {}
})();

// ===== High Scores modals: force compact style (League / Practice / Match / Round) =====
(function(){
  if (window.__hsCompactModalFixer) return;
  window.__hsCompactModalFixer = true;

  function applyHsCompact(root){
    try{
      const modal = root.querySelector('.modal');
      if (!modal) return;
      const h3 = modal.querySelector('h3');
      if (!h3) return;
      const title = (h3.textContent || '').trim().toLowerCase();

      // Any modal titled "High Scores" â†’ compact
      if (title.includes('high scores')) {
        modal.classList.add('compact');
      }
    } catch(e){
      console.error('applyHsCompact error', e);
    }
  }

  try {
    window.__sqUIMutationBus?.on((muts) => {
      for (const m of (muts || [])){
        for (const n of (m.addedNodes || [])){
          if (n.nodeType === 1 && n.classList.contains('modal-backdrop')){
            // Let the dialog render, then patch
            setTimeout(() => applyHsCompact(n), 0);
          }
        }
      }
    });
  } catch(_) {}
})();

// ===== PB/GR snapshot + refresh (cloud-first; saved players, official-only) =====
(function(){
  // Build PB/WR from throws; fallback to games.board if needed
  window.getPBGRSnapshot = async function getPBGRSnapshot(){
    try{
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) {
        return { byTargetMeta: {}, byPlayerMeta: new Map() };
      }

      // Saved players only (case-insensitive)
      let saved = [];
      try { saved = await (typeof cloudListPlayers === 'function' ? cloudListPlayers() : []); } catch(_){}
      const savedSet = new Set((saved||[]).map(p => String(p?.name || '').trim().toLowerCase()));
      const canonical = new Map((saved||[]).map(p => [String(p?.name || '').trim().toLowerCase(), String(p?.name || '')]));

      function catForRoundIdx(r){
        const rd = (typeof ROUNDS !== 'undefined') ? ROUNDS[r] : null;
        if (!rd) return null;
        if (rd.type === 'number')  return String(rd.target);
        if (rd.type === 'doubles') return 'D';
        if (rd.type === 'triples') return 'T';
        if (rd.type === 'bull')    return 'B';
        return null;
      }
      function preferNew(cur, val, ts){
        if (!cur) return true;
        if (val > (cur.val || 0)) return true;
        if (val < (cur.val || 0)) return false;
        if (ts && cur.ts) return new Date(ts) < new Date(cur.ts);
        return false;
      }

      const byPlayerMeta = new Map(); // nameKey -> { cat -> { val, ts, game_id, ridx } }
      const byTargetMeta = {};        // cat -> { val, player, ts, game_id, ridx }
      function updatePB(nameKey, cat, val, ts, game_id, ridx){
        let m = byPlayerMeta.get(nameKey); if (!m){ m={}; byPlayerMeta.set(nameKey,m); }
        const cur = m[cat];
        if (preferNew(cur, val, ts)) m[cat] = { val:Number(val)||0, ts:ts||null, game_id:game_id??null, ridx:(typeof ridx==='number'?ridx:null) };
      }
      function updateWR(cat, playerName, val, ts, game_id, ridx){
        const cur = byTargetMeta[cat];
        if (preferNew(cur, val, ts)) byTargetMeta[cat] = { val:Number(val)||0, player:String(playerName||''), ts:ts||null, game_id:game_id??null, ridx:(typeof ridx==='number'?ridx:null) };
      }

      // 1) OFFICIAL games (2+ players) â†’ ids + timestamps
      let gameRows = [];
      try{
        const { data, error } = await sb.from(TABLE_GAMES)
          .select('id, created_at, state')
          .order('created_at', { ascending: true });
        if (error) throw error;
        gameRows = (data||[]).filter(g => Array.isArray(g?.state?.players) && g.state.players.length >= 2);
      }catch(e){ console.error('getPBGRSnapshot: fetch games failed', e); }

      const gameMeta = new Map();
      const officialIds = [];
      for (const g of gameRows){
        if (g?.id == null) continue;
        gameMeta.set(g.id, { ts: g.created_at || null, players: (g?.state?.players||[]).map(p => (typeof p==='string'?{name:p}:p)) });
        officialIds.push(g.id);
      }

      // 2) Prefer throws-table path
      if (officialIds.length){
        let throwsRows = [];
        try{
          const { data, error } = await sb.from(TABLE_GAME_THROWS)
            .select('game_id, player, round_index, dart_index, points, kind')
            .in('game_id', officialIds)
            .order('game_id', { ascending: true })
            .order('round_index', { ascending: true })
            .order('dart_index', { ascending: true });
          if (error) throw error;
          throwsRows = data || [];
        }catch(e){ console.error('getPBGRSnapshot: throws fetch failed (falling back)', e); }

        if (throwsRows.length){
          const byKey = new Map(); // gid|playerLC|ridx -> {points, meta}
          for (const t of throwsRows){
            const gm = gameMeta.get(t.game_id); if (!gm) continue;
            const plc = String(t?.player||'').trim().toLowerCase();
            if (!savedSet.has(plc)) continue;
            const key = `${t.game_id}|${plc}|${t.round_index}`;
            let rec = byKey.get(key);
            if (!rec){
              rec = { game_id:t.game_id, ridx:Number(t.round_index||0), playerLC:plc, player: canonical.get(plc) || t.player || '', ts: gm.ts, points:0 };
              byKey.set(key, rec);
            }
            rec.points += Number(t.points||0);
          }
          for (const rec of byKey.values()){
            const cat = catForRoundIdx(rec.ridx); if (!cat) continue;
            const val = Number(rec.points||0); if (val <= 0) continue;
            updatePB(rec.playerLC, cat, val, rec.ts, rec.game_id, rec.ridx);
            updateWR(cat, rec.player, val, rec.ts, rec.game_id, rec.ridx);
          }
          return { byTargetMeta, byPlayerMeta };
        }
      }

      // 3) Fallback: compute from games.state.board
      for (const g of gameRows){
        const ts = g?.created_at || null;
        const players = (g?.state?.players||[]).map(p => (typeof p==='string'?{name:p}:p));
        const board = g?.state?.board || null;
        if (!Array.isArray(players) || !board) continue;
        for (let p = 0; p < players.length; p++){
          const name = players[p]?.name || '';
          const key  = name.trim().toLowerCase();
          if (!savedSet.has(key)) continue;
          const rows = board[p] || [];
          const maxR = (typeof MAX_ROUNDS==='number') ? Math.min(MAX_ROUNDS, rows.length) : rows.length;
          for (let r = 0; r < maxR; r++){
            const cat = catForRoundIdx(r); if (!cat) continue;
            const ent = rows[r] || {};
            let val = Number(ent.roundTotal ?? 0);
            if (!val && Array.isArray(ent.darts)) val = ent.darts.reduce((s,d)=> s + Number(d && d.points || 0), 0);
            if (val <= 0) continue;
            updatePB(key, cat, val, ts, g.id ?? null, r);
            updateWR(cat, name, val, ts, g.id ?? null, r);
          }
        }
      }
      return { byTargetMeta, byPlayerMeta };
    } catch (e){
      console.error('getPBGRSnapshot failed', e);
      return { byTargetMeta: {}, byPlayerMeta: new Map() };
    }
  };

  window.refreshPBGRCloud = async function refreshPBGRCloud(){
    try { window.__pbgrSnapshot = await window.getPBGRSnapshot(); return window.__pbgrSnapshot; }
    catch(e){ console.error('refreshPBGRCloud failed', e); return null; }
  };
})();

// High Score League â€” per-player best match score, rows clickable to open game
// ===== @JS:MODAL:HIGH_SCORE_LEAGUE =====
window.openHighScoreLeagueDialog = async function openHighScoreLeagueDialog() {
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); 
  modal.className = 'modal sq-wide-modal';
  const title   = document.createElement('h3');  title.textContent = 'High Score League â€” Best Match Score';
  const body    = document.createElement('div'); body.className    = 'modal-body';
  const footer  = document.createElement('div'); footer.className  = 'modal-footer';

  // When a league row is clicked, try to find & open the underlying game
  async function openGameForHighScore(row) {
    try {
      let games = [];
      if (typeof cloudFetchAllGamesAsLocal === 'function') {
        games = await cloudFetchAllGamesAsLocal();
      } else if (typeof ensureCloudInit === 'function' && ensureCloudInit()) {
        const table = (typeof TABLE_GAMES !== 'undefined' ? TABLE_GAMES : 'games');
        const { data } = await sb
          .from(table)
          .select('*')
          .order('created_at', { ascending: false })
          .limit(2000);
        games = data || [];
      }

      if (!Array.isArray(games) || !games.length) {
        if (typeof toast === 'function') toast('No games available to look up.');
        return;
      }

      const targetNameLC = String(row.name || '').trim().toLowerCase();
      const targetScore  = Number(row.score || 0);
      const rowTs        = row.ts || row.created_at || row.inserted_at || null;
      const rowTime      = rowTs ? new Date(rowTs).getTime() : null;

      let bestMatch = null;

      games.forEach(g => {
        const players = (g.players || []).map(p =>
          (p && p.name) ? p.name : String(p || '')
        );
        const idx = players.findIndex(n =>
          String(n || '').trim().toLowerCase() === targetNameLC
        );
        if (idx < 0) return;

        const totals = Array.isArray(g.totals) ? g.totals : [];
        const score  = Number(totals[idx] || 0);
        if (score !== targetScore) return;

        const gTsVal = g.ts || g.created_at || g.inserted_at ||
                       (g.meta && (g.meta.ts || g.meta.date)) || null;
        const gTime  = gTsVal ? new Date(gTsVal).getTime() : null;

        let penalty = 0;
        if (rowTime != null && gTime != null) {
          penalty = Math.abs(gTime - rowTime);      // smaller = closer in time
        }

        const cand = { game: g, penalty };
        if (!bestMatch || cand.penalty < bestMatch.penalty) {
          bestMatch = cand;
        }
      });

      if (!bestMatch) {
        if (typeof toast === 'function') toast('Could not locate game for this high score.');
        return;
      }

      if (typeof openSingleGameScoreSheet === 'function') {
        openSingleGameScoreSheet(bestMatch.game);
      }
    } catch (e) {
      console.error('openGameForHighScore failed', e);
      if (typeof toast === 'function') toast('Unable to open game for this high score.');
    }
  }

  async function render() {
    body.innerHTML = '';

    let rows = [];
    try {
      if (typeof cloudListHighScores === 'function') {
        // false â†’ league (not practice), pull a generous number of rows
        rows = await cloudListHighScores(false, 2000);
      } else {
        if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) {
          throw new Error('Cloud not initialised');
        }
        const table = (typeof TABLE_HS_LEAGUE !== 'undefined' ? TABLE_HS_LEAGUE : 'high_scores');
        const { data, error } = await sb
          .from(table)
          .select('name, score, ts')
          .order('score', { ascending: false })
          .order('ts',    { ascending: true })
          .limit(2000);
        if (error) throw error;
        rows = data || [];
      }
    } catch (e) {
      console.error('High Score League fetch failed', e);
      const p = document.createElement('p');
      p.textContent = 'Failed to load high score league.';
      body.appendChild(p);
      return;
    }
    
        // Restrict to saved players only, if we can fetch them
    try {
      if (typeof cloudListPlayers === 'function') {
        const saved = await cloudListPlayers();
        const savedSet = new Set(
          (saved || [])
            .map(p => (p && p.name ? String(p.name).trim().toLowerCase() : ''))
            .filter(Boolean)
        );
        rows = (rows || []).filter(r => {
          const nameLC = String(r.name || '').trim().toLowerCase();
          return nameLC && savedSet.has(nameLC);
        });
      }
    } catch (_) {}

    if (!Array.isArray(rows) || !rows.length) {
      const p = document.createElement('p');
      p.textContent = 'No high scores logged yet.';
      body.appendChild(p);
      return;
    }

    // Pick the single best row per player (highest score, then earliest ts)
    const bestByPlayer = new Map();
    rows.forEach(r => {
      const name = String(r.name || '').trim();
      if (!name) return;
      const key = name.toLowerCase();
      const ts  = r.ts || r.created_at || r.inserted_at || null;
      const score = Number(r.score || 0);

      const cur = bestByPlayer.get(key);
      if (!cur) {
        bestByPlayer.set(key, { name, score, ts, raw: r });
      } else {
        const curScore = Number(cur.score || 0);
        if (
          score > curScore ||
          (score === curScore && ts && cur.ts && new Date(ts) < new Date(cur.ts))
        ) {
          bestByPlayer.set(key, { name, score, ts, raw: r });
        }
      }
    });

    const league = Array.from(bestByPlayer.values()).sort((a, b) => {
      const ds = Number(b.score || 0) - Number(a.score || 0);
      if (ds !== 0) return ds;
      const at = a.ts ? new Date(a.ts).getTime() : 0;
      const bt = b.ts ? new Date(b.ts).getTime() : 0;
      return at - bt;
    });

    const table = document.createElement('table');
    table.className = 'hs-table hs-league-table';

    const colgroup = document.createElement('colgroup');
const colNum   = document.createElement('col');  colNum.style.width  = '3.5ch';
    const colName  = document.createElement('col');  colName.style.width = '10ch';
    const colScore = document.createElement('col');  colScore.style.width = '7ch';
    const colWhen  = document.createElement('col');
    colgroup.append(colNum, colName, colScore, colWhen);
    table.appendChild(colgroup);

    const thead = document.createElement('thead');
    const trh   = document.createElement('tr');
    ['#', 'Player', 'High Score', 'When'].forEach(h => {
      const th = document.createElement('th');
      th.textContent = h;
      trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');

    league.forEach((row, idx) => {
      const tr = document.createElement('tr');

      const tdRank  = document.createElement('td');
      const tdName  = document.createElement('td');
      const tdScore = document.createElement('td');
      const tdWhen  = document.createElement('td');

      tdRank.textContent  = String(idx + 1);
      tdName.textContent  = row.name || '';
      tdScore.textContent = String(row.score || 0);
      if (row.ts && typeof window.fmtWhen === 'function') {
        tdWhen.textContent = window.fmtWhen(row.ts);
      } else {
        tdWhen.textContent = '';
      }

      tr.append(tdRank, tdName, tdScore, tdWhen);

      // Make the row clickable to open the game
      tr.style.cursor = 'pointer';
      tr.title = 'Open the game where this score was hit';
      tr.onclick = () => { openGameForHighScore(row); };

      tbody.appendChild(tr);
    });

    table.appendChild(tbody);

    const wrap = document.createElement('div');
    wrap.className = 'table-wrap';
    wrap.appendChild(table);
    body.appendChild(wrap);
  }

  await render();

  const backBtn  = document.createElement('button'); backBtn.className  = 'btn sq-pill'; backBtn.textContent  = 'Back';
  const closeBtn = document.createElement('button'); closeBtn.className = 'btn sq-pill'; closeBtn.textContent = 'Close';
  backBtn.onclick  = () => {
    overlay.remove();
    if (window.__sqNavContext === 'admin' && typeof window.openAdminHub === 'function') {
      try { if (window.__sqLeagueOverlay && window.__sqLeagueOverlay.remove) window.__sqLeagueOverlay.remove(); } catch(_) {}
      try { window.openAdminHub(); } catch(_) {}
    }
  };
  closeBtn.onclick = () => overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
  modal.tabIndex = 0;
  modal.focus();
};

// ---- one-time error banner (shows first JS crash) ----
(function attachFirstErrorBanner(){
  if (window.__errorBannerAttached) return;
  window.__errorBannerAttached = true;
  window.addEventListener('error', function(ev){
    try {
      if (document.getElementById('firstErrorBanner')) return;
      const b = document.createElement('div');
      b.id = 'firstErrorBanner';
      b.style.cssText = 'position:fixed;left:8px;right:8px;top:8px;z-index:99999;padding:8px 10px;border-radius:6px;background:#400;color:#fff;font:12px/1.4 system-ui';
      b.textContent = 'JS error: ' + (ev.message || 'unknown') + (ev.filename?(' @ '+ev.filename+':'+ev.lineno):'');
      document.body.appendChild(b);
      setTimeout(()=>{ if(b && b.parentNode) b.parentNode.removeChild(b); }, 6000);
    } catch(_) {}
  });
})();

// League / Rankings popup (Power Rankings + High Score League)
// ===== @JS:MODAL:LEAGUE_RANKINGS =====
window.openLeagueRankingsDialog = async function openLeagueRankingsDialog(){
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';
  try { window.__sqLeagueOverlay = overlay; } catch(_) {}

  const modal = document.createElement('div');
  modal.className = 'modal menu-modal';

  // Header (Back + Title + Close)
  const header = document.createElement('div');
  header.className = 'menu-modal-header';

  const backBtn = document.createElement('button');
  backBtn.className = 'icon-btn';
  backBtn.type = 'button';
  backBtn.setAttribute('aria-label', 'Back');
  backBtn.innerHTML = '<svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true"><path d="M15 18l-6-6 6-6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'icon-btn';
  closeBtn.type = 'button';
  closeBtn.setAttribute('aria-label', 'Close');
  closeBtn.innerHTML = '<svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true"><path d="M18 6L6 18M6 6l12 12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';

  const titleWrap = document.createElement('div');
  titleWrap.className = 'menu-modal-title';

  const icon = document.createElement('div');
  icon.className = 'menu-modal-icon';
  icon.innerHTML = '<svg viewBox="0 0 24 24" width="28" height="28" aria-hidden="true"><path d="M8 5h8v3a4 4 0 0 1-8 0V5z" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/><path d="M6 6H4v1a4 4 0 0 0 4 4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M18 6h2v1a4 4 0 0 1-4 4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M10 14h4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M12 14v5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M9 19h6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';

  const title = document.createElement('div');
  title.className = 'menu-modal-title-text';
  title.textContent = 'LEAGUE / RANKINGS';

  titleWrap.append(icon, title);
  header.append(backBtn, titleWrap, closeBtn);

  const body = document.createElement('div');
  body.className = 'modal-body menu-modal-body';

  const list = document.createElement('div');
  list.className = 'menu-list';

  const makeRow = ({ id, label, desc, accent, svg }) => {
    const btn = document.createElement('button');
    btn.id = id;
    btn.className = 'menu-row';
    btn.type = 'button';
    if (accent) btn.style.setProperty('--accent', accent);

    const left = document.createElement('div');
    left.className = 'menu-row-left';

    const ic = document.createElement('div');
    ic.className = 'menu-row-icon';
    ic.innerHTML = svg;

    const txt = document.createElement('div');
    txt.className = 'menu-row-text';

    const t = document.createElement('div');
    t.className = 'menu-row-label';
    t.textContent = label;
    txt.appendChild(t);

    if (desc){
      const d = document.createElement('div');
      d.className = 'menu-row-desc';
      d.textContent = desc;
      txt.appendChild(d);
    }

    left.append(ic, txt);

    const right = document.createElement('div');
    right.className = 'menu-row-right';
    right.innerHTML = '<svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true"><path d="M9 18l6-6-6-6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';

    btn.append(left, right);
    return btn;
  };

  const icons = {
    chart: "<svg viewBox=\"0 0 24 24\" width=\"20\" height=\"20\" aria-hidden=\"true\"><path d=\"M4 19V5\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/><path d=\"M4 19h16\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/><path d=\"M7 14l4-4 3 3 5-6\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
    trophy: "<svg viewBox=\"0 0 24 24\" width=\"20\" height=\"20\" aria-hidden=\"true\"><path d=\"M8 5h8v3a4 4 0 0 1-8 0V5z\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linejoin=\"round\"/><path d=\"M6 6H4v1a4 4 0 0 0 4 4\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/><path d=\"M18 6h2v1a4 4 0 0 1-4 4\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/><path d=\"M10 14h4\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/><path d=\"M12 14v5\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/><path d=\"M9 19h6\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/></svg>",
    list: "<svg viewBox=\"0 0 24 24\" width=\"20\" height=\"20\" aria-hidden=\"true\"><path d=\"M8 6h13\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/><path d=\"M8 12h13\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/><path d=\"M8 18h13\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\"/><path d=\"M3 6h.01M3 12h.01M3 18h.01\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"3\" stroke-linecap=\"round\"/></svg>",
    clock: "<svg viewBox=\"0 0 24 24\" width=\"20\" height=\"20\" aria-hidden=\"true\"><path d=\"M12 8v5l3 2\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/><path d=\"M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0z\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"/></svg>",
    medal: "<svg viewBox=\"0 0 24 24\" width=\"20\" height=\"20\" aria-hidden=\"true\"><path d=\"M8 2l4 7 4-7\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linejoin=\"round\"/><path d=\"M12 22a6 6 0 1 0 0-12 6 6 0 0 0 0 12z\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"/></svg>"
  };

  // Rows (names already in use)
  list.appendChild(makeRow({
    id:'powerRankingsBtn',
    label:'Power Rankings',
    desc:'Form Guide',
    accent:'#41d3ff',
    svg:icons.chart
  }));

  list.appendChild(makeRow({
    id:'premierLeagueBtn',
    label:'Premier League',
    desc:'Monthly Highest Average League',
    accent:'#f6c453',
    svg:icons.trophy
  }));

  list.appendChild(makeRow({
    id:'highScoreLeagueBtn',
    label:'High Score League',
    desc:'Each Players PBs',
    accent:'#f6c453',
    svg:icons.medal
  }));

  list.appendChild(makeRow({
    id:'leagueRoundHighScoresBtn',
    label:'Round High Scores',
    desc:'Best single-round scores',
    accent:'#41d3ff',
    svg:icons.list
  }));

  list.appendChild(makeRow({
    id:'leagueTop50ScoresBtn',
    label:'Top 50 Scores',
    desc:'Best match scores',
    accent:'#41d3ff',
    svg:icons.list
  }));

  list.appendChild(makeRow({
    id:'leagueLatestScoresBtn',
    label:'Latest Scores',
    desc:'Last 10 results',
    accent:'#41d3ff',
    svg:icons.clock
  }));

  body.appendChild(list);
  modal.append(header, body);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  const remove = () => overlay.remove();
  backBtn.onclick = remove;
  closeBtn.onclick = remove;

  overlay.addEventListener('click', e => { if (e.target === overlay) remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') remove(); });

  modal.tabIndex = 0;
  modal.focus();

  // Wire buttons to dialogs (keep existing semantics)
  document.getElementById('powerRankingsBtn')?.addEventListener('click', () => {
    remove();
    if (typeof window.openPowerLeagueDialog === 'function') return window.openPowerLeagueDialog();
    if (typeof window.openPowerRankingsDialog === 'function') return window.openPowerRankingsDialog();
  });

  document.getElementById('premierLeagueBtn')?.addEventListener('click', () => {
    remove();
    if (typeof window.openPremierLeagueDialog === 'function') return window.openPremierLeagueDialog();
    if (typeof window.openPremierLeaguePopup === 'function') return window.openPremierLeaguePopup();
    try { toast('Premier League not available'); } catch(_) {}
  });

  document.getElementById('highScoreLeagueBtn')?.addEventListener('click', () => {
    remove();
    try {
      if (typeof window.openHighScoreLeagueDialog === 'function') return window.openHighScoreLeagueDialog();
      if (typeof openHighScoreLeagueDialog === 'function') return openHighScoreLeagueDialog();
    } catch(_) {}
    try { toast('High Score League not available'); } catch(_) {}
  });

  document.getElementById('leagueRoundHighScoresBtn')?.addEventListener('click', () => {
    remove();
    try {
      if (typeof window.openRoundHighScoresDialog === 'function') return window.openRoundHighScoresDialog();
      if (typeof openRoundHighScoresDialog === 'function') return openRoundHighScoresDialog();
    } catch(_) {}
    try { toast('Round High Scores not available'); } catch(_) {}
  });

  document.getElementById('leagueTop50ScoresBtn')?.addEventListener('click', () => {
    remove();
    try {
      if (typeof window.openTop50ScoresDialog === 'function') return window.openTop50ScoresDialog();
      if (typeof openTop50ScoresDialog === 'function') return openTop50ScoresDialog();
    } catch(_) {}
    try { toast('Top 50 Scores not available'); } catch(_) {}
  });

  document.getElementById('leagueLatestScoresBtn')?.addEventListener('click', () => {
    remove();
    try {
      if (typeof window.openLatestScoresDialog === 'function') return window.openLatestScoresDialog();
      if (typeof openLatestScoresDialog === 'function') return openLatestScoresDialog();
    } catch(_) {}
    try { toast('Latest Scores not available'); } catch(_) {}
  });
// Top 50 Scores (Official) â€” best single-game totals from cloud high scores
// ===== @JS:MODAL:TOP_50_SCORES =====
window.openTop50ScoresDialog = async function openTop50ScoresDialog(){
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className = 'modal sq-wide-modal';
  const title   = document.createElement('h3');  title.textContent = 'Top 50 Scores (Official)';
  const body    = document.createElement('div'); body.className = 'modal-body';
  const footer  = document.createElement('div'); footer.className = 'modal-footer';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn primary';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = ()=> overlay.remove();

  modal.append(title, body, footer);
  footer.appendChild(closeBtn);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  modal.tabIndex = 0; modal.focus();
  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); });

  body.innerHTML = '';

  // If cloud is not ready, explain dependency (donâ€™t silently fail)
  if (!window.sb){
    const p=document.createElement('p');
    p.textContent = 'Cloud offline â€” Top 50 Scores requires official cloud data.';
    body.appendChild(p);
    return;
  }

  let rows = [];
  try{
    // pull enough rows to dedupe + sort correctly, then slice top 50
    rows = await cloudListHighScores(false, 1000);
  }catch(e){
    console.error('openTop50ScoresDialog load failed', e);
    const p=document.createElement('p');
    p.textContent = 'Failed to load Top 50 Scores.';
    body.appendChild(p);
    return;
  }

  // Safety: keep one row per (name,score), earliest timestamp
  try{ rows = dedupeRowsByNameScoreKeepEarliest(rows); }catch(_){}

  rows = (rows || []).filter(r => r && r.score != null);
  rows.sort((a,b)=>{
    const sa = Number(a.score||0), sb = Number(b.score||0);
    if (sb!==sa) return sb-sa;
    const ta = a.ts ? Date.parse(a.ts) : 0;
    const tb = b.ts ? Date.parse(b.ts) : 0;
    if (tb!==ta) return tb-ta;
    return String(a.name||'').localeCompare(String(b.name||''));
  });

  rows = rows.slice(0, 50);

  if (!rows.length){
    const p=document.createElement('p');
    p.textContent = 'No official scores found.';
    body.appendChild(p);
    return;
  }

  const table=document.createElement('table'); table.className='hs-table';
  const thead=document.createElement('thead'); const trh=document.createElement('tr');
  ['#','Player','Score','Avg / Round','When'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
  thead.appendChild(trh); table.appendChild(thead);
  const tb=document.createElement('tbody');

  rows.forEach((r, idx)=>{
    const tr=document.createElement('tr');
    const td1=document.createElement('td'); td1.textContent=String(idx+1);
    const td2=document.createElement('td'); td2.textContent=String(r.name||'');
    const td3=document.createElement('td'); td3.textContent=String(r.score);
    const td4=document.createElement('td');
    const avg = (typeof MAX_ROUNDS==='number' && MAX_ROUNDS>0) ? (Number(r.score||0)/MAX_ROUNDS) : 0;
    td4.textContent = avg.toFixed(1);
    const td5=document.createElement('td');
    const d=r.ts?new Date(r.ts):null;
    td5.textContent = (d && !Number.isNaN(d.getTime()))
      ? d.toLocaleString(undefined,{year:'2-digit',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit'})
      : '';
    td5.style.fontSize='0.8rem';
    tr.append(td1,td2,td3,td4,td5);
    tb.appendChild(tr);
  });

  table.appendChild(tb);
  body.appendChild(table);
};};


// === Power Rankings â€” official only (hard cap + min sample; grey-out unqualified) ===
window.openPowerLeagueDialog = async function openPowerLeagueDialog(){
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal sq-wide-modal';
  modal.style.maxWidth = '980px';
  modal.style.width = '94vw';
  modal.style.maxHeight = '90vh';
  modal.style.overflow = 'hidden';

  // Config
  const LIMIT = 56;                 // 4 games (14 rounds each)
  const MIN_ROUNDS_CURRENT = 28;    // threshold for "qualified" status (Current)
  const DAYS_ACTIVE = 14;           // player removed if no official rounds in last N days (Current)
  const MIN_ROUNDS_ALLTIME = LIMIT; // All Time ranks require a full 56-round window

  let view = 'current';

  const head = document.createElement('div'); head.className = 'modal-header';
  head.style.display='flex'; head.style.alignItems='center'; head.style.justifyContent='space-between'; head.style.gap='12px';
  const titleWrap = document.createElement('div'); titleWrap.className = 'pr-modal-titlewrap';
  const title = document.createElement('h3'); title.textContent = 'Power Rankings â€” Last ' + LIMIT + ' Rounds (Official)';
  titleWrap.appendChild(title);

  const tog = document.createElement('div'); tog.className = 'segmented';
  tog.style.display='flex'; tog.style.gap='8px';
  const btnCur = document.createElement('button'); btnCur.type='button'; btnCur.textContent='Current';
  const btnAll = document.createElement('button'); btnAll.type='button'; btnAll.textContent='All Time';
  tog.append(btnCur, btnAll);

  // Segmented styling (matches Latest Scores)
  [btnCur, btnAll].forEach(b=>{
    b.className = 'seg-btn';
    b.style.padding='8px 12px';
    b.style.borderRadius='999px';
    b.style.border='1px solid rgba(255,255,255,.14)';
    b.style.background='rgba(10,12,24,.55)';
    b.style.color='rgba(255,255,255,.85)';
    b.style.fontWeight='800';
  });

  head.append(titleWrap, tog);

  const body    = document.createElement('div'); body.className    = 'modal-body';
  const footer  = document.createElement('div'); footer.className  = 'modal-footer';

  // Footer buttons
  const backBtn  = document.createElement('button');
  backBtn.className  = 'btn sq-pill';
  backBtn.textContent  = 'Back';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn sq-pill';
  closeBtn.textContent = 'Close';

  backBtn.onclick  = () => {
    overlay.remove();
    if (typeof window.openLeagueRankingsDialog === 'function') {
      window.openLeagueRankingsDialog();
    }
  };
  closeBtn.onclick = () => overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(head, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
  modal.tabIndex = 0;
  modal.focus();

  function setView(v){
    view = v;
    btnCur.classList.toggle('active', view==='current');
    btnAll.classList.toggle('active', view==='alltime');

    // Active pill styling (orange edge)
    const activeBorder = '1px solid rgba(255,138,0,.85)';
    const activeBg = 'rgba(255,138,0,.14)';
    const inactiveBorder = '1px solid rgba(255,255,255,.14)';
    const inactiveBg = 'rgba(10,12,24,.55)';
    btnCur.style.border = (view==='current') ? activeBorder : inactiveBorder;
    btnCur.style.background = (view==='current') ? activeBg : inactiveBg;
    btnCur.style.color = (view==='current') ? '#ff8a00' : 'rgba(255,255,255,.85)';
    btnAll.style.border = (view==='alltime') ? activeBorder : inactiveBorder;
    btnAll.style.background = (view==='alltime') ? activeBg : inactiveBg;
    btnAll.style.color = (view==='alltime') ? '#ff8a00' : 'rgba(255,255,255,.85)';
    title.textContent = (view==='current')
      ? ('Power Rankings â€” Last ' + LIMIT + ' Rounds (Official)')
      : ('Power Rankings â€” All Time Best ' + LIMIT + ' (Official)');
  }

  btnCur.onclick = () => { setView('current'); render(); };
  btnAll.onclick = () => { setView('alltime'); render(); };

async function computePowerLeagueRows(which){
  which = which || 'current';
  // Guard cloud
  try { if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) throw new Error('Cloud not initialised'); } catch(_) {}

if (typeof sb === 'undefined'
    || typeof TABLE_GAMES === 'undefined'
    || typeof TABLE_GAME_THROWS === 'undefined'
    || typeof TABLE_PLAYER_GAMES === 'undefined') {
  throw new Error('Cloud tables not configured');
}

  // Robust timestamp parsing (Safari is strict; Supabase often returns: "YYYY-MM-DD HH:MM:SS.sss+00")
  const parseMs = (ts) => {
    if (!ts) return 0;
    if (typeof ts === 'number') return ts;
    let s = String(ts).trim();
    // "2026-01-18 13:53:52.437+00" -> "2026-01-18T13:53:52.437+00:00"
    if (/^\d{4}-\d{2}-\d{2}\s/.test(s) && !s.includes('T')) s = s.replace(' ', 'T');
    // Add missing minutes in offset: "+00" -> "+00:00", "-05" -> "-05:00"
    if (/[+-]\d{2}$/.test(s)) s = s + ':00';
    // Insert colon in offset: "+0000" -> "+00:00"
    if (/[+-]\d{4}$/.test(s) && !/[+-]\d{2}:\d{2}$/.test(s)) s = s.replace(/([+-]\d{2})(\d{2})$/, '$1:$2');
    let ms = Date.parse(s);
    if (!Number.isFinite(ms)) {
      // Last-ditch: treat as UTC if it looks like an ISO datetime without zone.
      if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?$/.test(s)) ms = Date.parse(s + 'Z');
    }
    return Number.isFinite(ms) ? ms : 0;
  };

  // Saved players (case-insensitive)
  let saved = [];
  try { if (typeof cloudListPlayers === 'function') saved = await cloudListPlayers(); } catch(_){}
  const savedSet = new Set(
    (saved || []).map(p => (p && p.name ? String(p.name).trim().toLowerCase() : '')).filter(Boolean)
  );
  const canonical = new Map((saved || []).map(p => [String(p.name).trim().toLowerCase(), String(p.name)]));

  // 1) Fetch OFFICIAL games (2+ players), oldest â†’ newest
  let gameRows = [];
  try{
    const { data, error } = await sb
      .from(TABLE_GAMES)
      .select('id, created_at, state')
      .order('created_at', { ascending: true })
      .limit(5000);
    if (error) throw error;
    gameRows = (data || []).filter(g => Array.isArray(g?.state?.players) && g.state.players.length >= 2);
  } catch(e){
    console.error('Power Rankings: fetch games failed', e);
    throw new Error('Failed to fetch games for Power League');
  }

  if (!gameRows.length) return [];

  const gameMeta = new Map(); // id -> { ts, players:[{name}] }
  const officialIds = [];
  for (const g of gameRows){
    if (g?.id == null) continue;
    officialIds.push(g.id);
    const players = (g?.state?.players || []).map(p => (typeof p === 'string' ? { name: p } : p));
    gameMeta.set(g.id, { ts: g.created_at || null, players });
  }

// 2) Build ROUNDS list, prefer THROWS; fallback to PLAYER_GAMES

// Helper: fetch throws in small chunks to avoid URL length / IN() limits
async function fetchThrowsForGamesChunked(ids, chunkSize = 200){
  const all = [];
  for (let i = 0; i < ids.length; i += chunkSize) {
    const slice = ids.slice(i, i + chunkSize);
    const { data, error } = await sb
      .from(TABLE_GAME_THROWS)
      .select('game_id, player, round_index, dart_index, points, kind')
      .in('game_id', slice)
      .order('game_id',   { ascending: true })
      .order('round_index',{ ascending: true })
      .order('dart_index',{ ascending: true });
    if (error) throw error;
    all.push(...(data || []));
  }
  return all;
}

let roundsList = [];

// Try THROWS first
try {
  const throwsRows = await fetchThrowsForGamesChunked(officialIds);

  if (throwsRows.length) {
    // Group throws â†’ rounds
    const byRoundKey = new Map();
    for (const t of throwsRows){
      const plc = String(t?.player || '').trim().toLowerCase();
      if (savedSet.size && !savedSet.has(plc)) continue;

      const ridx = (typeof t.round_index === 'number') ? t.round_index : null;
      if (ridx == null || ridx < 0 || ridx > 13) continue; // 10..20, D, T, B

      const key = `${t.game_id}|${plc}|${ridx}`;
      let rec = byRoundKey.get(key);
      if (!rec){
        const gm = gameMeta.get(t.game_id) || {};
        const proper = canonical.get(plc) || t.player || '';
        rec = { gid: t.game_id, ts: gm.ts || null, name: proper, playerLC: plc, ridx, total: 0 };
        byRoundKey.set(key, rec);
      }
      rec.total += Number(t.points || 0); // includes D/T/B naturally
    }

    roundsList = Array.from(byRoundKey.values());
  }
} catch (e) {
  console.error('Power Rankings: throws fetch failed (will fallback)', e);
}

// Fallback: build approximate rounds from player_games if no throws
if (!roundsList.length) {
  try {
    const { data, error } = await sb
      .from(TABLE_PLAYER_GAMES)
      .select('player, score, rounds, ts, is_practice')
      .eq('is_practice', false)
      .order('ts', { ascending: true })
      .limit(20000);
    if (error) throw error;

    const pgRows = data || [];
    for (const r of pgRows){
      const name = String(r.player || '').trim();
      if (!name) continue;
      const plc = name.toLowerCase();
      if (savedSet.size && !savedSet.has(plc)) continue;

      let rounds = Number(r.rounds || 0);
      const score = Number(r.score || 0);
      if (!Number.isFinite(score)) continue;

      // Treat a full game as 14 rounds (11 + D + T + B)
      if (rounds >= 11) rounds = Math.min(14, rounds + 3);
      if (rounds <= 0) continue;

      const perRound = score / rounds;
      for (let i = 0; i < rounds; i++){
        roundsList.push({
          gid: null,
          ts: r.ts || null,
          name,
          playerLC: plc,
          ridx: i,
          total: perRound
        });
      }
    }
  } catch (e) {
    console.error('Power Rankings: fallback player_games fetch failed', e);
    // keep roundsList empty â†’ UI will show the "No official games..." message later
  }
}

if (!roundsList.length) return []; // nothing to compute

 // 4) Chronologically order rounds (oldest â†’ newest)
roundsList.sort((a, b) => {
  const ta = a.ts ? parseMs(a.ts) : 0;
  const tb = b.ts ? parseMs(b.ts) : 0;
  if (ta !== tb) return ta - tb;
  if (a.gid !== b.gid) return (a.gid < b.gid ? -1 : 1);
  return a.ridx - b.ridx;
});

  // 5) Build per-player rolling window of LAST 50 ROUNDS
  const byPlayer = new Map(); // nameLC -> { name, buf:number[], lastTs }
  for (const r of roundsList){
    const key = r.playerLC;
    let rec = byPlayer.get(key);
    if (!rec){
      rec = { name: r.name, all: [], tsAll: [], lastTs: null };
      byPlayer.set(key, rec);
    }
    rec.all.push(Number(r.total || 0));
    rec.tsAll.push(r.ts || null);
    if (r.ts) rec.lastTs = r.ts;
  }

  // 6) Compute outputs
  const out = [];
  const cutoffMs = Date.now() - (DAYS_ACTIVE * 24 * 60 * 60 * 1000);
  
  // Helper: best (max) average over any contiguous window of size win (or best available if fewer rounds)
  const bestWindow = (arr, tsArr, win) => {
    const n = arr.length;
    if (!n) return { avg: 0, used: 0, ts: null };
    const w = Math.max(1, Math.min(win, n));
    if (n <= w){
      const s = arr.reduce((a,b)=>a+b,0);
      return { avg: s / n, used: n, ts: (tsArr && tsArr.length) ? (tsArr[n-1] || null) : null };
    }
    let sum = 0;
    for (let i=0;i<w;i++) sum += arr[i];
    let bestSum = sum;
    let bestEnd = w-1;
    for (let i=w;i<n;i++){
      sum += arr[i] - arr[i-w];
      if (sum > bestSum){
        bestSum = sum;
        bestEnd = i;
      }
    }
    const bestTs = (tsArr && tsArr.length) ? (tsArr[bestEnd] || null) : null;
    return { avg: bestSum / w, used: w, ts: bestTs };
  };

for (const [key, rec] of byPlayer){
    const all = rec.all || [];
    const tsAll = rec.tsAll || [];
    if (!all.length) continue;

    const lastTs = rec.lastTs || null;
    const lastMs = lastTs ? parseMs(lastTs) : 0;

    if (which === 'current'){
      const recent = all.slice(-LIMIT);
      const count = recent.length;
      if (count <= 0) continue;

      const total = recent.reduce((s,v)=>s+v,0);
      const avg   = total / count;

      const inactive = (!lastMs) || (lastMs < cutoffMs);
      const qualifiesBase = count >= MIN_ROUNDS_CURRENT;
      const qualifies = qualifiesBase && !inactive;

      const name = canonical.get(key) || rec.name || 'â€”';
      out.push({ name, rounds: count, avg, ts: lastTs, qualifies, inactive, qualifiesBase });
    } else {
      const bw = bestWindow(all, tsAll, LIMIT);
      const inactive = false;
      const qualifiesBase = all.length >= MIN_ROUNDS_ALLTIME;
      const qualifies = qualifiesBase;

      const name = canonical.get(key) || rec.name || 'â€”';
      out.push({ name, rounds: bw.used, avg: bw.avg, ts: bw.ts || lastTs, qualifies, inactive, qualifiesBase, totalRounds: all.length });
    }
  }

  // 7) Sort: qualified first (ranked), then unqualified (grey/unranked)
  out.sort((a, b) => {
    if (a.qualifies !== b.qualifies) return a.qualifies ? -1 : 1;
    if (b.avg !== a.avg) return b.avg - a.avg;
    if ((b.rounds || 0) !== (a.rounds || 0)) return (b.rounds || 0) - (a.rounds || 0);
    const ta = a.ts ? parseMs(a.ts) : 0;
    const tb = b.ts ? parseMs(b.ts) : 0;
    if (tb !== ta) return tb - ta;
    return String(a.name || '').localeCompare(String(b.name || ''));
  });

  return out;
}

async function render(){
    body.innerHTML = '<p class="tag">Loading Power Rankingsâ€¦</p>';

    let rows = [];
    try {
      rows = await computePowerLeagueRows(view);
    } catch (e) {
      console.error(e);
      body.innerHTML = `<p>${(e && e.message) ? e.message : 'Failed to load Power League.'}</p>`;
      return;
    }

    if (!rows.length) {
      body.innerHTML = '<p>No official games found for any saved players yet.</p>';
      return;
    }

    const note = document.createElement('p');
    note.className = 'tag';
    if (rows.some(r => !r.qualifies)) {
      note.textContent = (view==='current')
        ? `Current uses the last ${LIMIT} official rounds (â‰ˆ4 games). Players with fewer than ${MIN_ROUNDS_CURRENT} rounds (2 games), or no official rounds in the last ${DAYS_ACTIVE} days, are greyed out and unranked.`
        : `All Time shows each player's best ${LIMIT}-round average (official). Players with fewer than ${MIN_ROUNDS_ALLTIME} rounds are greyed out and unranked.`;
      body.innerHTML = '';
      body.appendChild(note);
    } else {
      body.innerHTML = '';
    }

    const table = document.createElement('table');
    table.className = 'hs-table';

    const thead = document.createElement('thead');
    const trh   = document.createElement('tr');
    ['#','Player',(view==='current'?`Rounds (up to ${LIMIT})`:`Best Window (${LIMIT})`),'Avg / Round'].forEach(h => {
      const th = document.createElement('th');
      th.textContent = h;
      trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);
    
    // -- rank change arrows (persisted since last open) --
const LS_KEY = (view==='current') ? 'powerRankings.current.lastRanks' : 'powerRankings.allTime.lastRanks';
const LS_KEY_LEGACY = 'powerRankings.lastRanks';
const LS_KEY_LEGACY2 = 'powerLeague.lastRanks';
let prevRanks = new Map();
try {
  let raw = localStorage.getItem(LS_KEY);
  if (!raw && view==='current') raw = localStorage.getItem(LS_KEY_LEGACY) || localStorage.getItem(LS_KEY_LEGACY2);
  if (raw) {
    const obj = JSON.parse(raw);
    if (obj && obj.ranks && typeof obj.ranks === 'object') {
      prevRanks = new Map(Object.entries(obj.ranks)); // nameLC -> rank (1-based)
    }
  }
} catch (_) {}

    const tbody = document.createElement('tbody');

// rank only qualified rows
let rankCounter = 0;
const currRanksObj = {}; // nameLC -> rank

rows.forEach((row) => {
  const tr = document.createElement('tr');

  // Grey-out (and unrank) unqualified rows
  const unq = !row.qualifies;
  if (unq) {
    tr.classList.add('muted');
    tr.style.opacity = '0.6';
    const need = (view==='current')
    ? Math.max(0, MIN_ROUNDS_CURRENT - (row.rounds || 0))
    : Math.max(0, MIN_ROUNDS_ALLTIME - (row.totalRounds || 0));
    if (row.inactive) {
      tr.title = need
        ? `Inactive (no official rounds in last 14 days) â€¢ Needs ${need} more round${need===1?'':'s'} to qualify`
        : 'Inactive (no official rounds in last 14 days)';
    } else {
      tr.title = need ? `Needs ${need} more round${need===1?'':'s'} to qualify` : (view==='current' ? `Below ${MIN_ROUNDS_CURRENT} rounds` : `Below ${MIN_ROUNDS_ALLTIME} rounds`);
    }
  }

  // Determine current rank (qualified only)
  const currentRank = unq ? null : (++rankCounter);

  const tdRank   = document.createElement('td');
  tdRank.textContent = unq ? 'â€”' : String(currentRank);
  if (!unq) tdRank.style.color = '#ff8a00';
  tdRank.style.fontWeight='800';

  const tdName   = document.createElement('td');
  tdName.textContent = row.name || 'â€”';

  // Append green/red arrow if rank changed since last snapshot
  const keyLC = String(row.name || '').trim().toLowerCase();
  if (!unq && keyLC) {
    const prev = prevRanks.get(keyLC);
    if (typeof prev === 'number' && Number.isFinite(prev) && prev !== currentRank) {
      const up = prev > currentRank; // improved if current rank number is smaller
      const arrow = document.createElement('span');
      arrow.textContent = up ? 'â–²' : 'â–¼';
      arrow.style.marginLeft = '6px';
      arrow.style.color = up ? '#7fffd4' : '#ff6b6b';
      arrow.title = up ? `Up ${prev - currentRank}` : `Down ${currentRank - prev}`;
      tdName.appendChild(arrow);
    }
    // record current rank for persistence
    currRanksObj[keyLC] = currentRank;
  }

  const tdRounds = document.createElement('td'); tdRounds.textContent = String(row.rounds); // capped count
  const tdAvg    = document.createElement('td'); tdAvg.textContent    = (Number(row.avg)||0).toFixed(2);

  tr.append(tdRank, tdName, tdRounds, tdAvg);
  tbody.appendChild(tr);
});

    table.appendChild(tbody);


    const wrap = document.createElement('div');
    wrap.className = 'table-wrap';
    wrap.appendChild(table);

// Persist current ranks snapshot for next comparison
try {
  localStorage.setItem(LS_KEY, JSON.stringify({
    ts: new Date().toISOString(),
    ranks: currRanksObj
  }));
} catch (_) {}

    body.appendChild(wrap);
  }

  setView('current');
  render();
};

// Premier League popup â€“ average match total per player, with month filters
// ===== @JS:MODAL:PREMIER_LEAGUE =====
window.openPremierLeagueDialog = async function openPremierLeagueDialog() {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal sq-wide-modal';

  const title = document.createElement('h3');
  title.textContent = 'Premier League';

  const body = document.createElement('div');
  body.className = 'modal-body';
  
  // Lock outer modal â€” let only the inner table scroll
modal.style.maxHeight = '90vh';
modal.style.overflow = 'hidden';
body.style.maxHeight = 'none';
body.style.overflowY = 'visible';

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  // Filter rows + table mount
  const filterWrap = document.createElement('div');
  filterWrap.className = 'pl-filters';
  filterWrap.style.display = 'flex';
  filterWrap.style.flexDirection = 'column';
  filterWrap.style.gap = '6px';
  filterWrap.style.marginBottom = '8px';

  const filterRowRecords = document.createElement('div');
  const filterRowToday   = document.createElement('div');
  const filterRowMonths  = document.createElement('div');
  const filterRowAllYrs  = document.createElement('div');

  [filterRowRecords, filterRowToday, filterRowMonths, filterRowAllYrs].forEach(r => {
    r.className = 'row';
    r.style.display = 'flex';
    r.style.flexWrap = 'wrap';
    r.style.gap = '8px';
    r.style.alignItems = 'center';
  });

  filterWrap.appendChild(filterRowRecords); // Line 1: RECORDS
  filterWrap.appendChild(filterRowToday);   // Line 2: TODAY
  filterWrap.appendChild(filterRowMonths);  // Line 3: Months
  filterWrap.appendChild(filterRowAllYrs);  // Line 4: ALL TIME + Years

  const tableMount = document.createElement('div');
  tableMount.className = 'table-wrap';

  body.appendChild(filterWrap);
  body.appendChild(tableMount);

  // Footer buttons
  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn sq-pill';
  closeBtn.textContent = 'Close';

  backBtn.onclick = () => {
    overlay.remove();
    if (typeof window.openLeagueRankingsDialog === 'function') {
      window.openLeagueRankingsDialog();
    }
  };

  closeBtn.onclick = () => {
    overlay.remove();
  };

  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) overlay.remove();
  });

  overlay.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') overlay.remove();
  });

  modal.tabIndex = 0;
  modal.focus();

  // --- Data helpers ---

  async function fetchRows() {
    try {
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) {
        tableMount.innerHTML = '<p>Cloud not initialised.</p>';
        return [];
      }
    } catch (_) {}

    tableMount.innerHTML = '<p class="tag">Loading Premier Leagueâ€¦</p>';

    try {
      const { data, error } = await sb
        .from(TABLE_PLAYER_GAMES)
        .select('player, score, ts, is_practice')
        .eq('is_practice', false)
        .order('player', { ascending: true })
        .order('ts', { ascending: true })
        .limit(5000);
      if (error) throw error;

      let rows = data || [];

      // Restrict to saved players only, if available
      try {
        if (typeof cloudListPlayers === 'function') {
          const saved = await cloudListPlayers();
          const savedSet = new Set(
            (saved || [])
              .map(p => (p && p.name ? String(p.name).trim().toLowerCase() : ''))
              .filter(Boolean)
          );
          rows = rows.filter(r => {
            const nameLC = String(r.player || '').trim().toLowerCase();
            return nameLC && savedSet.has(nameLC);
          });
        }
      } catch (_) {}

      return rows;
    } catch (e) {
      console.error('Premier League fetch failed', e);
      tableMount.innerHTML = '<p>Failed to load Premier League.</p>';
      return [];
    }
  }

  function buildFilters() {
    const filters = [];

    const now = new Date();

    // RECORDS
    filters.push({
      id: 'RECORDS',
      label: 'RECORDS',
      match: () => true
    });

    // TODAY (local timezone)
    filters.push({
      id: 'TODAY',
      label: 'TODAY',
      match: (ts) => {
        const ms = parseMs(ts);
        if (!Number.isFinite(ms)) return false;
        const dt = new Date(ms);
        const start = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const end   = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
        return dt >= start && dt < end;
      }
    });

    // Recent months (most recent first)
    for (let i = 0; i < 6; i++) {
      const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
      const year = d.getFullYear();
      const month = d.getMonth();
      const label = d.toLocaleString('en-GB', { month: 'short' }).toUpperCase();

      filters.push({
        id: `M${year}-${String(month + 1).padStart(2,'0')}`,
        label,
        match: (ts) => {
          const ms = parseMs(ts);
          if (!Number.isFinite(ms)) return false;
          const dt = new Date(ms);
          return dt.getFullYear() === year && dt.getMonth() === month;
        }
      });
    }

    // Line 4: ALL TIME + explicit year buttons (newest first)
    filters.push({
      id: 'ALL',
      label: 'ALL TIME',
      match: () => true
    });

    // Years (explicit)
    [2026, 2025].forEach(y => {
      filters.push({
        id: `Y${y}`,
        label: String(y),
        match: (ts) => {
          const ms = parseMs(ts);
          if (!Number.isFinite(ms)) return false;
          const dt = new Date(ms);
          return dt.getFullYear() === y;
        }
      });
    });

    return filters;
  }

  function renderFilters(filters, onChange) {

    // Clear each line
    [filterRowRecords, filterRowToday, filterRowMonths, filterRowAllYrs].forEach(r => r.innerHTML = '');

    const buttons = [];

    const hostFor = (f) => {
      if (f.id === 'RECORDS') return filterRowRecords;              // Line 1
      if (f.id === 'TODAY')   return filterRowToday;                // Line 2
      if (f.id === 'ALL')     return filterRowAllYrs;                // Line 4
      if (/^Y\d{4}$/.test(f.id)) return filterRowAllYrs;            // Line 4 (years)
      return filterRowMonths;                                        // Line 3 (months)
    };

    filters.forEach((f) => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'btn small';
      btn.textContent = (f.id === 'ALL') ? 'ALL TIME' : f.label;
      btn.dataset.filterId = f.id;

      hostFor(f).appendChild(btn);
      buttons.push(btn);

      btn.onclick = () => {
        buttons.forEach(b => b.classList.remove('primary'));
        btn.classList.add('primary');
        onChange(f);
      };
    });

    // Default highlight: ALL TIME
    const allBtn = buttons.find(b => b.dataset.filterId === 'ALL');
    if (allBtn) allBtn.classList.add('primary');
  }

function renderRecords(rows){
  // Clear host
  tableMount.innerHTML = '';

// Records thresholds (RECORDS only)
const MIN_MONTHLY_GAMES = 3;
const MIN_ALLTIME_GAMES = 15; // Highest All Time Averages require 15+ games
const wrap = document.createElement('div');
  wrap.className = 'table-wrap';

  // small helper
  const monthLabel = (ts)=>{
    const ms = parseMs(ts);
    const d = Number.isFinite(ms) ? new Date(ms) : null;
    if (!d || Number.isNaN(d.getTime())) return '';
    return d.toLocaleString('en-GB', { month:'short', year:'numeric' }).toUpperCase();
  };

  // ---------- Highest Score (top 3 distinct) ----------
  const topBest = (() => {
    const ordered = (rows || [])
      .map(r => ({ name: String(r.player||'').trim(), score: Number(r.score||0), ts: r.ts }))
      .filter(x => x.name && Number.isFinite(x.score))
      .sort((a,b) => (b.score - a.score) || ((parseMs(a.ts) || 0) - (parseMs(b.ts) || 0)));
    const seen = new Set(); const out = [];
    for (const r of ordered){
      if (!seen.has(r.score)) { seen.add(r.score); out.push(r); }
      if (out.length === 3) break;
    }
    return out;
  })();

  // ---------- Highest Monthly Average (top 3 distinct) ----------
  const topMonthlyAvg = (() => {
    const agg = new Map(); // key: name|YYYY-M -> {total,games,tsAny}
    rows.forEach(r=>{
      const name = String(r.player||'').trim();
      const d = r.ts ? new Date(r.ts) : null;
      if (!name || !d || Number.isNaN(d.getTime())) return;
      const key = `${name}|${d.getFullYear()}-${d.getMonth()}`;
      const a = agg.get(key) || { total:0, games:0, ts:r.ts };
      a.total += Number(r.score||0); a.games += 1; if (!a.ts) a.ts = r.ts;
      agg.set(key, a);
    });
  let rowsM = [];
  agg.forEach((v, key)=>{
    const [name, ym] = key.split('|');
    const avg = v.games ? v.total / v.games : 0;
    rowsM.push({ name, avg, ts: v.ts, ym, games: v.games });
  });

  // Require at least 3 games in that month
  rowsM = rowsM.filter(r => (r.games || 0) >= MIN_MONTHLY_GAMES);

  rowsM.sort((a,b)=> (b.avg - a.avg) || ((parseMs(a.ts) || 0) - (parseMs(b.ts) || 0)));
  const seen = new Set(); const out = [];
  for (const r of rowsM){
    const k = r.avg.toFixed(3);
    if (!seen.has(k)) { seen.add(k); out.push(r); }
    if (out.length === 3) break;
  }
  return out;
})();
  
// ---------- Highest All Time Averages (top 3 distinct) ----------
const topCareerAvg = (() => {
  const agg = new Map(); // name -> { total, games, ts }

  (rows || []).forEach(r => {
    const name = String(r.player || '').trim();
    const sc = Number(r.score || 0);
    if (!name || !Number.isFinite(sc)) return;

    const ts = r.ts || r.created_at || r.inserted_at || null;
    const a = agg.get(name) || { total: 0, games: 0, firstTs: null, lastTs: null };

    a.total += sc;
    a.games += 1;

    if (!a.firstTs || (ts && new Date(ts) < new Date(a.firstTs))) a.firstTs = ts;
    if (!a.lastTs  || (ts && new Date(ts) > new Date(a.lastTs)))  a.lastTs  = ts;

    agg.set(name, a);
  });

 let list = [];
   agg.forEach((v, name) => {
    const avg = v.games ? v.total / v.games : 0;
      list.push({ name, avg, ts: v.lastTs, games: v.games });

  });
  // Require at least 5 career games
  list = list.filter(r => (r.games || 0) >= MIN_ALLTIME_GAMES);


  // Sort by avg desc, then by earliest ts (stable)
  list.sort((a, b) => (b.avg - a.avg) || ((parseMs(a.ts) || 0) - (parseMs(b.ts) || 0)));

  // Take top 3 distinct averages (treat near-equals as same)
  const seen = new Set(); const out = [];
  for (const r of list) {
    const k = r.avg.toFixed(3);
    if (!seen.has(k)) { seen.add(k); out.push(r); }
    if (out.length === 3) break;
  }
  return out;
})();

function section(title, rows, valueFmt, showMonth, noteText){
  const h = document.createElement('h4');
  h.textContent = title;
  h.style.margin = '8px 0 6px';
  wrap.appendChild(h);
  if (noteText) {
      const p = document.createElement('p');
      p.className = 'tag';
      p.textContent = noteText;
      p.style.marginTop = '0';
      p.style.marginBottom = '6px';
      wrap.appendChild(p);
    }

    const table = document.createElement('table');
    table.className = 'hs-table';
    const thead = document.createElement('thead');
    const trh = document.createElement('tr');
    ['#','Player','Score','Month'].forEach((t,i)=>{
      const th = document.createElement('th'); th.textContent = t;
      trh.appendChild(th);
    });
    thead.appendChild(trh); table.appendChild(thead);
    const tbody = document.createElement('tbody');

    rows.forEach((r, i)=>{
      const tr = document.createElement('tr');
      const tdRank  = document.createElement('td'); tdRank.textContent  = String(i+1);
      const tdName  = document.createElement('td'); tdName.textContent  = r.name;
      const tdScore = document.createElement('td'); tdScore.textContent = valueFmt(r);
      const tdMonth = document.createElement('td'); tdMonth.textContent = showMonth ? monthLabel(r.ts) : '';
      tr.append(tdRank, tdName, tdScore, tdMonth);
      tbody.appendChild(tr);
    });

    table.appendChild(tbody);
    wrap.appendChild(table);
  }

  section('Highest Score',
    topBest,
    r => String(r.score),
    true
  );

  section('Highest Monthly Average',
    topMonthlyAvg,
    r => (Number(r.avg)||0).toFixed(1),
    true
  );

section('Highest All Time Averages',
  topCareerAvg,
  r => (Number(r.avg)||0).toFixed(1),
  true,
  'Minimum 15 Games played'
);
  
    // Scroll only inside records list
  const scroll = document.createElement('div');
  scroll.style.maxHeight = '56vh';
  scroll.style.overflowY = 'auto';
  scroll.style.borderRadius = '8px';
  scroll.appendChild(wrap);
  tableMount.appendChild(scroll);


}

  function renderTable(rows, filter, prevFilter) {
    // Qualification thresholds
const MIN_MONTHLY_GAMES = 3;
const MIN_YEAR_GAMES = 10;
const MIN_ALLTIME_GAMES = 15;
    const filtered = rows.filter(r => {
      if (!r || !r.player) return false;
      const score = Number(r.score || 0);
      if (!Number.isFinite(score)) return false;
      if (!filter || filter.id === 'ALL') return true;
      return filter.match(r.ts);
    });

    if (!filtered.length) {
      tableMount.innerHTML = '<p>No games found for this period.</p>';
      return;
    }

    const byPlayer = new Map();

    filtered.forEach(r => {
      const name = String(r.player || '').trim();
      if (!name) return;
      const score = Number(r.score || 0);
      if (!Number.isFinite(score)) return;

      const existing = byPlayer.get(name) || {
        player: name,
        games: 0,
        total: 0,
        best: 0
      };

      existing.games += 1;
      existing.total += score;
      if (score > existing.best) existing.best = score;

      byPlayer.set(name, existing);
    });
    
// Determine qualification threshold by filter:
// - ALL TIME: 15 games
// - Year (e.g. 2025/2026): 10 games
// - Monthly: 3 games
const threshold = (() => {
  if (!filter || filter.id === 'ALL') return MIN_ALLTIME_GAMES;
  if (/^Y\d{4}$/.test(filter.id)) return MIN_YEAR_GAMES;
  return MIN_MONTHLY_GAMES;
})();

const rowsOut = Array.from(byPlayer.values())
  .map(p => {
    const avg = p.games ? (p.total / p.games) : 0;
    return {
      player: p.player,
      games: p.games,
      avg,
      best: p.best,
      qualifies: p.games >= threshold
    };
  })
  .sort((a, b) => {
    // Qualified first
    if (a.qualifies !== b.qualifies) return a.qualifies ? -1 : 1;
    // Then by Avg desc
    if (b.avg !== a.avg) return b.avg - a.avg;
    // Then by Games desc
    if (b.games !== a.games) return b.games - a.games;
    // Then by name asc
    return String(a.player||'').localeCompare(String(b.player||''));
  });
      
      // ALL TIME medals (based on BEST): precompute top 3 distinct best scores
let bestTop3 = null;
if (!filter || filter.id === 'ALL') {
  const uniques = Array.from(
    new Set(rowsOut.filter(p=>p.qualifies).map(p => Number(p.best || 0)).filter(v => Number.isFinite(v) && v > 0))
  ).sort((a, b) => b - a);
  bestTop3 = uniques.slice(0, 3); // [gold, silver, bronze]
}
      
      // --- Helpers to detect "NEW this month" ---
const monthKey = (ts) => {
  if (!ts) return null;
  const d = new Date(ts);
  return Number.isNaN(d.getTime()) ? null : `${d.getFullYear()}-${d.getMonth()}`; // matches buildFilters id
};

// Earliest official game timestamp per player (from ALL rows)
const earliestByPlayer = new Map();
rows.forEach(r => {
  const name = String(r.player || '').trim();
  if (!name || !r.ts) return;
  const cur = earliestByPlayer.get(name);
  if (!cur || new Date(r.ts) < new Date(cur)) {
    earliestByPlayer.set(name, r.ts);
  }
});

// Current month id for ALL TIME "NEW" badge logic
const _now = new Date();
const currentMonthId = `${_now.getFullYear()}-${_now.getMonth()}`;

// --- PB / WR precompute (all-time) ---

// All-time single-game PB per player + global WR (best game)
const bestGameAllByPlayer = new Map();
let globalBestGameWR = -Infinity;

rows.forEach(r => {
  const name = String(r.player || '').trim();
  if (!name) return;
  const sc = Number(r.score || 0);
  if (!Number.isFinite(sc)) return;

  const cur = bestGameAllByPlayer.get(name) || -Infinity;
  if (sc > cur) bestGameAllByPlayer.set(name, sc);
  if (sc > globalBestGameWR) globalBestGameWR = sc;
});

// Monthly average records (per player PB, and global WR)
const monthlyAgg = new Map(); // key: `${name}|${monthId}` -> { total, games }
rows.forEach(r => {
  const name = String(r.player || '').trim();
  const mId  = monthKey(r.ts);
  const sc   = Number(r.score || 0);
  if (!name || !mId || !Number.isFinite(sc)) return;

  const key = `${name}|${mId}`;
  const acc = monthlyAgg.get(key) || { total: 0, games: 0 };
  acc.total += sc; acc.games += 1;
  monthlyAgg.set(key, acc);
});

const maxMonthlyAvgByPlayer = new Map();
let globalMonthlyAvgWR = -Infinity;
monthlyAgg.forEach((v, key) => {
  const [name] = key.split('|');
  const avg = v.games ? (v.total / v.games) : 0;
  const cur = maxMonthlyAvgByPlayer.get(name) ?? -Infinity;
  if (avg > cur) maxMonthlyAvgByPlayer.set(name, avg);
  if (avg > globalMonthlyAvgWR) globalMonthlyAvgWR = avg;
});

    // --- Build previous-month aggregates (avg, best, rank) if prevFilter is provided ---
    let prevMap = null;
    let prevRankMap = null;

    if (prevFilter && filter && filter.id !== 'ALL') {
      const prevFiltered = rows.filter(r => {
        if (!r || !r.player) return false;
        const score = Number(r.score || 0);
        if (!Number.isFinite(score)) return false;
        return prevFilter.match(r.ts);
      });

      if (prevFiltered.length) {
        const prevByPlayer = new Map();

        prevFiltered.forEach(r => {
          const name = String(r.player || '').trim();
          if (!name) return;
          const __k = String(name).trim().toLowerCase();
          const __savedSet = (typeof __llsSavedSet !== "undefined" ? __llsSavedSet : (window.__llsSavedSet || null));
          if (__savedSet && !__savedSet.has(__k)) return;
          const score = Number(r.score || 0);
          if (!Number.isFinite(score)) return;

          const existing = prevByPlayer.get(name) || {
            player: name,
            games: 0,
            total: 0,
            best: 0
          };

          existing.games += 1;
          existing.total += score;
          if (score > existing.best) existing.best = score;

          prevByPlayer.set(name, existing);
        });

        const prevRowsOut = Array.from(prevByPlayer.values())
          .map(p => ({
            player: p.player,
            games: p.games,
            avg: p.games ? p.total / p.games : 0,
            best: p.best
          }))
          .sort((a, b) => b.avg - a.avg);

        prevMap = new Map();
        prevRankMap = new Map();
        prevRowsOut.forEach((p, idx) => {
          prevMap.set(p.player, p);
          prevRankMap.set(p.player, idx + 1);
        });
      }
    }

    function addRankArrow(td, prevRank, currRank) {
      if (!prevRank || !currRank || prevRank === currRank) return;
      const improved = currRank < prevRank; // lower rank number = better
      const span = document.createElement('span');
      span.textContent = improved ? 'â–²' : 'â–¼';
      span.style.marginLeft = '4px';
      span.style.color = improved ? '#7fffd4' : '#ff6b6b'; // green up, red down
      td.appendChild(span);
    }
    
    function addBadge(td, text, colour, title){
  const badge = document.createElement('span');
  badge.textContent = ' ' + text;
  badge.style.marginLeft = '6px';
  badge.style.color = colour;
  if (title) badge.title = title;
  td.appendChild(badge);
}

    function addMetricArrow(td, curr, prev) {
      if (prev == null || !Number.isFinite(prev)) return;
      const diff = curr - prev;
      if (Math.abs(diff) < 0.01) return; // ignore tiny noise
      const up = diff > 0;
      const span = document.createElement('span');
      span.textContent = up ? 'â–²' : 'â–¼';
      span.style.marginLeft = '4px';
      span.style.color = up ? '#7fffd4' : '#ff6b6b';
      td.appendChild(span);
    }

    const table = document.createElement('table');
    table.className = 'hs-table';

    const thead = document.createElement('thead');
    const trh = document.createElement('tr');
    ['#', 'Player', 'Games', 'Avg Total', 'Best'].forEach(h => {
      const th = document.createElement('th');
      th.textContent = h;
      trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);
    
    // Keep the table header fixed while tbody scrolls
Array.from(trh.children).forEach(th => {
  th.style.position = 'sticky';
  th.style.top = '0';
  th.style.zIndex = '2';
  th.style.background = 'rgba(0,0,0,0.4)'; // subtle backdrop
});

    const tbody = document.createElement('tbody');

let rankCounter = 0; // rank only qualified players

rowsOut.forEach((p) => {
  const tr = document.createElement('tr');

  const qualifies = !!p.qualifies;
  const rank = qualifies ? (++rankCounter) : null;

  // Grey-out styling for unqualified rows
  if (!qualifies) {
    tr.classList.add('muted');
    tr.style.opacity = '0.6';
    const need = Math.max(0, threshold - (p.games || 0));
    tr.title = need
      ? `Needs ${need} more game${need===1?'':'s'} to qualify (min ${threshold})`
      : `Unqualified (min ${threshold})`;
  }

  const tdRank = document.createElement('td');
  tdRank.textContent = qualifies ? String(rank) : 'â€”';

  const tdName  = document.createElement('td'); tdName.textContent  = p.player;
  const tdGames = document.createElement('td'); tdGames.textContent = String(p.games);
  const tdAvg   = document.createElement('td'); tdAvg.textContent   = p.avg.toFixed(1);
  const tdBest  = document.createElement('td'); tdBest.textContent  = String(p.best);

  // Add arrows for month-on-month changes when we have previous stats (qualified only)
  if (qualifies && prevMap && prevRankMap) {
    const prevRow  = prevMap.get(p.player);
    const prevRank = prevRankMap.get(p.player);
    addRankArrow(tdRank, prevRank, rank);
    if (prevRow) {
      addMetricArrow(tdAvg, p.avg, prevRow.avg);
      addMetricArrow(tdBest, p.best, prevRow.best);
    }
  }

  // Medals on ALL TIME: ðŸ¥‡ðŸ¥ˆðŸ¥‰ for top 3 distinct BEST scores
  if (!filter || filter.id === 'ALL') {
    const b = Number(p.best || 0);
    if (bestTop3 && b > 0) {
      let medalText = null, colour = null;
      if (bestTop3[0] != null && b === bestTop3[0]) { medalText = ' ðŸ¥‡'; colour = '#ffcc66'; }
      else if (bestTop3[1] != null && b === bestTop3[1]) { medalText = ' ðŸ¥ˆ'; colour = '#c0c0c0'; }
      else if (bestTop3[2] != null && b === bestTop3[2]) { medalText = ' ðŸ¥‰'; colour = '#cd7f32'; }
      if (medalText) {
        const m = document.createElement('span');
        m.textContent = medalText;
        m.style.marginLeft = '6px';
        m.style.color = colour;
        m.title = 'Top 3 all-time best score';
        tdBest.appendChild(m);
      }
    }
  }

  // "NEW" badge (unchanged): still shows even if unranked
  {
    const firstTs  = earliestByPlayer.get(p.player);
    const firstId  = firstTs ? monthKey(firstTs) : null;
    const isAll    = !filter || filter.id === 'ALL';
    const _now = new Date(); const currentMonthId = `${_now.getFullYear()}-${_now.getMonth()}`;
    const showNew  = firstId && (
      (!isAll && firstId === filter.id) ||
      (isAll && firstId === currentMonthId)
    );
    if (showNew) {
      const badge = document.createElement('span');
      badge.textContent = ' NEW';
      badge.style.marginLeft = '6px';
      badge.style.color = '#ffcc66';
      tdRank.appendChild(badge);
    }
  }

  // PB / WR badges â€“ monthly tabs only (unchanged)
  {
    const isAll = !filter || filter.id === 'ALL';
    if (!isAll) {
      const allPBGame = bestGameAllByPlayer.get(p.player) ?? -Infinity;
      const isWRBest  = p.best > 0 && p.best === globalBestGameWR;
      const isPBBest  = p.best > 0 && p.best === allPBGame;
      if (isWRBest)      addBadge(tdBest, 'WR ðŸ¥‡', '#ffcc66', 'World record game score');
      else if (isPBBest) addBadge(tdBest, 'PB',    '#7fffd4', 'Personal best game score');

      const pbMonthlyAvg = maxMonthlyAvgByPlayer.get(p.player) ?? -Infinity;
      const isWRAvg  = p.avg > 0 && Math.abs(p.avg - globalMonthlyAvgWR) < 0.01;
      const isPBAvg  = p.avg > 0 && Math.abs(p.avg - pbMonthlyAvg)      < 0.01;
      if (isWRAvg)      addBadge(tdAvg, 'WR ðŸ¥‡', '#ffcc66', 'World record monthly average');
      else if (isPBAvg) addBadge(tdAvg, 'PB',    '#7fffd4', 'Personal best monthly average');
    }
  }

  tr.append(tdRank, tdName, tdGames, tdAvg, tdBest);
  tbody.appendChild(tr);
});

    table.appendChild(tbody);
// Clear and add minimum-games note + table (only rows scroll)
tableMount.innerHTML = '';
const _isAll = !filter || filter.id === 'ALL';
const minNote = document.createElement('p');
minNote.className = 'tag';
minNote.textContent = _isAll ? '15 Games Minimum' : '10 Games Minimum';

// Scrolling area for the table body only
const scroll = document.createElement('div');
scroll.style.maxHeight = '56vh';     // keeps everything inside the modal
scroll.style.overflowY = 'auto';
scroll.style.borderRadius = '8px';

// Put the table inside the scroll area
scroll.appendChild(table);

// Mount: note stays fixed, header is sticky inside the scroll area
tableMount.appendChild(minNote);
tableMount.appendChild(scroll);

  }

  // Kick it all off
  (async () => {
    const rows = await fetchRows();
    if (!rows.length) return;

const filters = buildFilters();
// Default to ALL TIME even though RECORDS is the first button
let currentFilter = filters.find(f => f.id === 'ALL') || filters[0];

function getPrevFilter(f) {
  if (!f || f.id === 'ALL' || f.id === 'RECORDS') return null;
  const idx = filters.indexOf(f);
  if (idx < 0) return null;
  const nextIdx = idx + 1;
  if (nextIdx >= filters.length) return null;
  const prev = filters[nextIdx];
  if (!prev || prev.id === 'ALL' || prev.id === 'RECORDS') return null;
  return prev;
}

renderFilters(filters, f => {
  currentFilter = f;
  if (f.id === 'RECORDS') {
    renderRecords(rows);
  } else {
    const prev = getPrevFilter(currentFilter);
    renderTable(rows, currentFilter, prev);
  }
});

// Initial render = ALL TIME table
const initialPrev = getPrevFilter(currentFilter);
renderTable(rows, currentFilter, initialPrev);
  })();
};


// Latest Scores modal: overlay with # | Result | Date/Time + Official/Practice toggle + chart
// ===== @JS:MODAL:LATEST_SCORES =====
async function openLatestScoresDialog(initialMode){
  // Match Latest Matches modal look & feel
  document.querySelectorAll('.sq-latest-scores-backdrop').forEach(n => n.remove());

  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop sq-latest-scores-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.maxWidth = '980px';
  modal.style.width = '94vw';

  const mode0 = (initialMode === 'practice' || initialMode === 'official') ? initialMode : 'official';

  modal.innerHTML = `
    <div class="modal-header" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
      <div>
        <div style="font-size:18px; font-weight:800; letter-spacing:.02em;">Latest Scores</div>
        <div style="font-size:11px; opacity:.65; margin-top:2px;">Result / Date-Time</div>
      </div>

      <div style="display:flex; align-items:center; gap:10px;">
        <div class="segmented" style="display:flex; gap:8px;">
          <button class="seg-btn" data-mode="official">Official</button>
          <button class="seg-btn" data-mode="practice">Practice</button>
        </div>
      </div>
    </div>

    <div class="modal-body" style="padding-top:8px;">
      <div class="latest-scores-table-wrap" style="border:1px solid rgba(255,255,255,.08); border-radius:14px; overflow:auto; max-height:56vh;">
        <table class="sq-table latest-scores" style="width:100%; border-collapse:collapse; table-layout:fixed;">
          <colgroup>
            <col style="width:7%">
            <col style="width:70%">
            <col style="width:23%">
          </colgroup>
          <thead>
            <tr>
              <th style="text-align:left; padding-left:14px;">#</th>
              <th style="text-align:left;">Result</th>
              <th style="text-align:right; padding-right:14px;">Date/Time</th>
            </tr>
          </thead>
          <tbody data-role="rows"></tbody>
        </table>
      </div>

      <div class="modal-footer" style="display:flex; justify-content:flex-start; gap:10px; margin-top:14px;">
        <button class="btn small sq-pill" data-action="back" style="min-width:84px;">Back</button>
        <button class="btn small sq-pill" data-action="close" style="min-width:84px;">Close</button>
      </div>
    </div>
  `;

  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  const segBtns = modal.querySelectorAll('.seg-btn');
  segBtns.forEach(b=>{
    b.style.padding = '8px 12px';
    b.style.borderRadius = '999px';
    b.style.border = '1px solid rgba(255,255,255,.14)';
    b.style.background = 'rgba(10,12,24,.55)';
    b.style.color = 'rgba(255,255,255,.85)';
    b.style.fontWeight = '700';
    b.style.letterSpacing = '.02em';
    b.style.cursor = 'pointer';
    b.style.userSelect = 'none';
  });

  const rowsEl = modal.querySelector('[data-role="rows"]');

  // Local helpers (Latest Scores must be self-contained; do NOT rely on other modal scopes)
  const escapeHtml = (s) => String(s ?? '')
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');

  const playerNameFrom = (p) => {
    if (p == null) return '';
    if (typeof p === 'string') return p.trim();
    // Sometimes we store {name}, sometimes richer player objects
    const name = (p?.name || p?.player || p?.player_name || p?.playerName || '').toString().trim();
    if (name) return name;
    const first = (p?.first_name || p?.firstName || '').toString().trim();
    const last  = (p?.last_name  || p?.lastName  || '').toString().trim();
    const nick  = (p?.nickname   || '').toString().trim();
    if (first) {
      if (nick && last) return `${first} "${nick}" ${last}`.trim();
      if (nick) return `${first} "${nick}"`.trim();
      if (last) return `${first} ${last}`.trim();
      return first;
    }
    const id = (p?.id || p?.player_id || p?.playerId || '').toString().trim();
    return id;
  };

  const displayName = (n) => String(n || '').replace(/\s+/g,' ').trim();

  const setActiveModeUI = (mode) => {
    segBtns.forEach(btn=>{
      const on = btn.dataset.mode === mode;
      btn.style.borderColor = on ? 'rgba(255,123,26,.85)' : 'rgba(255,255,255,.14)';
      btn.style.boxShadow = on ? '0 0 0 2px rgba(255,123,26,.15) inset' : 'none';
      btn.style.color = on ? '#fff' : 'rgba(255,255,255,.85)';
      btn.style.background = on ? 'rgba(255,123,26,.12)' : 'rgba(10,12,24,.55)';
    });
  };

  const formatResult = (g) => {
    try {
      if (typeof window.formatGameResultLine === 'function') return window.formatGameResultLine(g);
    } catch(_) {}
    const players = (g.players || []).map(playerNameFrom).filter(Boolean).map(displayName);
    const totals  = Array.isArray(g.totals) ? g.totals : [];
    const ordered = players
      .map((name, i) => ({ name, score: Number(totals[i] || 0) }))
      .filter(x => x.name)
      .sort((a, b) => b.score - a.score);

    if (!ordered.length) return 'â€”';
    if (ordered.length === 1) return `${ordered[0].name} ${ordered[0].score}`;

    let result = `${ordered[0].name} ${ordered[0].score} beat ${ordered[1].name} ${ordered[1].score}`;
    if (ordered.length > 2) result += ' ' + ordered.slice(2).map(o => `${o.name} ${o.score}`).join(' ');
    return result;
  };

  const formatWhen = (g) => {
    try {
      if (typeof window.getGameTimestamp === 'function' && typeof window.fmtWhen === 'function') {
        const d = window.getGameTimestamp(g);
        if (d) return window.fmtWhen(d);
      }
    } catch(_) {}
    const tsVal = g?.ts || g?.created_at || g?.inserted_at || (g?.meta && (g.meta.ts || g.meta.date)) || null;
    if (!tsVal) return '';
    const ms = parseMs(tsVal);
    const d = Number.isFinite(ms) ? new Date(ms) : null;
    return d && !Number.isNaN(d.getTime())
      ? d.toLocaleString(undefined,{ year:'2-digit', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit' })
      : '';
  };

  const isPracticeGameRow = (g) => {
    // Strongest signal: explicit flags / mode
    const mode = String(g?.mode || g?.game_mode || g?.meta?.mode || g?.state?.mode || '').toLowerCase();
    if (mode.includes('practice')) return true;
    if (mode.includes('unofficial') || mode.includes('un-official')) return true;
    if (mode.includes('official')) return false;

    if (g?.is_practice === true || g?.practice === true || g?.isPractice === true) return true;
    if (g?.is_official === false || g?.official === false || g?.isOfficial === false) return true;
    if (g?.state?.is_practice === true || g?.state?.practice === true || g?.state?.isPractice === true) return true;

    // Match linkage: usually official games have a match_id, practice often doesn't.
    const mid = (g?.match_id ?? g?.matchId ?? g?.state?.match_id ?? g?.state?.matchId ?? null);
    if (mid) return false;

    // Player-count heuristic: practice supports 1p
    const ps = Array.isArray(g?.players) ? g.players : (Array.isArray(g?.state?.players) ? g.state.players : []);
    if (ps.length === 1) return true;

    // If we truly can't tell, default to PRACTICE only when match_id is missing.
    return true;
  };

  const isOfficialGameRow = (g) => !isPracticeGameRow(g);

  const renderRows = (games) => {
    const safe = Array.isArray(games) ? games : [];
    rowsEl.innerHTML = safe.map((g, idx) => {
      const res = escapeHtml(formatResult(g));
      const when = escapeHtml(formatWhen(g));
      return `
        <tr style="cursor:pointer;">
          <td style="text-align:left; padding-left:14px; color:rgba(255,123,26,.95); font-weight:800;">${idx+1}</td>
          <td style="text-align:left;">${res}</td>
          <td style="text-align:right; padding-right:14px; opacity:.9;">${when}</td>
        </tr>
      `;
    }).join('');

    // Row click opens score sheet (if available)
    Array.from(rowsEl.querySelectorAll('tr')).forEach((tr, i) => {
      tr.title = 'Open score sheet';
      tr.addEventListener('click', () => {
        try { if (typeof openSingleGameScoreSheet === 'function') openSingleGameScoreSheet(safe[i]); } catch(_) {}
      });
    });
  };

  let __sqLatestScoresLoadSeq = 0;

  const load = async (mode) => {
    const seq = ++__sqLatestScoresLoadSeq;

    setActiveModeUI(mode);
    rowsEl.innerHTML = `<tr><td colspan="3" style="padding:18px; opacity:.7;">Loadingâ€¦</td></tr>`;

    const withTimeout = (p, ms) => Promise.race([
      p,
      new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), ms))
    ]);

    let games = [];
    try {
      // Cloud-first, but don't hang forever if network stalls
      games = await withTimeout(cloudFetchAllGamesAsLocal(), 5000);
    } catch (e) {
      // Fallback to local cache (still useful offline)
      try { games = (typeof getGameLog === 'function') ? (getGameLog() || []) : []; } catch(_) { games = []; }
    }

    if (seq !== __sqLatestScoresLoadSeq) return;

    const toTS = (g) => {
      const t = g?.ts || g?.created_at || g?.inserted_at || (g?.meta && (g.meta.ts || g.meta.date)) || null;
      const n = t ? Date.parse(t) : NaN;
      return Number.isFinite(n) ? n : 0;
    };

    games = (games || []).filter(Boolean).sort((a,b)=> toTS(b) - toTS(a));
    games = games.filter(g => mode === 'official' ? isOfficialGameRow(g) : isPracticeGameRow(g));

    // keep games with any named player (avoid blank rows)
    games = games.filter(g => Array.isArray(g.players) && g.players.some(p => !!playerNameFrom(p)));

    games = games.slice(0, 50);

    if (!games.length) {
      rowsEl.innerHTML = `<tr><td colspan="3" style="padding:18px; opacity:.7;">No ${mode} games found.</td></tr>`;
      return;
    }
    renderRows(games);
  };

  let mode = mode0;
  load(mode);

  // Don't await inside click handler; keep UI responsive even if cloud is slow.
  segBtns.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      mode = btn.dataset.mode;
      load(mode);
    });
  });

  const close = () => overlay.remove();
  const goBack = () => { overlay.remove(); };

  overlay.addEventListener('click', (e)=>{ if (e.target === overlay) close(); });
  modal.addEventListener('click', (e)=>{
    const t = e.target.closest('[data-action]');
    if (!t) return;
    const a = t.getAttribute('data-action');
    if (a === 'close') close();
    if (a === 'back') goBack();
  });

  modal.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') close(); });
  modal.tabIndex = 0; modal.focus();
}

try { window.openLatestScoresDialog = openLatestScoresDialog; } catch(_) {}


// === Player Stats â€” redesigned overview =====================================
window.openPlayerStatsDialog = async function openPlayerStatsDialog(playerName){
  const name = String(playerName || '').trim();
  if (!name) { try{ toast('Pick a player'); }catch(_){ } return; }

  // Modal shell
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal';
  modal.style.maxWidth='980px'; modal.style.width='94vw';
  modal.style.maxHeight = '90vh'; modal.style.overflow = 'hidden';

  const header  = __sqStatsHeader(`Player Stats â€” ${name}`, 'Overview / Premier League / Targets');
  const body    = document.createElement('div'); body.className    = 'modal-body';
  body.style.paddingTop='8px';
  body.style.maxHeight = 'none'; body.style.overflowY = 'auto';

  const footer  = document.createElement('div'); footer.className  = 'modal-footer';
  footer.style.justifyContent='flex-start';
  footer.style.gap='10px';

  // Mount early so we never "flash" back to home between dialogs
  body.innerHTML = '<p class="muted">Loadingâ€¦</p>';
  modal.append(header, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
  modal.tabIndex = 0; 
  modal.focus();

  // Helpers
  const monthKey = d => {
    const x = (d instanceof Date) ? d : (d ? new Date(d) : null);
    return x && !Number.isNaN(x.getTime()) ? `${x.getFullYear()}-${String(x.getMonth()+1).padStart(2,'0')}` : '';
  };
  const monthLabel = k => {
    if (!k) return 'â€”';
    const [y,m] = k.split('-').map(Number);
    return new Date(y, m-1, 1).toLocaleString(undefined,{ month:'short', year:'numeric' }).toUpperCase();
  };

  // 1) All official games (normalized, oldestâ†’newest)
  const games = (await __fetchOfficialGames(50000)).map(__normalizeGame)
    .filter(g => Array.isArray(g.players) && g.players.some(p => String(p||'').trim().toLowerCase()===name.toLowerCase()))
    .sort((a,b)=> (new Date(a.ts) - new Date(b.ts)));

  // Short-circuit if nothing
  if (!games.length){
    body.innerHTML = '';
    const p = document.createElement('p');
    p.className = 'muted';
    p.style.opacity = '.8';
    p.textContent = 'No official games found for this player.';
    body.appendChild(p);

    footer.innerHTML = '';
    const backBtn  = document.createElement('button'); backBtn.className='btn sq-pill'; backBtn.textContent='Back';
    const closeBtn = document.createElement('button'); closeBtn.className='btn sq-pill'; closeBtn.textContent='Close';
    backBtn.onclick  = () => { overlay.remove(); __sqGoBackToStatsMain(); };
    closeBtn.onclick = () => overlay.remove();
    footer.append(backBtn, closeBtn);

    modal.focus();
    return;
  }

  // Index for this player and raw scores
  const idxOf = g => g.players.findIndex(p => String(p||'').trim().toLowerCase()===name.toLowerCase());
  const scores = games.map(g => Number(g.totals[idxOf(g)] || 0));

  // 2) Basic aggregates
  const GAMES = scores.length;
  const TOTAL = scores.reduce((s,v)=>s+v,0);
  const AVG   = GAMES ? (TOTAL / GAMES) : 0;
  const PB    = GAMES ? Math.max(...scores) : 0;
  const LOW   = GAMES ? Math.min(...scores) : 0;

  // Per-game ranks (1st place detection) and per-month buckets
  const monthly = new Map(); // key -> { sum, n, wins }
  games.forEach((g,i)=>{
    const meI = idxOf(g);
    const meS = Number(g.totals[meI] || 0);
    const max = Math.max(...(g.totals||[]).map(Number));
    const win = meS === max ? 1 : 0;

    const k = monthKey(g.ts);
    const rec = monthly.get(k) || { sum:0, n:0, wins:0 };
    rec.sum += meS; rec.n += 1; rec.wins += win;
    monthly.set(k, rec);
  });

  // Highest/lowest monthly averages
  const monthlyRows = Array.from(monthly.entries()).map(([k,rec])=>({ k, avg: rec.n ? rec.sum/rec.n : 0, wins: rec.wins }));
  monthlyRows.sort((a,b)=> a.k.localeCompare(b.k));
  const bestMonth = monthlyRows.length ? monthlyRows.reduce((m,r)=> r.avg>m.avg?r:m, monthlyRows[0]) : null;
  const worstMonth= monthlyRows.length ? monthlyRows.reduce((m,r)=> r.avg<m.avg?r:m, monthlyRows[0]) : null;

  // PL Average (career) & PL Monthly Wins (current month)
const nowK = monthKey(new Date());

// Premier League "Monthly Wins":
// # of months this player finished 1st by monthly average (min 3 games)
function computePLMonthlyWinsTop(games, minGames = 3, me = name){
  const byMonthPlayer = new Map(); // `${month}|${player}` -> { sum, n }

  games.forEach(g=>{
    const mk = monthKey(g.ts);
    (g.players||[]).forEach((p,i)=>{
      const key = `${mk}|${p}`;
      const rec = byMonthPlayer.get(key) || { sum:0, n:0 };
      rec.sum += Number(g.totals[i] || 0);
      rec.n   += 1;
      byMonthPlayer.set(key, rec);
    });
  });

  const months = new Set(Array.from(byMonthPlayer.keys()).map(k=>k.split('|')[0]));
  let wins = 0;

  months.forEach(mk=>{
    const contenders = [];
    byMonthPlayer.forEach((rec,key)=>{
      const [k,p] = key.split('|');
      if (k !== mk) return;
      if (rec.n >= minGames) contenders.push({ player:p, avg: rec.sum/rec.n });
    });
    if (!contenders.length) return;
    contenders.sort((a,b)=> b.avg - a.avg);
    if (contenders[0].player.toLowerCase() === me.toLowerCase()) wins += 1;
  });

  return wins;
}
const plMonthlyWins = computePLMonthlyWinsTop(games, 3, name);

 // 3) Highest Scoring Round (10â†’20 only) with S/D/T breakdown â€” robust via boards
function bestRoundFromBoards(playerName, games){
  const nameLC = String(playerName||'').trim().toLowerCase();
  let best = null;

  games.forEach(g=>{
    const pIdx = (g.players||[]).findIndex(p => String(p||'').trim().toLowerCase()===nameLC);
    if (pIdx < 0) return;
    const b = g.board; if (!b) return;

    const looksA = Array.isArray(b[pIdx]);
    const looksB = Array.isArray(b[0]) && Array.isArray(b[0][pIdx]);
    const rounds = looksA ? b[pIdx] : (looksB ? b.map(r => r ? r[pIdx] : null) : []);

    for (let r = 0; r < Math.min(14, rounds.length || 0); r++){
      if (r > 10) break; // 10..20 only
      const cell = rounds[r]; if (!cell) continue;

      const list = Array.isArray(cell)
        ? cell
        : (Array.isArray(cell.throws) ? cell.throws : (Array.isArray(cell.darts) ? cell.darts : []));

      let sum = 0, s = 0, d = 0, t = 0;
      const target = 10 + r;

      list.forEach(tw=>{
        const ringRaw = (tw?.kind || tw?.type || tw?.segment || tw?.ring || '').toString().toLowerCase();
        let mult = Number(tw?.mult ?? tw?.multiplier);
        if (!mult || !Number.isFinite(mult)) {
          // infer multiplier from points if needed
          const pts = Number(tw?.points ?? tw?.score ?? 0);
          const ratio = target ? (pts/target) : 0;
          if (ratio >= 2.5) mult = 3;
          else if (ratio >= 1.5) mult = 2;
          else mult = pts>0 ? 1 : 0;
        }
        const pts = Number.isFinite(Number(tw?.points ?? tw?.score))
          ? Number(tw?.points ?? tw?.score)
          : (target * mult);

        sum += pts;
        if (mult === 3 || ringRaw.includes('treb')) t++;
        else if (mult === 2 || ringRaw.includes('doub')) d++;
        else if (mult === 1) s++;
      });

      if (!best || sum > best.sum) best = { round: 10+r, sum, s, d, t };
    }
  });

  return best;
}
const bestRound = bestRoundFromBoards(name, games) || null;

  // 4) H2H for Nemesis/BFF (>=10 games vs opponent)
  const vs = new Map();
  games.forEach(g=>{
    const meI = idxOf(g), meS = Number(g.totals[meI]||0);
    g.players.forEach((op,j)=>{
      if (j===meI) return;
      const opp = String(op||'').trim();
      const theirs = Number(g.totals[j]||0);
      const rec = vs.get(opp) || { opp, W:0, L:0, n:0 };
      if (meS > theirs) rec.W++; else if (meS < theirs) rec.L++;
      rec.n++; vs.set(opp, rec);
    });
  });
const qualifiedOpp = Array.from(vs.values()).filter(r=> r.n >= 5).map(r=>({ ...r, pct: (r.W+r.L) ? (100*r.W/(r.W+r.L)) : 0 }));  const bff = qualifiedOpp.length ? qualifiedOpp.reduce((m,r)=> r.pct>m.pct?r:m, qualifiedOpp[0]) : null;
  const nem = qualifiedOpp.length ? qualifiedOpp.reduce((m,r)=> r.pct<m.pct?r:m, qualifiedOpp[0]) : null;

  // lifetime, from the games we already loaded at the top of this function
const myThrowsFromBoards = __throwsFromGamesForPlayer(name, games);
let onlyTargetRounds = [];
if (Array.isArray(myThrowsFromBoards) && myThrowsFromBoards.length) {
  onlyTargetRounds = myThrowsFromBoards.filter(
    t => typeof t.round_index === 'number' && t.round_index >= 0 && t.round_index <= 10 // 10..20 only
  );
}

  // Reuse same hits model: â€œmarks per dartâ€ (single=1, double=2, treble=3)
  const markUnits = (t, target) => {
    const k = String(t.kind||'').toLowerCase();
    if (k.includes('treble') || k.includes('triple')) return 3;
    if (k.includes('double')) return 2;
    if (k.includes('single')) return Number(t.points||0)>0 ? 1 : 0;
    const ratio = Number(t.points||0) / target; // fallback
    if (ratio >= 2.5) return 3; if (ratio >= 1.5) return 2; if (ratio >= 0.5) return 1; return 0;
  };
  const favRows = [];
  for (let r=0; r<=10; r++){
    const target = 10 + r;
    const shots  = onlyTargetRounds.filter(t => t.round_index === r);
    const throwsN = shots.length;
    const hitsUnits = shots.reduce((s,t)=> s + markUnits(t,target), 0);
    const pct = throwsN ? (100 * hitsUnits / (3*throwsN)) : 0; // units Ã· (3 per throw)
    favRows.push({ target, throwsN, pct });
  }
  // require a small sample to avoid noise
  const MIN_THROWS_PER_TARGET = 30;
  const favCandidates = favRows.filter(r => r.throwsN >= MIN_THROWS_PER_TARGET);
  const fav = favCandidates.length ? favCandidates.reduce((m,r)=> r.pct>m.pct?r:m, favCandidates[0]) : null;
  const worst = favCandidates.length ? favCandidates.reduce((m,r)=> r.pct<m.pct?r:m, favCandidates[0]) : null;

// 6) Current Power Rank â€” mirror â€œPower Rankings â€” Last 56 Rounds (Official)â€
const MIN_ROUNDS_QUALIFY = 28;   // 2 games (28 rounds)
const WINDOW_ROUNDS      = 56;   // last 56 rounds

// Use ALL official games (not just this player's) so we can rank everyone
const allGames = (await __fetchOfficialGames(50000)).map(__normalizeGame);

// Map game_id -> timestamp (for ordering rounds)
const gameTs = new Map();
allGames.forEach(g => {
  const gid = (g.raw && (g.raw.id || g.raw.game_id)) || g.id || g.game_id;
  if (gid) gameTs.set(gid, g.ts || null);
});

// Fetch throws for all those games; fallback to reconstruct from boards
let allThrows = [];
try {
  const allIds = allGames
    .map(g => (g.raw && (g.raw.id || g.raw.game_id)) || g.id || g.game_id)
    .filter(Boolean);
  allThrows = await __fetchThrowsForGames(allIds);
} catch (_) {}

if (!allThrows.length) {
  // fallback: synthesize from boards
  allGames.forEach(g => {
    (g.players || []).forEach(p => {
      const rows = __throwsFromGamesForPlayer(p, [g]);
      if (rows && rows.length) allThrows.push(...rows);
    });
  });
}

// Keep only real round rows and finite points
allThrows = allThrows.filter(t =>
  typeof t.round_index === 'number' &&
  t.round_index >= 0 && t.round_index <= 13 &&
  Number.isFinite(Number(t.points))
);

// Aggregate to per-player round totals, ordered by (game ts, round index)
const roundsByPlayer = new Map(); // player -> [{ts, ri, pts}, ...]
allThrows.forEach(t => {
  const player = String(t.player || '').trim();
  if (!player) return;
  const gid = t.game_id;
  const ts  = gameTs.get(gid) || null;
  const ri  = Number(t.round_index || 0);
  const pts = Number(t.points || 0);

  // key per game+round so multiple darts sum to that round
  const bucketKey = `${gid}|${ri}`;
  let list = roundsByPlayer.get(player);
  if (!list) { list = []; roundsByPlayer.set(player, list); }

  // find or create that round entry
  let entry = list.find(e => e.key === bucketKey);
  if (!entry) {
    entry = { key: bucketKey, ts, ri, sum: 0 };
    list.push(entry);
  }
  entry.sum += pts;
});

// Build power rows: last 56 rounds -> avg per round; qualify if >= 28 rounds (2 games)
const powerRows = Array.from(roundsByPlayer.entries()).map(([player, list]) => {
  // order by time then round index
  list.sort((a, b) => {
    const at = a.ts ? new Date(a.ts).getTime() : 0;
    const bt = b.ts ? new Date(b.ts).getTime() : 0;
    return (at - bt) || (a.ri - b.ri);
  });

  const last     = list.slice(-WINDOW_ROUNDS);
  const n        = last.length;
  const pts      = last.reduce((s, r) => s + Number(r.sum || 0), 0);
  const avgRound = n ? (pts / n) : 0;
  const recentTs = last.length ? (last[last.length - 1].ts || 0) : 0;
  const qualifies = n >= MIN_ROUNDS_QUALIFY;

  return { player, rounds: n, avgRound, recentTs, qualifies };
});

// Sort using the same tie-breakers as the Power Rankings table:
// 1) avg/round â†“, 2) rounds â†“, 3) most-recent ts â†“, 4) player name â†‘
const qualified = powerRows
  .filter(r => r.qualifies)
  .sort((a, b) =>
    (b.avgRound - a.avgRound) ||
    (b.rounds   - a.rounds)   ||
    (b.recentTs - a.recentTs) ||
    String(a.player).localeCompare(String(b.player))
  );

// My row + absolute position among qualified
const myPower = qualified.find(
  r => r.player.toLowerCase() === name.toLowerCase()
) || null;

const myPowerPos = myPower ? (qualified.indexOf(myPower) + 1) : null;

  // Highest power rank (historical) â€” not tracked; show current as best for now.
  const bestPowerPos = myPowerPos || null;

  // Best-score leaderboard rank (use each player's PB across all games)
  const bestByPlayer = new Map();
  games.forEach(g=>{
    (g.players||[]).forEach((p,i)=>{
      const s = Number(g.totals[i]||0);
      const prev = bestByPlayer.get(p) || 0;
      if (s > prev) bestByPlayer.set(p, s);
    });
  });
  const bestList = Array.from(bestByPlayer.entries()).map(([p,b])=>({p,b})).sort((a,b)=> b.b - a.b);
  const myPB = PB;
  const myPBPos = myPB ? (bestList.findIndex(x => x.p.toLowerCase()===name.toLowerCase()) + 1 || null) : null;

  // ---- Render as a tidy two-column grid of â€œstat cardsâ€ ----
  const grid = document.createElement('div');
  grid.style.display = 'grid';
  grid.style.gridTemplateColumns = '1fr 1fr';
  grid.style.gap = '10px';

  function card(label, value, hint){
    const c = document.createElement('div');
    c.className = 'tag';
    c.style.display='flex'; c.style.justifyContent='space-between'; c.style.alignItems='center';
    c.style.padding='8px 10px';
    const L = document.createElement('span'); L.textContent = label;
    const R = document.createElement('span'); R.textContent = value;
    if (hint) R.title = hint;
    c.append(L,R);
    return c;
  }

  // Section helper
  function section(titleTxt){
    const h = document.createElement('h4');
    h.textContent = titleTxt;
    h.style.margin = '12px 0 6px';
    return h;
  }

  // Top: Games / Current & Highest Power Rank
  body.appendChild(section('Overview'));
  grid.appendChild(card('Games', String(GAMES)));
grid.appendChild(card(
  'Current Power Rank',
  (myPower && myPower.qualifies) ? `${myPower.avgRound.toFixed(2)}  (#${myPowerPos})` : 'â€”',
  myPower ? `${myPower.rounds} rounds (last ${WINDOW_ROUNDS} window)` : ''
));
  grid.appendChild(card('Highest Power Rank', bestPowerPos ? `#${bestPowerPos}` : 'â€”', 'Best historical position (requires rank history)'));
  body.appendChild(grid);

  // Premier League style
  body.appendChild(section('Premier League'));
  const gridPL = document.createElement('div');
  gridPL.style.display='grid'; gridPL.style.gridTemplateColumns='1fr 1fr'; gridPL.style.gap='10px';
  gridPL.appendChild(card('PL Average', AVG.toFixed(1)));
gridPL.appendChild(card('PL Monthly Wins', String(plMonthlyWins)));
gridPL.appendChild(card('Highest Monthly Average', bestMonth ? `${bestMonth.avg.toFixed(1)} (${monthLabel(bestMonth.k)})` : 'â€”'));
  gridPL.appendChild(card('Lowest Monthly Average',  worstMonth ? `${worstMonth.avg.toFixed(1)} (${monthLabel(worstMonth.k)})` : 'â€”'));
  body.appendChild(gridPL);

  // Game highs/lows + best round
  body.appendChild(section('Game Highs & Lows'));
  const gridGL = document.createElement('div');
  gridGL.style.display='grid'; gridGL.style.gridTemplateColumns='1fr 1fr'; gridGL.style.gap='10px';
  gridGL.appendChild(card('Highest Score', myPB ? `${myPB}  (#${myPBPos||'â€”'})` : 'â€”'));
  gridGL.appendChild(card('Lowest Score', GAMES ? String(LOW) : 'â€”'));
function lettersFromCounts(s,d,t){
  return `${'S'.repeat(s).split('').join('/')}${s&& (d||t)?'/':''}${'D'.repeat(d).split('').join('/')}${d&&t?'/':''}${'T'.repeat(t).split('').join('/')}`.replace(/^\/|\/$/g,'') || 'â€”';
}
const brTxt = bestRound ? `${bestRound.round} â€¢ ${bestRound.sum}  (${lettersFromCounts(bestRound.s, bestRound.d, bestRound.t)})` : 'â€”';
  gridGL.appendChild(card('Highest Scoring Round', brTxt, '10â†’20 rounds only'));
  body.appendChild(gridGL);

  // Opponents
  body.appendChild(section('Opponents'));
  const gridOP = document.createElement('div');
  gridOP.style.display='grid'; gridOP.style.gridTemplateColumns='1fr 1fr'; gridOP.style.gap='10px';
gridOP.appendChild(card('Nemesis', nem ? `${nem.opp}  (${nem.pct.toFixed(1)}%)` : 'â€”', 'â‰¥5 games'));
gridOP.appendChild(card('BFF', bff ? `${bff.opp}  (${bff.pct.toFixed(1)}%)` : 'â€”', 'â‰¥5 games'));
  body.appendChild(gridOP);

  // Targets
  body.appendChild(section('Targets'));
  const gridTG = document.createElement('div');
  gridTG.style.display='grid'; gridTG.style.gridTemplateColumns='1fr 1fr'; gridTG.style.gap='10px';
  gridTG.appendChild(card('Favorite Number', fav ? `${fav.target}  (${fav.pct.toFixed(1)}%)` : 'â€”', 'min 30 throws'));
  gridTG.appendChild(card('Worst Number',   worst ? `${worst.target}  (${worst.pct.toFixed(1)}%)` : 'â€”', 'min 30 throws'));
  body.appendChild(gridTG);

  // Footer buttons
  const backBtn  = document.createElement('button'); backBtn.className = 'btn sq-pill'; backBtn.textContent = 'Back';
  const closeBtn = document.createElement('button'); closeBtn.className = 'btn sq-pill'; closeBtn.textContent = 'Close';
  backBtn.onclick  = () => { overlay.remove(); __sqGoBackToStatsMain(); };
  closeBtn.onclick = () => overlay.remove();
  footer.append(backBtn, closeBtn);

};



// --- Player Stats menu compat aliases (buttons expect these names) ---
// Keep the newer dialog implementations as the source of truth.
window.openPlayerTargetHitDialog = window.openPlayerTargetHitDialog || (function(playerName){
  try{
    if (typeof window.openPlayerTargetPctDialog === 'function') return window.openPlayerTargetPctDialog(playerName);
    if (typeof window.openTargetPctDialog === 'function') return window.openTargetPctDialog(playerName);
  }catch(e){ console.error(e); }
  try{ if (typeof toast==='function') toast('Target Hit % not available'); }catch(_){}
});

window.openPlayerTargetPointsDialog = window.openPlayerTargetPointsDialog || (function(playerName){
  try{
    if (typeof window.openPlayerTargetPointsPctDialog === 'function') return window.openPlayerTargetPointsPctDialog(playerName);
  }catch(e){ console.error(e); }
  try{ if (typeof toast==='function') toast('Target Points % not available'); }catch(_){}
});

window.openPlayerDTBDialog = window.openPlayerDTBDialog || (function(playerName){
  try{
    if (typeof window.openPlayerDTBCombinedPctDialog === 'function') return window.openPlayerDTBCombinedPctDialog(playerName);
    if (typeof window.openPlayerDTBPctDialog === 'function') return window.openPlayerDTBPctDialog(playerName);
  }catch(e){ console.error(e); }
  try{ if (typeof toast==='function') toast('DTB % not available'); }catch(_){}
});

// === Player Hub â€” Latest Matches / High Scores / Progression / Target % / D T B % / H2H ===
window.openPlayerStatsHub = function openPlayerStatsHub(playerName){
  try{ if (typeof __sqSetStatsOrigin==='function') __sqSetStatsOrigin('home', playerName); }catch(_){ }
  try{ console.debug('[Popup]', window.__sqStatsDebugName || 'New Game Screen Stats'); }catch(_){ }
  const name = String(playerName || '').trim();
  if (!name){ try{ toast('Pick a player'); }catch(_){} return; }

  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal menu-modal';

  // Header
  const header = document.createElement('div');
  header.className = 'menu-modal-header';

  const backBtn = document.createElement('button');
  backBtn.className = 'icon-btn';
  backBtn.type = 'button';
  backBtn.setAttribute('aria-label', 'Back');
  backBtn.innerHTML = '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'icon-btn';
  closeBtn.type = 'button';
  closeBtn.setAttribute('aria-label', 'Close');
  closeBtn.innerHTML = '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M18 6L6 18M6 6l12 12"/></svg>';

  const titleWrap = document.createElement('div');
  titleWrap.className = 'menu-modal-title';

  const icon = document.createElement('div');
  icon.className = 'menu-modal-icon';
  icon.innerHTML = '<svg viewBox="0 0 24 24" width="28" height="28" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M4 19V5"/><path d="M8 19V9"/><path d="M12 19V3"/><path d="M16 19v-6"/><path d="M20 19V7"/></svg>';

  const title = document.createElement('div');
  title.className = 'menu-modal-title-text';
  title.textContent = 'PLAYER STATS';

  const sub = document.createElement('div');
  sub.className = 'menu-modal-title-sub';
  sub.textContent = `Player â€” ${name}`;

  titleWrap.append(icon, title, sub);
  header.append(backBtn, titleWrap, closeBtn);

  const body = document.createElement('div');
  body.className = 'menu-modal-body';

  const list = document.createElement('div');
  list.className = 'menu-list';

  const mkRow = (label, sublabel, svg, onClick) => {
    const row = document.createElement('button');
    row.type = 'button';
    row.className = 'menu-row';
    row.innerHTML = `
      <span class="menu-row-icon">${svg || ''}</span>
      <span class="menu-row-text">
        <span class="menu-row-title">${label}</span>
        <span class="menu-row-sub">${sublabel || ''}</span>
      </span>
      <span class="menu-row-chev">
        <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M9 18l6-6-6-6"/></svg>
      </span>`;
    row.onclick = () => { try{ onClick && onClick(); }catch(e){ console.error('Player stats row failed', e); } };
    return row;
  };

  const svgClock = '<svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="9"/><path d="M12 7v6l4 2"/></svg>';
  const svgTrophy= '<svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M8 21h8"/><path d="M12 17v4"/><path d="M7 4h10v3a5 5 0 0 1-10 0V4z"/><path d="M5 5H3v2a4 4 0 0 0 4 4"/><path d="M19 5h2v2a4 4 0 0 1-4 4"/></svg>';
  const svgTrend = '<svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M3 17l6-6 4 4 7-7"/><path d="M14 8h6v6"/></svg>';
  const svgTarget= '<svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="8"/><circle cx="12" cy="12" r="3"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="M2 12h2"/><path d="M20 12h2"/></svg>';
  const svgVs    = '<svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M4 4l16 16"/><path d="M7 7h.01"/><path d="M17 17h.01"/></svg>';
  const svgBars  = '<svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M4 19V5"/><path d="M8 19V9"/><path d="M12 19V3"/><path d="M16 19v-6"/><path d="M20 19V7"/></svg>';

  list.append(
    mkRow('Latest Matches', 'Position / Points / Round Avg', svgClock, () => {
      // Close this menu first so Latest Matches behaves as a true modal (Close returns to main screen)
      try{ overlay && overlay.remove(); }catch(e){}
      if (typeof window.openPlayerLatestMatchesDialog === 'function') return window.openPlayerLatestMatchesDialog(name, 'official');
      if (typeof toast==='function') toast('Latest Matches not available');
    }),
    mkRow('High Scores', 'Full Game History', svgTrophy, () => {
      try{ overlay && overlay.remove(); }catch(e){}
      if (typeof window.openPlayerHighScoresDialog === 'function') return window.openPlayerHighScoresDialog(name);
      if (typeof toast==='function') toast('High Scores not available');
    }),
    mkRow('Progression', 'Players scores mapped over time', svgTrend, () => {
      try{ overlay && overlay.remove(); }catch(e){}
      if (typeof window.openPlayerProgressionDialog === 'function') return window.openPlayerProgressionDialog(name);
      if (typeof toast==='function') toast('Progression not available');
    }),
    mkRow('Target Hit %', 'Target hits per round', svgTarget, () => {
      try{ overlay && overlay.remove(); }catch(e){}
      if (typeof window.openPlayerTargetHitDialog === 'function') return window.openPlayerTargetHitDialog(name);
      if (typeof toast==='function') toast('Target Hit % not available');
    }),
    mkRow('Target Points %', 'Available points hit per round', svgTarget, () => {
      try{ overlay && overlay.remove(); }catch(e){}
      if (typeof window.openPlayerTargetPointsDialog === 'function') return window.openPlayerTargetPointsDialog(name);
      if (typeof toast==='function') toast('Target Points % not available');
    }),
    mkRow('D T B %', 'Double or Treble hit rate by target', svgTarget, () => {
      try{ overlay && overlay.remove(); }catch(e){}
      if (typeof window.openPlayerDTBDialog === 'function') return window.openPlayerDTBDialog(name);
      if (typeof toast==='function') toast('DTB % not available');
    }),
    mkRow('H2H', 'Record vs other players', svgVs, () => {
      try{ overlay && overlay.remove(); }catch(e){}
      if (typeof window.openPlayerH2HDialog === 'function') return window.openPlayerH2HDialog(name);
      if (typeof toast==='function') toast('H2H not available');
    }),
    mkRow('Player Stats', 'Averages, PB, recent games', svgBars, () => {
      try{ overlay && overlay.remove(); }catch(e){}
      if (typeof window.openPlayerStatsDialog === 'function') return window.openPlayerStatsDialog(name);
      if (typeof toast==='function') toast('Stats not available');
    })
  );

  body.appendChild(list);
  modal.append(header, body);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  const close = () => { try{ overlay.remove(); }catch(_){ overlay.parentNode && overlay.parentNode.removeChild(overlay); } };
  backBtn.onclick = close;
  closeBtn.onclick = close;
  overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });
modal.tabIndex = 0; modal.focus();
};


// ==== Player-Stats helpers ====================================================
async function __fetchOfficialGames(limit=5000){
  try{
    // Prefer local fetch if available (already normalized in your app)
    if (typeof cloudFetchAllGamesAsLocal === 'function') {
      const all = await cloudFetchAllGamesAsLocal();
      return (all||[]).filter(g => Array.isArray(g?.players) && g.players.length >= 2);
    }
    if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) return [];
    const table = (typeof TABLE_GAMES !== 'undefined' ? TABLE_GAMES : 'games');
    const { data, error } = await sb.from(table).select('*').order('created_at',{ascending:false}).limit(limit);
    if (error) throw error;
    return (data||[]).filter(g => Array.isArray(g?.state?.players) && g.state.players.length >= 2);
  }catch(e){ console.error('__fetchOfficialGames failed', e); return []; }
}
function __gameTs(g){
  return g?.ts || g?.created_at || g?.inserted_at || (g?.meta && (g.meta.ts || g.meta.date)) || null;
}
function __isSameLocalDay(a, b){
  if (!a || !b) return false;
  const da = new Date(a), db = new Date(b);
  return (
    da.getFullYear() === db.getFullYear() &&
    da.getMonth()    === db.getMonth() &&
    da.getDate()     === db.getDate()
  );
}
function __normalizeGame(g){
  const players = Array.isArray(g.players)
    ? g.players.map(p => (p && p.name) ? p.name : String(p||''))
    : (Array.isArray(g?.state?.players) ? g.state.players.map(p => (p && p.name) ? p.name : String(p||'')) : []);
  const totals = Array.isArray(g.totals) ? g.totals : (Array.isArray(g?.state?.totals) ? g.state.totals : []);
// prefer top-level board if present, else state.board
const board  = Array.isArray(g.board) ? g.board : (g?.state?.board || null);
  const ts     = __gameTs(g);
  return { players, totals, board, ts, raw: g };
}
// Filter helper for Premier League tabs (supports: ALL TIME, TODAY, and month codes like DEC/NOV/â€¦)
function __filterGamesByPLTab(mode, games){
  const m = String(mode || '').trim().toUpperCase();
  if (!Array.isArray(games)) return [];

  if (m === 'ALL TIME' || m === 'ALL' || m === 'ALLTIME') return games;

  if (m === 'TODAY') {
    const now   = new Date();
    const start = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const end   = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
    return games.filter(g => {
      const t = __gameTs(g.raw || g);
      if (!t) return false;
      const dt = new Date(t);
      return dt >= start && dt < end;
    });
  }

  // Month filters: JAN..DEC (3-letter uppercase codes)
  const MONTHS = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
  const mi = MONTHS.indexOf(m);
  if (mi >= 0) {
    return games.filter(g => {
      const t = __gameTs(g.raw || g);
      return t && new Date(t).getMonth() === mi;
    });
  }

  // Fallback = no filter
  return games;
}
function __roundCountFor(g, idx){
  if (g.board && Array.isArray(g.board[idx])) return Math.min(14, g.board[idx].length||0);
  return 14; // fallback
}
function __roundLabels(){
  return ['10','11','12','13','14','15','16','17','18','19','20','D','T','B'];
}

// Build throw rows for a player from normalized games' boards.
// Supports two shapes:
//   A) board[playerIndex][round][throw]
//   B) board[round][playerIndex][throw]
// Returns rows like: { game_id, player, round_index, dart_index, points, kind }
function __throwsFromGamesForPlayer(playerName, games){
  const nameLC = String(playerName||'').trim().toLowerCase();
  const out = [];

  (games||[]).forEach(g=>{
    const pIdx = (g.players||[]).findIndex(p => String(p||'').trim().toLowerCase()===nameLC);
    if (pIdx < 0) return;

    const b = g.board;
    if (!Array.isArray(b) || !b.length) return;

    // Detect shape
    // Shape A: b[pIdx] exists and is array of rounds
    const looksLikeA = Array.isArray(b[pIdx]) && (b[pIdx].length > 0);
    // Shape B: b[0][pIdx] exists => array of rounds where each round has array for this player
    const looksLikeB = Array.isArray(b[0]) && Array.isArray(b[0][pIdx]);

    // Build a per-player "rounds list" no matter the shape
    let rounds = [];
    if (looksLikeA) {
      rounds = b[pIdx]; // [round][throw]
    } else if (looksLikeB) {
      rounds = b.map(r => r ? r[pIdx] : null); // [round][throw]
    } else {
      // Unknown layout â€” give up on this game
      return;
    }

    for (let r = 0; r < Math.min(14, rounds.length || 0); r++){
      const cell = rounds[r];
      if (!cell) continue;

      // Each cell can be:
      //  - array of throws
      //  - object with { throws: [...] } or { darts: [...] }
      const list = Array.isArray(cell) ? cell
                  : (Array.isArray(cell.throws) ? cell.throws
                     : (Array.isArray(cell.darts) ? cell.darts : []));

      list.forEach((t, di)=>{
        const ringRaw = (t?.kind || t?.type || t?.segment || t?.ring || '').toString().toLowerCase();
        const mult  = Number(
          t?.mult ?? t?.multiplier ??
          (ringRaw==='double' ? 2 : (ringRaw==='treble'||ringRaw==='triple' ? 3 : 1))
        ) || 1;

        // value/number: for rounds 0..10 use 10+r fallback; D/T/B rows (11..13) have no number
        const baseVal = Number(t?.value ?? t?.number ?? t?.n ?? (r<=10 ? (10+r) : NaN));
        let points  = Number(t?.points ?? t?.pts ?? t?.score);
        if (!Number.isFinite(points)) {
          points = (Number.isFinite(baseVal) ? baseVal : 0) * mult;
        }

        let kind = ringRaw;
        if (!kind){
          if (mult===2) kind = 'double';
          else if (mult===3) kind = 'treble';
          else if (r===13)   kind = 'bull';
          else               kind = 'single';
        }

        out.push({
          game_id: g.raw?.id || g.raw?.game_id || null,
          player: g.players[pIdx],
          round_index: r,
          dart_index: di,
          points: Number.isFinite(points) ? points : 0,
          kind
        });
      });
    }
  });

  return out;
}

// Fetch throws for a set of game IDs; returns rows normalized to:
// { game_id, player, round_index, dart_index, points, kind }
async function __fetchThrowsForGames(gameIds){
  const ids = Array.isArray(gameIds) ? gameIds.filter(Boolean) : [];
  if (!ids.length) return [];

  // Candidate tables to try (put your real table first if you know it)
  const tableCandidates = [
    // Prefer the canonical backdated view if it exists
    'throw_events_v', 'throw_events',
    (typeof TABLE_GAME_THROWS !== 'undefined') ? TABLE_GAME_THROWS : 'game_throws',
    'throws', 'shots', 'game_shots', 'game_darts'
  ];
  // Candidate game-id columns to try
  const idCols = ['game_id','game','gid','match_id','gameId','gameID'];

  // Map raw row -> normalized row
  const norm = (r) => {
    const gid =
      r.game_id ?? r.game ?? r.gid ?? r.match_id ?? r.gameId ?? r.gameID ?? null;
    const player =
      r.player ?? r.name ?? r.player_name ?? r.playerName ?? r.p ?? null;

    // round index: prefer 0..13; otherwise derive from number/ring if present
    let ri = r.round_index ?? r.round ?? r.roundIdx ?? r.ri ?? null;
    if (ri == null) {
      const target = r.target ?? r.number ?? r.n ?? null; // 10..20
      const ring   = (r.ring ?? r.segment ?? r.kind ?? r.type ?? '').toString().toUpperCase();
      if (typeof target === 'number' && target >= 10 && target <= 20) ri = target - 10;
      else if (ring === 'D') ri = 11;
      else if (ring === 'T' || ring === 'TRIPLE' || ring === 'TREBLE') ri = 12;
      else if (ring === 'B' || ring === 'BULL') ri = 13;
    }

    let di = r.dart_index ?? r.throw_index ?? r.dart ?? r.d ?? r.index ?? r.di ?? null;

    // points
    let pts = Number(r.points ?? r.pts ?? r.score ?? NaN);
    if (!Number.isFinite(pts)) {
      const val = Number(r.value ?? r.number ?? NaN);
      const mul = Number(r.mult ?? r.multiplier ?? NaN);
      if (Number.isFinite(val) && Number.isFinite(mul)) pts = val * mul;
    }

    // kind
    let kind = r.kind ?? r.type ?? r.segment ?? r.ring ?? '';
    if (!kind) {
      const mul = Number(r.mult ?? r.multiplier ?? NaN);
      if (mul === 2) kind = 'double';
      else if (mul === 3) kind = 'treble';
      else if (mul === 1) kind = 'single';
    }

    const ts = r.ts ?? r.created_at ?? r.inserted_at ?? r.time ?? null;

    return {
      game_id: gid, player, round_index: ri, dart_index: di,
      points: Number.isFinite(pts) ? pts : 0,
      kind: String(kind || '').toLowerCase(),
      ts
    };
  };

  const out = [];
  const CHUNK = 200;

  for (const table of tableCandidates) {
    try {
      for (let i = 0; i < ids.length; i += CHUNK) {
        const slice = ids.slice(i, i + CHUNK);

        // try each id column until one works
        let data = null, errLast = null;
        for (const col of idCols) {
          try {
            const { data: d, error } = await sb
              .from(table)
              .select('*')
              .in(col, slice)
              .order(col, { ascending: true })
              .limit(2000);
            if (!error && Array.isArray(d)) { data = d; break; }
            errLast = error;
          } catch (e) { errLast = e; }
        }
        if (data && data.length) out.push(...data.map(norm));
      }
      if (out.length) {
        console.info('[throws] using table:', table, 'rows:', out.length);
        break; // found a working table
      }
    } catch (e) {
      console.warn('[throws] failed table', table, e);
    }
  }

  if (!out.length) {
    console.warn('[throws] no throw rows found for supplied game ids:', ids.slice(0,10), 'â€¦');
  }
  return out;
}


// ---- Latest Matches data loader (cloud-first, safe fallbacks) ----
// Returns rows: [{ position, points, round_avg, when, sheet_id }]
window.fetchLatestMatchesRows = async function fetchLatestMatchesRows(playerName, mode='official', limit=50){
  const name = String(playerName||'').trim();
  if (!name) return [];
  const isPractice = (String(mode).toLowerCase()==='practice');
  const lim = Math.max(1, Math.min(200, Number(limit)||50));

  const fmt = (ts)=>{
    try{
      if (!ts) return '';
      if (typeof window.fmtWhen === 'function') return window.fmtWhen(ts);
      const d = new Date(ts);
      if (!Number.isNaN(d.getTime()) && typeof window.fmtDdMmYyAtTime === 'function') return window.fmtDdMmYyAtTime(d);
      return !Number.isNaN(d.getTime()) ? d.toLocaleString() : String(ts);
    }catch(_){ return String(ts||''); }
  };

  // 1) Preferred: player_games_union (TABLE_PLAYER_GAMES)
  try{
    if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) throw new Error('cloud not ready');
    const tableName = (typeof TABLE_PLAYER_GAMES !== 'undefined' && TABLE_PLAYER_GAMES) ? TABLE_PLAYER_GAMES : 'player_games_union';

    let q = sb
      .from(tableName)
      .select('sheet_id, player, score, position, rounds, ts, is_practice')
      .ilike('player', name)
      .order('ts', { ascending:false })
      .limit(lim);

    // Important: some historic rows have is_practice NULL; treat as official.
    if (isPractice) q = q.eq('is_practice', true);
    else q = q.or('is_practice.is.null,is_practice.eq.false');

    const { data, error } = await q;
    if (error) throw error;

    const rows = (data||[]).filter(Boolean).map(r=>{
      const score = Number(r.score||0);
      const rounds = Number(r.rounds||0);
      const avg = rounds ? (score/rounds) : null;
      return {
        sheet_id: r.sheet_id || null,
        position: (r.position ?? ''),
        points: (r.score ?? ''),
        round_avg: avg,
        when: fmt(r.ts),
        ts: r.ts
      };
    });



// Enrich with total players (single bulk lookup against games)
try{
  const ids = rows.map(x=>x.sheet_id).filter(Boolean);
  if (ids.length){
    const gTable = (typeof TABLE_GAMES !== 'undefined' ? TABLE_GAMES : 'games');
    const { data: gRows, error: gErr } = await sb.from(gTable).select('id,state,created_at,mode,is_practice').in('id', ids);
    if (!gErr && Array.isArray(gRows)){
      const map = new Map();
      for (const gr of gRows){
        try{
          const ng = (typeof __normalizeGame==='function') ? __normalizeGame(gr) : null;
          const cnt = ng && Array.isArray(ng.players) ? ng.players.length : (gr?.state?.players?.length || null);
          if (gr?.id) map.set(String(gr.id), cnt);
        }catch(_){ }
      }
      rows.forEach(r=>{ const k=String(r.sheet_id||''); if (map.has(k)) r.players_count = map.get(k); });
    }
  }
}catch(_){ }
    if (rows.length) return rows;
  }catch(e){
    // keep going to fallback (do not spam console in UI path)
    console.warn('[LatestMatches] player_games_union query failed or empty; falling back.', e?.message || e);
  }

  // 2) Fallback: derive from games table (TABLE_GAMES) so UI still works during migrations.
  try{
    if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) return [];
    const table = (typeof TABLE_GAMES !== 'undefined' ? TABLE_GAMES : 'games');

    // Pull a wider window so we can filter down to the last N games for this player.
    const fetchN = Math.max(500, lim * 80);
    const { data, error } = await sb.from(table).select('*').order('created_at',{ascending:false}).limit(fetchN);
    if (error) throw error;

    const norm = (g)=>{
      const ng = (typeof __normalizeGame === 'function') ? __normalizeGame(g) : { players:[], totals:[], board:null, ts:(g.created_at||null), raw:g };
      const matchId = (g?.match_id || g?.matchId || g?.state?.match_id || g?.state?.match?.id || null);
      const playersCount = (ng.players||[]).length;
      const modeRaw = String((g?.mode || g?.state?.mode || '')).toLowerCase();
      const isPracticeDerived = (
        g?.is_practice === true ||
        g?.state?.is_practice === true ||
        modeRaw === 'practice' ||
        playersCount === 1
      );
      const modeNorm = isPracticeDerived ? 'practice' : 'official';
      return {
        players: ng.players || [],
        totals: ng.totals || [],
        board: ng.board || null,
        ts: ng.ts || g.created_at || null,
        mode: modeNorm,
        is_practice: isPracticeDerived,
        match_id: matchId,
        raw: g
      };
    };

    const games = (data||[]).map(norm)
      .filter(g => (isPractice ? (typeof isPracticeGame==='function'? isPracticeGame(g): (g.is_practice===true)) : (typeof isOfficialGame==='function'? isOfficialGame(g): (g.is_practice!==true && (g.players||[]).length>=2))))
      .filter(g => (g.players||[]).some(p => (typeof eqName==='function'? eqName(p,name) : String(p||'').trim().toLowerCase()===name.toLowerCase())));

    const rows = [];
    for (const g of games){
      const i = (g.players||[]).findIndex(p => (typeof eqName==='function'? eqName(p,name) : String(p||'').trim().toLowerCase()===name.toLowerCase()));
      if (i < 0) continue;
      const score = Number((g.totals||[])[i] || 0);
      // Position: dense rank by score (desc), tie-break by original index.
      const ord = (g.totals||[]).map((s, idx)=>({ idx, s:Number(s||0) }))
        .sort((a,b)=> (b.s - a.s) || (a.idx - b.idx));
      const uniq = [];
      ord.forEach(o=>{ if (!uniq.includes(o.s)) uniq.push(o.s); });
      const pos = (uniq.indexOf(score) >= 0) ? (uniq.indexOf(score)+1) : '';

      let rounds = 14;
      try{
        if (typeof __roundCountFor==='function') rounds = __roundCountFor(g, i);
        else if (g.board && Array.isArray(g.board[i])) rounds = Math.min(14, g.board[i].length||0) || 14;
      }catch(_){}
      const avg = rounds ? (score/rounds) : null;

      rows.push({
        sheet_id: g.raw?.id || null,
        players_count: (g.players||[]).length,
        position: pos,
        points: score,
        round_avg: avg,
        when: fmt(g.ts),
        ts: g.ts
      });
      if (rows.length >= lim) break;
    }
    return rows;
  }catch(e){
    console.error('[LatestMatches] fallback failed', e);
    return [];
  }
};

// ==== (1) Latest Matches ======================================================
window.openPlayerLatestMatchesDialog = async function openPlayerLatestMatchesDialog(playerName, initialMode){
  try {
    if (!playerName) return;

    const escapeHtml = (s) => {
      if (s == null) return '';
      return String(s).replace(/[&<>"']/g, (c) => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[c] || c));
    };

    // Close any existing Latest Matches modal to avoid stacking duplicates
    document.querySelectorAll('.sq-latest-matches-backdrop').forEach(n => n.remove());

    const overlay = document.createElement('div');
    overlay.className = 'modal-backdrop sq-latest-matches-backdrop';

    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.maxWidth = '980px';
    modal.style.width = '94vw';

    const safeName = escapeHtml(playerName);

    modal.innerHTML = `
      <div class="modal-header" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
        <div style="display:flex; align-items:center; gap:10px;">
          <div>
            <div style="font-size:18px; font-weight:800; letter-spacing:.02em;">Latest Matches â€” ${safeName}</div>
            <div style="font-size:11px; opacity:.65; margin-top:2px;">Position / Points / Round Avg</div>
          </div>
        </div>

        <div style="display:flex; align-items:center; gap:10px;">
          <div class="segmented" style="display:flex; gap:8px;">
            <button class="seg-btn" data-mode="official">Official</button>
            <button class="seg-btn" data-mode="practice">Practice</button>
          </div>
        </div>
      </div>

      <div class="modal-body" style="padding-top:8px;">
        <div class="latest-matches-table-wrap" style="border:1px solid rgba(255,255,255,.08); border-radius:14px; overflow:auto; max-height:56vh;">
          <table class="sq-table latest-matches" style="width:100%; border-collapse:collapse; table-layout:fixed;">
            <colgroup>
              <col style="width:7%">
              <col style="width:18%">
              <col style="width:18%">
              <col style="width:18%">
              <col style="width:39%">
            </colgroup>
            <thead>
              <tr>
                <th style="text-align:left; padding-left:14px;">#</th>
                <th style="text-align:center;">Position</th>
                <th style="text-align:center;">Points</th>
                <th style="text-align:center;">Round Avg</th>
                <th style="text-align:right; padding-right:14px;">When</th>
              </tr>
            </thead>
            <tbody data-role="rows"></tbody>
          </table>
        </div>

        <div class="modal-footer" style="display:flex; justify-content:flex-start; gap:10px; margin-top:14px;">
          <button class="btn small sq-pill" data-action="back" style="min-width:84px;">Back</button>
          <button class="btn small sq-pill" data-action="close" style="min-width:84px;">Close</button>
        </div>
      </div>
    `;

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    // Styling hooks (reuses existing theme)
    const segBtns = modal.querySelectorAll('.seg-btn');
    segBtns.forEach(b=>{
      b.style.padding = '8px 12px';
      b.style.borderRadius = '999px';
      b.style.border = '1px solid rgba(255,255,255,.14)';
      b.style.background = 'rgba(10,12,24,.55)';
      b.style.color = 'rgba(255,255,255,.85)';
      b.style.fontWeight = '700';
      b.style.letterSpacing = '.02em';
      b.style.cursor = 'pointer';
      b.style.userSelect = 'none';
    });

    const rowsEl = modal.querySelector('[data-role="rows"]');

    const setActiveModeUI = (mode) => {
      segBtns.forEach(btn=>{
        const on = btn.dataset.mode === mode;
        btn.style.borderColor = on ? 'rgba(255,123,26,.85)' : 'rgba(255,255,255,.14)';
        btn.style.boxShadow = on ? '0 0 0 2px rgba(255,123,26,.15) inset' : 'none';
        btn.style.color = on ? '#fff' : 'rgba(255,255,255,.85)';
        btn.style.background = on ? 'rgba(255,123,26,.12)' : 'rgba(10,12,24,.55)';
      });
    };

    const renderRows = (rows) => {
      const safeRows = Array.isArray(rows) ? rows : [];
      rowsEl.innerHTML = safeRows.map((r, idx) => {
        const posRaw = (r.position != null) ? r.position : '';
        const pc = (r.players_count ?? r.playersCount ?? r.total_players ?? r.player_count ?? '');
        const pos = (String(posRaw||'').includes('/') || !pc) ? posRaw : (String(posRaw||'') ? String(posRaw) + '/' + String(pc) : '');
        const pts = (r.points != null) ? r.points : '';
        const av  = (r.round_avg != null) ? Number(r.round_avg).toFixed(1) : (r.roundAvg != null ? Number(r.roundAvg).toFixed(1) : '');
        const when = escapeHtml(r.when || r.created_at || r.played_at || '');
        return `
          <tr>
            <td style="text-align:left; padding-left:14px; color:rgba(255,123,26,.95); font-weight:800;">${idx+1}</td>
            <td style="text-align:center;">${escapeHtml(pos)}</td>
            <td style="text-align:center;">${escapeHtml(pts)}</td>
            <td style="text-align:center;">${escapeHtml(av)}</td>
            <td style="text-align:right; padding-right:14px; opacity:.9;">${when}</td>
          </tr>
        `;
      }).join('');
    };

    const load = async (mode) => {
      setActiveModeUI(mode);
      rowsEl.innerHTML = `<tr><td colspan="5" style="padding:18px; opacity:.7;">Loadingâ€¦</td></tr>`;
      let rows = [];
      try {
        if (typeof fetchLatestMatchesRows === 'function') {
          rows = await fetchLatestMatchesRows(playerName, mode, 50);
        } else if (typeof window.fetchLatestMatchesRows === 'function') {
          rows = await window.fetchLatestMatchesRows(playerName, mode, 50);
        }
      } catch(e){
        rows = [];
      }
      if (!rows || !rows.length) {
        rowsEl.innerHTML = `<tr><td colspan="5" style="padding:18px; opacity:.7;">No ${mode} matches found.</td></tr>`;
        return;
      }
      renderRows(rows);
    };

    let mode = (initialMode === 'practice' || initialMode === 'official') ? initialMode : 'official';
    await load(mode);

    segBtns.forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        mode = btn.dataset.mode;
        await load(mode);
      });
    });

    const close = () => overlay.remove();
    const goBack = () => {
      overlay.remove();
      __sqGoBackToStatsMain();
    };

    overlay.addEventListener('click', (e)=>{ if (e.target === overlay) close(); });
    modal.addEventListener('click', (e)=>{
      const t = e.target.closest('[data-action]');
      if (!t) return;
      const a = t.dataset.action;
      if (a === 'close') close();
      if (a === 'back') goBack();
    });

    window.addEventListener('keydown', function escHandler(ev){
      if (ev.key === 'Escape') {
        window.removeEventListener('keydown', escHandler);
        close();
      }
    });

    // Accessibility focus
    modal.tabIndex = 0;
    modal.focus();
  } catch (err) {
    console.error('[LatestMatches] failed', err);
  }
};

// ---- Stats modal theming helpers (match Latest Matches look) ----
function __sqStatsHeader(titleText, subtitleText, rightNode){
  const header = document.createElement('div');
  header.className = 'modal-header';
  header.style.display = 'flex';
  header.style.alignItems = 'center';
  header.style.justifyContent = 'space-between';
  header.style.gap = '12px';

  const left = document.createElement('div');
  const t = document.createElement('div');
  t.style.fontSize = '18px';
  t.style.fontWeight = '800';
  t.style.letterSpacing = '.02em';
  t.textContent = String(titleText || '');
  left.appendChild(t);

  if (subtitleText){
    const s = document.createElement('div');
    s.style.fontSize = '11px';
    s.style.opacity = '.65';
    s.style.marginTop = '2px';
    s.textContent = String(subtitleText);
    left.appendChild(s);
  }

  const right = document.createElement('div');
  right.style.display = 'flex';
  right.style.alignItems = 'center';
  right.style.gap = '10px';
  if (rightNode) right.appendChild(rightNode);

  header.append(left, right);
  return header;
}

// Style a scroll/table wrapper to match Latest Matches table chrome
function __sqStyleStatsTableWrap(wrap){
  if (!wrap || !wrap.style) return;
  wrap.style.border = '1px solid rgba(255,255,255,.08)';
  wrap.style.borderRadius = '14px';
  wrap.style.overflow = 'auto';
  if (!wrap.style.maxHeight) wrap.style.maxHeight = '56vh';
}


// ---- Stats navigation helpers ----
// We have TWO "Stats main menus":
//  - Home/Start Menu: per-player stats hub (Latest Matches, H2H, etc.)
//  - In-Game: game/match stats hub (Game Stats, Match Stats, etc.)
window.__sqStatsOrigin = window.__sqStatsOrigin || 'home';   // 'home' | 'ingame'
window.__sqStatsReturnPlayer = window.__sqStatsReturnPlayer || '';
window.__sqStatsDebugName = window.__sqStatsDebugName || 'New Game Screen Stats';

function __sqSetStatsOrigin(origin, playerName){
  window.__sqStatsOrigin = (origin === 'ingame') ? 'ingame' : 'home';
  window.__sqStatsDebugName = (window.__sqStatsOrigin === 'ingame') ? 'In Game Player Stats' : 'New Game Screen Stats';
  if (playerName != null) window.__sqStatsReturnPlayer = String(playerName || '').trim();
}

function __sqGoBackToStatsMain(playerName){
  try{
    const origin = window.__sqStatsOrigin || 'home';
    const name = String(playerName || window.__sqStatsReturnPlayer || window.__sqSelectedPlayerName || '').trim();

    if (origin === 'home'){
      // If we know the player, go back to the per-player hub; otherwise go back to the player select.
      if (name && typeof window.openPlayerStatsHub === 'function') return window.openPlayerStatsHub(name);
      if (typeof window.openPlayerStatsSelectDialog === 'function') return window.openPlayerStatsSelectDialog();
      return;
    }

    // In-game stats hub
    if (typeof window.openStatsHubDialog === 'function') return window.openStatsHubDialog();
    if (typeof openStatsHubDialog === 'function') return openStatsHubDialog();
  }catch(_){ }
}


// ==== (2) High Scores â€” per-player (Top 50 scores, official) ==================
window.openPlayerHighScoresDialog = async function openPlayerHighScoresDialog(playerName){
  const name = String(playerName||'').trim();
  if (!name) return;

  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal';
  modal.style.maxWidth='980px'; modal.style.width='94vw';
  modal.style.maxHeight='90vh'; modal.style.overflow='hidden';

  const header  = __sqStatsHeader(`High Scores â€” ${name}`, 'Score / Avg per Round');
  const body    = document.createElement('div'); body.className   ='modal-body';
  body.style.paddingTop='8px';
  const footer  = document.createElement('div'); footer.className ='modal-footer';
  footer.style.justifyContent='flex-start';
  footer.style.gap='10px';

  // Data (prefer union; fall back to official games scan)
  const fmt = (ts)=>{
    try{
      if (!ts) return '';
      if (typeof window.fmtWhen === 'function') return window.fmtWhen(ts);
      const d = new Date(ts);
      if (!Number.isNaN(d.getTime()) && typeof window.fmtDdMmYyAtTime === 'function') return window.fmtDdMmYyAtTime(d);
      return !Number.isNaN(d.getTime()) ? d.toLocaleString() : String(ts);
    }catch(_){ return String(ts||''); }
  };

  let rows = [];
  try{
    if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) throw new Error('cloud not ready');
    const tableName = (typeof TABLE_PLAYER_GAMES !== 'undefined' && TABLE_PLAYER_GAMES) ? TABLE_PLAYER_GAMES : 'player_games_union';
    const q = sb
      .from(tableName)
      .select('sheet_id, player, score, rounds, ts, is_practice')
      .ilike('player', name)
      .or('is_practice.is.null,is_practice.eq.false')
      .order('score', { ascending:false })
      .order('ts', { ascending:false })
      .limit(50);
    const { data, error } = await q;
    if (error) throw error;

    rows = (data||[]).filter(Boolean).map(r=>{
      const score = Number(r.score||0);
      const rounds = Number(r.rounds||0) || 14;
      return {
        sheet_id: r.sheet_id || null,
        score,
        avg: rounds ? (score/rounds) : 0,
        when: fmt(r.ts),
        ts: r.ts
      };
    });
  }
  catch(e){
    console.warn('[HighScores] player_games_union query failed; showing empty.', e?.message||e);
  }

  // Fallback: derive Top 50 from official games if union is empty/mismatched (migration-safe)
  if (!rows.length){
    try{
      const gamesAll = (await __fetchOfficialGames(50000)).map(__normalizeGame)
        .filter(g => (g.players||[]).some(p => String(p||'').trim().toLowerCase()===name.toLowerCase()));
      const tmp = [];
      for (const g of gamesAll){
        const i = (g.players||[]).findIndex(p => String(p||'').trim().toLowerCase()===name.toLowerCase());
        if (i < 0) continue;
        const score = Number((g.totals||[])[i] || 0);
        let rounds = 14;
        try{
          if (typeof __roundCountFor==='function') rounds = __roundCountFor(g, i);
          else if (g.board && Array.isArray(g.board[i])) rounds = Math.min(14, g.board[i].length||0) || 14;
        }catch(_){}
        tmp.push({
          sheet_id: (g.raw && (g.raw.id || g.raw.game_id)) || null,
          score,
          avg: rounds ? (score/rounds) : 0,
          when: fmt(g.ts),
          ts: g.ts
        });
      }
      tmp.sort((a,b)=> (b.score-a.score) || (new Date(b.ts||0)-new Date(a.ts||0)));
      rows = tmp.slice(0, 50);
    }catch(e){
      console.warn('[HighScores] fallback scan failed.', e?.message||e);
    }
  }

  if (!rows.length){
    body.innerHTML = '<div class="muted" style="padding:18px; opacity:.75;">No high scores found.</div>';
  } else {
    // ensure sorted high->low
    rows.sort((a,b)=> (b.score-a.score) || (new Date(b.ts||0)-new Date(a.ts||0)));

    const table=document.createElement('table'); table.className='sq-table hs-table';
    const thead=document.createElement('thead'); const trh=document.createElement('tr');
    ['#','Score','Avg / Round','When'].forEach((h,idx)=>{
      const th=document.createElement('th');
      th.textContent=h;
      if (idx===0) th.style.paddingLeft='14px';
      if (h==='When') th.style.textAlign='right';
      else if (h!=='#') th.style.textAlign='center';
      trh.appendChild(th);
    });
    thead.appendChild(trh); table.appendChild(thead);

    const tbody=document.createElement('tbody');
    rows.slice(0,50).forEach((r,idx)=>{
      const tr=document.createElement('tr');
      const tdI=document.createElement('td'); tdI.textContent=String(idx+1); tdI.style.paddingLeft='14px'; tdI.className='sq-rank-cell';
      const tdS=document.createElement('td'); tdS.textContent=String(r.score); tdS.style.textAlign='center';
      const tdA=document.createElement('td'); tdA.textContent=Number(r.avg||0).toFixed(1); tdA.style.textAlign='center';
      const tdW=document.createElement('td'); tdW.textContent=String(r.when||''); tdW.style.textAlign='right'; tdW.style.paddingRight='14px';
      tr.append(tdI,tdS,tdA,tdW);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);

    const wrap=document.createElement('div');
    wrap.style.maxHeight='56vh'; wrap.style.overflowY='auto';
    __sqStyleStatsTableWrap(wrap);
    wrap.appendChild(table);
    body.appendChild(wrap);
  }

  const backBtn=document.createElement('button'); backBtn.className='btn sq-pill'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn sq-pill'; closeBtn.textContent='Close';
  backBtn.onclick=()=>{ overlay.remove(); __sqGoBackToStatsMain(); };
  closeBtn.onclick=()=>overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(header, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  const close=()=>overlay.remove();
  overlay.addEventListener('click',e=>{ if(e.target===overlay) close(); });
  overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') close(); });
  modal.tabIndex=0; modal.focus();
};


// ==== (3) Progression â€” per-game bar chart + avg overlay ==================
window.openPlayerProgressionDialog = async function openPlayerProgressionDialog(playerName){
  const name = String(playerName||'').trim();
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal';
  modal.style.maxWidth='980px'; modal.style.width='94vw';
  const header  = __sqStatsHeader(`Progression â€” ${name}`, 'Scores over time');
  const body    = document.createElement('div'); body.className   ='modal-body';
  body.style.paddingTop='8px';
  const footer  = document.createElement('div'); footer.className ='modal-footer';
  modal.style.maxHeight='90vh'; modal.style.overflow='hidden';
  body .style.maxHeight='none'; body .style.overflowY='visible';

  // ---- Data: official games only, oldest -> newest
  let games = [];
  try {
    games = (await __fetchOfficialGames(50000)).map(__normalizeGame)
      .filter(g => (g.players||[]).some(p => String(p||'').trim().toLowerCase()===name.toLowerCase()))
      .sort((a,b)=> (new Date(a.ts) - new Date(b.ts)));
  } catch (e) {
    console.error('Progression: games fetch failed', e);
  }

  const scores = games.map(g => {
    const i = (g.players||[]).findIndex(p => String(p||'').trim().toLowerCase()===name.toLowerCase());
    return Number((g.totals||[])[i] || 0);
  });

  const avgAll = scores.length ? (scores.reduce((s,v)=>s+v,0) / scores.length) : 0;
  const yMaxRaw = scores.length ? Math.max(...scores, avgAll) : 0;
  const Y_MAX = Math.max(25, Math.ceil(yMaxRaw / 25) * 25);

  function blockAvgPoints(arr, k){
    const pts = [];
    if (!arr.length || !k) return pts;
    const n = arr.length;
    const blocks = Math.ceil(n / k);
    for (let bi=0; bi<blocks; bi++){
      const s = bi*k;
      const e = Math.min((bi+1)*k, n);
      const slice = arr.slice(s, e);
      const mean = slice.reduce((a,b)=>a+b,0) / slice.length;
      const x = Math.min(bi*k, n-1); // point at start of each block (1, 1+k, 1+2k ... visually)
      pts.push({ x, y: mean });
    }
    // Ensure final point reaches the end so the line doesn't stop early
    if (pts.length){
      const last = pts[pts.length-1];
      if (last.x !== n-1) pts.push({ x: n-1, y: last.y });
    }
    return pts;
  }

  // ---- UI: buttons change ONLY the block-average line; bars always show per-game scores.
  const row = document.createElement('div');
  row.className = 'row';
  row.style.gap = '8px';
  row.style.marginBottom = '8px';

  const modes = [
    { id:'B5',  label:'5 Game AV',  k:5  },
    { id:'B10', label:'10 Game AV', k:10 },
    { id:'B20', label:'20 Game AV', k:20 },
  ];

  const buttons = [];
  modes.forEach(m=>{
    const b=document.createElement('button');
    b.type='button'; b.className='btn small'; b.textContent=m.label; b.dataset.mode=m.id;
    b.onclick=()=>{ buttons.forEach(x=>x.classList.remove('primary')); b.classList.add('primary'); draw(m.k); };
    buttons.push(b); row.appendChild(b);
  });
  (buttons[2]||buttons[0]||{}).classList.add('primary'); // default 20

  const chartHost = document.createElement('div');
  chartHost.style.position='relative';
  chartHost.style.borderRadius='14px';
  chartHost.style.overflow='hidden';
  // Keep the plot clean: pills sit BELOW the canvas, not over it.
  chartHost.style.padding='34px 6px 10px 6px';

  // Canvas (responsive)
  const canvas = document.createElement('canvas');
  canvas.style.width = '100%';
  canvas.style.height = '280px';
  canvas.style.display='block';
  chartHost.appendChild(canvas);

    // Precompute legend numbers
  const __progAllTimeAvg = scores.reduce((s,v)=>s+v,0) / Math.max(1, scores.length);
  const __progMid = Math.max(1, Math.floor(scores.length/2));
  const __progTrajStart = scores.slice(0, __progMid).reduce((s,v)=>s+v,0) / Math.max(1, scores.slice(0, __progMid).length);
  const __progTrajEnd = scores.slice(__progMid).reduce((s,v)=>s+v,0) / Math.max(1, scores.slice(__progMid).length || 1);

// Legend (top-right)
  const legend = document.createElement('div');
  legend.className = 'prog-legend';
  legend.style.position = 'absolute';
  legend.style.top = '6px';
  legend.style.right = '10px';
  legend.style.display = 'flex';
  legend.style.flexDirection = 'column';
  legend.style.gap = '6px';
  legend.style.pointerEvents = 'none';
  legend.style.opacity = '0.92';
  legend.innerHTML = `
    <div style="display:flex;flex-direction:column;gap:2px">
      <div style="display:flex;align-items:center;gap:8px;font-size:12px;color:rgba(255,255,255,0.78)">
        <span style="display:inline-block;width:18px;height:0;border-top:2px dashed rgba(255,140,0,0.95)"></span>
        <span>All Time AVG</span>
      </div>
      <div style="padding-left:26px;font-size:11px;color:rgba(255,255,255,0.72)">${Math.round(__progAllTimeAvg)}</div>
    </div>
    <div style="display:flex;flex-direction:column;gap:2px">
      <div style="display:flex;align-items:center;gap:8px;font-size:12px;color:rgba(255,255,255,0.78)">
        <span style="display:inline-block;width:18px;height:0;border-top:2px solid rgba(90,255,140,0.95)"></span>
        <span>Trajectory</span>
      </div>
      <div style="padding-left:26px;font-size:11px;color:rgba(255,255,255,0.72)">${Math.round(__progTrajStart)} &rarr; ${Math.round(__progTrajEnd)}</div>
    </div>
  `;
  chartHost.appendChild(legend);

  // Stats pills (below canvas, right-aligned)
  const pillRow = document.createElement('div');
  pillRow.style.display = 'flex';
  pillRow.style.flexDirection = 'column';
  pillRow.style.alignItems = 'flex-end';
  pillRow.style.gap = '6px';
  pillRow.style.padding = '10px 6px 0 6px';

  const pillAll = document.createElement('div');
  pillAll.className = 'tag prog-stats';
  pillAll.style.opacity = '0.9';
  pillAll.style.pointerEvents = 'none';

  const pillAvg = document.createElement('div');
  pillAvg.className = 'tag prog-stats';
  pillAvg.style.opacity = '0.9';
  pillAvg.style.pointerEvents = 'none';

  pillRow.append(pillAll, pillAvg);
  chartHost.appendChild(pillRow);

  body.append(row, chartHost);

  // Footer buttons
  const backBtn=document.createElement('button'); backBtn.className='btn sq-pill'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn sq-pill'; closeBtn.textContent='Close';
  const close=()=>overlay.remove();
  backBtn.onclick=()=>{ overlay.remove(); __sqGoBackToStatsMain(); }; closeBtn.onclick=close;
  footer.append(backBtn, closeBtn);

  modal.append(header, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  // ---- Draw
  function draw(blockSize){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const W = Math.max(320, Math.floor(rect.width));
    const H = 280;
    canvas.width  = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.height = H+'px';

    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,W,H);

    // Layout
    // Extra bottom padding so X-axis labels never fight the pills below.
    const padL=42, padR=10, padT=8, padB=34;
    const plotW = W - padL - padR;
    const plotH = H - padT - padB;

    // Background
    ctx.fillStyle = 'rgba(10,12,18,0.25)';
    ctx.fillRect(0,0,W,H);

    // Grid
    ctx.strokeStyle='rgba(255,255,255,0.10)';
    ctx.lineWidth=1;
    for (let y=0; y<=Y_MAX; y+=50){
      const py = padT + plotH - (y/Y_MAX)*plotH;
      ctx.beginPath(); ctx.moveTo(padL, py); ctx.lineTo(padL+plotW, py); ctx.stroke();
      ctx.fillStyle='rgba(255,255,255,0.55)';
      ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign='right'; ctx.textBaseline='middle';
      ctx.fillText(String(y), padL-6, py);
    }

    // Bars: one per game
    const n = scores.length;
    if (!n){
      ctx.fillStyle='rgba(255,255,255,0.65)';
      ctx.font='14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('No data', W/2, H/2);
      pillAll.textContent='';
      pillAvg.textContent='';
      return;
    }

    const barGap = 1;
    const barW = Math.max(1, Math.floor(plotW / n));
    for (let i=0;i<n;i++){
      const v = Math.max(0, Math.min(Y_MAX, scores[i]));
      const x = padL + i*(plotW/n);
      const h = (v/Y_MAX)*plotH;
      const y = padT + (plotH - h);
      ctx.fillStyle='rgba(255,255,255,0.70)';
      ctx.fillRect(x, y, Math.max(1, (plotW/n) - barGap), h);
    }

    // Orange "current average" line (overall)
    const avgY = padT + plotH - (avgAll/Y_MAX)*plotH;
    ctx.strokeStyle = 'rgba(255,140,0,0.95)'; // Shateki orange
    ctx.lineWidth = 2;
    ctx.setLineDash([6,4]);
    ctx.beginPath();
    ctx.moveTo(padL, avgY);
    ctx.lineTo(padL+plotW, avgY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Trajectory (green solid): first-half avg -> second-half avg
    const mid = Math.max(1, Math.floor(n/2));
    const avg1 = scores.slice(0, mid).reduce((s,v)=>s+v,0) / Math.max(1, scores.slice(0, mid).length);
    const avg2 = scores.slice(mid).length ? (scores.slice(mid).reduce((s,v)=>s+v,0) / scores.slice(mid).length) : avg1;
    const y1 = padT + plotH - (avg1/Y_MAX)*plotH;
    const y2 = padT + plotH - (avg2/Y_MAX)*plotH;
    ctx.strokeStyle = 'rgba(90,255,140,0.95)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(padL, y1);
    ctx.lineTo(padL+plotW, y2);
    ctx.stroke();

    // Block average line (white) - points connected
    const pts = blockAvgPoints(scores, blockSize || 20);
    if (pts.length){
      ctx.strokeStyle='rgba(255,255,255,0.92)';
      ctx.lineWidth=2;
      ctx.beginPath();
      pts.forEach((p, idx)=>{
        const px = padL + (p.x/(n-1))*plotW;
        const py = padT + plotH - (p.y/Y_MAX)*plotH;
        if (idx===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      });
      ctx.stroke();
    }

    // X axis ticks: every 10 games
    ctx.fillStyle='rgba(255,255,255,0.55)';
    ctx.font='11px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.textAlign='center'; ctx.textBaseline='top';
    for (let i=0;i<n;i+=10){
      const x = padL + (i/(n-1))*plotW;
      ctx.fillText(String(i+1), x, padT+plotH+6);
    }

    const minV = Math.min(...scores);
    const maxV = Math.max(...scores);

    // Block-average range (selected mode)
    const k = blockSize || 20;
    const blockMeans = [];
    for (let s=0; s<n; s+=k){
      const slice = scores.slice(s, Math.min(s+k, n));
      if (!slice.length) continue;
      blockMeans.push(slice.reduce((a,b)=>a+b,0) / slice.length);
    }
    const minAvg = blockMeans.length ? Math.min(...blockMeans) : avgAll;
    const maxAvg = blockMeans.length ? Math.max(...blockMeans) : avgAll;

    pillAll.textContent = `Avg ${avgAll.toFixed(1)} Â· Low ${minV} Â· High ${maxV}`;
    pillAvg.textContent = `Avg Low ${minAvg.toFixed(1)} Â· Avg High ${maxAvg.toFixed(1)}`;
  }

  // initial draw
  draw(20);

  // redraw on resize
  const ro = new ResizeObserver(()=>draw(Number((body.querySelector('.btn.primary')||{}).dataset && (body.querySelector('.btn.primary')||{}).dataset.mode==='B5'?5:(body.querySelector('.btn.primary')||{}).dataset.mode==='B10'?10:20)));
  try { ro.observe(chartHost); } catch(_){}
}
;


// ==== (4) Target % â€” per round (10â†’20 + D + T + B) ==========================
window.openPlayerTargetPctDialog = async function openPlayerTargetPctDialog(playerName){
  const name = String(playerName||'').trim();
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal';
  modal.style.maxWidth='980px'; modal.style.width='94vw';
  const header  = __sqStatsHeader(`Target Hit % â€” ${name}`, 'Throws / Hits / % / Ranks');
const body    = document.createElement('div'); body.className   ='modal-body';
  body.style.paddingTop='8px';
  const footer  = document.createElement('div'); footer.className ='modal-footer';
  modal.style.maxHeight='90vh'; modal.style.overflow='hidden';
  body .style.maxHeight='none'; body .style.overflowY='visible';

// Collect game IDs from official games only.
// (Avoid querying player_games_union here â€” its schema varies and causes noisy 400s.)
let ids = [];
if (!ids.length) {
  const games = (await __fetchOfficialGames(50000)).map(__normalizeGame);
  ids = games
    .map(g => (g.raw && (g.raw.id || g.raw.game_id)) || g.id || g.game_id)
    .filter(Boolean);
}

let throwsRows = ids.length ? await __fetchThrowsForGames(ids) : [];
if (!throwsRows.length) {
  // Fallback to reconstruct from game boards (lifetime official)
  const gamesAll = (await __fetchOfficialGames(50000)).map(__normalizeGame);
  throwsRows = __throwsFromGamesForPlayer(name, gamesAll);
}
  const labels = __roundLabels();
  const nameLC = name.toLowerCase();

  const playerThrows = throwsRows.filter(t => String(t.player||'').trim().toLowerCase()===nameLC);

  const taken = Array(14).fill(0), hits = Array(14).fill(0);
  playerThrows.forEach(t=>{
      const r=(typeof t.round_index==='number')?t.round_index:null;
      if (r==null || r<0 || r>13) return;
      taken[r] += 1;
      if ((t.hit===true) || (Number(t.points||0)>0)) hits[r] += 1; // any scoring counts as a hit (incl. bull)
    });

  const pctArr = taken.map((n,i)=> n ? (100*hits[i]/n) : 0);

  // Rank (within this player's own targets): higher % => better
  const playerRankMap = new Map(
    pctArr
      .map((pct,i)=>({i,pct:Number(pct)||0,n:taken[i],h:hits[i]}))
      .filter(x=>x.n>0)
      .sort((a,b)=> (b.pct-a.pct) || (b.h-a.h) || (b.n-a.n) || (a.i-b.i))
      .map((x,idx)=>[x.i, idx+1])
  );

  // Game Rank (across all players): prefer Supabase view (server-derived, backdated)
  const gameRankByKey = new Map(); // key -> game_rank
  try{
    const { data: grRows, error: grErr } = await sb
      .from('player_hit_bucket_ranks_v')
      .select('bucket_key, game_rank')
      .eq('player_name', name);
    if (grErr) throw grErr;
    (grRows||[]).forEach(r=>{
      const k = String(r.bucket_key||'').trim().toUpperCase();
      const v = Number(r.game_rank);
      if (k) gameRankByKey.set(k, Number.isFinite(v) ? v : null);
    });
  }catch(e){
    console.warn('Game Rank view not available (player_hit_bucket_ranks_v).', e);
  }



  const table=document.createElement('table'); table.className='sq-table hs-table';
  const thead=document.createElement('thead'); const trh=document.createElement('tr');
  ['Round','Throws','Hits','%','Rank','Game Rank'].forEach(h=>{
    const th=document.createElement('th');
    if (h === 'Game Rank') th.innerHTML = 'Game<br>Rank';
    else th.textContent=h;
    trh.appendChild(th);
  });
  thead.appendChild(trh); table.appendChild(thead);
  const tbody=document.createElement('tbody');
   for (let i=0;i<14;i++){
    const tr=document.createElement('tr');
    const tdR=document.createElement('td'); tdR.textContent=labels[i]; tdR.className='sq-rank-cell';
    const tdT=document.createElement('td'); tdT.textContent=String(taken[i]); // Throws
    const tdH=document.createElement('td'); tdH.textContent=String(hits[i]);  // Hits
    const pct = pctArr[i] || 0;
    const tdP=document.createElement('td'); tdP.textContent=pct.toFixed(1)+'%';
    const tdRank=document.createElement('td'); tdRank.textContent=String(playerRankMap.get(i) || 'â€”');
    const lbl=labels[i];
    const key = (/^\d+$/.test(lbl) ? lbl : String(lbl||'').trim().toUpperCase());
    const gr = (gameRankByKey.get(key) != null) ? gameRankByKey.get(key) : 'â€”';
    const tdGameRank=document.createElement('td'); tdGameRank.textContent=String(gr);
    tr.append(tdR,tdT,tdH,tdP,tdRank,tdGameRank); tbody.appendChild(tr);
  }
  table.appendChild(tbody);
  const scroll=document.createElement('div'); scroll.style.maxHeight='56vh'; scroll.style.overflowY='auto'; __sqStyleStatsTableWrap(scroll); scroll.appendChild(table);
  body.appendChild(scroll);

  const grNote=document.createElement('div');
  grNote.className='tag muted';
  grNote.style.marginTop='10px';
  grNote.textContent='Game Rank is shown only after 15+ throws (5 rounds) for that row.';
  body.appendChild(grNote);


  const backBtn=document.createElement('button'); backBtn.className='btn sq-pill'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn sq-pill'; closeBtn.textContent='Close';
  backBtn.onclick=()=>{ overlay.remove(); __sqGoBackToStatsMain(); };
  closeBtn.onclick=()=>overlay.remove();
  const __spacer=document.createElement('div'); __spacer.style.flex='1';
  const spiderBtn=document.createElement('button'); spiderBtn.className='btn small'; spiderBtn.textContent='SPIDER'; spiderBtn.onclick=()=>{ overlay.style.display='none'; if (typeof window.openPlayerSpiderDialog==='function') window.openPlayerSpiderDialog(name,{parentOverlay:overlay,data:{labels:labels,pct:pctArr}}); else if (typeof toast==='function') toast('SPIDER not available'); };
  const progBtn=document.createElement('button'); progBtn.className='btn small'; progBtn.textContent='PROGRESS'; progBtn.onclick=()=>{ overlay.style.display='none'; if (typeof window.openPlayerProgressHitDialog==='function') window.openPlayerProgressHitDialog(name,{parentOverlay:overlay,mode:'hit',data:{labels:labels,throws:playerThrows,gameOrder:ids}}); else if (typeof toast==='function') toast('PROGRESS not available'); };
  footer.append(backBtn,closeBtn,__spacer,spiderBtn,progBtn);

  modal.append(header,body,footer); overlay.appendChild(modal); document.body.appendChild(overlay);

  function closeToHub(){ overlay.remove(); }
  overlay.addEventListener('click',e=>{ if(e.target===overlay) closeToHub();}); overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') closeToHub();});
  modal.tabIndex=0; modal.focus();
};

// ==== (4b) Target Points % â€” lifetime, per target (10..20) ===================
window.openPlayerTargetPointsPctDialog = async function openPlayerTargetPointsPctDialog(playerName){
  const name = String(playerName||'').trim();

  // Modal shell
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal';
  modal.style.maxWidth='980px'; modal.style.width='94vw';
  const header  = __sqStatsHeader(`Target Points % â€” ${name}`, 'Thrown / Points % / Ranks');
const body    = document.createElement('div'); body.className   ='modal-body';
  body.style.paddingTop='8px';
  const footer  = document.createElement('div'); footer.className ='modal-footer';
  modal.style.maxHeight='90vh'; modal.style.overflow='hidden';
  body .style.maxHeight='none'; body .style.overflowY='visible';

  // Mount early so user always sees something
  modal.append(header,body,footer); overlay.appendChild(modal); document.body.appendChild(overlay);

  function closeToHub(){ overlay.remove(); }
  overlay.addEventListener('click',e=>{ if(e.target===overlay) closeToHub();});
  overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') closeToHub();});
  modal.tabIndex=0; modal.focus();

  const backBtn=document.createElement('button'); backBtn.className='btn sq-pill'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn sq-pill'; closeBtn.textContent='Close';
  backBtn.onclick=()=>{ overlay.remove(); __sqGoBackToStatsMain(); };
  closeBtn.onclick=()=>overlay.remove();
  const __spacer=document.createElement('div'); __spacer.style.flex='1';
  const spiderBtn=document.createElement('button'); spiderBtn.className='btn small'; spiderBtn.textContent='SPIDER'; spiderBtn.onclick=()=>{ overlay.style.display='none'; if (typeof window.openPlayerSpiderDialog==='function') window.openPlayerSpiderDialog(name,{parentOverlay:overlay, mode:'points', data: window.__lastPointsPctSpiderData}); else if (typeof toast==='function') toast('SPIDER not available'); };
  const progBtn=document.createElement('button'); progBtn.className='btn small'; progBtn.textContent='PROGRESS'; progBtn.onclick=()=>{ overlay.style.display='none'; if (typeof window.openPlayerProgressHitDialog==='function') window.openPlayerProgressHitDialog(name,{parentOverlay:overlay,mode:'points'}); else if (typeof toast==='function') toast('PROGRESS not available'); };
  footer.append(backBtn,closeBtn,__spacer,spiderBtn,progBtn);

  body.innerHTML = '<p class="muted">Loadingâ€¦</p>';

  try{
    const safeDate = (ts) => {
      if (!ts) return null;
      const d = ts instanceof Date ? ts : new Date(ts);
      return Number.isNaN(d.getTime()) ? null : d;
    };

    // Build official game IDs for this player (lifetime), fallback to scan official games
    let ids = [];
    const gameTs = new Map();
    try {
      const { data: pg } = await sb
        .from(TABLE_PLAYER_GAMES)
        .select('game_id, is_practice, ts')
        .eq('player', name)
        .eq('is_practice', false)
        .order('game_id', { ascending: true })
        .limit(5000);
      (pg || []).forEach(r => {
        if (r.game_id) {
          ids.push(r.game_id);
          if (r.ts) gameTs.set(r.game_id, r.ts);
        }
      });
    } catch(_){}

    if (!ids.length) {
      const games = (await __fetchOfficialGames(50000)).map(__normalizeGame);
      ids = games
        .map(g => {
          const gid = (g.raw && (g.raw.id || g.raw.game_id)) || g.id || g.game_id;
          if (gid && g.ts) gameTs.set(gid, g.ts);
          return gid;
        })
        .filter(Boolean);
    }

    // Fetch throws; fallback to reconstruct from boards
    let throwsRows = ids.length ? await __fetchThrowsForGames(ids) : [];
    if (!throwsRows.length) {
      const gamesAll = (await __fetchOfficialGames(50000)).map(__normalizeGame);
      gamesAll.forEach(g => {
        const gid = (g.raw && (g.raw.id || g.raw.game_id)) || g.id || g.game_id;
        if (gid && g.ts) gameTs.set(gid, g.ts);
      });
      throwsRows = __throwsFromGamesForPlayer(name, gamesAll);
    }

    // Attach timestamps from the game map (if present)
    throwsRows = (throwsRows || []).map(t => {
      const ts = t.ts || gameTs.get(t.game_id) || null;
      return Object.assign({}, t, { ts });
    });

    const mineAll = throwsRows.filter(t => String(t.player||'').trim().toLowerCase() === name.toLowerCase());
    
    // --- Clean view (no filters): All-time Target Points % (10..20)
    const content = document.createElement('div');
    body.innerHTML = '';
    body.appendChild(content);

    // Game Rank (across all players): prefer Supabase view (server-derived, backdated)
    const gameRankByTarget = new Map(); // target_round -> game_rank
    try{
      const { data: grRows, error: grErr } = await sb
        .from('player_points_bucket_ranks_v')
        .select('target_round, game_rank')
        .eq('player_name', name)
        .order('target_round', { ascending: true });
      if (grErr) throw grErr;
      (grRows||[]).forEach(r=>{
        const t = Number(r.target_round);
        const v = Number(r.game_rank);
        if (Number.isFinite(t)) gameRankByTarget.set(t, Number.isFinite(v) ? v : null);
      });
    }catch(e){
      console.warn('Game Rank view not available (player_points_bucket_ranks_v).', e);
    }


    // Aggregate per target 10..20 for THIS player
    const mine = mineAll.filter(t => typeof t.round_index === 'number' && t.round_index >= 0 && t.round_index <= 10);
    const rows=[];
    for (let r=0; r<=10; r++){
      const target  = 10 + r;
      const shots   = mine.filter(t => t.round_index === r);
      const throwsN = shots.length;
      const hitsUnits = shots.reduce((s,t)=>{
        const k = String(t.kind||'').toLowerCase();
        if (k.includes('treble') || k.includes('triple')) return s + 3;
        if (k.includes('double')) return s + 2;
        if (k.includes('single')) return s + (Number(t.points||0) > 0 ? 1 : 0);
        const ratio = Number(t.points||0) / target;
        if (ratio >= 2.5) return s + 3;
        if (ratio >= 1.5) return s + 2;
        if (ratio >= 0.5) return s + 1;
        return s;
      }, 0);
      const available = 3 * throwsN;
      const pct       = available ? (100 * hitsUnits / available) : 0;
      rows.push({ target, throwsN, hitsUnits, available, pct });
    }

    // Player Rank: by Points% (desc). Tie: thrown, then lower target.
    const pctRanks = rows
      .filter(r => r.throwsN > 0)
      .slice()
      .sort((a,b) => (b.pct - a.pct) || (b.throwsN - a.throwsN) || (a.target - b.target))
      .map((r, idx) => ({ target: r.target, rank: idx + 1 }));
    const pctRankMap = new Map(pctRanks.map(x => [x.target, x.rank]));

    // Table
    const table=document.createElement('table'); table.className='sq-table hs-table';
    const thead=document.createElement('thead'); const trh=document.createElement('tr');
    ['Target','Thrown','Available Hits','Actual Hits','Points %','Rank','Game Rank']
      .forEach(h => {
        const th = document.createElement('th');
        if (h === 'Game Rank') th.innerHTML = 'Game<br>Rank';
        else th.textContent = h;
        trh.appendChild(th);
      });
    thead.appendChild(trh); table.appendChild(thead);

    Array.from(trh.children).forEach(th => {
      th.style.position='sticky'; th.style.top='0'; th.style.zIndex='2'; th.style.background='rgba(0,0,0,0.4)';
    });

    const tbody=document.createElement('tbody');
    rows.forEach(r=>{
      const tr=document.createElement('tr');
      const tdTarget = document.createElement('td'); tdTarget.textContent = String(r.target);
      const tdThrown = document.createElement('td'); tdThrown.textContent = String(r.throwsN);
      const tdAvail  = document.createElement('td'); tdAvail.textContent  = String(r.available);
      const tdHits   = document.createElement('td'); tdHits.textContent   = String(r.hitsUnits || 0);
      const tdPct    = document.createElement('td'); tdPct.textContent    = (r.pct||0).toFixed(1)+'%';
      const tdRank   = document.createElement('td'); tdRank.textContent   = String(pctRankMap.get(r.target) || 'â€”');
      const tdGR     = document.createElement('td');
      const gr = gameRankByTarget.get(r.target);
      tdGR.textContent = gr ? String(gr) : 'â€”';
      tr.append(tdTarget, tdThrown, tdAvail, tdHits, tdPct, tdRank, tdGR);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);

    const info=document.createElement('p');
    info.className='tag';
    info.style.marginTop='8px';
    info.textContent = 'Actual Hits = single 1 â€¢ double 2 â€¢ treble 3 â€” Available Hits = 3 Ã— thrown (9 per round) â€” Points % = Actual Ã· Available';

    const scroll=document.createElement('div');
    scroll.style.maxHeight='56vh';
    scroll.style.overflowY='auto';
    __sqStyleStatsTableWrap(scroll);
    scroll.appendChild(table);

    content.innerHTML='';
    content.appendChild(scroll);
    content.appendChild(info);

    const grNote=document.createElement('div');
    grNote.className='tag muted';
    grNote.style.marginTop='10px';
    grNote.textContent='Game Rank is shown only after 15+ throws (5 rounds) for that target.';
    content.appendChild(grNote);


    // (optional) Feed SPIDER with this tableâ€™s Points% (10..20, then D/T/B zeros)
    window.__lastPointsPctSpiderData = {
      labels: rows.map(r=>String(r.target)),
      pct: rows.map(r=>Number(r.pct||0))
    };
}catch(e){
    console.error('Target Points % failed', e);
    body.innerHTML = '<p>Failed to load Target Points %.</p>';
    try{ if (typeof toast==='function') toast('Failed to open Target Points %'); }catch(_){}
  }
};

// ==== (5) D T B Hit % â€” per number (10..20), lifetime =======================
window.openPlayerDTBPctDialog = async function openPlayerDTBPctDialog(playerName){
  const name = String(playerName||'').trim();
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal';
  modal.style.maxWidth='980px'; modal.style.width='94vw';
  const header  = __sqStatsHeader(`D T B Hit % â€” ${name}`, 'Doubles / Trebles / Rank');
const body    = document.createElement('div'); body.className   ='modal-body';
  body.style.paddingTop='8px';
  const footer  = document.createElement('div'); footer.className ='modal-footer';
  modal.style.maxHeight='90vh'; modal.style.overflow='hidden';
  body .style.maxHeight='none'; body .style.overflowY='visible';

// Lifetime throws across all official games (build IDs from player_games)
let ids = [];
try {
  const { data: pg } = await sb
    .from(TABLE_PLAYER_GAMES)
    .select('game_id, is_practice')
    .eq('player', name)
    .eq('is_practice', false)
    .order('game_id', { ascending: true })
    .limit(5000);
  ids = (pg || []).map(r => r.game_id).filter(Boolean);
} catch (_) {}

if (!ids.length) {
  const games = (await __fetchOfficialGames(50000)).map(__normalizeGame);
  ids = games
    .map(g => (g.raw && (g.raw.id || g.raw.game_id)) || g.id || g.game_id)
    .filter(Boolean);
}

let throwsRows = ids.length ? await __fetchThrowsForGames(ids) : [];
if (!throwsRows.length) {
  const gamesAll = (await __fetchOfficialGames(50000)).map(__normalizeGame);
  throwsRows = __throwsFromGamesForPlayer(name, gamesAll);
}
const mineAll = throwsRows.filter(t => String(t.player||'').trim().toLowerCase() === name.toLowerCase());
const mine    = mineAll.filter(t => typeof t.round_index === 'number' && t.round_index >= 0 && t.round_index <= 10); // 10..20 only
const kindL = t => String(t.kind||'').toLowerCase();

  // Build per-target stats for 10..20 (round_index 0..10)
  const rows = [];
  for (let r=0; r<=10; r++){
    const target = 10 + r;
    const shots = mine.filter(t => t.round_index === r);
    const throwsN = shots.length;
    const dHits = shots.filter(t => kindL(t).includes('double')).length;
    const tHits = shots.filter(t => kindL(t).includes('treble') || kindL(t).includes('triple')).length;
    const dPct = throwsN ? (100 * dHits / throwsN) : 0;
    const tPct = throwsN ? (100 * tHits / throwsN) : 0;
    const hitPct = throwsN ? (100 * (dHits + tHits) / throwsN) : 0; // for ranking
    rows.push({ target, throwsN, dPct, tPct, hitPct });
  }
  // Rank by total hit% (D or T) descending, only among rows with throws>0
  const rankedTargets = rows
    .filter(r => r.throwsN > 0)
    .slice()
    .sort((a,b)=> b.hitPct - a.hitPct || b.dPct - a.dPct || b.tPct - a.tPct)
    .map((r,idx)=>({target:r.target, rank: idx+1}));
  const rankMap = new Map(rankedTargets.map(x=>[x.target, x.rank]));

  // Table
  const table=document.createElement('table'); table.className='sq-table hs-table';
  const thead=document.createElement('thead'); const trh=document.createElement('tr');
  ['Target','Throws','D %','T %','Rank'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);});
  thead.appendChild(trh); table.appendChild(thead);

  const tbody=document.createElement('tbody');
  rows.forEach(r=>{
    const tr=document.createElement('tr');
    const mk = v => { const td=document.createElement('td'); td.textContent = (typeof v==='number') ? (Number.isFinite(v) ? (v % 1 === 0 ? String(v) : v.toFixed(1)) : '0') : (v??''); return td; };
    tr.append(mk(r.target), mk(r.throwsN), mk(r.dPct ? (r.dPct.toFixed(1)+'%') : '0%'), mk(r.tPct ? (r.tPct.toFixed(1)+'%') : '0%'), mk(rankMap.get(r.target) || 'â€”'));
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);

  const scroll=document.createElement('div'); scroll.style.maxHeight='56vh'; scroll.style.overflowY='auto'; __sqStyleStatsTableWrap(scroll); scroll.appendChild(table);
  body.appendChild(scroll);

  const backBtn=document.createElement('button'); backBtn.className='btn sq-pill'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn sq-pill'; closeBtn.textContent='Close';
  backBtn.onclick=()=>{ overlay.remove(); __sqGoBackToStatsMain(); };
  closeBtn.onclick=()=>overlay.remove(); footer.append(backBtn,closeBtn);

  modal.append(header,body,footer); overlay.appendChild(modal); document.body.appendChild(overlay);

  function closeToHub(){ overlay.remove(); }
  overlay.addEventListener('click',e=>{ if(e.target===overlay) closeToHub();});
  overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') closeToHub();});
  modal.tabIndex=0; modal.focus();
};

// ==== (4c) D T B % â€” combined D/T hit rate per target (10..20), lifetime ====
window.openPlayerDTBCombinedPctDialog = async function openPlayerDTBCombinedPctDialog(playerName){
  const name = String(playerName||'').trim();
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal';
  modal.style.maxWidth='980px'; modal.style.width='94vw';
  const header  = __sqStatsHeader(`DTB % â€” ${name}`, 'Doubles / Trebles / Bull');
const body    = document.createElement('div'); body.className   ='modal-body';
  body.style.paddingTop='8px';
  const footer  = document.createElement('div'); footer.className ='modal-footer';

  modal.style.maxHeight='90vh';
  modal.style.overflow='hidden';
  body.style.maxHeight='none';
  body.style.overflowY='visible';

  // Build player's official game IDs (lifetime) from official games only.
// (Avoid querying player_games_union here â€” its schema varies and causes noisy 400s.)
  let ids = [];
  if (!ids.length) {
    const games = (await __fetchOfficialGames(60000)).map(__normalizeGame);
    ids = games
      .map(g => (g.raw && (g.raw.id || g.raw.game_id)) || g.id || g.game_id)
      .filter(Boolean);
  }

  // Fetch throws; if table is absent, reconstruct from boards
  let throwsRows = ids.length ? await __fetchThrowsForGames(ids) : [];
  if (!throwsRows.length) {
    const gamesAll = (await __fetchOfficialGames(60000)).map(__normalizeGame);
    throwsRows = __throwsFromGamesForPlayer(name, gamesAll);
  }

  const mineAll = (throwsRows||[]).filter(t => String(t.player||'').trim().toLowerCase() === name.toLowerCase());
  const mine1020 = mineAll.filter(t => typeof t.round_index === 'number' && t.round_index >= 0 && t.round_index <= 10); // 10..20 only

  const kindL = (t)=> String(t.kind || '').toLowerCase();

  // ---- Game Rank helpers (server view preferred)
  const dGameRankByTarget = new Map();
  const tGameRankByTarget = new Map();
  try {
    const { data: grRows, error: grErr } = await sb
      .from('player_dtb_bucket_ranks_v')
      .select('target_round, d_game_rank, t_game_rank')
      .eq('player_name', name)
      .order('target_round', { ascending: true });
    if (grErr) throw grErr;
    (grRows||[]).forEach(r=>{
      const t = Number(r.target_round);
      if (!Number.isFinite(t)) return;
      const dgr = Number(r.d_game_rank);
      const tgr = Number(r.t_game_rank);
      dGameRankByTarget.set(t, Number.isFinite(dgr) ? dgr : null);
      tGameRankByTarget.set(t, Number.isFinite(tgr) ? tgr : null);
    });
  } catch(e) {
    console.warn('Game Rank view not available (player_dtb_bucket_ranks_v).', e);
  }

  // ---- Player aggregates per target 10..20
  const rows = [];
  for (let r=0; r<=10; r++){
    const target  = 10 + r;
    const shots   = mine1020.filter(t => t.round_index === r);
    const throwsN = shots.length;

    const dHits = shots.reduce((s,t)=>{
      const k = kindL(t);
      if (k.includes('double')) return s + 1;
      const ratio = Number(t.points||0) / target;
      return s + (ratio >= 1.5 && ratio < 2.5 ? 1 : 0);
    }, 0);

    const tHits = shots.reduce((s,t)=>{
      const k = kindL(t);
      if (k.includes('treble') || k.includes('triple')) return s + 1;
      const ratio = Number(t.points||0) / target;
      return s + (ratio >= 2.5 ? 1 : 0);
    }, 0);

    const dPct = throwsN ? (100*dHits/throwsN) : 0;
    const tPct = throwsN ? (100*tHits/throwsN) : 0;

    rows.push({ target, throwsN, dHits, dPct, tHits, tPct });
  }

  // Player rank (within-player)
  const dRanked = rows
    .filter(r => r.throwsN > 0)
    .slice()
    .sort((a,b) => (b.dPct - a.dPct) || (b.dHits - a.dHits) || (a.target - b.target))
    .map((r,idx) => ({ target:r.target, rank:idx+1 }));

  const tRanked = rows
    .filter(r => r.throwsN > 0)
    .slice()
    .sort((a,b) => (b.tPct - a.tPct) || (b.tHits - a.tHits) || (a.target - b.target))
    .map((r,idx) => ({ target:r.target, rank:idx+1 }));

  const dRankMap = new Map(dRanked.map(x => [x.target, x.rank]));
  const tRankMap = new Map(tRanked.map(x => [x.target, x.rank]));

  // ---- Bull (single row): outer = 25, inner = 50
  const bullShots = mineAll.filter(t => Number(t.target) === 25 || Number(t.target) === 50 || t.round_index === 13);
  let outerCount = 0;
  let innerCount = 0;
  if (bullShots.length){
    bullShots.forEach(t=>{
      const tgt = Number(t.target);
      const k = String(t.kind||'').toLowerCase();
      const pts = Number(t.points||0);
      if (tgt === 25 || k.includes('outer') || (pts > 0 && pts < 40)) outerCount += 1;
      if (tgt === 50 || k.includes('inner') || (pts >= 40)) innerCount += 1;
    });
  }
  const bullThrows = bullShots.length || (outerCount + innerCount);
  const outerPct = bullThrows ? (100*outerCount/bullThrows) : 0;
  const innerPct = bullThrows ? (100*innerCount/bullThrows) : 0;

  // ---- Table
  const table=document.createElement('table'); table.className='sq-table hs-table';
  const thead=document.createElement('thead');
  const trh=document.createElement('tr');

  const headers = ['Target','Throws','Doubles','My Rank','Game Rank','Trebles','My Rank','Game Rank'];
  headers.forEach(h=>{
    const th=document.createElement('th');
    if (h === 'Game Rank') th.innerHTML = 'Game<br>Rank';
    else if (h === 'My Rank') th.innerHTML = 'My<br>Rank';
    else if (h === 'Doubles') th.innerHTML = 'Doubles<br><span class="thSub">(Hits / %)</span>';
    else if (h === 'Trebles') th.innerHTML = 'Trebles<br><span class="thSub">(Hits / %)</span>';
    else th.textContent = h;
    trh.appendChild(th);
  });

  thead.appendChild(trh);
  table.appendChild(thead);

  Array.from(trh.children).forEach(th => {
    th.style.position = 'sticky';
    th.style.top = '0';
    th.style.zIndex = '2';
    th.style.background = 'rgba(0,0,0,0.4)';
    th.style.whiteSpace = 'normal';
    th.style.lineHeight = '1.05';
  });

  const tbody=document.createElement('tbody');

  rows.forEach(r=>{
    const tr=document.createElement('tr');
    const tdTarget=document.createElement('td'); tdTarget.textContent=String(r.target);
    const tdThrows=document.createElement('td'); tdThrows.textContent=String(r.throwsN);

    const tdD=document.createElement('td'); tdD.textContent=`${r.dHits} (${(r.dPct||0).toFixed(1)}%)`;
    const tdDR=document.createElement('td'); tdDR.textContent = r.throwsN ? String(dRankMap.get(r.target) || 'â€”') : 'â€”';
    const tdDGR=document.createElement('td');
    const dgr = dGameRankByTarget.get(r.target);
    tdDGR.textContent = dgr ? String(dgr) : 'â€”';

    const tdT=document.createElement('td'); tdT.textContent=`${r.tHits} (${(r.tPct||0).toFixed(1)}%)`;
    const tdTR=document.createElement('td'); tdTR.textContent = r.throwsN ? String(tRankMap.get(r.target) || 'â€”') : 'â€”';
    const tdTGR=document.createElement('td');
    const tgr = tGameRankByTarget.get(r.target);
    tdTGR.textContent = tgr ? String(tgr) : 'â€”';

    tr.append(tdTarget, tdThrows, tdD, tdDR, tdDGR, tdT, tdTR, tdTGR);
    tbody.appendChild(tr);
  });

  // Bull summary row
  const bullTr=document.createElement('tr');
  const tdBT=document.createElement('td'); tdBT.textContent='BULL';
  const tdBTh=document.createElement('td'); tdBTh.textContent=String(bullThrows || 0);
  const tdBD=document.createElement('td'); tdBD.textContent = bullThrows ? `${outerCount} (${outerPct.toFixed(1)}%)` : 'â€”';
  const tdBDR=document.createElement('td'); tdBDR.textContent='â€”';
  const tdBDGR=document.createElement('td'); tdBDGR.textContent='â€”';
  const tdBTc=document.createElement('td'); tdBTc.textContent = bullThrows ? `${innerCount} (${innerPct.toFixed(1)}%)` : 'â€”';
  const tdBTR=document.createElement('td'); tdBTR.textContent='â€”';
  const tdBTGR=document.createElement('td'); tdBTGR.textContent='â€”';
  bullTr.append(tdBT, tdBTh, tdBD, tdBDR, tdBDGR, tdBTc, tdBTR, tdBTGR);
  tbody.appendChild(bullTr);

  table.appendChild(tbody);

  const scroll=document.createElement('div');
  scroll.style.maxHeight='56vh';
  scroll.style.overflowY='auto';
  __sqStyleStatsTableWrap(scroll);
  scroll.appendChild(table);
  body.appendChild(scroll);

  const note=document.createElement('div');
  note.className='tag';
  note.style.marginTop='10px';
  note.textContent = 'Bull: Doubles column = outer bull (25). Trebles column = inner bull (50).';
  body.appendChild(note);

  const grNote=document.createElement('div');
  grNote.className='tag muted';
  grNote.style.marginTop='10px';
  grNote.textContent='Game Rank is shown only after 15+ throws (5 rounds) for that row.';
  body.appendChild(grNote);


  const backBtn=document.createElement('button'); backBtn.className='btn sq-pill'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn sq-pill'; closeBtn.textContent='Close';
  backBtn.onclick=()=>{ overlay.remove(); __sqGoBackToStatsMain(); };
  closeBtn.onclick=()=>overlay.remove();

  const __spacer=document.createElement('div'); __spacer.style.flex='1';

  const __dtbSpiderData = {
    labels: rows.map(r=>String(r.target)).concat(['BULL']),
    pctD: rows.map(r=>Number(r.dPct||0)).concat([Number(outerPct||0)]),
    pctT: rows.map(r=>Number(r.tPct||0)).concat([Number(innerPct||0)])
  };

  const spiderBtn=document.createElement('button'); spiderBtn.className='btn small'; spiderBtn.textContent='SPIDER';
  spiderBtn.onclick=()=>{ overlay.style.display='none'; if (typeof window.openPlayerSpiderDialog==='function') window.openPlayerSpiderDialog(name,{parentOverlay:overlay, mode:'dtb', data: __dtbSpiderData}); else if (typeof toast==='function') toast('SPIDER not available'); };

  const progBtn=document.createElement('button'); progBtn.className='btn small'; progBtn.textContent='PROGRESS';
  progBtn.onclick=()=>{ overlay.style.display='none'; if (typeof window.openPlayerProgressHitDialog==='function') window.openPlayerProgressHitDialog(name,{parentOverlay:overlay, mode:'dtb'}); else if (typeof toast==='function') toast('PROGRESS not available'); };

  footer.append(backBtn, closeBtn, __spacer, spiderBtn, progBtn);

  modal.append(header, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  function closeToHub(){ overlay.remove(); }
  overlay.addEventListener('click',e=>{ if(e.target===overlay) closeToHub();});
  overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') closeToHub();});
  modal.tabIndex=0; modal.focus();
};

// ==== (6) H2H â€” wins/losses vs each opponent =================================
window.openPlayerH2HDialog = async function openPlayerH2HDialog(playerName){
  const nameLC = String(playerName||'').trim().toLowerCase();
  const pretty = String(playerName||'').trim();

  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal';
  modal.style.maxWidth='980px'; modal.style.width='94vw';
  modal.style.maxHeight='90vh'; modal.style.overflow='hidden';

  const header  = __sqStatsHeader(`H2H â€” ${pretty}`, 'Matches / Wins / Losses / Win % / Avg Diff');
  const body    = document.createElement('div'); body.className   ='modal-body';
  body.style.paddingTop='8px';
  const footer  = document.createElement('div'); footer.className ='modal-footer';

  // Pull plenty then filter locally (cloud-first)
  const games=(await __fetchOfficialGames(5000)).map(__normalizeGame)
    .filter(g => Array.isArray(g.players) && g.players.some(p => String(p||'').trim().toLowerCase()===nameLC));

  const vs=new Map(); // lc -> aggregate
  games.forEach(g=>{
    const i = g.players.findIndex(p => String(p||'').trim().toLowerCase()===nameLC);
    if (i < 0) return;
    const me=Number(g.totals[i]||0);

    g.players.forEach((op,j)=>{
      const lc=String(op||'').trim().toLowerCase();
      if (!lc || lc===nameLC) return;

      const their=Number(g.totals[j]||0);
      const rec=vs.get(lc) || { opp: op, W:0, L:0, diffs:[], games:0 };
      if (me>their) rec.W++; else if (me<their) rec.L++;
      rec.games++; rec.diffs.push(me-their);
      vs.set(lc,rec);
    });
  });

  const allRows=Array.from(vs.values()).map(r=>({
    opp:r.opp,
    games: Number(r.games || (r.W + r.L) || 0),
    W: Number(r.W||0),
    L: Number(r.L||0),
    winp: (r.W+r.L)? (100*r.W/(r.W+r.L)) : 0,
    avgdiff: r.diffs.length ? (r.diffs.reduce((s,x)=>s+x,0)/r.diffs.length) : 0
  }));

  const ineligible = allRows
    .filter(r => (r.games||0) < 4)
    .sort((a,b)=> (b.games-a.games) || String(a.opp).localeCompare(String(b.opp)));

  const eligible = allRows
    .filter(r => (r.games||0) >= 4)
    .sort((a,b)=> (b.winp-a.winp) || (b.avgdiff-a.avgdiff) || (b.games-a.games) || String(a.opp).localeCompare(String(b.opp)));

  const wrap = document.createElement('div');
  wrap.style.maxHeight='56vh';
  wrap.style.overflowY='auto';
  __sqStyleStatsTableWrap(wrap);

  const makeTable = (headers, rows, rowFn) => {
    const table=document.createElement('table'); table.className='sq-table hs-table';
    const thead=document.createElement('thead'); const trh=document.createElement('tr');
    headers.forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
    thead.appendChild(trh); table.appendChild(thead);
    const tbody=document.createElement('tbody');
    rows.forEach((r, idx)=> tbody.appendChild(rowFn(r, idx)));
    table.appendChild(tbody);
    return table;
  };

  const orangeRankCell = (n) => {
    const td=document.createElement('td');
    td.textContent=String(n);
    td.style.textAlign='left';
    td.style.paddingLeft='14px';
    td.style.color='rgba(255,123,26,.95)';
    td.style.fontWeight='800';
    return td;
  };

  if (!allRows.length){
    const p = document.createElement('div');
    p.style.padding='18px';
    p.style.opacity='.75';
    p.textContent = 'No head-to-head data (official games only).';
    wrap.appendChild(p);
  } else {

    if (ineligible.length){
      const cap = document.createElement('div');
      cap.className = 'muted';
      cap.style.margin = '2px 0 10px';
      cap.textContent = 'Opponents need 4+ games to enter the H2H league table.';
      wrap.appendChild(cap);

      const t0 = makeTable(['#','Opponent','Matches','Wins','Losses','Win %','Avg Score Diff'], ineligible, (r,idx)=>{
        const tr=document.createElement('tr');
        tr.style.opacity='0.45';
        tr.title='Greyed out until 4+ games played vs this opponent';

        const tdO=document.createElement('td'); tdO.textContent=String(r.opp||'');
        const tdM=document.createElement('td'); tdM.textContent=String(r.games||0); tdM.style.textAlign='center';
        const tdW=document.createElement('td'); tdW.textContent=String(r.W||0); tdW.style.textAlign='center';
        const tdL=document.createElement('td'); tdL.textContent=String(r.L||0); tdL.style.textAlign='center';
        const tdP=document.createElement('td'); tdP.textContent=(Number(r.winp||0)).toFixed(1)+'%'; tdP.style.textAlign='center';

        const tdD=document.createElement('td');
        tdD.textContent = (r.avgdiff>=0?'+':'') + Number(r.avgdiff||0).toFixed(1);
        tdD.style.textAlign='center';
        if (r.avgdiff > 0) tdD.style.color = 'rgba(0,255,120,.85)';
        else if (r.avgdiff < 0) tdD.style.color = 'var(--danger)';

        tr.append(orangeRankCell(idx+1), tdO, tdM, tdW, tdL, tdP, tdD);
        return tr;
      });
      wrap.appendChild(t0);

      const rule = document.createElement('div');
      rule.style.height='1px';
      rule.style.background='rgba(255,255,255,0.08)';
      rule.style.margin='12px 0';
      wrap.appendChild(rule);
    }

    if (!eligible.length){
      const p = document.createElement('div');
      p.style.padding='12px 0 4px';
      p.style.opacity='.75';
      p.textContent = 'No eligible opponents yet (need 4+ games).';
      wrap.appendChild(p);
    } else {
      const t1 = makeTable(['#','Opponent','Matches','Wins','Losses','Win %','Avg Score Diff'], eligible, (r,idx)=>{
        const tr=document.createElement('tr');

        const tdO=document.createElement('td'); tdO.textContent=String(r.opp||'');
        const tdM=document.createElement('td'); tdM.textContent=String(r.games||0); tdM.style.textAlign='center';
        const tdW=document.createElement('td'); tdW.textContent=String(r.W||0); tdW.style.textAlign='center';
        const tdL=document.createElement('td'); tdL.textContent=String(r.L||0); tdL.style.textAlign='center';
        const tdP=document.createElement('td'); tdP.textContent=r.winp.toFixed(1)+'%'; tdP.style.textAlign='center';

        const tdD=document.createElement('td');
        tdD.textContent = (r.avgdiff>=0?'+':'') + r.avgdiff.toFixed(1);
        tdD.style.textAlign='center';
        if (r.avgdiff > 0) tdD.style.color = 'rgba(0,255,120,.85)';
        else if (r.avgdiff < 0) tdD.style.color = 'var(--danger)';

        tr.append(orangeRankCell(idx+1), tdO, tdM, tdW, tdL, tdP, tdD);
        return tr;
      });
      wrap.appendChild(t1);
    }
  }

  body.appendChild(wrap);

  const backBtn=document.createElement('button'); backBtn.className='btn sq-pill'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn sq-pill'; closeBtn.textContent='Close';
  backBtn.onclick=()=>{ overlay.remove(); __sqGoBackToStatsMain(); };
  closeBtn.onclick=()=>overlay.remove();
  footer.append(backBtn,closeBtn);

  modal.append(header,body,footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  const closeToHub = ()=>overlay.remove();
  overlay.addEventListener('click',e=>{ if(e.target===overlay) closeToHub();});
  overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') closeToHub();});
  modal.tabIndex=0; modal.focus();
};

// === Player Stats â€” shim so the Select Player modal can open stats (always hub) ===
window.openPlayerStatsModePicker = function openPlayerStatsModePicker(name) {
  const n = String(name || '').trim();
  if (!n) { if (typeof toast==='function') toast('Pick a player'); return; }
  if (typeof window.openPlayerStatsHub === 'function') return window.openPlayerStatsHub(n);
  // Fallback: open the detail dialog if hub is somehow missing
  if (typeof window.openPlayerStatsDialog === 'function') return window.openPlayerStatsDialog(n);
  if (typeof toast==='function') toast('Stats view not available in this build');
};

// ---- ensure "New Game" button always works ----
document.addEventListener('DOMContentLoaded', function(){
  const btn = document.getElementById('newGameBtn') || document.getElementById('startNewGameBtn');
  if (!btn) return;
  btn.onclick = function(){
    try {
      if (typeof window.openSelectPlayersDialog === 'function') {
        window.openSelectPlayersDialog();
      } else if (typeof window.startNewGame === 'function') {
        window.startNewGame();
      } else if (typeof window.openPlayerSelectDialog === 'function') {
        window.openPlayerSelectDialog();
      } else {
        console.warn('No New Game opener found');
      }
      

    } catch(e){
      console.error('New Game failed', e);
      try { if (typeof toast==='function') toast('Failed to open New Game'); } catch(_) {}
    }
  };
});

// === End Game (Leaderboard only): insert "PREMIER LEAGUE" below HIGH SCORES ===
(function plBtnLeaderboardOnly(){
  function onLeaderboard(){
    return (document.body && (document.body.dataset.page || '').toLowerCase()) === 'leaderboard';
  }
  function findLeaderboardHighScoresButton(){
    // search only within the leaderboard page
    const root = document.querySelector('[data-page="leaderboard"]') || document.body;
    return Array.from(root.querySelectorAll('button,.btn,[role="button"]'))
      .find(el => /^\s*high\s*scores\s*$/i.test((el.textContent || '')));
  }
  function ensureOpener(){
    // use existing opener if defined; otherwise click any visible UI that opens PL
    return async function openPL(){
      if (typeof window.openPremierLeagueDialog === 'function') { try { window.openPremierLeagueDialog(); return; } catch(_){} }
      if (typeof window.openPremierLeaguePopup === 'function') { try { window.openPremierLeaguePopup(); return; } catch(_){} }
      const trigger = Array.from(document.querySelectorAll('button,.btn,a,[role="button"]'))
        .find(el => /premier\s*league|records/i.test((el.textContent||'')) && el.offsetParent);
      if (trigger) trigger.click();
    };
  }
  function ensureBtn(){
    if (!onLeaderboard()) return;
    const hs = findLeaderboardHighScoresButton();
    if (!hs) return;
    if (document.getElementById('btnPremierLeague')) return;

    const btn = document.createElement('button');
    btn.id = 'btnPremierLeague';
    btn.className = hs.className || 'btn';
    btn.type = 'button';
    btn.textContent = 'PREMIER LEAGUE';
    const openPL = ensureOpener();
    btn.addEventListener('click', (e)=>{ e.preventDefault(); openPL(); });

    // place directly under the High Scores button on the leaderboard screen
    hs.insertAdjacentElement('afterend', btn);
  }
  function tick(){ ensureBtn(); }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', tick); else tick();
  try { window.__sqUIMutationBus?.on(()=>tick()); } catch(_) {}
})();


// === Premier League â€” TODAY (clone a month pill; no min-games rule) =========
(function premierLeagueTodayCloneMonth(){
  // Disabled: superseded by openPremierLeagueDialog + filterId='TODAY'
  if (typeof window.openPremierLeagueDialog === 'function') return;
  const TITLE_RX = /^\s*premier league\s*$/i;
  const MONTHS   = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];

  // ---- helpers --------------------------------------------------------------
  function findModal(){
    const mods = document.querySelectorAll('.modal,[role="dialog"]');
    for (const m of mods){
      if (Array.from(m.querySelectorAll('h1,h2,h3')).some(h => TITLE_RX.test(h.textContent||''))) return m;
    }
    return null;
  }
  function findTabsRow(modal){
    if (!modal) return null;
    const blocks = modal.querySelectorAll('div,nav,section');
    for (const c of blocks){
      const btns = Array.from(c.querySelectorAll('button,.btn,[role="tab"]'));
      if (!btns.length) continue;
      const labs = btns.map(b => (b.textContent||'').trim().toUpperCase());
      const hasAll   = labs.includes('ALL TIME') || labs.includes('ALL') || labs.includes('ALLTIME');
      const hasMonth = labs.some(t => MONTHS.includes(t));
      const hasRec   = labs.includes('RECORDS');
      if (hasAll && (hasMonth || hasRec)) return c;
    }
    return null;
  }
  const visible = el => !!(el && el.offsetParent !== null);

  function todayRange(){
    const now = new Date();
    const start = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const end   = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1);
    return { start, end };
  }

  // ---- render Today table (replaces only the table, keeps pills visible) ----
  async function renderToday(modal){
   let row = findTabsRow(modal);
if (!row || row.offsetParent === null) {
  row = createFallbackTabsRow(modal);
}
let todayBtn = row && Array.from(row.querySelectorAll('button,.btn,[role="tab"]'))
  .find(b => /^today$/i.test((b.textContent||'').trim()));
if (!todayBtn) {
  // make sure there is a TODAY pill in this row
  const sample = row.querySelector('button,.btn,[role="tab"]');
  const tag = (sample && sample.tagName) ? sample.tagName.toLowerCase() : 'button';
  todayBtn = document.createElement(tag);
  todayBtn.type = 'button';
  todayBtn.setAttribute('role', (sample && (sample.getAttribute('role') || 'tab')) || 'tab');
  todayBtn.className = (sample && sample.className) || 'btn small';
  todayBtn.textContent = 'TODAY';
  row.insertAdjacentElement('afterbegin', todayBtn);
  todayBtn.addEventListener('click', (e)=>{ e.preventDefault(); renderToday(modal); });
}


    // hide only the table, NOT the tabs row
    const existingTable = modal.querySelector('table.hs-table');
    if (existingTable && !existingTable.dataset._pl_today_hidden){
      existingTable.dataset._pl_today_hidden = '1';
      existingTable.style.display = 'none';
    }

    // hide "X Games Minimum" banner (TODAY has no minimum)
    Array.from(modal.querySelectorAll('.tag,div,p,span'))
      .filter(el => /games\s+minimum/i.test((el.textContent||'')))
      .forEach(el => el.style.display = 'none');

    // remove any previous Today mount
    modal.querySelector('#plTodayMount')?.remove();

    // fetch & reduce
    let games = [];
    try { games = (await __fetchOfficialGames(50000)).map(__normalizeGame); } catch(e){ console.error(e); }
    const { start, end } = todayRange();
    games = games.filter(g => {
      const t = __gameTs(g.raw || g);
      if (!t) return false; const d = new Date(t);
      return d >= start && d < end;
    });

    const by = new Map(); // name -> {games,sum,best}
    games.forEach(g=>{
      (g.players||[]).forEach((p,i)=>{
        const name = String(p||'').trim(); if (!name) return;
        const score = Number(g.totals?.[i] || 0);
        const r = by.get(name) || { games:0, sum:0, best:0 };
        r.games += 1; r.sum += score; r.best = Math.max(r.best, score);
        by.set(name, r);
      });
    });
    const rows = Array.from(by.entries()).map(([name,r])=>({
      name, games:r.games, avg: r.games ? (r.sum / r.games) : 0, best:r.best
    })).sort((a,b)=> (b.avg - a.avg) || (b.games - a.games) || a.name.localeCompare(b.name));

    // build UI
    const mount = document.createElement('div'); mount.id = 'plTodayMount';

    const banner = document.createElement('div');
    banner.className = 'tag'; banner.textContent = 'Today Only'; banner.style.margin='6px 0';
    mount.appendChild(banner);

    const scroll = document.createElement('div');
    scroll.style.maxHeight='56vh'; scroll.style.overflowY='auto'; scroll.style.borderRadius='8px';
    mount.appendChild(scroll);

    const table = document.createElement('table'); table.className = 'hs-table';
    const thead = document.createElement('thead'); const trh = document.createElement('tr');
    ['#','Player','Games','Avg Total','Best'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
    thead.appendChild(trh); table.appendChild(thead);
    const tbody = document.createElement('tbody');
    rows.forEach((r,i)=>{
      const tr=document.createElement('tr');
      const td=v=>{const t=document.createElement('td'); t.textContent=v; return t;};
      tr.append(td(String(i+1)), td(r.name), td(String(r.games)), td((r.avg||0).toFixed(1)), td(String(r.best||0)));
      tbody.appendChild(tr);
    });
    table.appendChild(tbody); scroll.appendChild(table);

    // place the mount directly under the tabs row if visible, else top of modal body
    const rowEl = row && visible(row) ? row : null;
    if (rowEl) rowEl.insertAdjacentElement('afterend', mount);
    else (modal.querySelector('.modal-body') || modal).insertAdjacentElement('afterbegin', mount);
  }

  // ---- restore the app's default view when leaving TODAY --------------------
  function restore(modal){
    modal.querySelector('#plTodayMount')?.remove();
    Array.from(modal.querySelectorAll('.tag,div,p,span'))
      .filter(el => /games\s+minimum/i.test((el.textContent||'')))
      .forEach(el => el.style.display = '');
    const t = modal.querySelector('table.hs-table[data-_pl_today_hidden="1"]') || modal.querySelector('table.hs-table');
    if (t) { t.style.display=''; delete t.dataset._pl_today_hidden; }
  }
  
  function createFallbackTabsRow(modal){
  // if a visible real row exists, use it
  const real = findTabsRow(modal);
  if (real && real.offsetParent !== null) return real;

  // Build a compact row and clone styling from any button we can find
  const sampleBtn = modal.querySelector('button,.btn,[role="tab"]');
  // If TODAY already exists (native tab), don't inject a duplicate
  if (Array.from(modal.querySelectorAll('button')).some(b => ((b.textContent||'').trim().toUpperCase() === 'TODAY'))) return;
  const mk = (label) => {
    const tag = (sampleBtn && sampleBtn.tagName) ? sampleBtn.tagName.toLowerCase() : 'button';
    const b = document.createElement(tag);
    b.type = 'button';
    b.setAttribute('role', (sampleBtn && (sampleBtn.getAttribute('role') || 'tab')) || 'tab');
    b.className = (sampleBtn && sampleBtn.className) || 'btn small';
    b.textContent = label;
    return b;
  };

  const row = document.createElement('div');
  row.id = 'plTodayTabsFallback';
  row.style.display = 'flex';
  row.style.flexWrap = 'wrap';
  row.style.gap = '8px';
  row.style.margin = '6px 0 8px';

  // Standard set: RECORDS, ALL TIME, TODAY, months (DEC â†’ JAN)
  const pills = [mk('RECORDS'), mk('ALL TIME'), mk('TODAY'), ...[...MONTHS].reverse().map(m => mk(m))];
  pills.forEach(b => row.appendChild(b));

  // Mount right under the title so it's always visible
  const titleEl = modal.querySelector('h1,h2,h3');
  if (titleEl) titleEl.insertAdjacentElement('afterend', row);
  else (modal.querySelector('.modal-body') || modal).insertAdjacentElement('afterbegin', row);

  // Wire: TODAY renders our view; other pills restore and try to trigger the real tab
  const clickOther = (label) => {
        restore(modal);
    const realRow = findTabsRow(modal);
    if (realRow) {
      const target = Array.from(realRow.querySelectorAll('button,.btn,[role="tab"]'))
        .find(b => new RegExp(`^${label}$`, 'i').test((b.textContent || '').trim()));
      if (target) target.click();
    }
  };
  pills.forEach(b => {
    const label = (b.textContent || '').trim().toUpperCase();
    if (label === 'TODAY') b.addEventListener('click', (e)=>{ e.preventDefault(); renderToday(modal); });
    else b.addEventListener('click', ()=> clickOther(label));
  });

  return row;
}

  // ---- add a TODAY pill by cloning a real month pill -----------------------
  function ensureTodayPill(modal){
    const row = findTabsRow(modal); if (!row || !visible(row)) return null;

    // already present?
    let btn = Array.from(row.querySelectorAll('button,.btn,[role="tab"]'))
      .find(b => /^today$/i.test((b.textContent||'').trim()));
    if (btn) return btn;

    // clone a month pill to copy exact styling
    const monthBtn = Array.from(row.querySelectorAll('button,.btn,[role="tab"]'))
      .find(b => MONTHS.includes((b.textContent||'').trim().toUpperCase()));
    if (!monthBtn) return null;

    const clone = monthBtn.cloneNode(true);
    clone.textContent = 'TODAY';
    clone.dataset.mode = 'TODAY';
    // remove any existing handlers by replacing the node
    const tag = clone.tagName.toLowerCase(); const fresh = document.createElement(tag);
    fresh.className = clone.className; fresh.type = 'button'; fresh.setAttribute('role', clone.getAttribute('role') || 'tab');
    fresh.textContent = 'TODAY'; fresh.dataset.mode = 'TODAY';

    // place it right after ALL TIME if present; else before first month
    const allBtn = Array.from(row.querySelectorAll('button,.btn,[role="tab"]')).find(b => /all\s*time/i.test((b.textContent||'')));
    if (allBtn && allBtn.parentElement === row) allBtn.insertAdjacentElement('afterend', fresh);
    else monthBtn.insertAdjacentElement('beforebegin', fresh);

    // wire: render Today on click
    fresh.addEventListener('click', (e)=>{ e.preventDefault(); renderToday(modal); });

    // when any other pill is clicked, restore the default table/banner
    if (!row.dataset._todayRestoreWired){
      row.dataset._todayRestoreWired = '1';
      row.addEventListener('click', (e)=>{
        const label = (e.target && (e.target.textContent||'').trim().toUpperCase()) || '';
        if (label && label !== 'TODAY') restore(modal);
      }, true);
    }

    return fresh;
  }

  function tick(){
    const m = findModal(); if (!m) return;
    ensureTodayPill(m);
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', tick); else tick();
  try { window.__sqUIMutationBus?.on(()=>tick()); } catch(_) {}
})();

// === High Score League â€” rewritten: NEW + movement + even widths ============
(function highScoreLeagueRewritten(){
  const TITLE_RX = /high\s*score\s*league/i;
  const STORAGE_KEY = 'hsLeaguePositions.v2';
  const NEW_LIMIT_DAYS = 14;

  // ---- utilities ------------------------------------------------------------
  const daysBetween = (a,b) => Math.floor((a - b) / 86400000);
  const visible = el => !!(el && el.offsetParent !== null);

  function findHSModal(){
    const mods = document.querySelectorAll('.modal,[role="dialog"]');
    for (const m of mods){
      const ok = Array.from(m.querySelectorAll('h1,h2,h3'))
        .some(h => TITLE_RX.test(h.textContent || ''));
      if (ok) return m;
    }
    return null;
  }

  function getTable(modal){
    if (!modal) return null;
    const table = modal.querySelector('table.hs-table');
    if (!table) return null;
    const ths = Array.from(table.querySelectorAll('thead th'));
    if (!ths.length) return null;

    // Expected headers: "# | Player | High Score | When"
    const idxPos    = 0; // "#"
    const idxPlayer = ths.findIndex(th => /player/i.test(th.textContent||''));
    const idxHigh   = ths.findIndex(th => /high\s*score/i.test(th.textContent||''));
    const idxWhen   = ths.findIndex(th => /when/i.test(th.textContent||''));
    if (idxPlayer < 0 || idxHigh < 0 || idxWhen < 0) return null;
    return { table, ths, idxPos, idxPlayer, idxHigh, idxWhen };
  }

  async function earliestMap(){
    if (window.__hsEarliestMap_v2) return window.__hsEarliestMap_v2;
    let games = [];
    try { games = (await __fetchOfficialGames(50000)).map(__normalizeGame); } catch(_){}
    const map = new Map(); // nameLC -> earliest Date
    games.forEach(g=>{
      const t = __gameTs(g.raw || g); if (!t) return;
      const d = new Date(t);
      (g.players||[]).forEach(p=>{
        const k = String(p||'').trim().toLowerCase(); if (!k) return;
        const cur = map.get(k);
        if (!cur || d < cur) map.set(k, d);
      });
    });
    window.__hsEarliestMap_v2 = map;
    return map;
  }

  function arrowHTML(delta){
    if (delta > 0) return `<span title="+${delta}" style="color:#22c55e;font-weight:700">â–²</span>`;
    if (delta < 0) return `<span title="${delta}" style="color:#ef4444;font-weight:700">â–¼</span>`;
    return `<span style="opacity:.5">â€“</span>`;
  }

  // ---- main apply -----------------------------------------------------------
  async function apply(modal){
    const refs = getTable(modal); if (!refs) return;
    const { table, ths, idxPos, idxPlayer, idxHigh, idxWhen } = refs;

    // 1) Insert movement header AFTER "#"
    let thMove = table.querySelector('thead th[data-move-col="1"]');
    if (!thMove){
      thMove = document.createElement('th');
      thMove.dataset.moveCol = '1';
      thMove.style.textAlign = 'center';
      thMove.style.width     = '26px';
      thMove.style.minWidth  = '24px';
      thMove.style.maxWidth  = '36px';
      ths[idxPos].insertAdjacentElement('afterend', thMove);
    }

    // 2) Even spacing for Player / High Score / When
    const headNow = Array.from(table.querySelectorAll('thead th'));
    const idxMove = headNow.findIndex(th => th.dataset && th.dataset.moveCol === '1');

    table.style.tableLayout = 'fixed';
    table.style.width = '100%';
    if (headNow[0]) {
      headNow[0].style.width    = '36px';
      headNow[0].style.minWidth = '32px';
      headNow[0].style.maxWidth = '42px';
    }
    if (idxMove >= 0 && headNow[idxMove]) {
      headNow[idxMove].style.width     = '26px';
      headNow[idxMove].style.minWidth  = '24px';
      headNow[idxMove].style.maxWidth  = '34px';
      headNow[idxMove].style.textAlign = 'center';
    }
    // recompute indexes by text (header DOM may have shifted)
    const idxPlayerNow = headNow.findIndex(th => /player/i.test(th.textContent||''));
    const idxHighNow   = headNow.findIndex(th => /high\s*score/i.test(th.textContent||''));
    const idxWhenNow   = headNow.findIndex(th => /when/i.test(th.textContent||''));

    const fixedPx = 36 + (idxMove >= 0 ? 26 : 0);
    const EVEN = `calc((100% - ${fixedPx}px) / 3)`;
    [idxPlayerNow, idxHighNow, idxWhenNow].forEach(i => {
      if (i >= 0 && headNow[i]) headNow[i].style.width = EVEN;
    });

    // 3) Per-row: add movement cell; add NEW tag if first-game â‰¤ 14 days
    const prevRaw = localStorage.getItem(STORAGE_KEY);
    const prevMap = prevRaw ? JSON.parse(prevRaw) : {}; // nameLC -> prev position
    const now = new Date();
    const firstMap = await earliestMap();

    const rows = Array.from(table.querySelectorAll('tbody tr'));
    const curMap = {}; // nameLC -> current position

    rows.forEach((tr, i) => {
      const pos = i + 1;
      const tds = Array.from(tr.children);
      const tdPos    = tds[idxPos];
      // movement cell sits AFTER position; if not there, create
      let tdMove = tds[idxMove];
      if (!tdMove || tdMove === tdPos || tdMove.dataset.moveCell !== '1') {
        tdMove = document.createElement('td');
        tdMove.dataset.moveCell = '1';
        tdMove.style.textAlign = 'center';
        tdPos.insertAdjacentElement('afterend', tdMove);
      }

      // After inserting a new td, refresh children and resolve Player cell
      const tds2 = Array.from(tr.children);
      // Player column shifts by +1 if movement col was inserted before it
      const tdPlayerCell = tds2[(idxPlayerNow >= 0 ? idxPlayerNow : idxPlayer) + (idxMove >= 0 ? 1 : 0)];
      if (!tdPlayerCell) return;

      // Player name (strip any existing "NEW")
      const nameText = (tdPlayerCell.textContent || '').replace(/\bNEW\b/gi,'').trim();
      const nameLC = nameText.toLowerCase();
      curMap[nameLC] = pos;

      // Movement arrow against previous snapshot
      let html = '<span style="opacity:.5">â€“</span>';
      const prevPos = prevMap[nameLC];
      if (typeof prevPos === 'number') {
        const delta = prevPos - pos; // positive = moved UP (better)
        html = arrowHTML(delta);
      }
      tdMove.innerHTML = html;

      // NEW tag (first official game within the last 14 days)
      if (nameLC && firstMap.has(nameLC)) {
        const first = firstMap.get(nameLC);
        const isNew = daysBetween(now, first) <= NEW_LIMIT_DAYS && daysBetween(now, first) >= 0;
        if (isNew && !/\bNEW\b/i.test(tdPlayerCell.innerHTML)) {
          const tag = document.createElement('span');
          tag.className = 'tag';
          tag.textContent = 'NEW';
          tag.style.marginLeft = '6px';
          tdPlayerCell.appendChild(tag);
        }
      }
    });

    // 4) Save snapshot for next time
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(curMap)); } catch(_) {}
  }

  // Debounced observer to apply when the league modal appears/updates
  let scheduled = false;
  function tick(){
    const m = findHSModal();
    if (!m || !visible(m)) return;
    if (scheduled) return;
    scheduled = true;
    requestAnimationFrame(async ()=>{ scheduled = false; try { await apply(m); } catch(e){ console.error(e); } });
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', tick); else tick();
  try { window.__sqUIMutationBus?.on(()=>tick()); } catch(_) {}
})();

// === High Scores (Match) â€” v4: movement â–²/â–¼ (7d), NEW(7d), PB, date fmt =====
(function enhanceHighScoresMatch_v4(){
  const TITLE_RX = /^\s*high\s*scores\s*$/i;
  // Expected header: "# | Player | Score | Avg / Round | When"
  const COLS_RX  = [/^#$/i, /player/i, /^score$/i, /avg\s*\/\s*round/i, /when/i];
  const NEW_MS   = 7 * 24 * 60 * 60 * 1000; // 7 days
  const POS_KEY  = 'hsMatchEntryPositions.v1'; // entryKey -> {pos, delta, tISO}

  // ---------- helpers ----------
  function findModalAndTable(){
    const mods = document.querySelectorAll('.modal,[role="dialog"]');
    for (const m of mods){
      const ok = Array.from(m.querySelectorAll('h1,h2,h3'))
        .some(h => TITLE_RX.test(h.textContent||''));
      if (!ok) continue;
      const table = m.querySelector('table.hs-table'); if (!table) continue;
      const ths = Array.from(table.querySelectorAll('thead th'));
      if (ths.length < 5) continue;
      const matches = COLS_RX.every((rx, idx)=> rx.test((ths[idx].textContent||'').trim()));
      if (matches) return { modal: m, table, ths };
    }
    return null;
  }

  // "20 Nov 25 at 20:35" | "20 Nov 25 @ 20:35" â†’ "20/11/25 @ 20:35"
  function fmt_DDMMYY_HHMM(text){
    if (!text) return text;
    const m = text.match(/^\s*(\d{1,2})\s+([A-Za-z]{3})\s+(\d{2})(?:\s+at|\s*@)\s+(\d{2}):(\d{2})\s*$/);
    if (!m) return text;
    const [, d, mon, yy, hh, mm] = m;
    const MONTH = {JAN:'01',FEB:'02',MAR:'03',APR:'04',MAY:'05',JUN:'06',JUL:'07',AUG:'08',SEP:'09',OCT:'10',NOV:'11',DEC:'12'};
    const mmNum = MONTH[mon.toUpperCase()];
    if (!mmNum) return text;
    const dd = String(d).padStart(2,'0');
    return `${dd}/${mmNum}/${yy} @ ${hh}:${mm}`;
  }

  function yellowNEW(){
    const span = document.createElement('span');
    span.className = 'tag';
    span.textContent = 'NEW';
    span.style.color = '#facc15';
    span.style.borderColor = 'rgba(250,204,21,.35)';
    span.style.background = 'rgba(250,204,21,.08)';
    return span;
  }

  function arrowHTML(delta){
    if (delta > 0) return `<span title="+${delta}" style="color:#22c55e;font-weight:700">â–²</span>`;
    if (delta < 0) return `<span title="${delta}" style="color:#ef4444;font-weight:700">â–¼</span>`;
    return `<span style="opacity:.5">â€“</span>`;
  }

  // Build PB map + (player|score)â†’latest timestamp
  async function buildMaps(){
    if (window.__hsMatchMaps_v4) return window.__hsMatchMaps_v4;

    let games = [];
    try { games = (await __fetchOfficialGames(50000)).map(__normalizeGame); } catch(_) {}

    const pb = new Map();      // nameLC -> max score
    const keyTs = new Map();   // `${nameLC}|${score}` -> latest Date
    let globalMax = 0;

    games.forEach(g=>{
      const ts = __gameTs(g.raw || g);
      const d  = ts ? new Date(ts) : null;
      (g.players||[]).forEach((p,i)=>{
        const name = String(p||'').trim(); if (!name) return;
        const k = name.toLowerCase();
        const score = Number(g.totals?.[i] || 0);
        if (!Number.isFinite(score)) return;
        if (score > (pb.get(k) || 0)) pb.set(k, score);
        if (score > globalMax) globalMax = score;
        if (d) {
          const key = `${k}|${score}`;
          const prev = keyTs.get(key);
          if (!prev || d > prev) keyTs.set(key, d);
        }
      });
    });

    window.__hsMatchMaps_v4 = { pb, keyTs, globalMax };
    return window.__hsMatchMaps_v4;
  }

  function loadPos(){ try { return JSON.parse(localStorage.getItem(POS_KEY) || '{}'); } catch(_) { return {}; } }
  function savePos(m){ try { localStorage.setItem(POS_KEY, JSON.stringify(m)); } catch(_){} }

  async function apply(){
    const found = findModalAndTable(); if (!found) return;
    const { table, ths } = found;

    // Insert movement header AFTER "#"
    let thMove = table.querySelector('thead th[data-move-col="1"]');
    if (!thMove){
      thMove = document.createElement('th');
      thMove.dataset.moveCol = '1';
      thMove.style.textAlign = 'center';
      thMove.style.width     = '26px';
      thMove.style.minWidth  = '22px';
      thMove.style.maxWidth  = '34px';
      ths[0].insertAdjacentElement('afterend', thMove);
    }

    // Insert NEW header AFTER movement
    let headNow = Array.from(table.querySelectorAll('thead th'));
    let idxRank = headNow.findIndex(th => /^#$/i.test((th.textContent||'').trim()));
    let idxMove = headNow.findIndex(th => th.dataset && th.dataset.moveCol === '1');

    let thNew = table.querySelector('thead th[data-newcol="1"]');
    if (!thNew){
      thNew = document.createElement('th');
      thNew.dataset.newcol = '1';
      thNew.style.textAlign = 'center';
      thNew.style.width = '44px';
      thNew.style.minWidth = '38px';
      thNew.style.maxWidth = '60px';
      headNow[idxMove].insertAdjacentElement('afterend', thNew);
    }

    // Narrow the "#" column
    headNow = Array.from(table.querySelectorAll('thead th'));
    idxRank = headNow.findIndex(th => /^#$/i.test((th.textContent||'').trim()));
    idxMove = headNow.findIndex(th => th.dataset && th.dataset.moveCol === '1');
    const idxNew = headNow.findIndex(th => th.dataset && th.dataset.newcol === '1');

    if (headNow[idxRank]) {
      headNow[idxRank].style.width     = '24px';
      headNow[idxRank].style.minWidth  = '22px';
      headNow[idxRank].style.maxWidth  = '28px';
      headNow[idxRank].style.textAlign = 'center';
    }
    table.style.tableLayout = 'fixed';
    table.style.width = '100%';

    // Resolve main column indexes by header text (after our inserts)
    const idxPlayer = headNow.findIndex(th => /player/i.test(th.textContent||''));
    const idxScore  = headNow.findIndex(th => /^score$/i.test(th.textContent||''));
    let   idxWhen   = headNow.findIndex(th => /when/i.test(th.textContent||''));
    if (idxWhen < 0) idxWhen = headNow.length - 1;

    const { pb, keyTs, globalMax } = await buildMaps();

    // Load previous entry positions (per entry: nameLC|score)
    const prev = loadPos();
    const next = {};
    const now = Date.now();

    // Per-row updates
    const rows = Array.from(table.querySelectorAll('tbody tr'));
    rows.forEach((tr, i)=>{
      const tds0 = Array.from(tr.children);
      const tdRank = tds0[idxRank];

      // Ensure movement cell immediately after rank
      let tdMove = tds0[idxMove];
      if (!tdMove || tdMove === tdRank || tdMove.dataset.moveCell !== '1') {
        tdMove = document.createElement('td');
        tdMove.dataset.moveCell = '1';
        tdMove.style.textAlign = 'center';
        tdRank.insertAdjacentElement('afterend', tdMove);
      } else {
        tdMove.innerHTML = '';
      }

      // Ensure NEW cell immediately after movement
      const tds1 = Array.from(tr.children);
      const tdAfterMove = tds1[idxMove + 1] || tdMove.nextElementSibling;
      let tdNew = tds1[idxNew];
      if (!tdNew || tdNew === tdRank || tdNew === tdMove || tdNew.dataset.newCell !== '1') {
        tdNew = document.createElement('td');
        tdNew.dataset.newCell = '1';
        tdNew.style.textAlign = 'center';
        (tdAfterMove || tdMove).insertAdjacentElement('afterend', tdNew);
      } else {
        tdNew.innerHTML = '';
      }

      // Refresh indexes after inserts and read data cells
      const tds = Array.from(tr.children);
      const tdPlayer = tds[idxPlayer];
      const tdScore  = tds[idxScore];
      const tdWhen   = tds[idxWhen] || tds[tds.length - 1];

      // 1) Format When => DD/MM/YY @ HH:MM
      if (tdWhen) {
        const orig = tdWhen.textContent || '';
        const fmt  = fmt_DDMMYY_HHMM(orig);
        if (fmt && fmt !== orig) tdWhen.textContent = fmt;
      }

      // Entry key for movement & NEW: nameLC|score
      const nameLC = (tdPlayer?.textContent || '').trim().toLowerCase();
      const scoreN = Number((tdScore?.textContent || '').replace(/[^\d.]/g,''));
      const entryKey = `${nameLC}|${Number.isFinite(scoreN) ? scoreN : -1}`;
      const pos = i + 1;

      // 2) Movement (persist 7 days if no further movement)
      const prevRec = prev[entryKey];
      let deltaToShow = 0;
      if (prevRec && typeof prevRec.pos === 'number') {
        if (prevRec.pos !== pos) {
          // changed now
          deltaToShow = prevRec.pos - pos; // + = moved up
          next[entryKey] = { pos, delta: deltaToShow, tISO: new Date(now).toISOString() };
        } else {
          // unchanged; keep showing if within 7d and delta != 0
          const ageOK = prevRec.tISO && (now - Date.parse(prevRec.tISO)) <= NEW_MS;
          deltaToShow = ageOK ? (prevRec.delta || 0) : 0;
          next[entryKey] = { pos, delta: prevRec.delta || 0, tISO: prevRec.tISO || new Date(now).toISOString() };
        }
      } else {
        // first time seeing this entry
        next[entryKey] = { pos, delta: 0, tISO: new Date(now).toISOString() };
      }
      tdMove.innerHTML = arrowHTML(deltaToShow);

      // 3) NEW (â‰¤7 days since that exact (player,score))
      if (nameLC && Number.isFinite(scoreN)) {
        const k = `${nameLC}|${scoreN}`;
        const ts = keyTs.get(k);
        if (ts && (Date.now() - ts.getTime()) <= NEW_MS) {
          tdNew.appendChild(yellowNEW());
        }
      }

      // 4) PB after Score (exclude global top score)
      const isGlobalTop = Number((tdScore?.textContent || '').replace(/[^\d.]/g,'')) === globalMax;
      const best = pb.get(nameLC) || -Infinity;
      const isPB = Number((tdScore?.textContent || '').replace(/[^\d.]/g,'')) === best;
      if (!isGlobalTop && isPB && tdScore && !/\bPB\b/i.test(tdScore.innerHTML)) {
        const tag = document.createElement('span');
        tag.className = 'tag';
        tag.textContent = 'PB';
        tag.style.marginLeft = '6px';
        tdScore.appendChild(tag);
      }
    });

    // Save snapshot for next time
    savePos(next);
  }

  function tick(){ try { apply(); } catch(e){ console.error('HS Match v4 failed', e); } }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', tick); else tick();
  try { window.__sqUIMutationBus?.on(()=>tick()); } catch(_) {}
})();

// === T button flash + shake â€” v3 (Safari-safe; 1â†’2â†’3 only when T is pressed)
(function tButtonFXv3(){
  // CSS (proper injection)
  if (!document.getElementById('tfx-css')) {
    const s = document.createElement('style'); s.id = 'tfx-css';
    s.textContent =
`.tfx{will-change:transform,filter}
@keyframes tFlashLow{0%{filter:brightness(1);box-shadow:none}12%{filter:brightness(1.4);box-shadow:0 0 10px rgba(255,255,255,.5),0 0 18px rgba(77,163,255,.3)}30%{filter:brightness(1.05);box-shadow:none}100%{filter:brightness(1);box-shadow:none}}
@keyframes tFlashMed{0%{filter:brightness(1);box-shadow:none}10%{filter:brightness(1.9);box-shadow:0 0 16px rgba(255,255,255,.7),0 0 28px rgba(77,163,255,.4)}24%{filter:brightness(1.1);box-shadow:none}38%{filter:brightness(1.6);box-shadow:0 0 12px rgba(255,255,255,.5),0 0 22px rgba(77,163,255,.35)}100%{filter:brightness(1);box-shadow:none}}
@keyframes tFlashHigh{0%{filter:brightness(1);box-shadow:none}8%{filter:brightness(2.6);box-shadow:0 0 22px rgba(255,255,255,.85),0 0 40px rgba(77,163,255,.5)}18%{filter:brightness(1.1);box-shadow:none}28%{filter:brightness(2.2);box-shadow:0 0 18px rgba(255,255,255,.7),0 0 34px rgba(77,163,255,.45)}42%{filter:brightness(1.15);box-shadow:none}100%{filter:brightness(1);box-shadow:none}}
@keyframes tShakeLow{0%,100%{transform:translateX(0)}20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-2px)}80%{transform:translateX(2px)}}
@keyframes tShakeMed{0%,100%{transform:translateX(0)}15%{transform:translateX(-5px)}30%{transform:translateX(5px)}45%{transform:translateX(-4px)}60%{transform:translateX(4px)}75%{transform:translateX(-3px)}}
@keyframes tShakeHigh{0%,100%{transform:translateX(0) rotate(0)}12%{transform:translateX(-8px) rotate(-1deg)}24%{transform:translateX(8px) rotate(1deg)}36%{transform:translateX(-7px) rotate(-.9deg)}48%{transform:translateX(7px) rotate(.9deg)}60%{transform:translateX(-6px) rotate(-.8deg)}72%{transform:translateX(6px) rotate(.8deg)}84%{transform:translateX(-4px) rotate(-.6deg)}}
.tfx.flash-low{animation:tFlashLow .22s ease-in-out,tShakeLow .22s linear}
.tfx.flash-med{animation:tFlashMed .34s ease-in-out,tShakeMed .34s linear}
.tfx.flash-high{animation:tFlashHigh .50s ease-in-out,tShakeHigh .50s linear}`;
    document.head.appendChild(s);
  }

  // Find the visible T button (label "T" or treble)
  function isT(el){
    if (!el) return false;
    const label = (el.textContent || el.getAttribute('aria-label') || el.title || '').trim().toUpperCase();
    const data  = ((el.dataset && (el.dataset.shot || el.dataset.kind || '')) || '').toUpperCase();
    const isBtn = /^(BUTTON|A)$/i.test(el.tagName) || el.hasAttribute('role');
    return isBtn && (label === 'T' || data === 'T' || /TREB|TREBLE/.test(label+data));
  }
  function findT(){ return Array.from(document.querySelectorAll('button,.btn,a,[role="button"]')).find(el => isT(el) && el.offsetParent); }

  // Press-order only: 1 -> 2 -> 3 -> 1 ... (only T presses advance)
  let count = 0;

  function animate(el){
    el.classList.add('tfx');
    el.classList.remove('flash-low','flash-med','flash-high');
    void el.offsetWidth; // restart
    el.classList.add(count===1 ? 'flash-low' : count===2 ? 'flash-med' : 'flash-high');
    setTimeout(() => el.classList.remove('flash-low','flash-med','flash-high'), 700);
  }

  function onPress(){
    const el = findT(); if (!el) return;
    count = (count % 3) + 1;     // 1â†’2â†’3â†’1â€¦
    animate(el);
  }

  // Wire clicks only on T; keyboard 't' also triggers it
  function wire(){
    const btn = findT(); if (!btn || btn.dataset.tFxWired==='1') return;
    btn.dataset.tFxWired = '1';
    btn.addEventListener('click', onPress);
  }
  document.addEventListener('keydown', e => { if ((e.key||'').toLowerCase() === 't') onPress(); });

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', wire); else wire();
  try { window.__sqUIMutationBus?.on(()=>wire()); } catch(_) {}
})();

// === D button flash + shake â€” v1 (1â†’2â†’3: Ultra-low â†’ Low â†’ Medium)
(function dButtonFX(){
  // CSS for D (kept separate from T)
  if (!document.getElementById('dfx-css')) {
    const s = document.createElement('style'); s.id = 'dfx-css';
    s.textContent =
`.dfx{will-change:transform,filter}
@keyframes dFlashUltra{0%{filter:brightness(1);box-shadow:none}18%{filter:brightness(1.2);box-shadow:0 0 6px rgba(255,255,255,.35),0 0 12px rgba(77,163,255,.20)}100%{filter:brightness(1);box-shadow:none}}
@keyframes dFlashLow{0%{filter:brightness(1);box-shadow:none}14%{filter:brightness(1.45);box-shadow:0 0 10px rgba(255,255,255,.45),0 0 18px rgba(77,163,255,.28)}100%{filter:brightness(1);box-shadow:none}}
@keyframes dFlashMed{0%{filter:brightness(1);box-shadow:none}12%{filter:brightness(1.7);box-shadow:0 0 14px rgba(255,255,255,.6),0 0 24px rgba(77,163,255,.35)}32%{filter:brightness(1.1);box-shadow:none}100%{filter:brightness(1);box-shadow:none}}
@keyframes dShakeUltra{0%,100%{transform:translateX(0)}25%{transform:translateX(-1px)}75%{transform:translateX(1px)}}
@keyframes dShakeLow{0%,100%{transform:translateX(0)}20%{transform:translateX(-3px)}40%{transform:translateX(3px)}60%{transform:translateX(-2px)}80%{transform:translateX(2px)}}
@keyframes dShakeMed{0%,100%{transform:translateX(0)}15%{transform:translateX(-5px)}30%{transform:translateX(5px)}45%{transform:translateX(-4px)}60%{transform:translateX(4px)}}
.dfx.flash-ultra{animation:dFlashUltra .18s ease-in-out,dShakeUltra .18s linear}
.dfx.flash-low{animation:dFlashLow .26s ease-in-out,dShakeLow .26s linear}
.dfx.flash-med{animation:dFlashMed .34s ease-in-out,dShakeMed .34s linear}`;
    document.head.appendChild(s);
  }

  // Find the visible D button (label "D" or "Double")
  function isD(el){
    if (!el) return false;
    const label = (el.textContent || el.getAttribute('aria-label') || el.title || '').trim().toUpperCase();
    const data  = ((el.dataset && (el.dataset.shot || el.dataset.kind || '')) || '').toUpperCase();
    const isBtn = /^(BUTTON|A)$/i.test(el.tagName) || el.hasAttribute('role');
    return isBtn && (label === 'D' || data === 'D' || /DOUBLE/.test(label+data));
  }
  function findD(){ return Array.from(document.querySelectorAll('button,.btn,a,[role="button"]')).find(el => isD(el) && el.offsetParent); }

  // Press-order only for D (independent of T/S)
  let dCount = 0;

  function animate(el){
    el.classList.add('dfx');
    el.classList.remove('flash-ultra','flash-low','flash-med');
    void el.offsetWidth; // restart
    el.classList.add(dCount===1 ? 'flash-ultra' : dCount===2 ? 'flash-low' : 'flash-med');
    setTimeout(()=> el.classList.remove('flash-ultra','flash-low','flash-med'), 600);
  }

  function onPressD(){
    const el = findD(); if (!el) return;
    dCount = (dCount % 3) + 1;   // 1 (ultra-low) â†’ 2 (low) â†’ 3 (medium)
    animate(el);
  }

  // Wire clicks only on D; keyboard 'd' also triggers it
  function wire(){
    const btn = findD(); if (!btn || btn.dataset.dFxWired==='1') return;
    btn.dataset.dFxWired = '1';
    btn.addEventListener('click', onPressD);
  }
  document.addEventListener('keydown', e => { if ((e.key||'').toLowerCase() === 'd') onPressD(); });

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', wire); else wire();
  try { window.__sqUIMutationBus?.on(()=>wire()); } catch(_) {}
})();

// === S button flash + shake â€” v1 (1â†’2â†’3: Ultra-ultra low â†’ Ultra low â†’ Low)
(function sButtonFX(){
  // CSS for S
  if (!document.getElementById('sfx-css')) {
    const s = document.createElement('style'); s.id = 'sfx-css';
    s.textContent =
`.sfx{will-change:transform,filter}
@keyframes sFlashXXL{0%{filter:brightness(1);box-shadow:none}
  18%{filter:brightness(1.12);box-shadow:0 0 4px rgba(255,255,255,.25),0 0 8px rgba(77,163,255,.15)}
  100%{filter:brightness(1);box-shadow:none}}
@keyframes sFlashUltra{0%{filter:brightness(1);box-shadow:none}
  16%{filter:brightness(1.25);box-shadow:0 0 6px rgba(255,255,255,.35),0 0 12px rgba(77,163,255,.20)}
  100%{filter:brightness(1);box-shadow:none}}
@keyframes sFlashLow{0%{filter:brightness(1);box-shadow:none}
  14%{filter:brightness(1.4);box-shadow:0 0 9px rgba(255,255,255,.45),0 0 16px rgba(77,163,255,.25)}
  100%{filter:brightness(1);box-shadow:none}}
@keyframes sShakeXXL{0%,100%{transform:translateX(0)}
  50%{transform:translateX(.4px)}}
@keyframes sShakeUltra{0%,100%{transform:translateX(0)}
  25%{transform:translateX(-.8px)}75%{transform:translateX(.8px)}}
@keyframes sShakeLow{0%,100%{transform:translateX(0)}
  20%{transform:translateX(-2px)}40%{transform:translateX(2px)}}
.sfx.flash-xxl{animation:sFlashXXL .16s ease-in-out, sShakeXXL .16s linear}
.sfx.flash-ultra{animation:sFlashUltra .20s ease-in-out, sShakeUltra .20s linear}
.sfx.flash-low{animation:sFlashLow .26s ease-in-out, sShakeLow .26s linear}`;
    document.head.appendChild(s);
  }

  // Find the visible S button (label "S" or "Single")
  function isS(el){
    if (!el) return false;
    const label = (el.textContent || el.getAttribute('aria-label') || el.title || '').trim().toUpperCase();
    const data  = ((el.dataset && (el.dataset.shot || el.dataset.kind || '')) || '').toUpperCase();
    const isBtn = /^(BUTTON|A)$/i.test(el.tagName) || el.hasAttribute('role');
    return isBtn && (label === 'S' || /SINGLE/.test(label+data) || data === 'S');
  }
  function findS(){
    return Array.from(document.querySelectorAll('button,.btn,a,[role="button"]'))
      .find(el => isS(el) && el.offsetParent);
  }

  // Press-order only for S (independent of T/D)
  let sCount = 0;

  function animate(el){
    el.classList.add('sfx');
    el.classList.remove('flash-xxl','flash-ultra','flash-low');
    void el.offsetWidth; // restart
    el.classList.add(sCount===1 ? 'flash-xxl' : sCount===2 ? 'flash-ultra' : 'flash-low');
    setTimeout(()=> el.classList.remove('flash-xxl','flash-ultra','flash-low'), 500);
  }

  function onPressS(){
    const el = findS(); if (!el) return;
    sCount = (sCount % 3) + 1;   // 1 (XXL) â†’ 2 (Ultra) â†’ 3 (Low)
    animate(el);
  }

  // Wire clicks on S; keyboard 's' also triggers it
  function wire(){
    const btn = findS(); if (!btn || btn.dataset.sFxWired==='1') return;
    btn.dataset.sFxWired = '1';
    btn.addEventListener('click', onPressS);
  }
  document.addEventListener('keydown', e => { if ((e.key||'').toLowerCase() === 's') onPressS(); });

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', wire); else wire();
  try { window.__sqUIMutationBus?.on(()=>wire()); } catch(_) {}
})();

// === MISS button â€” red glow (1â†’2â†’3: soft â†’ medium â†’ high) ==================
(function missButtonFX(){
  // CSS for MISS
  if (!document.getElementById('mfx-css')) {
    const s = document.createElement('style'); s.id = 'mfx-css';
    s.textContent =
    ` .missfx{will-change:filter,box-shadow,transform,background-color}

/* existing glow tweaked to pair with bg pulse */
@keyframes mGlowSoft{
  0%{filter:brightness(1);box-shadow:none}
  20%{filter:brightness(1.15);box-shadow:0 0 10px rgba(244,63,94,.45),0 0 20px rgba(244,63,94,.25)}
  100%{filter:brightness(1);box-shadow:none}
}
@keyframes mGlowMed{
  0%{filter:brightness(1);box-shadow:none}
  18%{filter:brightness(1.35);box-shadow:0 0 16px rgba(244,63,94,.6),0 0 28px rgba(244,63,94,.35)}
  40%{filter:brightness(1.1);box-shadow:none}
  100%{filter:brightness(1);box-shadow:none}
}
@keyframes mGlowHigh{
  0%{filter:brightness(1);box-shadow:none;transform:scale(1)}
  14%{filter:brightness(1.6);box-shadow:0 0 22px rgba(244,63,94,.75),0 0 40px rgba(244,63,94,.45);transform:scale(1.02)}
  30%{filter:brightness(1.2);box-shadow:0 0 12px rgba(244,63,94,.45),0 0 26px rgba(244,63,94,.30);transform:scale(1.01)}
  100%{filter:brightness(1);box-shadow:none;transform:scale(1)}
}

/* pulse the actual red background from --miss-from to --miss-to and back */
@keyframes mBgPulse{
  0%  { background-color: var(--miss-from); }
  22% { background-color: var(--miss-to);   }
  100%{ background-color: var(--miss-from); }
}

/* combine glow + bg pulse; durations match levels */
.missfx.glow-soft{animation: mGlowSoft .26s ease-out, mBgPulse .26s ease-in-out}
.missfx.glow-med {animation: mGlowMed  .34s ease-out, mBgPulse .34s ease-in-out}
.missfx.glow-high{animation: mGlowHigh .44s ease-out, mBgPulse .44s ease-in-out}`
    
    document.head.appendChild(s);
  }

  // Find the visible MISS button (label "MISS"; allow 'X' only if marked as miss)
  function isMISS(el){
    if (!el) return false;
    const label = (el.textContent || el.getAttribute('aria-label') || el.title || '').trim();
    const up    = label.toUpperCase();
    const data  = ((el.dataset && (el.dataset.kind || el.dataset.shot || '')) || '').toLowerCase();
    const isBtn = /^(BUTTON|A)$/i.test(el.tagName) || el.hasAttribute('role');
    if (!isBtn) return false;
    if (up === 'MISS') return true;
    // Accept "X" only if metadata indicates miss
    if (up === 'X' && /miss/.test(data + ' ' + (el.getAttribute('aria-label')||'').toLowerCase())) return true;
    return /miss/.test(data);
  }
  function findMISS(){
    return Array.from(document.querySelectorAll('button,.btn,a,[role="button"]'))
      .find(el => isMISS(el) && el.offsetParent);
  }

  // Press-order only for MISS (independent)
  let mCount = 0;

  function animate(el){
    el.classList.add('missfx');
    el.classList.remove('glow-soft','glow-med','glow-high');
    void el.offsetWidth; // restart
    el.classList.add(mCount===1 ? 'glow-soft' : mCount===2 ? 'glow-med' : 'glow-high');
  }

  function onPressMISS(){
    const el = findMISS(); if (!el) return;
    mCount = (mCount % 3) + 1; // 1 soft â†’ 2 med â†’ 3 high
    animate(el);
  }

  // Wire clicks on MISS; keyboard 'm' also triggers it
  function wire(){
    const btn = findMISS(); if (!btn || btn.dataset.mFxWired==='1') return;
    btn.dataset.mFxWired = '1';
    btn.addEventListener('click', onPressMISS);
  }
  document.addEventListener('keydown', e => { if ((e.key||'').toLowerCase() === 'm') onPressMISS(); });

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', wire); else wire();
  try { window.__sqUIMutationBus?.on(()=>wire()); } catch(_) {}
})();


// === Miss x3 (spanning) â€” left of S/Miss; tall (S+Miss), half-width of S; hides on D/T ===
(function missX3_spanning(){
  const BTN_ID = 'missX3_spanning_btn';

  // Find S / Miss buttons
  function findBtnByLabel(rx){
    return Array.from(document.querySelectorAll('button,.btn,[role="button"],a'))
      .find(el => el.offsetParent && rx.test((el.textContent || el.getAttribute('aria-label') || '').trim()));
  }
  function findS(){  return findBtnByLabel(/^\s*S\s*$/i); }
  function findMiss(){ return findBtnByLabel(/^\s*Miss\s*$/i); }

  // Doubles/Triples sector chooser visible?
  function chooserVisible(){
    return Array.from(document.querySelectorAll('div,section'))
      .some(el => el.offsetParent && /\b(Doubles|Triples)\s+round\s*â€”?\s*choose\s*sector\b/i.test(el.textContent || ''));
  }

  // Nearest common ancestor
  function nca(a,b){
    if (!a || !b) return null;
    const path = new Set();
    let p=a; while(p){ path.add(p); p=p.parentElement; }
    p=b; while(p){ if(path.has(p)) return p; p=p.parentElement; }
    return null;
  }

  // How many misses should be auto-logged given the current dart (3 â†’ 2 â†’ 1)
  function missCountForCurrentThrow(){
    try{
      const dart = (typeof state !== 'undefined' && state && typeof state.currentDart === 'number') ? state.currentDart : 0;
      const remaining = 3 - dart;
      return Math.max(1, Math.min(3, remaining));
    }catch(_){
      return 3;
    }
  }

  async function clickMissThrice(miss){
    const count = missCountForCurrentThrow();
    for (let i=0;i<count;i++){
      try{
        ['mousedown','mouseup','click'].forEach(t => miss.dispatchEvent(new MouseEvent(t,{bubbles:true,cancelable:true})));
      }catch(_){ miss.click(); }
      // small gap so your game logic records three throws
      // eslint-disable-next-line no-await-in-loop
      await new Promise(r=>setTimeout(r,70));
    }
  }

  function ensure(){
    const s = findS();
    const miss = findMiss();
    const wrap = nca(s, miss);
    let x3 = document.getElementById(BTN_ID);

    // If we cannot find S/Miss yet, just hide/remove the button
    if (!s || !miss || !wrap){
      if (x3){
        x3.style.display = 'none';
        if (x3.parentElement) x3.parentElement.style.paddingLeft = '';
      }
      return;
    }

    // Create once
    if (!x3){
      x3 = document.createElement((miss.tagName || 'button').toLowerCase());
      x3.id = BTN_ID;
      x3.type = 'button';
      x3.className = miss.className || 'btn';
      x3.textContent = `Miss\nx${missCountForCurrentThrow()}`;
      x3.style.whiteSpace = 'pre-line';
      x3.style.textAlign  = 'center';
      x3.style.display    = 'inline-flex';
      x3.style.alignItems = 'center';
      x3.style.justifyContent = 'center';
      x3.style.position   = 'absolute';
      x3.style.left       = '8px';          // small gutter
      x3.style.zIndex     = '4';

      x3.addEventListener('click', (e)=>{ e.preventDefault(); clickMissThrice(miss); });

      // Insert into the shared container and reserve space by padding-left
      if (getComputedStyle(wrap).position === 'static') wrap.style.position = 'relative';
      wrap.insertAdjacentElement('afterbegin', x3);
    }

    // Size and position: tall (S+Miss), half width of S; aligned to S's top
    const wr = wrap.getBoundingClientRect();
    const sr = s.getBoundingClientRect();
    const mr = miss.getBoundingClientRect();

    const topPx    = Math.round(sr.top - wr.top);
    const heightPx = Math.max(44, Math.round((mr.bottom - sr.top))); // S+gap+Miss
    const widthPx  = Math.max(64, Math.round(sr.width / 2));

    x3.style.top    = `${topPx}px`;
    x3.style.width  = `${widthPx}px`;
    x3.style.minWidth = `${widthPx}px`;
    x3.style.height = `${heightPx}px`;
    x3.style.minHeight = `${heightPx}px`;

    // Update label based on how many misses we will apply (3 â†’ 2 â†’ 1)
    const missCount = missCountForCurrentThrow();
    const nextLabel = `Miss\nx${missCount}`;
    if (x3.textContent !== nextLabel) x3.textContent = nextLabel;

    // Push the button rows to the right so x3 doesnâ€™t overlap
    const padLeft = widthPx + 16; // leave a small gutter
    const hideNow = chooserVisible();
    wrap.style.paddingLeft = hideNow ? '' : `${padLeft}px`;

    // Hide during Doubles/Triples chooser
    x3.style.display = hideNow ? 'none' : 'inline-flex';
  }

  function boot(){
    // Remove any old leftover element (from older attempts)
    document.getElementById(BTN_ID)?.remove();

    const tick = ()=>{ try{ ensure(); }catch(e){ /* no-op */ } };
    tick();
    // React to layout changes and window resizes
    try { window.__sqUIMutationBus?.on(()=>tick()); } catch(_) {}
    window.addEventListener('resize', tick, { passive:true });
    document.addEventListener('visibilitychange', tick, { passive:true });
  }

  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', boot); } else { boot(); }
})();


// === In-game minis ( (xx) ) â€” strip green boxes; only highest is green ======
(function strictBracketWinner(){
  const GREEN = '#6ee7b7';
  const MUTED = 'rgba(255,255,255,.6)';
  const RX = /^\(\d{1,3}\)$/; // "(30)", "(99)", etc.

  function isMini(el){
    if (!el || !el.offsetParent) return false;
    const t = (el.textContent || '').trim();
    return RX.test(t);
  }

  // remove any .tag styling that makes them boxed/green
  function sanitize(el){
    // If the mini or its parent uses .tag for the bracket, strip it
    const nodes = [el, el.parentElement];
    for (const n of nodes){
      if (!n) continue;
      if (n.classList && n.classList.contains('tag') && RX.test((n.textContent||'').trim())){
        n.classList.remove('tag');
        // clear visual remnants
        n.style.removeProperty('background');
        n.style.removeProperty('border');
        n.style.removeProperty('borderColor');
        n.style.removeProperty('color');
        n.style.removeProperty('box-shadow');
      }
    }
  }

  // find minis within a row-like container
  function findRowMinis(row){
    // pick visible nodes that look like a mini
    const cand = Array.from(row.querySelectorAll('small,span,strong,div'));
    const minis = cand.filter(isMini);
    if (minis.length < 2) return [];

    // sort by x, then take the left-most and right-most (the two player columns)
    minis.sort((a,b)=>a.getBoundingClientRect().left - b.getBoundingClientRect().left);
    return [minis[0], minis[minis.length-1]];
  }

  function valueOf(el){
    return parseInt((el.textContent||'').replace(/[^\d]/g,''), 10) || 0;
  }

  function paintRow(miniL, miniR){
    if (!miniL || !miniR) return;
    sanitize(miniL); sanitize(miniR);

    const vL = valueOf(miniL);
    const vR = valueOf(miniR);

    if (vL > vR){
      miniL.style.color = GREEN;
      miniR.style.color = MUTED;
    } else if (vR > vL){
      miniL.style.color = MUTED;
      miniR.style.color = GREEN;
    } else {
      // tie -> neither green
      miniL.style.color = MUTED;
      miniR.style.color = MUTED;
    }
  }

  function apply(root){
    // Try table rows first
    const rows = Array.from(root.querySelectorAll('table tr,[role="row"]'))
      .filter(r => r.offsetParent);
    let touched = 0;
    rows.forEach(r=>{
      const [a,b] = findRowMinis(r);
      if (a && b){ paintRow(a,b); touched++; }
    });

    // Fallback: scan visible sections that look like round rows
    if (!touched){
      const sections = Array.from(root.querySelectorAll('section,div,li'))
        .filter(s => s.offsetParent);
      sections.forEach(s=>{
        const [a,b] = findRowMinis(s);
        if (a && b) paintRow(a,b);
      });
    }
  }

  function run(){ apply(document.body || document); }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }

  // Re-apply whenever the board updates (via shared UI mutation bus)
  try { window.__sqUIMutationBus?.on(()=>{ try { run(); } catch(_){/* ignore */} }); } catch(_){}
})();

// === Top Nav (Start / Restart / Stats) â€” equal widths across full row =======
(function equalizeTopNav_v1(){
  // 1) CSS (scoped)
  if (!document.getElementById('topNavEqStyles')){
    const s = document.createElement('style');
    s.id = 'topNavEqStyles';
    s.textContent =
`.top-nav-eq{display:flex;gap:12px;width:100%;align-items:stretch;justify-content:space-between;flex-wrap:nowrap}
.top-nav-eq > *{flex:1 1 0;min-width:0}
.top-nav-eq > *:is(button,.btn,[role="button"],a){display:block;width:100%;text-align:center}`;
    document.head.appendChild(s);
  }

  // 2) Find the three buttons by their labels (keeps existing handlers intact)
  const LABELS = [/^\s*start\s*screen\s*$/i, /^\s*restart\s*game\s*$/i, /^\s*stats\s*$/i];
  function findButtons(){
    const all = Array.from(document.querySelectorAll('button,.btn,[role="button"],a'));
    return LABELS.map(rx => all.find(el => rx.test((el.textContent||'').trim()) && el.offsetParent));
  }

  // 3) Find nearest common ancestor of the three buttons
  function nearestCommonAncestor(els){
    if (els.some(e=>!e)) return null;
    const paths = els.map(el=>{
      const p=[]; let n=el;
      while(n){ p.push(n); n=n.parentElement; }
      return p;
    });
    for (const a of paths[0]){
      if (paths[1].includes(a) && paths[2].includes(a)) return a;
    }
    return null;
  }

  function apply(){
    const btns = findButtons();
    if (btns.some(b=>!b)) return; // not on this screen yet
    const root = nearestCommonAncestor(btns);
    if (!root) return;

    // Avoid double-applying
    if (!root.classList.contains('top-nav-eq')) {
      root.classList.add('top-nav-eq');
      // Make sure the row actually spans the page width
      root.style.maxWidth = 'unset';
      root.style.width    = '100%';
    }
  }

  // Run now + when DOM changes (in case the header re-renders)
  function run(){ try{ apply(); }catch(e){ console.warn('TopNav equalize failed', e); } }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', run); else run();
  try { window.__sqUIMutationBus?.on(()=>run()); } catch(_) {}
})();






// >>> PATCH:data-admin START
(function(){
  const DAY_MS = 24*60*60*1000;

  // ---- Supabase analytics tables ----
  // This code expects (or you should create) the following table in Supabase:
  //   app_logons(day date not null, device_id text not null, created_at timestamptz default now(),
  //             primary key (day, device_id))
  // And (recommended) players table has either created_at or joined_at timestamptz.

  // NOTE: we keep a local fallback for offline/dev, but the source of truth is cloud.

  function isoDay(d){
    const dt = new Date(d);
    const y = dt.getFullYear();
    const m = String(dt.getMonth()+1).padStart(2,'0');
    const da = String(dt.getDate()).padStart(2,'0');
    return y + '-' + m + '-' + da;
  }

  function isoNow(){
    return new Date().toISOString();
  }

  function getSb(){
    // Supports both window.sb and a local sb binding if present.
    try { if (window.sb) return window.sb; } catch(e){}
    try { if (typeof sb !== 'undefined') return sb; } catch(e){}
    return null;
  }

  // Table name constant (safe if you already defined it elsewhere)
  try {
    if (typeof TABLE_APP_LOGONS === 'undefined') {
      // eslint-disable-next-line no-var
      var TABLE_APP_LOGONS = 'app_logons';
    }
  } catch(e){}

  function getDeviceId(){
    try {
      let id = localStorage.getItem('sq_device_id');
      if (!id) {
        id = (window.crypto && crypto.randomUUID) ? crypto.randomUUID() : ('dev_' + Math.random().toString(16).slice(2) + Date.now());
        localStorage.setItem('sq_device_id', id);
      }
      return id;
    } catch(e){
      return 'anon';
    }
  }

  // ---- Cloud logon tracking (device/day) ----
  async function logDailyVisitToCloud(){
    const client = getSb();
    if (!client) return;

    // If cloud logons are blocked by RLS/policies, stop spamming the console.
    try {
      if (localStorage.getItem('sq_cloud_logons_disabled') === '1') return;
    } catch(_){}

    const day = isoDay(new Date());
    const device_id = getDeviceId();

    // Upsert once per device per day.
    try {
      const { error } = await client
        .from(TABLE_APP_LOGONS)
        .upsert({ day, device_id }, { onConflict: 'day,device_id' });

      if (error) {
        // Common: 42501 insufficient_privilege, 401/403 auth/policy issues
        const code = (error && (error.code || error.status)) || '';
        if (String(code) === '42501' || String(code) === '401' || String(code) === '403') {
          try { localStorage.setItem('sq_cloud_logons_disabled', '1'); } catch(_){}
          console.warn('Cloud logons disabled (policy/privilege). Using local-only.');
          return;
        }
        console.warn('Cloud logon upsert failed', error);
      }
    } catch(e){
      console.warn('Cloud logon upsert exception', e);
    }
  }

  // ---- Local fallback logon tracking (kept for offline/dev) ----
  function logDailyVisitLocal(){
    try {
      const key = 'sq_daily_logons';
      const raw = JSON.parse(localStorage.getItem(key) || '{}');
      const day = isoDay(new Date());
      const did = getDeviceId();
      raw[day] = raw[day] || {};
      raw[day][did] = true;
      localStorage.setItem(key, JSON.stringify(raw));
    } catch(e){}
  }

  // Log on page load
  try { logDailyVisitLocal(); } catch(_){ }
  try { logDailyVisitToCloud(); } catch(_){ }

  // ---- Saved players stats ----
  function getSavedPlayersSafe(){
    try {
      if (typeof getSavedPlayers === 'function') return getSavedPlayers() || [];
    } catch(e){}
    try {
      return JSON.parse(localStorage.getItem('shateki_players') || '[]');
    } catch(e){
      return [];
    }
  }

  function countNewPlayersLocal(days){
    const arr = getSavedPlayersSafe();
    const cutoff = Date.now() - (days * DAY_MS);
    let c = 0;
    for (const p of arr){
      if (!p) continue;
      const t = Date.parse(p.joinedAt || p.createdAt || p.created_at || '');
      if (Number.isFinite(t) && t >= cutoff) c++;
    }
    return c;
  }

  async function fetchPlayersStatsCloud(days){
    const client = getSb();
    if (!client) return null;

    // Total players (count)
    let total = null;
    try {
      const { count, error } = await client
        .from(TABLE_PLAYERS)
        .select('name', { count: 'exact', head: true });
      if (!error && typeof count === 'number') total = count;
    } catch(e){ }

    // New players count: derive locally to avoid relying on optional timestamp columns (joined_at/created_at).
    // (Those columns are not guaranteed in your current schema and cause noisy 400s in the console.)
    const newN = null;

    // If either failed, return what we have (caller can fall back locally)
    return { total, newN };
  }

  function openModal(id){
    const el = document.getElementById(id);
    if (el) el.classList.remove('hidden');
  }
  function closeModal(id){
    const el = document.getElementById(id);
    if (el) el.classList.add('hidden');
  }

  // ---- Daily games series (cloud; existing) ----
  async function getDailyGamesSeries(daysBack){
    daysBack = daysBack || 30;
    const labels = [];
    const counts = [];
    const today = new Date();
    for (let i=daysBack-1; i>=0; i--){
      const d = new Date(today.getTime() - i*DAY_MS);
      labels.push(isoDay(d));
      counts.push(0);
    }

    const client = getSb();
    if (!client) return { labels, counts };

    const from = labels[0];

    // Pull only what's needed; aggregate client-side
    try {
      const { data, error } = await client
        .from(TABLE_GAMES)
        .select('created_at, ts')
        .gte('created_at', from + 'T00:00:00Z')
        .order('created_at', { ascending: true });

      if (error) throw error;
      const idxByDay = new Map(labels.map((d,i)=>[d,i]));
      for (const row of (data||[])){
        const t = row.created_at || row.ts;
        if (!t) continue;
        const day = isoDay(t);
        const idx = idxByDay.get(day);
        if (idx == null) continue;
        counts[idx] = (counts[idx]||0) + 1;
      }
    } catch(e){
      // If created_at filter failed (older schema), try ts only
      try {
        const { data } = await client
          .from(TABLE_GAMES)
          .select('ts')
          .order('ts', { ascending: true });
        const idxByDay = new Map(labels.map((d,i)=>[d,i]));
        for (const row of (data||[])){
          const t = row.ts;
          if (!t) continue;
          const day = isoDay(t);
          const idx = idxByDay.get(day);
          if (idx == null) continue;
          counts[idx] = (counts[idx]||0) + 1;
        }
      } catch(_){ }
    }

    return { labels, counts };
  }

  // ---- Unique logons series (cloud) ----
  async function getUniqueLogonsSeriesCloud(daysBack){
    daysBack = daysBack || 30;
    const labels = [];
    const counts = [];
    const today = new Date();
    for (let i=daysBack-1; i>=0; i--){
      const d = new Date(today.getTime() - i*DAY_MS);
      labels.push(isoDay(d));
      counts.push(0);
    }

    const client = getSb();
    if (!client) return { labels, counts };

    const from = labels[0];

    try {
      const { data, error } = await client
        .from(TABLE_APP_LOGONS)
        .select('day, device_id')
        .gte('day', from)
        .order('day', { ascending: true });
      if (error) throw error;

      // Aggregate distinct device_id per day client-side
      const setByDay = new Map(labels.map(d=>[d, new Set()]));
      for (const row of (data||[])){
        const day = row.day;
        const did = row.device_id;
        if (!day || !did) continue;
        const s = setByDay.get(day);
        if (s) s.add(did);
      }
      for (let i=0;i<labels.length;i++){
        counts[i] = setByDay.get(labels[i]).size;
      }
    } catch(e){
      console.warn('Unique logons cloud fetch failed', e);
    }

    return { labels, counts };
  }

  // ---- Unique logons fallback (local) ----
  function getUniqueLogonsSeriesLocal(daysBack){
    daysBack = daysBack || 30;
    const labels = [];
    const counts = [];
    const today = new Date();
    for (let i=daysBack-1; i>=0; i--){
      const d = new Date(today.getTime() - i*DAY_MS);
      labels.push(isoDay(d));
      counts.push(0);
    }

    try {
      const raw = JSON.parse(localStorage.getItem('sq_daily_logons') || '{}');
      const idxByDay = new Map(labels.map((d,i)=>[d,i]));
      for (const day in raw){
        const idx = idxByDay.get(day);
        if (idx == null) continue;
        counts[idx] = Object.keys(raw[day] || {}).length;
      }
    } catch(e){}

    return { labels, counts };
  }

  function drawBarChart(canvas, labels, values){
    const existingChart = Chart.getChart(canvas);
    if (existingChart) existingChart.destroy();

    new Chart(canvas, {
      type: 'bar',
      data: {
        labels: labels.map(lab => lab.includes('-') ? lab.slice(5) : lab),
        datasets: [{
          data: values,
          backgroundColor: 'rgba(255, 255, 255, 0.2)',
          borderColor: 'rgba(255, 255, 255, 0.5)',
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            grid: { display: false },
            ticks: { color: 'rgba(255, 255, 255, 0.5)', maxRotation: 0, autoSkip: true, maxTicksLimit: 6 }
          },
          y: {
            beginAtZero: true,
            grid: { color: 'rgba(255, 255, 255, 0.1)' },
            ticks: { color: 'rgba(255, 255, 255, 0.5)' }
          }
        },
        plugins: {
          legend: { display: false }
        }
      }
    });
  }

  function bind(){
    const openBtn = document.getElementById('openDataAdminBtn');
    const back = document.getElementById('dataAdminBackBtn');
    const close = document.getElementById('dataAdminCloseBtn');
    const chartBack = document.getElementById('dataChartBackBtn');
    const chartClose= document.getElementById('dataChartCloseBtn');

    async function refreshData(){
      const elTotal = document.getElementById('dataPlayersCount');
      const elNew7  = document.getElementById('dataNewPlayers7');

      // local fallback
      let totalLocal = 0;
      try { totalLocal = getSavedPlayersSafe().length; } catch(e){}
      let new7Local = 0;
      try { new7Local = countNewPlayersLocal(7); } catch(e){}

      // cloud preferred
      let total = null;
      let new7  = null;
      try {
        const cloud = await fetchPlayersStatsCloud(7);
        if (cloud) {
          total = cloud.total;
          new7  = cloud.newN;
        }
      } catch(e){}

      const finalTotal = (typeof total === 'number') ? total : totalLocal;
      const finalNew7  = (typeof new7  === 'number') ? new7  : new7Local;

      if (elTotal) elTotal.textContent = 'Number of saved players ' + finalTotal;
      if (elNew7)  elNew7.textContent  = 'New saved players (past 7 days) ' + finalNew7;
    }

    if (openBtn){
      openBtn.onclick = async () => {
        closeModal('adminHubModal');
        await refreshData();
        openModal('dataAdminModal');
      };
    }

    if (back) back.onclick = () => { closeModal('dataAdminModal'); openModal('adminHubModal'); };
    if (close) close.onclick = () => { closeModal('dataAdminModal'); };
    if (chartBack) chartBack.onclick = () => { closeModal('dataChartModal'); openModal('dataAdminModal'); };
    if (chartClose) chartClose.onclick = () => { closeModal('dataChartModal'); };

    const dailyBtn = document.getElementById('dataDailyGamesBtn');
    const logonsBtn= document.getElementById('dataUniqueLogonsBtn');

    let currentKind = null;
    let currentRange = 'daily';

    function setRangeActive(range){
      currentRange = range;
      const map = {
        daily: document.getElementById('dataChartRangeDaily'),
        weekly: document.getElementById('dataChartRangeWeekly'),
        monthly: document.getElementById('dataChartRangeMonthly'),
        yearly: document.getElementById('dataChartRangeYearly'),
      };
      Object.entries(map).forEach(([k, el]) => {
        if (!el) return;
        el.classList.toggle('active', k === range);
      });
    }

    function formatMonthLabel(key){
      // key: YYYY-MM
      const y = key.slice(0,4);
      const m = parseInt(key.slice(5,7), 10);
      const names = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      return (names[m-1] || key) + ' ' + y.slice(2);
    }

    function aggregateSeries(labels, counts, mode){
      const out = new Map();
      for (let i=0;i<labels.length;i++){
        const lab = labels[i];
        const v = Number(counts[i]||0);
        let key = lab;
        if (mode === 'weekly'){
          const d = new Date(lab + 'T00:00:00Z');
          const day = d.getUTCDay(); // 0=Sun
          const offset = (day + 6) % 7; // days since Mon
          d.setUTCDate(d.getUTCDate() - offset);
          key = d.toISOString().slice(0,20); // week start
        } else if (mode === 'monthly'){
          key = lab.slice(0,7);
        } else if (mode === 'yearly'){
          key = lab.slice(0,4);
        }
        out.set(key, (out.get(key)||0) + v);
      }
      const keys = Array.from(out.keys()).sort();
      const outLabels = keys.map(k => {
        if (mode === 'weekly') return 'Wk ' + k.slice(5); // MM-DD
        if (mode === 'monthly') return formatMonthLabel(k);
        if (mode === 'yearly') return k;
        return k;
      });
      const outCounts = keys.map(k => out.get(k)||0);
      return { labels: outLabels, counts: outCounts };
    }

    async function getSeriesFor(kind, range){
      // Fetch enough daily data, then aggregate client-side.
      if (range === 'daily'){
        if (kind === 'games') return await getDailyGamesSeries(30);
        const s = await getUniqueLogonsSeriesCloud(30);
        const any = (s.counts || []).some(v => (v||0) > 0);
        return any ? s : getUniqueLogonsSeriesLocal(30);
      }

      if (range === 'weekly'){
        const days = 84; // 12 weeks
        const raw = (kind === 'games') ? await getDailyGamesSeries(days) : await getUniqueLogonsSeriesCloud(days);
        const any = (raw.counts || []).some(v => (v||0) > 0);
        const base = (kind === 'logons' && !any) ? getUniqueLogonsSeriesLocal(days) : raw;
        return aggregateSeries(base.labels, base.counts, 'weekly');
      }

      if (range === 'monthly'){
        const days = 365; // 12 months-ish
        const raw = (kind === 'games') ? await getDailyGamesSeries(days) : await getUniqueLogonsSeriesCloud(days);
        const any = (raw.counts || []).some(v => (v||0) > 0);
        const base = (kind === 'logons' && !any) ? getUniqueLogonsSeriesLocal(days) : raw;
        return aggregateSeries(base.labels, base.counts, 'monthly');
      }

      // yearly
      const days = 365 * 5;
      const raw = (kind === 'games') ? await getDailyGamesSeries(days) : await getUniqueLogonsSeriesCloud(days);
      const any = (raw.counts || []).some(v => (v||0) > 0);
      const base = (kind === 'logons' && !any) ? getUniqueLogonsSeriesLocal(days) : raw;
      return aggregateSeries(base.labels, base.counts, 'yearly');
    }

    async function renderChart(){
      const title = document.getElementById('dataChartTitle');
      const hint  = document.getElementById('dataChartHint');
      const canvas= document.getElementById('dataChartCanvas');
      if (!canvas || !canvas.getContext) {
        if (typeof toast === 'function') toast('Canvas not supported');
        return;
      }

      const k = currentKind;
      const r = currentRange;

      if (k === 'games'){
        if (title) title.textContent = (r[0].toUpperCase()+r.slice(1)) + ' Games';
      } else {
        if (title) title.textContent = (r[0].toUpperCase()+r.slice(1)) + ' Unique Log Ons';
      }

      if (hint){
        const x = (r === 'daily') ? 'Date' : (r === 'weekly') ? 'Week' : (r === 'monthly') ? 'Month' : 'Year';
        const y = (k === 'games') ? 'Games played' : 'Unique device log ons';
        hint.textContent = 'Horizontal: ' + x + ', Vertical: ' + y;
      }

      const series = await getSeriesFor(k, r);
      drawBarChart(canvas, series.labels, series.counts);
    }

    async function openChart(kind){
      currentKind = (kind === 'games') ? 'games' : 'logons';
      setRangeActive('daily');
      await renderChart();
      closeModal('dataAdminModal');
      openModal('dataChartModal');
    }

    const bDaily = document.getElementById('dataChartRangeDaily');
    const bWeekly = document.getElementById('dataChartRangeWeekly');
    const bMonthly = document.getElementById('dataChartRangeMonthly');
    const bYearly = document.getElementById('dataChartRangeYearly');

    function hookRange(btn, range){
      if (!btn) return;
      btn.onclick = async () => {
        if (!currentKind) return;
        setRangeActive(range);
        await renderChart();
      };
    }
    hookRange(bDaily, 'daily');
    hookRange(bWeekly, 'weekly');
    hookRange(bMonthly, 'monthly');
    hookRange(bYearly, 'yearly');

    if (dailyBtn) dailyBtn.onclick = () => { openChart('games'); };
    if (logonsBtn) logonsBtn.onclick = () => { openChart('logons'); };

    // If you add a saved player, refresh the stats when returning to DATA.
    document.addEventListener('sq:savedPlayersUpdated', () => {
      try { refreshData(); } catch(e){}
    });
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind);
  else bind();
})();
// >>> PATCH:data-admin END


// >>> PATCH:player_stats_spider_progress START
(function(){
  function safeLower(s){return String(s||'').trim().toLowerCase();}
  function isoWeekStart(d){
    const x = (d instanceof Date) ? new Date(d) : new Date(d);
    if (Number.isNaN(x.getTime())) return null;
    // Monday start
    const day = (x.getDay()+6)%7; // Mon=0
    x.setHours(0,0,0,0);
    x.setDate(x.getDate()-day);
    return x;
  }

  function drawRadar(canvas, labels, valuesPct){
    const existingChart = Chart.getChart(canvas);
    if (existingChart) existingChart.destroy();

    new Chart(canvas, {
      type: 'radar',
      data: {
        labels: labels,
        datasets: [{
          data: valuesPct,
          backgroundColor: 'rgba(34, 197, 94, 0.2)',
          borderColor: 'rgba(34, 197, 94, 1)',
          borderWidth: 2,
          pointBackgroundColor: 'rgba(34, 197, 94, 1)',
        }]
      },
      options: {
        responsive: true,
        scales: {
          r: {
            angleLines: { color: 'rgba(255, 255, 255, 0.2)' },
            grid: { color: 'rgba(255, 255, 255, 0.2)' },
            pointLabels: { color: 'rgba(255, 255, 255, 0.8)', font: { size: 11 } },
            ticks: { display: false, stepSize: 20 },
            suggestedMin: 0,
            suggestedMax: 100
          }
        },
        plugins: {
          legend: { display: false }
        }
      }
    });
  }

  function drawMultiLine(canvas, xLabels, seriesMap){
    const existingChart = Chart.getChart(canvas);
    if (existingChart) existingChart.destroy();

    const keys = Object.keys(seriesMap||{});
    const palette = ['#34d399','#60a5fa','#f472b6','#fbbf24','#a78bfa','#fb7185','#22d3ee','#c084fc','#86efac','#fde047','#93c5fd','#fda4af','#fca5a5','#67e8f9'];

    const datasets = keys.map((k, idx) => ({
      label: k,
      data: seriesMap[k],
      borderColor: palette[idx % palette.length],
      borderWidth: (idx === 0 ? 3 : 2),
      tension: 0.1,
      pointRadius: 0
    }));

    new Chart(canvas, {
      type: 'line',
      data: {
        labels: xLabels,
        datasets: datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            grid: { display: false },
            ticks: { color: 'rgba(255, 255, 255, 0.5)', maxRotation: 0, autoSkip: true, maxTicksLimit: 6 }
          },
          y: {
            min: 0,
            max: 100,
            grid: { color: 'rgba(255, 255, 255, 0.1)' },
            ticks: { color: 'rgba(255, 255, 255, 0.5)' }
          }
        },
        plugins: {
          legend: { display: false }
        }
      }
    });
  }

  async function fetchPlayerThrowsWithTs(playerName){
    const name = String(playerName||'').trim();
    const nameLC = safeLower(name);

    // --- Preferred: Supabase canonical view (one row per throw) ---
    // Columns (confirmed): match_id, game_number, created_at, player_index, player_name,
    // round_number, target, ring, hit
    // NOTE: This view is read-only; ideal for analytics.
    try{
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) throw new Error('Cloud not initialised');
      if (!sb) throw new Error('Supabase client missing');

      const VIEW = 'throw_events_v';

      const selectCols = 'created_at,player_name,round_number,target,ring,hit';
      const rows = [];
      const PAGE = 1000;
      const MAX = 50000;

      for (let from = 0; from < MAX; from += PAGE){
        const to = from + PAGE - 1;
        const { data, error } = await sb
          .from(VIEW)
          .select(selectCols)
          .ilike('player_name', `%${name}%`)
          .order('created_at', { ascending: true })
          .range(from, to);
        if (error) throw error;
        if (Array.isArray(data) && data.length) rows.push(...data);
        if (!Array.isArray(data) || data.length < PAGE) break;
      }

      // Map view row -> internal throw row used by SPIDER/PROGRESS
      const mapped = (rows||[]).map(r => {
        const rn = Number(r.round_number);
        let round_index = null;

        // Robust mapping: different schemas encode rounds differently.
        // Supported encodings:
        //  A) round_number = 10..20 (numbers), 21 (Doubles), 22 (Triples), 23 (Bull)
        //  B) round_number = 1..11 (maps to 10..20), 12 (Doubles), 13 (Triples), 14 (Bull)
        //  C) round_number = 0..13 (direct index)

        if (Number.isFinite(rn)) {
          // C) direct index
          if (rn >= 0 && rn <= 13) {
            round_index = rn;
          }
          // B) 1..11 -> 10..20, then 12/13/14
          else if (rn >= 1 && rn <= 11) {
            round_index = rn - 1;
          } else if (rn === 12) {
            round_index = 11;
          } else if (rn === 13) {
            round_index = 12;
          } else if (rn === 14) {
            round_index = 13;
          }
          // A) 10..20, 21/22/23
          else if (rn >= 10 && rn <= 20) {
            round_index = rn - 10;
          } else if (rn === 21) {
            round_index = 11;
          } else if (rn === 22) {
            round_index = 12;
          } else if (rn === 23) {
            round_index = 13;
          }
        }

        // Last-resort fallback: infer from target/ring
        if (round_index == null) {
          const ring = String(r.ring || '').trim().toUpperCase();
          const target = Number(r.target);
          if (Number.isFinite(target) && target >= 10 && target <= 20) round_index = target - 10;
          else if (ring === 'D') round_index = 11;
          else if (ring === 'T') round_index = 12;
          else if (ring === 'B') round_index = 13;
        }

        const ts = r.created_at || null;
        const hit = !!r.hit;

        return {
          game_id: r.match_id || null,
          player: r.player_name || name,
          round_index,
          dart_index: null,
          points: hit ? 1 : 0,
          kind: String(r.ring || '').toLowerCase(),
          hit,
          ts
        };
      }).filter(x => safeLower(x.player) === nameLC);

      return mapped;
    }catch(e){
      console.warn('[throws] throw_events_v not available, falling back to game boards', e);
    }

    // --- Fallback: reconstruct from official games (local-normalised) ---
    const gamesAll = (await __fetchOfficialGames(50000)).map(__normalizeGame);
    const rows = __throwsFromGamesForPlayer(name, gamesAll);
    // Attach timestamps from games if available
    const gameTs = new Map();
    gamesAll.forEach(g => {
      const gid = (g.raw && (g.raw.id || g.raw.game_id)) || g.id || g.game_id;
      if (gid && g.ts) gameTs.set(gid, g.ts);
    });

    return (rows||[]).map(r => {
      const ts = r.ts || gameTs.get(r.game_id) || null;
      const hit = Number(r.points||0) > 0;
      return Object.assign({}, r, { ts, hit });
    }).filter(r => safeLower(r.player) === nameLC);
  }

  window.openPlayerSpiderDialog = async function openPlayerSpiderDialog(playerName, opts){
    const name = String(playerName||'').trim();
    const overlay = document.createElement('div'); overlay.className='modal-backdrop';
    const modal   = document.createElement('div'); modal.className  ='modal';
  modal.style.maxWidth='980px'; modal.style.width='94vw';
    const title   = document.createElement('h3');  title.textContent=`SPIDER â€” ${name}`;
    const body    = document.createElement('div'); body.className   ='modal-body';
    const footer  = document.createElement('div'); footer.className ='modal-footer';
    modal.style.maxHeight='90vh'; modal.style.overflow='hidden';
    body.style.maxHeight='none'; body.style.overflowY='visible';

    const wrap = document.createElement('div');
    wrap.style.display='flex';
    wrap.style.flexDirection='column';
    wrap.style.alignItems='center';
    wrap.style.gap='10px';

    const canvas = document.createElement('canvas');
    canvas.width = 360; canvas.height = 360;
    canvas.style.width = 'min(360px, 92vw)';
    canvas.style.height= 'auto';

    const note = document.createElement('p');
    note.className='muted';
    note.style.textAlign='center';
    note.textContent='Loadingâ€¦';

    wrap.append(canvas, note);
    body.appendChild(wrap);

    const backBtn=document.createElement('button'); backBtn.className='btn sq-pill'; backBtn.textContent='Back';
    const closeBtn=document.createElement('button'); closeBtn.className='btn sq-pill'; closeBtn.textContent='Close';
    const parentOverlay = opts && opts.parentOverlay ? opts.parentOverlay : null;
    const backToPrev = () => {
      overlay.remove();
      if (parentOverlay){ parentOverlay.style.display=''; try{ parentOverlay.querySelector('.modal')?.focus?.(); }catch(_e){} return; }
      if (typeof window.openPlayerStatsModePicker==='function') window.openPlayerStatsModePicker(name);
      else if (typeof window.openPlayerStatsHub==='function') window.openPlayerStatsHub(name);
    };
    const closeToHub = () => {
      overlay.remove();
      if (parentOverlay) parentOverlay.remove();
      if (typeof window.openPlayerStatsHub==='function') window.openPlayerStatsHub(name);
      else if (typeof window.openPlayerStatsModePicker==='function') window.openPlayerStatsModePicker(name);
    };
    backBtn.onclick = backToPrev;
    closeBtn.onclick = closeToHub;
    footer.append(backBtn, closeBtn);

    modal.append(title, body, footer);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    overlay.addEventListener('click',e=>{ if(e.target===overlay) closeToHub();});
    overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') closeToHub();});
    modal.tabIndex=0; modal.focus();

    try{
      const mode = (opts && opts.mode) ? String(opts.mode).toLowerCase() : 'hit';
      const data = (opts && opts.data) ? opts.data : null;

      if (mode === 'points' && data && Array.isArray(data.labels) && Array.isArray(data.pct)) {
        const labels = data.labels.slice();
        const pct = data.pct.slice();
        drawRadar(canvas, labels, pct);
        note.textContent = 'Points % by target (10â€“20).';
        return;
      }

      if (mode === 'dtb' && data && Array.isArray(data.labels) && Array.isArray(data.pctD) && Array.isArray(data.pctT)) {
        const labels = data.labels.slice();
        const pctD = data.pctD.slice();
        const pctT = data.pctT.slice();

        const toggleRow = document.createElement('div');
        toggleRow.className='row';
        toggleRow.style.gap='8px';
        toggleRow.style.justifyContent='center';
        toggleRow.style.flexWrap='wrap';
        toggleRow.dataset.dtbToggle='1';

        const btnD = document.createElement('button'); btnD.className='btn small primary'; btnD.textContent='DOUBLES';
        const btnT = document.createElement('button'); btnT.className='btn small'; btnT.textContent='TREBLES';

        let which = 'd';
        const renderDTB = () => {
          if (which === 'd') {
            btnD.classList.add('primary'); btnT.classList.remove('primary');
            drawRadar(canvas, labels, pctD);
            note.textContent = 'Doubles % by target (10â€“20) + outer bull.';
          } else {
            btnT.classList.add('primary'); btnD.classList.remove('primary');
            drawRadar(canvas, labels, pctT);
            note.textContent = 'Trebles % by target (10â€“20) + inner bull.';
          }
        };

        btnD.onclick = ()=>{ which='d'; renderDTB(); };
        btnT.onclick = ()=>{ which='t'; renderDTB(); };

        if (!wrap.querySelector('[data-dtb-toggle="1"]')) {
          toggleRow.append(btnD, btnT);
          wrap.insertBefore(toggleRow, canvas);
        }

        renderDTB();
        return;
      }

      // Default: Hit % spider (10â€“20, D, T, B)
      const labels = (data && Array.isArray(data.labels)) ? data.labels : __roundLabels();
      let pct = (data && Array.isArray(data.pct)) ? data.pct.slice(0, labels.length) : null;

      if (!pct){
        const rows = await fetchPlayerThrowsWithTs(name);
        const taken = Array(14).fill(0), hits = Array(14).fill(0);
        rows.forEach(t=>{
          const r = (typeof t.round_index==='number') ? t.round_index : null;
          if (r==null || r<0 || r>13) return;
          taken[r] += 1;
          if ((t.hit===true) || (Number(t.points||0)>0)) hits[r] += 1;
        });
        pct = taken.map((n,i)=> n ? (100*hits[i]/n) : 0);
      }

      drawRadar(canvas, labels, pct);
      note.textContent = 'Hit % by target (10â€“20, D, T, B).';
    }catch(e){
      console.error('SPIDER failed', e);
      note.textContent = 'Could not load data.';
    }
  };

  window.openPlayerProgressHitDialog = async function openPlayerProgressHitDialog(playerName, opts={}){
    const name = String(playerName||'').trim();
    const mode = String((opts && opts.mode) || 'hit').toLowerCase(); // hit | points | dtb
    const parentOverlay = opts && opts.parentOverlay ? opts.parentOverlay : null;

    // --- modal shell (match Game Race / Progression styling) ---
    const overlay = document.createElement('div'); overlay.className='modal-backdrop';
    const modal   = document.createElement('div'); modal.className='modal wide';
    modal.style.maxWidth = '920px';
    modal.style.width = 'min(920px, 96vw)';
    modal.style.maxHeight = '90vh';
    modal.style.overflow = 'hidden';

    const title = document.createElement('h3');
    title.textContent = (mode==='points') ? `TARGET POINTS % â€” ${name}` : (mode==='dtb' ? `DTB % â€” ${name}` : `TARGET HIT % â€” ${name}`);

    const body = document.createElement('div'); body.className='modal-body';
    body.style.overflow = 'auto'; body.style.overflowY = 'hidden';

    const footer = document.createElement('div'); footer.className='modal-footer';
    const backBtn=document.createElement('button'); backBtn.className='btn sq-pill'; backBtn.textContent='Back';
    const closeBtn=document.createElement('button'); closeBtn.className='btn sq-pill'; closeBtn.textContent='Close';

    const backToPrev = () => {
      overlay.remove();
      if (parentOverlay){ parentOverlay.style.display=''; try{ parentOverlay.querySelector('.modal')?.focus?.(); }catch(_e){} return; }
      if (typeof window.openPlayerStatsModePicker==='function') window.openPlayerStatsModePicker(name);
      else if (typeof window.openPlayerStatsHub==='function') window.openPlayerStatsHub(name);
    };
    const closeToHub = () => {
      overlay.remove();
      if (parentOverlay) parentOverlay.remove();
      if (typeof window.openPlayerStatsHub==='function') window.openPlayerStatsHub(name);
      else if (typeof window.openPlayerStatsModePicker==='function') window.openPlayerStatsModePicker(name);
    };
    backBtn.onclick = backToPrev;
    closeBtn.onclick = closeToHub;
    footer.append(backBtn, closeBtn);

    // --- controls ---
    const controls = document.createElement('div');
    controls.style.display='flex';
    controls.style.flexDirection='column';
    controls.style.gap='10px';

    const avgRow = document.createElement('div');
    avgRow.style.display='flex';
    avgRow.style.gap='8px';
    avgRow.style.flexWrap='wrap';

    const avgBtns = [
      { key:'avg3',  label:'3 Dart AV' },
      { key:'avg10', label:'10 Dart AV' },
      { key:'avg20', label:'20 Dart AV' },
      { key:'traj',  label:'Trajectory' }
    ];

    const targetRow = document.createElement('div');
    targetRow.style.display='flex';
    targetRow.style.gap='8px';
    targetRow.style.flexWrap='wrap';

    // Targets: 10..20 plus D/T/B (single-select)
    const targets = [];
    for (let n=10;n<=20;n++) targets.push({ key:String(n), label:String(n) });
    targets.push({ key:'D', label:'D' }, { key:'T', label:'T' }, { key:'B', label:'B' });

    let selectedTarget = '10';
    let avgMode = 'avg10';

    function makePillButton(label, isActive=false){
      const b=document.createElement('button');
      b.className='btn tiny';
      b.textContent=label;
      b.style.borderRadius='999px';
      b.style.padding='6px 10px';
      b.style.fontSize='12px';
      b.style.letterSpacing='.06em';
      b.style.textTransform='uppercase';
      b.style.opacity = isActive ? '1' : '.75';
      b.style.borderColor = isActive ? 'rgba(255,140,0,.65)' : 'rgba(255,255,255,.14)';
      b.style.boxShadow = isActive ? '0 0 0 2px rgba(255,140,0,.10) inset' : 'none';
      return b;
    }

    function renderButtons(){
      avgRow.innerHTML='';
      avgBtns.forEach(it=>{
        const b = makePillButton(it.label, avgMode===it.key);
        b.onclick = () => { avgMode = it.key; renderButtons(); draw(); };
        avgRow.appendChild(b);
      });

      targetRow.innerHTML='';
      targets.forEach(it=>{
        const b = makePillButton(it.label, selectedTarget===it.key);
        b.onclick = () => { selectedTarget = it.key; renderButtons(); draw(); };
        targetRow.appendChild(b);
      });
    }

    // --- chart ---
    const canvas = document.createElement('canvas');
    canvas.width = 860;
    canvas.height = 420;
    canvas.style.width = 'auto'; canvas.style.display='block';
    canvas.style.height = 'auto';
    canvas.style.borderRadius = '14px';
    canvas.style.background = 'rgba(0,0,0,.18)';
    canvas.style.border = '1px solid rgba(255,255,255,.08)';

    const note = document.createElement('div');
    note.className='muted';
    note.style.display='flex';
    note.style.justifyContent='space-between';
    note.style.gap='10px';
    note.style.marginTop='6px';
    note.style.fontSize='12px';
    note.innerHTML = `<span>Single target selected; bars are per-game for that target.</span><span></span>`;

    controls.appendChild(avgRow);
    controls.appendChild(targetRow);

    body.appendChild(controls);
    body.appendChild(canvas);
    body.appendChild(note);

    modal.append(title, body, footer);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    overlay.addEventListener('click',e=>{ if(e.target===overlay) closeToHub();});
    overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') closeToHub();});
    modal.tabIndex=0; modal.focus();

    // --- data ---
    let rows = null;
    try{
      if (opts && opts.data && Array.isArray(opts.data.throws)) rows = opts.data.throws;
      else rows = await fetchPlayerThrowsWithTs(name);
    }catch(e){
      console.warn('progress fetch failed', e);
      rows = [];
    }

    // Normalise game ordering (old data may not include game_id; treat null as one bucket)
    const games = new Map(); // gid -> { tsMax, byRound: Map(ri -> [throws]) }
    const safeGid = (r, i) => (r && r.game_id) ? String(r.game_id) : `local_${i}`;

    (rows||[]).forEach((r,i)=>{
      const gid = safeGid(r,i);
      if (!games.has(gid)) games.set(gid, { tsMax: null, byRound: new Map() });
      const g = games.get(gid);
      const ts = r && r.ts ? new Date(r.ts).getTime() : null;
      if (ts!=null && (g.tsMax==null || ts>g.tsMax)) g.tsMax = ts;

      const ri = Number(r.round_index);
      if (!Number.isFinite(ri)) return;
      if (!g.byRound.has(ri)) g.byRound.set(ri, []);
      g.byRound.get(ri).push(r);
    });

    // Order games by timestamp asc (fallback to insertion order)
    const gameList = Array.from(games.entries()).map(([gid, g]) => ({ gid, tsMax: g.tsMax, byRound: g.byRound }));
    gameList.sort((a,b)=>{
      const at=a.tsMax??0, bt=b.tsMax??0;
      return at-bt;
    });

    function roundIndexFromKey(key){
      if (key==='D') return 11;
      if (key==='T') return 12;
      if (key==='B') return 13;
      const n = Number(key);
      if (Number.isFinite(n) && n>=10 && n<=20) return n-10;
      return 0;
    }

    function pointsForThrow(r){
      const hit = !!(r && (r.hit || Number(r.points||0)>0));
      if (!hit) return 0;
      const ri = Number(r.round_index);
      const base = (ri>=0 && ri<=10) ? (10+ri) : (ri===11 ? 20 : (ri===12 ? 20 : (ri===13 ? 50 : 0)));
      const k = String(r.kind||'').toLowerCase();
      if (k==='d') return base*2;
      if (k==='t') return base*3;
      if (k==='ib') return 50;
      if (k==='ob') return 25;
      if (k==='b') return base; // if base is 50
      return base; // single/default
    }

    function maxPointsPerDart(ri){
      if (ri>=0 && ri<=10) return (10+ri)*3;
      if (ri===11) return 40;
      if (ri===12) return 60;
      if (ri===13) return 50;
      return 0;
    }

    function calcValueForRound(ri, throws){
      const darts = (throws||[]);
      const attempts = darts.length || 0;
      if (!attempts) return null;

      if (mode === 'points'){
        const sumPts = darts.reduce((a,r)=>a+pointsForThrow(r),0);
        const maxPts = attempts * maxPointsPerDart(ri);
        return maxPts>0 ? (sumPts/maxPts)*100 : 0;
      }

      if (mode === 'dtb'){
        let ok = 0;
        darts.forEach(r=>{
          const hit = !!(r && (r.hit || Number(r.points||0)>0));
          if (!hit) return;
          const k = String(r.kind||'').toLowerCase();
          if (ri>=0 && ri<=10){
            if (k==='d' || k==='t') ok++;
          }else if (ri===11){
            if (k==='d') ok++;
          }else if (ri===12){
            if (k==='t') ok++;
          }else if (ri===13){
            if (k==='ib' || k==='ob' || k==='b') ok++;
          }
        });
        return (ok/attempts)*100;
      }

      // default: hit%
      const hits = darts.reduce((a,r)=>a + ( (r && (r.hit || Number(r.points||0)>0)) ? 1 : 0 ), 0);
      return (hits/attempts)*100;
    }

    function computeSeries(targetKey){
      const ri = roundIndexFromKey(targetKey);
      const xs = []; // game indices (1..N)
      const ys = []; // values (0..100)
      gameList.forEach((g, idx)=>{
        const arr = g.byRound.get(ri) || [];
        const v = calcValueForRound(ri, arr);
        if (v==null) return; // skip games missing that round (rare)
        xs.push(idx+1);
        ys.push({ i: idx+1, v });
      });
      return { xs, ys, ri };
    }

    function rollingAvg(ys, win){
      const out=[];
      for (let i=0;i<ys.length;i++){
        const s = Math.max(0, i-win+1);
        let sum=0, c=0;
        for (let j=s;j<=i;j++){ const v=ys[j]; if (Number.isFinite(v)){ sum+=v; c++; } }
        out.push(c?sum/c:null);
      }
      return out;
    }

    function bucketLine(ys, bucketSize){
      const pts=[]; // {xIndex, y}
      for (let i=0;i<ys.length;i+=bucketSize){
        const slice=ys.slice(i, i+bucketSize);
        const vals=slice.filter(v=>Number.isFinite(v));
        const avg=vals.length?vals.reduce((a,b)=>a+b,0)/vals.length:null;
        pts.push({ x:i, y:avg });
      }
      return pts;
    }

    function trajectoryLine(ys){
      const n=ys.length;
      if (!n) return null;
      const mid = Math.floor(n/2);
      const a1 = ys.slice(0, mid).filter(v=>Number.isFinite(v));
      const a2 = ys.slice(mid).filter(v=>Number.isFinite(v));
      const y1 = a1.length? a1.reduce((a,b)=>a+b,0)/a1.length : null;
      const y2 = a2.length? a2.reduce((a,b)=>a+b,0)/a2.length : null;
      return { y1, y2 };
    }

    function drawChart(series){
      series = Array.isArray(series) ? series : [];
      const ys = series.map(d=>d.v);
      const labels = series.map(d=>d.i);
      const n = ys.length;
      if (n === 0) return;

      const allTimeHigh = Math.max(...ys);
      const allTimeAvg = ys.reduce((a,b)=>a+b, 0) / n;

      const existingChart = Chart.getChart(canvas);
      if (existingChart) existingChart.destroy();

      const datasets = [
        {
          type: 'bar',
          label: 'Game Score',
          data: ys,
          backgroundColor: 'rgba(255, 255, 255, 0.2)',
          order: 2
        },
        {
          type: 'line',
          label: 'Average',
          data: new Array(n).fill(allTimeAvg),
          borderColor: 'rgba(255, 140, 0, 0.8)',
          borderWidth: 2,
          borderDash: [5, 5],
          pointRadius: 0,
          order: 1
        },
        {
          type: 'line',
          label: 'All-Time High',
          data: new Array(n).fill(allTimeHigh),
          borderColor: 'rgba(255, 255, 255, 0.2)',
          borderWidth: 1,
          borderDash: [2, 2],
          pointRadius: 0,
          order: 1
        }
      ];

      if (avgMode === 'traj') {
        if (n > 1) {
          const half = Math.floor(n / 2);
          const a1 = ys.slice(0, half).reduce((a, b) => a + b, 0) / Math.max(1, half);
          const a2 = ys.slice(half).reduce((a, b) => a + b, 0) / Math.max(1, n - half);
          // To draw a simple trajectory line from first to last point in Chart.js
          // we can use a sparse dataset or just two points.
          const trajData = new Array(n).fill(null);
          trajData[0] = a1;
          trajData[n-1] = a2;
          datasets.push({
            type: 'line',
            label: 'Trajectory',
            data: trajData,
            borderColor: 'rgba(140, 255, 140, 0.8)',
            borderWidth: 3,
            pointRadius: 0,
            spanGaps: true,
            order: 0
          });
        }
      } else if (avgMode.startsWith('avg')) {
        const windowSize = parseInt(avgMode.replace('avg', '')) || 10;
        const rolling = [];
        for (let i = 0; i < n; i++) {
          const s = Math.max(0, i - windowSize + 1);
          const seg = ys.slice(s, i + 1);
          rolling.push(seg.reduce((a, b) => a + b, 0) / seg.length);
        }
        datasets.push({
          type: 'line',
          label: `${windowSize} Dart AV`,
          data: rolling,
          borderColor: 'rgba(140, 255, 140, 0.8)',
          borderWidth: 3,
          pointRadius: 0,
          order: 0
        });
      }

      new Chart(canvas, {
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          datasets: {
            bar: {
              maxBarThickness: 40
            }
          },
          scales: {
            x: {
              grid: { display: false },
              ticks: { color: 'rgba(255, 255, 255, 0.5)', maxRotation: 0, autoSkip: true, maxTicksLimit: 10 }
            },
            y: {
              min: 0,
              max: 100,
              grid: { color: 'rgba(255, 255, 255, 0.1)' },
              ticks: { color: 'rgba(255, 255, 255, 0.5)' }
            }
          },
          plugins: {
            legend: { display: false }
          }
        }
      });
    }

    function draw(){
      if (!canvas) return;
      const series = computeSeries(selectedTarget);
      if (!series.ys.length){
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle='rgba(255,255,255,.65)';
        ctx.font='14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.textAlign='center';
        ctx.fillText('No data yet for this target.', canvas.width/2, canvas.height/2);
        return;
      }
      // draw expects the per-game point series array [{i,v}, ...]
      drawChart(series.ys);
    }

    renderButtons();
    draw();
  };;
})();
// >>> PATCH:player_stats_spider_progress END


// ===== @PATCHES:REGISTRY =====
// Active patch blocks in this file (keep this list current):
// - MOT3_2_ALLGAMES_TOTS
// - MOT3_2_LLS_DELETE_TS
// - MOT3_2_LLS_FILTER_SAVED
// - MOT3_3_ALLGAMES_FILTER_ACTIVE_START
// - PLAYER_ID_SUPPORT
// - PLAYER_RENAME_RPC
// - data-admin
// - game-utils
// - player_stats_spider_progress
// - power-league-rounds
//
// Patch rules:
// 1) Patches must be named and small.
// 2) Avoid redefining whole modals unless unavoidable.
// 3) If a patch becomes permanent, merge it into core code and delete the patch.
// 4) Patches should log once (not spam) when they fail.

/* === PATCH v12.4.57: Admin button always requires password (no silent bypass) === */
(function(){
  try { window.__sqAdminAuthed = false; } catch(_){}

  function openGate(){
    if (typeof window.openAdminPasswordModal === 'function') return window.openAdminPasswordModal();
    try { if (typeof toast === 'function') toast('Admin login unavailable'); } catch(_){}
  }

  function wire(){
    const btn = document.getElementById('adminBtn') || document.getElementById('adminCodeBtn');
    if (btn) btn.onclick = openGate;
  }

  // Wire now + keep wired if footer re-renders
  try { wire(); } catch(_){}
  try {
    const mo = new MutationObserver(()=>{ try{ wire(); }catch(_){} });
    mo.observe(document.body, { childList:true, subtree:true });
  } catch(_){}

  // Capture clicks on any admin entry element and force the gate
  document.addEventListener('click', (e)=>{
    const el = e.target && e.target.closest ? e.target.closest('#adminBtn,#adminCodeBtn,.adminLink') : null;
    if (!el) return;
    e.preventDefault();
    e.stopPropagation();
    openGate();
  }, true);
})();


/* === PATCH v12.4.58: Admin login always available (wire outside steppers) === */
(function adminLoginAlways(){
  const expected = (window.ADMIN_PASSWORD || 'hownowbrowncow');

  if (window.__sqAdminAuthed == null) window.__sqAdminAuthed = false;

  if (typeof window.openAdminPasswordModal !== 'function'){
    window.openAdminPasswordModal = function openAdminPasswordModal(){
      const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
      const modal   = document.createElement('div'); modal.className = 'modal';

      const title = document.createElement('h3'); title.textContent = 'Admin Login';
      const body  = document.createElement('div'); body.className = 'modal-body';

      const label = document.createElement('label');
      label.textContent = 'Enter password:';
      label.className = 'muted';
      label.style.display = 'block';
      label.style.marginBottom = '6px';

      const input = document.createElement('input');
      input.type = 'password';
      input.className = 'input';
      input.autocomplete = 'current-password';
      input.placeholder = 'Password';
      input.style.minWidth = '220px';

      body.append(label, input);

      const footer = document.createElement('div'); footer.className = 'modal-footer';
      const cancel = document.createElement('button'); cancel.className = 'btn';         cancel.textContent = 'Cancel';
      const enter  = document.createElement('button'); enter.className  = 'btn primary'; enter.textContent  = 'Enter';

      function close(){ overlay.remove(); }
      function deny(){
        if (typeof toast === 'function') toast('Incorrect password');
        else alert('Incorrect password');
        input.focus(); input.select();
      }
      function grant(){
        window.__sqAdminAuthed = true;
        close();
        if (typeof window.__openAdminHubUnsafe === 'function') window.__openAdminHubUnsafe();
        else if (typeof window.openAdminHub === 'function') window.openAdminHub();
      }
      function submit(){
        const v = (input.value || '').trim();
        if (!expected || v === expected) grant(); else deny();
      }

      cancel.onclick = close;
      enter.onclick  = submit;
      input.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') submit(); });

      footer.append(cancel, enter);
      modal.append(title, body, footer);
      overlay.appendChild(modal);
      document.body.appendChild(overlay);

      modal.tabIndex = 0; modal.focus();
      overlay.addEventListener('click', e => { if (e.target === overlay) close(); });
      overlay.addEventListener('keydown', e => { if (e.key === 'Escape') close(); });

      setTimeout(()=> input.focus(), 0);
    };
  }

  function wire(){
    const btn = document.getElementById('adminCodeBtn') || document.getElementById('adminBtn');
    if (btn){
      btn.onclick = (e)=>{ e?.preventDefault?.(); window.openAdminPasswordModal(); };
    }

    // Wrap hub if not already wrapped
    if (typeof window.openAdminHub === 'function' && !window.openAdminHub.__sqIsGated){
      const unsafe = window.openAdminHub;
      window.__openAdminHubUnsafe = unsafe;
      window.openAdminHub = function(){
        if (window.__sqAdminAuthed) return unsafe();
        return window.openAdminPasswordModal();
      };
      window.openAdminHub.__sqIsGated = true;
    }

    // Capture-click safety net
    document.addEventListener('click', (e)=>{
      const el = e.target && e.target.closest ? e.target.closest('#adminBtn,#adminCodeBtn,button,a') : null;
      if (!el) return;
      const id = (el.id||'').toLowerCase();
      const label = String(el.textContent||'').trim().toLowerCase();
      const isAdmin = (id==='adminbtn' || id==='admincodebtn' || label==='admin' || label==='admin hub');
      if (!isAdmin) return;
      if (!window.__sqAdminAuthed){
        e.preventDefault();
        e.stopPropagation();
        window.openAdminPasswordModal();
      }
    }, true);
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', wire);
  else wire();
})();

</script>
<!-- PB / GR Admin Modal -->
<div id="pbgrAdminModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="pbgrTitle">
  <h3 id="pbgrTitle">PB / GR Admin</h3>
  <div class="modal-body">
    <p class="muted" style="margin-top:-6px;margin-bottom:10px;">
      Manage Personal Bests and Game Records. Deleting a row will remove the underlying round from the cloud.
    </p>

    <h4 style="margin:8px 0 6px;">World Records (All Players)</h4>
    <div id="pbgrGlobal" class="table-wrap"></div>

    <hr style="border:0;border-top:1px solid rgba(255,255,255,.08);margin:12px 0;">

    <h4 style="margin:8px 0 6px;">Player PBs</h4>
    <label for="pbgrPlayerSelect" class="muted" style="display:block;margin-bottom:6px;">Select saved player:</label>
    <select id="pbgrPlayerSelect" class="input" style="min-width:220px;"></select>
    <div class="row" id="pbgrBackfillRow" style="margin-top:10px; gap:8px; align-items:center;">
  <button id="pbgrBackfillBtn" class="btn warn" type="button">Backdate PB / WR</button>
  <span class="muted">Scan cloud throws (saved players, official only) and write PBs + WRs.</span>
</div>
    <div id="pbgrPlayer" class="table-wrap" style="margin-top:8px;"></div>
  </div>
  <div class="modal-footer">
    <button id="pbgrBackBtn" class="btn">Back</button>
    <button id="pbgrRefreshBtn" class="btn">Refresh</button>
    <button id="pbgrCloseBtn" class="btn">Close</button>
  </div>
  
</div>
</body>
</html>