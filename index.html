<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shateki Quest Scorer</title>

<!-- Supabase JS v2 -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<style>
  :root{
    --bg:#0f1220;--card:#171a2b;--ink:#e7e9f5;--muted:#a8acc3;--accent:#7bdcff;--accent-2:#8cff9e;
    --danger:#ff6b6b;--warn:#ffcc66;--good:#7fffd4;--shadow:0 10px 30px rgba(0,0,0,.35);--radius:14px;
    --pad-h:148px; --left-col-w:96px; --start-btn-h:52px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; min-height:100dvh; overflow-x:hidden;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,"Apple Color Emoji","Segoe UI Emoji";
    background:radial-gradient(1000px 600px at 0% 0%,#1b1f36 0%,#0f1220 45%,#0b0e1a 100%); color:var(--ink);
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
  }
  /* Start Match button full-width under the player box */
#startMatchRow{
  margin-top:16px;
  max-width:640px;
  margin-inline:auto;
}

#startMatchBtn{
  width:100%;          /* same width as the box */
}
 .wrap{max-width:1100px;margin-inline:auto;padding:16px; padding-bottom:calc(var(--pad-h) + 16px)}
.start-actions{
  display:flex;
  flex-direction:column;
  align-items:center;
  margin:0 auto;
  text-align:center;
  max-width:480px; 
}

.start-actions .btn.big{
  width:100%;
}

.section{
  margin:14px 0;
  padding:14px;
}
/* Game Details layout tweaks */
#details h2 {
  display: none;
}
#details #appTitle {
  display: block;               /* override the display:none */
  font-size: 2.6rem;
  font-weight: 800;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  text-align: center;
  margin-bottom: 24px;
  color: #e7e9f5;
}
/* Center the contents of the Game Details screen */
#details {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: calc(100vh - var(--pad-h));
}

/* Center the main buttons block */
#details .start-actions {
  margin: 0 auto;
}

/* Player Select layout tweaks */
#players h2{
  display:none;              /* hide "Player Select" text */
}

#players #gameTopRow{
  margin-bottom:12px;
}

/* Center the Player Select screen vertically like page 1 */
#players{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  min-height:calc(100vh - var(--pad-h));
}

/* Box wrappers on Player Select: games/players + player list */
.ps-config-row{
  padding:12px;
  border-radius:12px;
  background:#101533;
  border:1px solid #23284a;
  display:flex;
  flex-direction:column;
  gap:10px;
  max-width:640px;
  width:100%;
  margin:12px auto 0;

}

/* Box each player row (guest name + select/save buttons) */
#psPlayerFields .pf{
  padding:10px 12px;
  border-radius:12px;
  border:1px solid #23284a;
  background:#101533;
}
.th-throws{
  font-size: 11px;
  line-height: 1;
  color: var(--muted);
  min-height: 14px;
}

/* highlight overall leaders in Total row */
.leader-total{
  color: var(--accent-2) !important;
}

/* Slightly darker input inside the box */
#psPlayerFields .pf input[data-role="display"]{
  background:#ffffff;
  color:#000000;
}

/* Keep the buttons a decent width inside the box */
#psPlayerFields .pf .btn{
  min-width:120px;
}

/* Stack the admin code + button vertically and centre them */
#adminCodeRow {
  display: flex;              /* override .row */
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin-top: 24px;
  max-width: 260px;
  margin-inline: auto;
}

#adminCodeRow .grow {
  max-width: none;
  width: 100%;
}

/* Full-width input + button under it */
#adminCode {
  width: 100%;
}

#adminEnterBtn {
  width: 100%;
}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .column{display:flex;flex-direction:column;gap:10px}
  .grow{flex:1}
  .hidden{display:none!important}
  .tag{font-size:.78rem;color:var(--muted);padding:.15rem .45rem;border:1px solid #2b3050;border-radius:999px}
  .banner{background:linear-gradient(180deg,#14284a,#12213d);border:1px solid #2a4777;border-radius:12px;padding:12px;margin-top:10px}

  input[type="text"],select,input[type="password"]{
    background:#101329;border:1px solid #2b3050;color:var(--ink);padding:.65rem .8rem;border-radius:10px;outline:none;width:100%
  }
  .btn{appearance:none;border:1px solid #2b3050;border-radius:12px;background:#131733;color:var(--ink);
       padding:.7rem 1rem;cursor:pointer;transition:.15s transform,.15s background,.15s border-color,.15s opacity;font-weight:700}
  .btn:hover{transform:translateY(-1px);background:#161a3a}
  .btn:disabled{opacity:.55;cursor:not-allowed;transform:none}
  .btn.primary{background:linear-gradient(180deg,#1d255a,#19214f);border-color:#32407a}
  .btn.good{background:linear-gradient(180deg,#1b3d2e,#183628);border-color:#2e6a4f}
  .btn.warn{background:linear-gradient(180deg,#3a3219,#2f2914);border-color:#6b5821}
  .btn.danger{background:linear-gradient(180deg,#47212a,#3c1b23);border-color:#7a2e3f}
  .btn.big{font-size:1.15rem;padding:1rem 1.25rem;border-radius:14px}
  .btn.small { padding: 4px 8px; font-size: 0.8rem; min-width: 30px; min-height: 24px; }

  /* Tables */
  .table-wrap{overflow:auto;border-radius:12px;border:1px solid #2a2e48}
  table{width:100%;border-collapse:separate;border-spacing:0;background:#0f1329;table-layout:fixed}
  thead th{
    background:#14183a;border-bottom:1px solid #2a2e48;padding:.6rem .5rem;text-align:left;font-weight:700;
    position:sticky; top:0; z-index:5;
  }
  #scoreWrap thead th:first-child{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w)}
  #scoreWrap tbody th{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w);
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-right:6px}
  thead th.player, tbody td.player{min-width:120px; text-align:center}
  tbody td,tbody th{padding:.55rem .5rem;border-bottom:1px dashed #23284a;text-align:left;vertical-align:middle}
  tbody td{white-space:nowrap; overflow:hidden; text-overflow:clip}
  tbody tr:last-child td{border-bottom:none}
  tbody th{font-weight:600;color:#cfd3ee;background:#101533;border-right:1px solid #22264a}
  .num{font-variant-numeric:tabular-nums}
  .center{text-align:center}
  .current-cell{background:linear-gradient(180deg,#1e2450,#171d45)!important;box-shadow:inset 0 0 0 1px #4050a7}
  .current-col{background:rgba(64,80,167,.07)}

  /* Header content */
  thead th .th-wrap{display:flex;flex-direction:column;align-items:center;gap:2px}
  thead th .th-name{font-weight:800;letter-spacing:.02em}
  thead th .th-beers{font-size:12px;line-height:1;min-height:14px;letter-spacing:.5px;filter:drop-shadow(0 0 6px rgba(255,204,102,.35)); text-align:center}
  .th-throw-arrow{font-size:13px; line-height:1}
  .th-total{font-weight:800;letter-spacing:.02em}
  .th-diff{font-size:10px; line-height:1; font-weight:400 !important; color:var(--muted); text-align:center}
  .th-diff-label{font-size:11px; font-weight:400 !important; color:var(--muted)}

  /* Score cell */
  .cell-wrap{display:inline-flex;flex-direction:column;align-items:center;gap:1px;line-height:1}
  .cell-main{font-weight:800;line-height:1.1}
  .cell-sub{color:var(--muted);font-size:.60em;font-weight:500;opacity:.95;letter-spacing:-0.01em;line-height:1}
  .sub-win{color:var(--accent-2)!important;font-weight:700}

  /* Stats (kept for layout sync; shown via modals) */
  .stats-box{display:none}
  #statsWrap thead th:first-child,
  #mstatsWrap thead th:first-child{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w)}
  #statsWrap tbody th.stats-th,
  #mstatsWrap tbody th.stats-th{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w);
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-right:8px}
  .stats-th{background:#101533;color:#cfd3ee}
  .stats-row th,.stats-row td{font-size:.86rem;line-height:1.15;padding:.45rem .5rem}
  .stats-row td{color:#e1e4fb}

  /* Floating names header */
  .float-head{position:sticky; top:0; z-index:200000;
    background:rgba(17,19,38,.96); backdrop-filter:blur(6px);
    border:1px solid #2a2e48; border-radius:12px; margin-bottom:10px}
  .float-head .table-wrap{border:none;border-radius:12px}
  #floatWrap thead th:first-child{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w)}

/* Current round target display (left header cell) */
#floatWrap #froundlabel {
  text-align: center;
  vertical-align: middle;
}
#floatWrap #froundlabel .round-now{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  padding:8px 4px;
}
#floatWrap #froundlabel .rn-label{
  font-size:11px;
  font-weight:700;
  letter-spacing:.18em;
  color:var(--muted);
  margin-bottom:4px;
  text-transform:uppercase;
}
#floatWrap #froundlabel .rn-value{
  font-weight:900;
  line-height:1;
  /* Big, but responsive so it nearly fills the cell */
  font-size:clamp(28px, 6.5vw, 64px);
  letter-spacing:.01em;
}

/* Bigger, bold S / D / T buttons + match size for pad actions & top bar */
.btn.letter-throw{
  font-size: 1.25rem;
  font-weight: 700;
}
.pad .btn.letter-throw{
  min-height: 46px;
}
/* Top action buttons (Start Screen, Restart Game, Stats) â€“ smaller & shorter */
#leaderboardTopRow .btn{
  font-size: 0.86rem;      /* a lot smaller */
  font-weight: 700;
  line-height: 1.1;
  padding: 6px 10px;       /* tighter padding */
  min-height: 32px;        /* shorter buttons */
}

/* Center the "10sâ€¦Bull" row labels in the main scoreboard */
#scoreWrap tbody th{
  text-align: center;
}
#leaderboardTopRow .btn.top-throw{
  flex: 1 1 0;
  min-width: 0;
  min-height: 35px;       /* matches .pad .btn.letter-throw */
  font-size: 1rem;
  font-weight: 500;
}

  /* Hide Throw Pad off non-game pages */
  body[data-page="details"] .pad-bar,
  body[data-page="players"] .pad-bar,
  body[data-page="leaderboard"] .pad-bar.hidden { display:none; }
  body[data-page="game"] .pad-bar { display:block; }

  /* Fixed Throw Pad */
  .pad-bar{position:fixed;left:0;right:0;bottom:0;background:rgba(17,19,38,.96);backdrop-filter:blur(6px);
    border-top:1px solid #23284a;z-index:100000;padding-bottom:max(8px, env(safe-area-inset-bottom))}
  .pad-inner{max-width:1100px;margin:0 auto;padding:8px 10px}
  .pad-head{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:6px}
  .pad-left{display:flex;align-items:center;gap:10px}
  .pad-hint{color:#a8acc3;font-size:.82rem}
.pad{
  display:flex;
  flex-direction:column;
  align-items:stretch;   /* allow rows to fill width */
  gap:6px;
  max-height:140px;
  overflow:auto;
}  
.pad .btn{min-width:52px;min-height:38px}
  .pad-spacer{flex:1 1 auto}
  .pad .btn.main-throw{
    min-width:104px;  /* roughly double the default 52px */
  }

  /* Modal */
  .modal-backdrop{position:fixed; inset:0; background:rgba(0,0,0,.5); display:flex; align-items:center; justify-content:center; z-index:400000}
  .modal{background:#0f1329; border:1px solid #2a2e48; border-radius:14px; box-shadow:var(--shadow); padding:12px; width:92%; max-width:640px}
  .modal h3{ margin:0 0 8px 0; font-size:1.02rem }
  .modal-body{ max-height:60vh; overflow:auto; padding-right:2px; }
  .modal-footer{ margin-top:10px; display:flex; gap:8px; }
  .hs-table{ width:100%; border-collapse:separate; border-spacing:0 }
  .hs-table th, .hs-table td{ padding:.5rem .5rem; border-bottom:1px dashed #23284a; }
  .hs-table th{ text-align:left; color:#cfd3ee; }

  /* Add / Select Player Modals */
  #addPlayerModal.hidden, #selectPlayerModal.hidden, #adminHubModal.hidden, #savedPlayersAdminModal.hidden { display:none; }

  /* Compact admin tables */
  .compact * { font-size: 12px !important; }
  .compact .btn { padding: 4px 8px; font-weight: 600; }
  .compact table th, .compact table td { padding: .35rem .4rem; }
  
  /* Cloud status pill (top-right) */
.cloud-status {
  position: fixed;
  right: 12px;
  top: 12px;          /* moved from bottom to top */
  bottom: auto;
  background: rgba(10, 12, 30, .92);
  border: 1px solid #2b3050;
  color: var(--muted);
  font-size: 11px;
  padding: 4px 8px;
  border-radius: 999px;
  display: flex;
  align-items: center;
  gap: 6px;
  z-index: 500000;
  pointer-events: none;
}

.cloud-status .cloud-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #666;
}

/* States */
.cloud-status.checking .cloud-dot { background: var(--warn); }
.cloud-status.ok       .cloud-dot { background: var(--accent-2); }
.cloud-status.error    .cloud-dot { background: var(--danger); }
  
:root{
  /* one place to tweak section spacing */
  --section-gap: 10px;
}

/* Top row of buttons: put the same gap below as the float-head/score gap */
#leaderboardTopRow{
  margin-bottom: var(--section-gap);
}

/* Make the float header + score gap use the same token too */
.float-head{
  margin-bottom: var(--section-gap);
}

/* Scoreboard had inline margin-top; override to match */
#scoreWrap{
  margin-top: var(--section-gap) !important;
}

/* (from earlier ask) keep these tiny + shorter */
#leaderboardTopRow .btn{
  font-size: 0.9rem;
  min-height: 34px;
  padding: 6px 10px;
}
/* match buttons to the app title width */
#details { --title-w: auto; }
#details #appTitle { display: inline-block; }    /* needed to measure width */

#details .start-actions{
  max-width: none;               /* remove old cap */
  width: var(--title-w);         /* driven by JS below */
}

/* Make each button line fill that width */
#details .start-actions .btn.big{ width: 100%; }
#details .start-actions .row{ width: 100%; }     /* High Scores / Player Stats row */
#details .start-actions .row .btn{ width: 100%; }

/* Leave Admin Code row compact/independent */
#adminCodeRow{ max-width: 260px; width: 100%; }

</style>
</head>
<body data-page="details">
  <div class="wrap">

    <!-- PAGE 1: GAME DETAILS -->
    <section id="details" class="card section">
<h2 id="appTitle">SHATEKI-QUEST</h2>
      <div class="start-actions column" style="gap:8px; max-width:480px">
        <button id="questBtn" class="btn primary big" type="button">New game â–¶</button>
        <button id="resumeBtn" class="btn good big" type="button" disabled title="No saved match">Resume game â–¶</button>

        <div class="row" style="justify-content:center; gap:8px; flex-wrap:wrap; margin-top:4px;">
  <button id="hsMainBtn" class="btn" type="button">High Scores</button>
  <button id="playerStatsBtn" class="btn" type="button">Player Stats</button>
</div>

            <!-- Single Admin Code row -->
      <div class="row" id="adminCodeRow" style="margin-top:16px;">
        <div class="grow" style="max-width:360px">
          <input id="adminCode" placeholder="Admin Code" />
        </div>
        <button id="adminEnterBtn" class="btn" type="button">Enter</button>
      </div>
    </div> <!-- CLOSE .start-actions -->
    </section>

<!-- PAGE 2: PLAYER SELECT -->
<section id="players" class="card section hidden">
  <div class="row" id="gameTopRow" style="align-items:center; justify-content:flex-start;">
    <button id="startScreenBtn" class="btn" type="button">Back</button>
  </div>

  <h2>Player Select</h2>

  <!-- BOX 1: Number of games / Number of players -->
  <div class="ps-config-row">
    <div class="row" style="justify-content:center; gap:10px; flex-wrap:wrap;">
      <div class="column" style="flex:1; min-width:220px">
        <label class="tag" for="psNumGames">Number of games</label>
        <select id="psNumGames">
          <option value="1">1 game</option>
          <option value="2">2 games</option>
          <option value="3">3 games</option>
          <option value="4">4 games</option>
          <option value="5" selected>5 games</option>
        </select>
      </div>
      <div class="column" style="flex:1; min-width:220px">
        <label class="tag" for="psNumPlayers">Number of players</label>
        <select id="psNumPlayers">
          <option value="1">1 player (Training)</option>
          <option value="2" selected>2 players</option>
          <option value="3">3 players</option>
          <option value="4">4 players</option>
          <option value="5">5 players</option>
          <option value="6">6 players</option>
        </select>
      </div>
    </div>
  </div>

  <!-- BOX 2: Player rows (guest / saved players) -->
  <div class="ps-config-row">
    <div id="psPlayerFields" class="column" style="width:100%;">
      <!-- Rows injected -->
    </div>
  </div>

  <!-- Start Match button â€“ full width under the boxes -->
  <div class="row" id="startMatchRow">
    <button id="startMatchBtn" class="btn good big" type="button">Start Match â–¶</button>
  </div>
</section>

    <!--PAGE3: GAME -->
    <section id="game" class="hidden">
      <div class="card section">
 <div class="row" id="leaderboardTopRow">
  <button id="startScreenBtnLB" class="btn letter-throw top-throw">Start Screen</button>
  <button id="restartGameBtnLB" class="btn letter-throw top-throw">Restart Game</button>
  <button id="statsHubBtnLB" class="btn letter-throw top-throw">Stats</button>
</div>

        <!-- Floating names + wins + totals -->
        <div class="float-head" id="floatHead">
          <div class="table-wrap" id="floatWrap">
            <table aria-hidden="true"><thead id="floatThead"></thead></table>
          </div>
        </div>

        <!-- Scoreboard -->
        <div class="table-wrap" id="scoreWrap" style="margin-top:10px">
          <table aria-label="Scoreboard">
            <thead id="thead"></thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>

        <!-- Hidden stats tables used to keep column widths aligned -->
        <div class="stats-box">
          <div class="table-wrap" id="statsWrap">
            <table aria-label="Player statistics">
              <thead id="statsThead"></thead>
              <tbody id="statsTbody"></tbody>
            </table>
          </div>
        </div>
        <div class="stats-box">
          <div class="table-wrap" id="mstatsWrap">
            <table aria-label="Match statistics">
              <thead id="mstatsThead"></thead>
              <tbody id="mstatsTbody"></tbody>
            </table>
          </div>
        </div>

        <div id="endBanner" class="banner hidden"></div>
      </div>
    </section>

    <!-- LEADERBOARD -->
    <section id="leaderboard" class="card section hidden">
      <div class="row" style="position: relative; height: 40px;">
        <button id="startScreenBtnLB" class="btn" style="position: absolute; top: 0; left: 0;">Start Screen</button>
        <button id="restartGameBtnLB" class="btn" style="position: absolute; top: 0; left: 110px;">Restart Game</button>
      </div>
      <h2>Leaderboard</h2>
      <p class="tag"><span id="lbMatchInfo"></span></p>

      <div class="table-wrap" style="margin-top:8px">
        <table id="lbTable">
          <thead></thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="row" style="margin-top:10px; align-items:center;">
        <button id="nextGameBtn" class="btn primary big" type="button">Next game â–¶</button>
        <span class="grow"></span>
        <button id="gameScoresBtn" class="btn" type="button">Game Scores</button>
        <button id="newMatchBtn" class="btn danger" type="button">ðŸ—‘ END MATCH</button>
        <span id="gamesRemainTag" class="tag"></span>
      </div>

      <!-- New stats row under leaderboard -->
      <div class="row" style="margin-top:10px; justify-content:center; gap:8px;">
        <button id="lbGameStatsBtn" class="btn" type="button">Game Stats</button>
        <button id="lbMatchStatsBtn" class="btn" type="button">Match Stats</button>
        <button id="lbGameRaceBtn" class="btn" type="button">Race</button>
      </div>
    </section>

    <!-- Fixed Throw Pad (Game Stats / Match Stats / High Scores / Race appear here) -->
    <div class="pad-bar" id="padBar">
      <!-- keep your existing inner markup exactly as it is -->
      <div class="pad-inner">
        <div class="pad-head">
          <div class="pad-left">
            <div id="padHint" class="pad-hint"></div>
          </div>
        </div>
        <div id="pad" class="pad"></div>
      </div>
    </div>

    <!-- Add Player Modal -->
    <div id="addPlayerModal" class="modal-backdrop hidden">
      <div class="modal">
        <h3>Add New Player</h3>
        <div class="modal-body">
          <div class="stack">
            <label class="tag" for="newPlayerName">Player Name</label>
            <input id="newPlayerName" type="text" placeholder="Enter player name" />
          </div>
          <div class="stack" style="margin-top: 15px;">
            <label class="tag" for="newPlayerPassword">Password</label>
            <input
              id="newPlayerPassword"
              type="tel"
              inputmode="numeric"
              pattern="\d{4}"
              maxlength="4"
              placeholder="4-digit PIN"
            />
          </div>
        </div>
        <div class="modal-footer">
          <button id="cancelAddPlayerBtn" class="btn" type="button">Cancel</button>
          <button id="savePlayerBtn" class="btn primary" type="button">Save Player</button>
        </div>
      </div>
    </div>

    <!-- Select Player Modal -->
    <div id="selectPlayerModal" class="modal-backdrop hidden">
      <div class="modal">
        <h3>Select Player</h3>
        <div class="modal-body">
          <div class="stack">
            <label class="tag">Player Name</label>
            <select id="existingPlayerSelect" style="width: 100%;">
              <option value="">Select a saved player...</option>
            </select>
          </div>
          <div class="stack" style="margin-top: 15px;">
            <label class="tag" for="playerPassword">Password</label>
            <input
              id="playerPassword"
              type="tel"
              inputmode="numeric"
              pattern="\d{4}"
              maxlength="4"
              placeholder="4-digit PIN"
            />
          </div>
        </div>
        <div class="modal-footer">
          <button id="cancelSelectPlayerBtn" class="btn" type="button">Cancel</button>
          <button id="confirmSelectPlayerBtn" class="btn primary" type="button">Confirm</button>
        </div>
      </div>
    </div>

    <!-- Admin Hub Modal -->
    <div id="adminHubModal" class="modal-backdrop hidden">
      <div class="modal">
        <h3>Admin Hub</h3>
        <div class="modal-body">
          <div class="row">
            <button id="openHsLeagueAdmin" class="btn">League High Scores Admin</button>
            <button id="openHsPracticeAdmin" class="btn">Practice High Scores Admin</button>
            <button id="openSavedPlayersAdmin" class="btn">Saved Players Admin</button>
          </div>
        </div>
        <div class="modal-footer">
          <button id="closeAdminHubBtn" class="btn" type="button">Close</button>
        </div>
      </div>
    </div>

    <!-- Saved Players Admin Modal -->
    <div id="savedPlayersAdminModal" class="modal-backdrop hidden">
      <div class="modal compact">
        <h3>Saved Players Admin</h3>
        <div class="modal-body">
          <div id="savedPlayersAdminBody"></div>
        </div>
        <div class="modal-footer">
          <button id="closeSavedPlayersAdminBtn" class="btn" type="button">Close</button>
        </div>
      </div>
    </div>

    <!-- Cloud Status -->
    <div id="cloudStatus" class="cloud-status checking">
      <span class="cloud-dot"></span>
      <span id="cloudStatusText">Checking cloudâ€¦</span>
    </div>
<script>
/**********************
 * CONFIG: Supabase
 **********************/
const SUPABASE_URL = "https://vvfqumgtasuacpggdmxx.supabase.co";
const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ2ZnF1bWd0YXN1YWNwZ2dkbXh4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5NTk0MDMsImV4cCI6MjA3ODUzNTQwM30.8NblWOwEsY1FP1hxvO6isQ908NyxkTgntnZZiXIFPHE";
const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);

const TABLE_PLAYERS = "players";
const TABLE_HS_LEAGUE = "high_scores";
const TABLE_HS_PRACTICE = "high_scores_sp";
const TABLE_GAME_THROWS = "game_throws";

// Extra tables used for cloud-backed stats
const TABLE_GAMES   = "games";
const TABLE_MATCHES = "matches";

/**********************
 * SAFETY + TOAST
 **********************/
(function(){
  window.addEventListener('error', function(e){
    var b=document.getElementById('__err_banner')||document.createElement('div');
    b.id='__err_banner';
    b.style.cssText='position:fixed;left:0;right:0;top:0;background:#7a2e3f;color:#fff;padding:8px 12px;z-index:999999;font-weight:800';
    b.textContent='JS error: ' + (e.message||'(open console)');
    document.body.appendChild(b);
  });
  if(!window.toast){
    window.toast=function(msg){
      var d=document.createElement('div');
      d.textContent=msg;
      d.style.cssText='position:fixed;left:50%;top:16px;transform:translateX(-50%);background:#121735;border:1px solid #2b3050;color:#e7e9f5;padding:8px 12px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.35);z-index:110000';
      document.body.appendChild(d); setTimeout(function(){d.remove();},1700);
    };
  }
})();

/*****************
 * CORE HELPERS
 *****************/
const byId = id => document.getElementById(id);
const STORAGE_KEY='shateki_quest_scorer_v6';
const HS_KEY='shateki_quest_highscores_v1';       // kept for backward-compat local
const HS_KEY_SP='shateki_quest_highscores_sp_v1'; // kept for backward-compat local
// Long-term history logs (not cleared when a match ends)
const GAMES_LOG_KEY   = 'shateki_quest_games_log_v1';
const MATCHES_LOG_KEY = 'shateki_quest_matches_log_v1';
const safeSave=(k,o)=>{try{localStorage.setItem(k,JSON.stringify(o));}catch(e){}};
const safeLoad=k=>{try{const r=localStorage.getItem(k);return r?JSON.parse(r):null;}catch(e){return null;}};
const safeClear=k=>{try{localStorage.removeItem(k);}catch(e){}};

// Case/whitespace-insensitive player name compare
function eqName(a, b){
  return String(a || '').trim().toLowerCase() === String(b || '').trim().toLowerCase();
}

// Legacy log keys (fallback/migration)
const LEGACY_GAME_KEYS  = ['shateki_quest_games_log', 'shateki_quest_games_log_v0'];
const LEGACY_MATCH_KEYS = ['shateki_quest_matches_log', 'shateki_quest_matches_log_v0'];

// UUID v4 for Supabase match IDs (uuid column)
function genUuidV4() {
  const a = crypto.getRandomValues(new Uint8Array(16));
  a[6] = (a[6] & 0x0f) | 0x40;  // version
  a[8] = (a[8] & 0x3f) | 0x80;  // variant
  const h = [...a].map(b => b.toString(16).padStart(2,'0')).join('');
  return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
}

// Backdate (applies to the NEXT cloud save only)
let _tsOverride = null;

function setBackdateInteractive() {
  const v = prompt('Enter local date/time for *next* cloud save (YYYY-MM-DD HH:MM)');
  if (!v) return;
  const m = v.trim().replace(' ', 'T');
  const dt = new Date(m);
  if (isNaN(dt.getTime())) { toast('Bad date/time'); return; }
  _tsOverride = dt.toISOString();
  toast('Backdate set for next save');
}
function clearBackdate(){ _tsOverride = null; }

// ---------- CORE STATE ----------
const baseState = {
  players: [],
  score: [],
  currentRound: 0,
  currentPlayer: 0,
  currentDart: 0,
  history: [],
  finished: false,
  suddenDeath: { active: false, participants: [], turnIndex: 0, throws: [], round: 1 },
  match: {
    id: null,
    targetWins: 4,      // default "first to 4 wins" â€“ overwritten when you start a match
    gameNumber: 1,
    wins: [],
    history: [],
    completedLogged: false
  },
  matchAgg: null,
  gameAwarded: false
};

let state = JSON.parse(JSON.stringify(baseState));

const COLOR_PALETTE=['#7bdcff','#8cff9e','#ffcc66','#ff9bd6','#f8d66d','#a6b3ff','#7fffd4','#ffb27b','#ffd166','#06d6a0','#118ab2','#ef476f'];
function assignUniqueColors(arr){ for(let i=0;i<arr.length;i++){ arr[i].color = COLOR_PALETTE[i % COLOR_PALETTE.length]; } }

// Cloud status indicator
const cloudStatusEl     = byId('cloudStatus');
const cloudStatusTextEl = byId('cloudStatusText');

function setCloudStatus(mode, text) {
  if (!cloudStatusEl || !cloudStatusTextEl) return;
  cloudStatusEl.classList.remove('ok', 'error', 'checking');
  cloudStatusEl.classList.add(mode);
  cloudStatusTextEl.textContent = text;
}

function markCloudOk() {
  setCloudStatus('ok', 'Cloud: connected');
}
function openGameCompleteDialog() {
  const totals = state.players.map((_, i) => totalScoreForPlayer(i));
  if (!totals.length) return;

  const max = Math.max(...totals);
  const winnerIdx = [];
  totals.forEach((t, i) => {
    if (t === max) winnerIdx.push(i);
  });

  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Game Complete';
  title.style.textAlign = 'center';
  title.style.fontSize = '1.6rem';
  title.style.marginBottom = '10px';

  const body = document.createElement('div');
  body.className = 'modal-body';

  // BIG winner line in the centre
  const winnerP = document.createElement('p');
  winnerP.style.fontWeight = '900';
  winnerP.style.fontSize = '1.8rem';
  winnerP.style.textAlign = 'center';
  winnerP.style.margin = '4px 0 12px';
  winnerP.style.letterSpacing = '0.03em';

  const winnerNames = winnerIdx.map(i => state.players[i].name);
  if (winnerNames.length === 1) {
    winnerP.textContent = `${winnerNames[0]} WINS (${max})`;
  } else {
    winnerP.textContent = `JOINT WINNERS: ${winnerNames.join(' Â· ')} (${max})`;
  }
  body.appendChild(winnerP);

  // Ranked list underneath
  const list = document.createElement('ol');
  list.style.paddingLeft = '20px';
  list.style.margin = '0';

  const ranking = totals
    .map((score, index) => ({ index, score }))
    .sort((a, b) => b.score - a.score);

  ranking.forEach(row => {
    const li = document.createElement('li');
    const name = state.players[row.index].name;
    li.textContent = `${name} â€“ ${row.score}`;
    list.appendChild(li);
  });

  body.appendChild(list);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';
  footer.style.flexDirection = 'column';
  footer.style.alignItems = 'stretch';

  const finishBtn = document.createElement('button');
  finishBtn.className = 'btn good big';
  finishBtn.style.width = '100%';
  finishBtn.textContent = 'Finish Game > Leaderboard';
  finishBtn.onclick = async () => {
    overlay.remove();
    await awardAndShowLeaderboard();
  };

  footer.appendChild(finishBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });

  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });
}

function markCloudError(err) {
  console.error('[Supabase]', err);
  setCloudStatus('error', 'Cloud: problem â€“ using local');
}
function addPadUtilityButtons() {
  const spacer = document.createElement('span');
  spacer.className = 'pad-spacer';
  pad.appendChild(spacer);

  const statsBtn = document.createElement('button');
  statsBtn.className = 'btn';
  statsBtn.textContent = 'Stats';
  statsBtn.onclick = openStatsHubDialog;

  pad.append(statsBtn);
}

function show(id){
  ['details','players','game','leaderboard'].forEach(x=>byId(x)?.classList.add('hidden'));
  byId(id)?.classList.remove('hidden');
  document.body.setAttribute('data-page', id);
  updatePadSpacer();
  const fh=byId('floatHead');
  if(fh) fh.classList.toggle('hidden', id!=='game');
  buildPad();
}
const padBar = byId('padBar');
const pad     = byId('pad');
const padHint = byId('padHint');
function updatePadSpacer(){ try{ const h=padBar?padBar.getBoundingClientRect().height:148; document.documentElement.style.setProperty('--pad-h', h+'px'); }catch(e){} }
addEventListener('resize',updatePadSpacer,{passive:true}); addEventListener('orientationchange',updatePadSpacer,{passive:true});

/*****************
 * GAME & STATE
 *****************/
const ROUNDS = (()=>{ const a=[]; for(let i=0;i<11;i++) a.push({type:'number',target:10+i}); a.push({type:'doubles'},{type:'triples'},{type:'bull'}); return a; })();
function labelForRound(def){
  if (!def) return '';
  if (def.type === 'number')  return String(def.target);
  if (def.type === 'doubles') return 'D';
  if (def.type === 'triples') return 'T';
  if (def.type === 'bull')    return 'B';
  return '';
}
const MAX_ROUNDS=ROUNDS.length;
const totalScoreForPlayer = i => (state.score[i]||[]).reduce((s,row)=>s+(row?.roundTotal||0),0);
const save=()=>safeSave(STORAGE_KEY,state);
function ensureMatchAgg(){ if(state.matchAgg && state.matchAgg.hits) return; state.matchAgg={ hits:Array.from({length:state.players.length},()=>({})), totals60:Array.from({length:state.players.length},()=>0), totals100:Array.from({length:state.players.length},()=>0), totals140:Array.from({length:state.players.length},()=>0) }; }

function getGameLog() {
  const v1 = safeLoad(GAMES_LOG_KEY);
  if (Array.isArray(v1) && v1.length) return v1;

  // Fallback to legacy keys; if found, migrate to v1 for future reads
  for (const k of (LEGACY_GAME_KEYS || [])) {
    const v = safeLoad(k);
    if (Array.isArray(v) && v.length) {
      setGameLog(v);
      return v;
    }
  }
  return [];
}

function setGameLog(arr) {
  safeSave(GAMES_LOG_KEY, arr || []);
}

function getMatchLog() {
  const v1 = safeLoad(MATCHES_LOG_KEY);
  if (Array.isArray(v1) && v1.length) return v1;

  for (const k of (LEGACY_MATCH_KEYS || [])) {
    const v = safeLoad(k);
    if (Array.isArray(v) && v.length) {
      setMatchLog(v);
      return v;
    }
  }
  return [];
}

function setMatchLog(arr) {
  safeSave(MATCHES_LOG_KEY, arr || []);
}

function logCompletedGame(totals, winners, boardClone) {
  const games = getGameLog();
  const nowIso = new Date().toISOString();

  games.push({
    id: `g-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
    ts: nowIso,
    matchId: state.match.id || null,
    players: state.players.map(p => ({ name: p.name })),
    totals: totals.slice(),
    winners: winners.slice(),
    board: boardClone
  });

  setGameLog(games);
}

function logCompletedMatch() {
  const matches = getMatchLog();
  const nowIso = new Date().toISOString();
  const gamesInMatch = state.match.history.length;

  const players = state.players.map(p => ({ name: p.name }));
  const wins    = (state.match.wins || []).slice();

  const matchTotals = state.players.map((_, idx) =>
    state.match.history.reduce((sum, g) => sum + (g.totals?.[idx] || 0), 0)
  );

  matches.push({
    id: state.match.id || `m-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
    ts: nowIso,
    players,
    wins,
    targetWins: state.match.targetWins || 1,
    games: gamesInMatch,
    matchTotals
  });

  setMatchLog(matches);
}

/*****************
 * SUPABASE HELPERS
 *****************/
// simple SHA-256 hex for demo auth (client-side)
async function sha256Hex(text){
  const enc = new TextEncoder().encode(text);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,'0')).join('');
}

// PLAYERS
async function cloudListPlayers(){
  const { data, error } = await sb.from(TABLE_PLAYERS).select('name').order('name');
  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
  return data || [];
}

async function cloudCreatePlayer(name, password){
  const password_hash = await sha256Hex(password);
  const { error } = await sb.from(TABLE_PLAYERS).upsert({ name, password_hash }, { onConflict: 'name' });
  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
}

async function cloudValidatePlayer(name, password){
  const hash = await sha256Hex(password);
  const { data, error } = await sb.from(TABLE_PLAYERS)
    .select('name, password_hash')
    .eq('name', name)
    .maybeSingle();
  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
  if (!data) return false;
  return data.password_hash === hash;
}

async function cloudDeletePlayer(name){
  const { error } = await sb.from(TABLE_PLAYERS).delete().eq('name', name);
  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
}

async function cloudUpdatePlayerPassword(name, newPassword){
  const password_hash = await sha256Hex(newPassword);
  const { error } = await sb.from(TABLE_PLAYERS).update({ password_hash }).eq('name', name);
  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
}

// Simple initial Supabase connectivity check
async function initialCloudCheck() {
  try {
    // keep UI consistent
    setCloudStatus('checking', 'Checking cloudâ€¦');

    // cheap HEAD-style query against players table
    const { error } = await sb
      .from(TABLE_PLAYERS)
      .select('name', { head: true, count: 'exact' });

    if (error) throw error;
    markCloudOk();
  } catch (err) {
    markCloudError(err);
  }
}

// HIGH SCORES
async function cloudInsertHighScore(name, score, single=false){
  const table   = single ? TABLE_HS_PRACTICE : TABLE_HS_LEAGUE;
  const payload = { name, score, ts: new Date().toISOString() };
  const { error } = await sb.from(table).insert(payload);
  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
}

async function cloudListHighScores(single=false, limit=20){
  const table = single ? TABLE_HS_PRACTICE : TABLE_HS_LEAGUE;
  const { data, error } = await sb.from(table)
    .select('name, score, ts')
    .order('score', { ascending:false })
    .order('ts', { ascending:true })
    .limit(limit);
  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
  return data || [];
}

async function cloudDeleteHighScore(row, single=false){
  const table = single ? TABLE_HS_PRACTICE : TABLE_HS_LEAGUE;
  const { error } = await sb.from(table).delete()
    .eq('name', row.name)
    .eq('score', row.score)
    .eq('ts', row.ts);
  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
}
/*****************
 * CLOUD STATS HELPERS
 *****************/
// Map a Supabase `games` row into the same local shape used by stats
function mapCloudGameRowToLocal(row){
  const players = (row?.state?.players || []).map(p => ({ name: p.name }));
  const totals  = Array.isArray(row?.totals) ? row.totals.slice() : [];
  // winners from totals (highest score)
  let max = -Infinity, winners = [];
  totals.forEach((t,i) => { if (t > max) { max = t; winners = [i]; } else if (t === max) { winners.push(i); } });
  return {
    ts: row?.created_at || null,
    players,
    totals,
    winners,
    board: row?.state?.board || null
  };
}

// Fetch *all* games from cloud (we filter by window later)
async function cloudFetchAllGamesAsLocal(){
  const { data, error } = await sb
    .from(TABLE_GAMES)
    .select('created_at,state,totals')
    .order('created_at', { ascending: true });
  if (error) throw error;
  return (data || []).map(mapCloudGameRowToLocal);
}

// Fallback synthesizer: create 1-player "pseudo games" from high_scores rows
async function cloudSynthGamesFromHighScores(playerName){
  const synth = [];

  async function fetchRows(table){
    const { data, error } = await sb
      .from(table)
      .select('name, score, ts')
      .eq('name', playerName)
      .order('ts', { ascending: true });
    if (error) throw error;
    return data || [];
  }

  try {
    const league   = await fetchRows(TABLE_HS_LEAGUE);
    const practice = await fetchRows(TABLE_HS_PRACTICE);

    [...league, ...practice].forEach(row => {
      synth.push({
        ts: row.ts || null,
        players: [{ name: row.name }],
        totals: [Number(row.score) || 0],
        winners: [0],     // unknown; treat as self-only game
        board: null
      });
    });
  } catch(e){
    console.error('cloudSynthGamesFromHighScores failed', e);
  }

  return synth;
}

// Async: compute stats; prefer local logs; else use cloud games; else synth from high_scores
async function computePlayerWindowStatsAsync(playerName) {
  // Load local logs first
  let games   = getGameLog();
  let matches = getMatchLog(); // currently unused in cloud fallback; left for future

  // If none found locally, try cloud `games`
  if (!Array.isArray(games) || games.length === 0) {
    try {
      games = await cloudFetchAllGamesAsLocal();
    } catch(e) {
      console.error('cloudFetchAllGamesAsLocal failed', e);
      games = [];
    }
  }

  // If still nothing, synthesize from high_scores so we show *something*
  if (!games.length) {
    games = await cloudSynthGamesFromHighScores(playerName);
  }

  // Reuse the existing sync window splitter + row computer
  const now = new Date();
  const result = {};
  STAT_WINDOWS.forEach(w => {
    // Window-filtered copies
    const gWin = games.filter(g => {
      if (!g.ts) return false;
      const dt = new Date(g.ts);
      return w.test(dt, now);
    });
    // We donâ€™t have cloud matches wired yet; leave matches empty here
    const stats = computeSingleWindowStats(playerName, gWin, [], w, now);
    result[w.key] = stats;
  });

  // Lifetime across everything (even if ts missing)
  const lifeStats = computeSingleWindowStats(playerName, games, [], { test: ()=>true }, now);
  result['life'] = lifeStats;

  return result;
}
/*****************
 * CLOUD MATCH HELPERS
 *****************/
async function upsertMatchToSupabase(createdAtOverride) {
  try {
    const payload = {
      id: state.match.id,                                                // uuid
      created_at: state.match.createdAtIso || createdAtOverride || new Date().toISOString(),
      total_games: state.match.history.length,
      players: state.players.map(p => ({ name: p.name })),               // [{name}]
      wins: (state.match.wins || []).slice(),
      history: state.match.history.map(g => ({ totals: (g?.totals || []).slice() }))
    };
    const { error } = await sb.from(TABLE_MATCHES).upsert(payload);
    if (error) throw error;
  } catch (e) {
    console.error('upsertMatchToSupabase failed', e);
  }
}

// Map Supabase -> local shapes the stats code already understands
function mapCloudGameRowToLocal(row){
  const players = (row?.state?.players || []).map(p => ({ name: p.name }));
  const totals  = Array.isArray(row?.totals) ? row.totals.slice() : [];
  let max = -Infinity, winners = [];
  totals.forEach((t,i)=>{ if (t>max){max=t; winners=[i];} else if (t===max){ winners.push(i);} });
  return { ts: row?.created_at || null, players, totals, winners, board: row?.state?.board || null };
}
async function cloudFetchAllGamesAsLocal(){
  const { data, error } = await sb
    .from(TABLE_GAMES)
    .select('created_at,state,totals')
    .order('created_at', { ascending: true });
  if (error) throw error;
  return (data || []).map(mapCloudGameRowToLocal);
}

function mapCloudMatchRowToLocal(row){
  const playersArr = Array.isArray(row?.players) ? row.players : [];
  const players = playersArr.map(p => (typeof p === 'string') ? { name: p } : { name: p?.name });
  const wins = Array.isArray(row?.wins) ? row.wins.slice() : [];
  const games = row?.total_games || (Array.isArray(row?.history) ? row.history.length : 0);
  const matchTotals = [];
  if (Array.isArray(row?.history)) {
    row.history.forEach(g => {
      (g?.totals || []).forEach((v,i) => { matchTotals[i] = (matchTotals[i] || 0) + (Number(v)||0); });
    });
  }
  return { id: row?.id, ts: row?.created_at || null, players, wins, targetWins: null, games, matchTotals };
}
async function cloudFetchAllMatchesAsLocal(){
  const { data, error } = await sb
    .from(TABLE_MATCHES)
    .select('id,created_at,players,wins,history,total_games')
    .order('created_at', { ascending: true });
  if (error) throw error;
  return (data || []).map(mapCloudMatchRowToLocal);
}

/*****************
 * CLOUD STATS FALLBACK (games + matches)
 *****************/
async function computePlayerWindowStatsAsync(playerName) {
  // 1) games: local -> cloud -> synth from highscores
  let games = getGameLog();
  if (!Array.isArray(games) || games.length === 0) {
    try { games = await cloudFetchAllGamesAsLocal(); } catch(e){ console.error(e); games = []; }
  }
  if (!games.length) {
    // synth (ensures at least totals/averages show)
    const synth = [];
    async function fetchRows(tbl) {
      const { data, error } = await sb.from(tbl).select('name,score,ts').eq('name', playerName).order('ts',{ascending:true});
      if (error) throw error; return data || [];
    }
    try {
      const league   = await fetchRows(TABLE_HS_LEAGUE);
      const practice = await fetchRows(TABLE_HS_PRACTICE);
      [...league, ...practice].forEach(row => synth.push({
        ts: row.ts || null, players:[{name: row.name}], totals:[Number(row.score)||0], winners:[0], board:null
      }));
      games = synth;
    } catch(e){ console.error('synth from highscores failed', e); }
  }

  // 2) matches: local -> cloud
  let matches = getMatchLog();
  if (!Array.isArray(matches) || matches.length === 0) {
    try { matches = await cloudFetchAllMatchesAsLocal(); } catch(e){ console.error(e); matches = []; }
  }

  const now = new Date();
  const result = {};
  STAT_WINDOWS.forEach(w => {
    const gWin = games.filter(g => g.ts && w.test(new Date(g.ts), now));
    const mWin = matches.filter(m => m.ts && w.test(new Date(m.ts), now));
    result[w.key] = computeSingleWindowStats(playerName, gWin, mWin, w, now);
  });
  result['life'] = computeSingleWindowStats(playerName, games, matches, { test: ()=>true }, now);
  return result;
}
/*****************
 * DETAILS PAGE (page 1)
 *****************/
const resumeBtn=byId('resumeBtn');
function getSavedState(){ 
  try{
    const raw=localStorage.getItem(STORAGE_KEY); 
    if(!raw) return null; 
    const saved=JSON.parse(raw); 
    if(!saved||!Array.isArray(saved.players)||!saved.players.length) return null; 
    return saved;
  }catch(e){ 
    return null; 
  } 
}
function setupStartMenuButtons(){ 
  const saved   = getSavedState(); 
  const hasSaved = !!saved; 

  resumeBtn.disabled = !hasSaved; 
  resumeBtn.title    = hasSaved ? 'Resume last match' : 'No saved match'; 

  if (hasSaved){ 
    resumeBtn.onclick = () => { 
      Object.assign(state, saved); 
      show('game'); 
      assignUniqueColors(state.players); 
      buildEverything(); 
      updateUI(); 
      toast('Resumed last match'); 
    }; 
  } else { 
    resumeBtn.onclick = null; 
  }

  const hsMainBtn = byId('hsMainBtn');
  if (hsMainBtn) {
    hsMainBtn.onclick = openHighScoresMenuDialog;
  }

  const playerStatsBtn = byId('playerStatsBtn');
  if (playerStatsBtn) {
    playerStatsBtn.onclick = openPlayerStatsLookupDialog;
  }
}

byId('questBtn').addEventListener('click', ()=>{
  // go to Player Select
  show('players');
  // sync dropdown defaults from details (if you want, you can keep psNumGames default 5)
});

['startScreenBtn', 'startScreenBtnLB', 'backToDetailsBtn'].forEach(id => {
  document.querySelectorAll('#' + id).forEach(btn => {
    btn.addEventListener('click', () => show('details'));
  });
});

byId('adminEnterBtn').addEventListener('click', ()=>{
  const code=(byId('adminCode')?.value||'').trim();
  if(code.toLowerCase()==='hownowbrowncow'){
    byId('adminCode').value='';
    openAdminHub();
  }else{
    toast('Invalid code');
  }
});

/*****************
 * PLAYER SELECT (page 2)
 *****************/
 const psNumGamesSel   = byId('psNumGames');
const psNumPlayersSel = byId('psNumPlayers');
const psPlayerFields  = byId('psPlayerFields');
function drawPsRows() {
  const count = parseInt(psNumPlayersSel.value, 10) || 2;
  psPlayerFields.innerHTML = '';

  for (let i = 1; i <= count; i++) {
   const row = document.createElement('div');
row.className = 'row pf';
row.style.justifyContent = 'center';
row.style.flexWrap = 'wrap';
row.style.gap = '8px';
    row.style.justifyContent = 'center';
    row.style.gap = '8px';
    row.style.flexWrap = 'wrap';
    row.dataset.index = String(i);

    row.innerHTML = `
      <div class="grow">
        <input placeholder="Guest Player Name" data-role="display">
      </div>
      <button class="btn select-player-btn" type="button">Select Player</button>
      <button class="btn primary save-player-btn" type="button">Save Player</button>
    `;

    psPlayerFields.appendChild(row);
  }

  // Wire buttons for each row
  [...psPlayerFields.querySelectorAll('.pf')].forEach(row => {
    const idx = parseInt(row.dataset.index, 10);
    row.querySelector('.select-player-btn').onclick =
      () => showSelectPlayerDialog(idx);
    row.querySelector('.save-player-btn').onclick =
      () => showAddPlayerDialog(idx);
  });
}

psNumPlayersSel.addEventListener('change', drawPsRows);
psNumGamesSel.addEventListener('change', ()=>{/* nothing else; read on start */});
// ---- Saved players helpers (shared by Add + Select modals) ----
function getSavedPlayers(){
  try { return JSON.parse(localStorage.getItem('shateki_players') || '[]'); }
  catch(e){ return []; }
}
function setSavedPlayers(arr){
  try { localStorage.setItem('shateki_players', JSON.stringify(arr)); }
  catch(e){}
}
function populateSavedPlayersSelects(){
  const arr = getSavedPlayers();
  const sel1 = document.getElementById('existingPlayers');       // Add Player modal
  const sel2 = document.getElementById('existingPlayerSelect');  // Select Player modal
  [sel1, sel2].forEach(sel=>{
    if(!sel) return;
    sel.innerHTML = '<option value=\"\">Select a saved player...</option>' +
      arr.map(p=>`<option value="${p.name}">${p.name}</option>`).join('');
  });
}
async function showAddPlayerDialog(index){
  const modal = byId('addPlayerModal');
  if (!modal) { toast('Add Player modal missing'); return; }

  let chosenName = '';

  function finish(msg){
    const idx = parseInt(modal.dataset.playerIndex || '0', 10) || 1;
    const row =
      document.querySelector(`#psPlayerFields .pf[data-index="${idx}"]`) ||
      document.querySelector(`.pf[data-index="${idx}"]`);
    const input = row?.querySelector('input[data-role="display"]');
    if (input) input.value = chosenName || '';

    // close + reset
    modal.classList.add('hidden');
    byId('newPlayerName').value = '';
    byId('newPlayerPassword').value = '';
    toast(msg);
  }

  // Reset fields
  byId('newPlayerName').value = '';
  byId('newPlayerPassword').value = '';

  // Remember which row invoked the dialog
  modal.dataset.playerIndex = index ? String(index) : '';

  // Show
  modal.classList.remove('hidden');

  // Wire buttons
  const saveBtn   = byId('savePlayerBtn');
  const cancelBtn = byId('cancelAddPlayerBtn');

  saveBtn.onclick = async () => {
    const newName = byId('newPlayerName').value.trim();
    const newPass = byId('newPlayerPassword').value.trim();

    if (!newName || !newPass) {
      toast('Enter name & PIN');
      return;
    }
    if (!/^\d{4}$/.test(newPass)) {
      toast('PIN must be exactly 4 digits');
      return;
    }

    // Local duplicate check (same device)
    const players = getSavedPlayers();
    if (players.some(p => p.name.toLowerCase() === newName.toLowerCase())) {
      toast('Name already exists');
      return;
    }

    // Try cloud create â€“ but DO NOT block local if it fails
    try {
      await cloudCreatePlayer(newName, newPass);
    } catch (err) {
      console.error(err);
      toast('Cloud save failed â€“ saved locally only');
      // fall through to local save
    }

    // Always keep a local cache for offline behaviour
    players.push({ name: newName, password: newPass });
    setSavedPlayers(players);

    chosenName = newName;
    finish('Player saved');
  };

  cancelBtn.onclick = () => modal.classList.add('hidden');
}
function computePlayerThrowStatsFromGames(playerName, gamesSubset) {
  let totalPoints = 0;
  let totalThrows = 0;

  let miss = 0, single = 0, double = 0, treble = 0, bulls = 0;
  const perNumberTotals = {};

  for (const game of gamesSubset) {
    if (!game || !Array.isArray(game.players) || !game.board) continue;

    const pIdx = game.players.findIndex(p => p && eqName(p.name, playerName));
    if (pIdx === -1) continue;

    const board = game.board[pIdx];
    if (!board) continue;

    for (let r = 0; r < MAX_ROUNDS; r++) {
      const roundDef = ROUNDS[r];
      const entry = board[r];
      if (!entry || !entry.darts) continue;

      for (const dart of entry.darts) {
        if (!dart) continue;

        const points = dart.points || 0;
        totalPoints += points;
        totalThrows++;

        if (!points || dart.kind === 'Miss') {
          miss++;
          continue;
        }

        let key = null;

        if (dart.kind === 'Bull') {
          bulls++;
          key = 'Bull';
        } else {
          if (dart.kind === 'S' || dart.kind === 'Single') single++;
          else if (dart.kind === 'D' || dart.kind === 'Double') double++;
          else if (dart.kind === 'T' || dart.kind === 'Triple') treble++;

          if (roundDef.type === 'number') {
            key = String(roundDef.target);
          } else if ((roundDef.type === 'doubles' || roundDef.type === 'triples') && dart.sector) {
            key = String(dart.sector);
          }
        }

        if (key) perNumberTotals[key] = (perNumberTotals[key] || 0) + points;
      }
    }
  }

  const pct = v => totalThrows ? Math.round((v / totalThrows) * 100) : 0;

  let bestKey = null, bestScore = 0;
  let worstKey = null, worstScore = Infinity;

  Object.keys(perNumberTotals).forEach(key => {
    const total = perNumberTotals[key];
    if (total > bestScore) { bestScore = total; bestKey = key; }
    if (total < worstScore) { worstScore = total; worstKey = key; }
  });

  const fmtNum = (key, score) => (!key || !isFinite(score)) ? 'â€”' : (key === 'Bull' ? `Bull (${score})` : `${key} (${score})`);

  return {
    totalPoints,
    totalThrows,
    missPct:   pct(miss),
    singlePct: pct(single),
    doublePct: pct(double),
    treblePct: pct(treble),
    bullsPct:  pct(bulls),
    favouriteNumber: fmtNum(bestKey, bestScore),
    worstNumber:     fmtNum(worstKey, worstScore)
  };
}
const STAT_WINDOWS = [
  { key: 'today',     label: 'Today',         test: (dt, now) => (
      dt.getFullYear() === now.getFullYear() &&
      dt.getMonth()    === now.getMonth() &&
      dt.getDate()     === now.getDate()
    )},
  { key: 'week',      label: '1 Week',        test: (dt, now) => (now - dt) / 86400000 < 7 },
  { key: 'last30',    label: 'Past 30 Days',  test: (dt, now) => (now - dt) / 86400000 < 30 },
  { key: 'days30_60', label: '30â€“60 days',    test: (dt, now) => {
      const d = (now - dt) / 86400000;
      return d >= 30 && d < 60;
    }},
  { key: 'life',      label: 'Lifetime',      test: () => true }
];

function computePlayerWindowStats(playerName) {
  const games   = getGameLog();
  const matches = getMatchLog();
  const now     = new Date();

  const result = {};

  for (const win of STAT_WINDOWS) {
    result[win.key] = computeSingleWindowStats(playerName, games, matches, win, now);
  }

  return result;
}
function computeSingleWindowStats(playerName, games, matches, win, now) {
  const stats = {
    gamesPlayed:  0,
    gamesWon:     0,
    gameWinPct:   0,

    matchesPlayed: 0,
    matchesWon:    0,
    matchWinPct:   0,

    totalPoints:        0,
    avgPointsPerThrow:  0,
    avgPointsPerGame:   0,
    avgPointsPerMatch:  0,

    missPct:   0,
    singlePct: 0,
    doublePct: 0,
    treblePct: 0,
    bullsPct:  0,

    favouriteNumber: 'â€”',
    worstNumber:     'â€”',

    favouriteOpponent: 'â€”',
    nemesis:           'â€”'
  };

  const gamesForPlayer = [];
  const aheadCounts  = {};
  const behindCounts = {};

  // --- Games ---
  for (const game of games) {
    if (!game || !game.ts) continue;
    const dt = new Date(game.ts);
    if (!win.test(dt, now)) continue;
    if (!Array.isArray(game.players)) continue;

    const idx = game.players.findIndex(p => p && eqName(p.name, playerName));
    if (idx === -1) continue;

    gamesForPlayer.push(game);
    stats.gamesPlayed++;

    const total = (game.totals && game.totals[idx]) || 0;
    stats.totalPoints += total;

    const winners = game.winners || [];
    if (winners.includes(idx)) stats.gamesWon++;

    // Opponent stats
    game.players.forEach((p, j) => {
      if (!p || j === idx) return;
      const oppName  = (p.name || '').trim();
      const oppTotal = (game.totals && game.totals[j]) || 0;

      if (total > oppTotal) {
        aheadCounts[oppName]  = (aheadCounts[oppName]  || 0) + 1;
      } else if (total < oppTotal) {
        behindCounts[oppName] = (behindCounts[oppName] || 0) + 1;
      }
    });
  }

  // Throw-level stats
  if (gamesForPlayer.length) {
    const tStats = computePlayerThrowStatsFromGames(playerName, gamesForPlayer);
    stats.missPct   = tStats.missPct;
    stats.singlePct = tStats.singlePct;
    stats.doublePct = tStats.doublePct;
    stats.treblePct = tStats.treblePct;
    stats.bullsPct  = tStats.bullsPct;

    stats.avgPointsPerThrow = tStats.totalThrows
      ? tStats.totalPoints / tStats.totalThrows
      : 0;

    stats.favouriteNumber = tStats.favouriteNumber;
    stats.worstNumber     = tStats.worstNumber;
  }

  stats.gameWinPct = stats.gamesPlayed
    ? (stats.gamesWon / stats.gamesPlayed * 100)
    : 0;

  stats.avgPointsPerGame = stats.gamesPlayed
    ? (stats.totalPoints / stats.gamesPlayed)
    : 0;

  // --- Matches (completed only) ---
  let matchPointsSum = 0;

  for (const match of matches) {
    if (!match || !match.ts) continue;
    const dt = new Date(match.ts);
    if (!win.test(dt, now)) continue;
    if (!Array.isArray(match.players)) continue;

    const idx = match.players.findIndex(p => p && eqName(p.name, playerName));
    if (idx === -1) continue;

    stats.matchesPlayed++;

    const winsArr  = match.wins || [];
    const myWins   = winsArr[idx] || 0;
    const maxWins  = winsArr.length ? Math.max(...winsArr) : 0;
    if (maxWins > 0 && myWins === maxWins) {
      stats.matchesWon++;
    }

    if (match.matchTotals && match.matchTotals[idx] != null) {
      matchPointsSum += match.matchTotals[idx];
    }
  }

  stats.matchWinPct = stats.matchesPlayed
    ? (stats.matchesWon / stats.matchesPlayed * 100)
    : 0;

  stats.avgPointsPerMatch = stats.matchesPlayed
    ? (matchPointsSum / stats.matchesPlayed)
    : 0;

  // Favourite opponent / Nemesis
  const pickMaxName = (map) => {
    let bestName = null, bestVal = 0;
    Object.keys(map).forEach(name => {
      const v = map[name];
      if (v > bestVal) { bestVal = v; bestName = name; }
    });
    return bestVal > 0 ? `${bestName} (${bestVal})` : 'â€”';
    };

  stats.favouriteOpponent = pickMaxName(aheadCounts);
  stats.nemesis           = pickMaxName(behindCounts);

  return stats;
}
async function openPlayerStatsDialog(playerName) {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = `Player Stats â€“ ${playerName}`;

  const body = document.createElement('div');
  body.className = 'modal-body';

  // Try local first; if empty, auto-fallback to cloud (games or high_scores)
  let statsByWindow = computePlayerWindowStats(playerName);
  if (!statsByWindow?.life || (statsByWindow.life.gamesPlayed || 0) === 0) {
    try {
      statsByWindow = await computePlayerWindowStatsAsync(playerName);
    } catch(e) {
      console.error('computePlayerWindowStatsAsync failed', e);
    }
  }

  const table = document.createElement('table');
  table.className = 'hs-table';

  const thead = document.createElement('thead');
  const trh = document.createElement('tr');

  const metricTh = document.createElement('th');
  metricTh.textContent = 'Metric';
  trh.appendChild(metricTh);

  STAT_WINDOWS.forEach(w => {
    const th = document.createElement('th');
    th.textContent = w.label;
    th.style.textAlign = 'center';
    trh.appendChild(th);
  });

  thead.appendChild(trh);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');

  const num = v => (v || 0).toString();
  const avg = (v, has) => (has ? v.toFixed(1) : 'â€”');
  const pct = (v, has) => (has ? v.toFixed(1) + '%' : 'â€”');
  const pctInt = (v, has) => (has ? Math.round(v) + '%' : 'â€”');
  const txt = v => (v && v !== 'NaN' ? v : 'â€”');

  function addRow(label, key, formatter, needsDataKey) {
    const tr = document.createElement('tr');
    const th = document.createElement('th');
    th.className = 'stats-th';
    th.textContent = label;
    tr.appendChild(th);

    STAT_WINDOWS.forEach(w => {
      const td = document.createElement('td');
      td.className = 'center num';
      const s = statsByWindow[w.key] || {};
      const hasData = needsDataKey ? (s[needsDataKey] > 0) : true;
      const v = s[key];
      td.textContent = formatter(v, hasData);
      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  }

  // Games / Matches
  addRow('Games Played',        'gamesPlayed',      num,    'gamesPlayed');
  addRow('Games Won',           'gamesWon',         num,    'gamesPlayed');
  addRow('Win % (Games)',       'gameWinPct',       pct,    'gamesPlayed');
  addRow('Matches Played',      'matchesPlayed',    num,    'matchesPlayed');
  addRow('Matches Won',         'matchesWon',       num,    'matchesPlayed');
  addRow('Win % (Matches)',     'matchWinPct',      pct,    'matchesPlayed');

  // Spacer
  const spacer1 = document.createElement('tr');
  const spTd1 = document.createElement('td');
  spTd1.colSpan = 1 + STAT_WINDOWS.length;
  spTd1.textContent = '';
  spacer1.appendChild(spTd1);
  tbody.appendChild(spacer1);

  // Points
  addRow('Total Points',            'totalPoints',       num,  'gamesPlayed');
  addRow('Avg Points / Throw',      'avgPointsPerThrow', avg,  'gamesPlayed');
  addRow('Avg Points / Game',       'avgPointsPerGame',  avg,  'gamesPlayed');
  addRow('Avg Points / Match',      'avgPointsPerMatch', avg,  'matchesPlayed');

  // Spacer
  const spacer2 = document.createElement('tr');
  const spTd2 = document.createElement('td');
  spTd2.colSpan = 1 + STAT_WINDOWS.length;
  spTd2.textContent = '';
  spacer2.appendChild(spTd2);
  tbody.appendChild(spacer2);

  // Hit-type percentages
  addRow('Miss %',    'missPct',   pctInt, 'gamesPlayed');
  addRow('Single %',  'singlePct', pctInt, 'gamesPlayed');
  addRow('Double %',  'doublePct', pctInt, 'gamesPlayed');
  addRow('Treble %',  'treblePct', pctInt, 'gamesPlayed');
  addRow('Bulls %',   'bullsPct',  pctInt, 'gamesPlayed');

  // Spacer
  const spacer3 = document.createElement('tr');
  const spTd3 = document.createElement('td');
  spTd3.colSpan = 1 + STAT_WINDOWS.length;
  spTd3.textContent = '';
  spacer3.appendChild(spTd3);
  tbody.appendChild(spacer3);

  // Favourite / Worst number
  addRow('Favourite Number', 'favouriteNumber', txt, 'gamesPlayed');
  addRow('Worst Number',     'worstNumber',     txt, 'gamesPlayed');

  // Spacer
  const spacer4 = document.createElement('tr');
  const spTd4 = document.createElement('td');
  spTd4.colSpan = 1 + STAT_WINDOWS.length;
  spTd4.textContent = '';
  spacer4.appendChild(spTd4);
  tbody.appendChild(spacer4);

  // Opponents
  addRow('Favourite Opponent', 'favouriteOpponent', txt, 'gamesPlayed');
  addRow('Nemesis',            'nemesis',           txt, 'gamesPlayed');

  table.appendChild(tbody);
  body.appendChild(table);

  // ---- Lifetime extras (unchanged) ----
  const lifeStats = statsByWindow['life'] || {};
  const extraWrap = document.createElement('div');
  extraWrap.style.marginTop = '10px';
  extraWrap.style.fontSize = '0.9rem';

  const favP = document.createElement('p');
  favP.textContent = 'Favourite Opponent: ' + (lifeStats.favouriteOpponent || 'â€”');
  const nemP = document.createElement('p');
  nemP.textContent = 'Nemesis: ' + (lifeStats.nemesis || 'â€”');

  extraWrap.appendChild(favP);
  extraWrap.appendChild(nemP);

  const sep = document.createElement('hr');
  sep.style.borderColor = '#23284a';
  sep.style.margin = '8px 0';
  extraWrap.appendChild(sep);

  const topTitle = document.createElement('div');
  topTitle.textContent = 'Top Scores (lifetime)';
  topTitle.style.fontWeight = '700';
  topTitle.style.marginBottom = '4px';
  extraWrap.appendChild(topTitle);

  const gamesAll = getGameLog();
  const scores = [];
  (gamesAll || []).forEach(g => {
    if (!g || !Array.isArray(g.players) || !Array.isArray(g.totals)) return;
    const idx = g.players.findIndex(p => p && eqName(p.name, playerName));
    if (idx === -1) return;
    const s = Number(g.totals[idx] || 0);
    scores.push({ score: s, ts: g.ts });
  });
  scores.sort((a, b) => b.score - a.score);
  const top = scores.slice(0, 10);

  if (!top.length) {
    const none = document.createElement('p');
    none.textContent = 'No recorded games yet.';
    none.style.fontStyle = 'italic';
    extraWrap.appendChild(none);
  } else {
    const ol = document.createElement('ol');
    ol.style.paddingLeft = '18px';
    ol.style.margin = '0';
    top.forEach(item => {
      const li = document.createElement('li');
      let when = '';
      if (item.ts) {
        const d = new Date(item.ts);
        if (!Number.isNaN(d.getTime())) {
          when = d.toLocaleDateString(undefined, {
            year: '2-digit',
            month: 'short',
            day: '2-digit'
          });
        }
      }
      li.textContent = when ? `${item.score} (${when})` : String(item.score);
      ol.appendChild(li);
    });
    extraWrap.appendChild(ol);
  }

  body.appendChild(extraWrap);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();

  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });
}
async function openPlayerStatsLookupDialog() {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Player Stats â€“ Select Player';

  const body = document.createElement('div');
  body.className = 'modal-body';

  const nameWrap = document.createElement('div');
  nameWrap.className = 'stack';
  const nameLabel = document.createElement('label');
  nameLabel.className = 'tag';
  nameLabel.textContent = 'Player Name';
  const nameSelect = document.createElement('select');
  nameSelect.id = 'statsPlayerSelect';
  nameSelect.style.width = '100%';
  nameWrap.append(nameLabel, nameSelect);

  const passWrap = document.createElement('div');
  passWrap.className = 'stack';
  passWrap.style.marginTop = '12px';
  const passLabel = document.createElement('label');
  passLabel.className = 'tag';
  passLabel.textContent = 'Password';
  const passInput = document.createElement('input');
  passInput.id = 'statsPlayerPassword';
  passInput.type = 'tel';
  passInput.inputMode = 'numeric';
  passInput.pattern = '\\d{4}';
  passInput.maxLength = 4;
  passInput.placeholder = '4-digit PIN';
  passWrap.append(passLabel, passInput);

  body.append(nameWrap, passWrap);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'btn';
  cancelBtn.textContent = 'Cancel';
  cancelBtn.onclick = () => overlay.remove();

  const viewBtn = document.createElement('button');
  viewBtn.className = 'btn primary';
  viewBtn.textContent = 'View Stats';

  footer.append(cancelBtn, viewBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });

  // Populate players: cloud first, local fallback
  nameSelect.innerHTML = '<option value="">Select a saved player...</option>';
  let anyPlayers = false;

  try {
    const cloudPlayers = await cloudListPlayers();
    cloudPlayers.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      nameSelect.appendChild(opt);
      anyPlayers = true;
    });
  } catch (err) {
    console.error('Stats: cloudListPlayers failed', err);
  }

  if (!anyPlayers) {
    const local = getSavedPlayers();
    local.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      nameSelect.appendChild(opt);
      anyPlayers = true;
    });
  }

  if (!anyPlayers) {
    body.innerHTML = '<p>No saved players found. Save a player from the Player Select screen first.</p>';
    viewBtn.disabled = true;
    return;
  }

  viewBtn.onclick = async () => {
    const name = nameSelect.value;
    const pass = passInput.value.trim();

    if (!name || !pass) {
      toast('Enter player & PIN');
      return;
    }
    if (!/^\d{4}$/.test(pass)) {
      toast('PIN must be exactly 4 digits');
      return;
    }

    let ok = false;

    // Try cloud
    try {
      ok = await cloudValidatePlayer(name, pass);
    } catch (err) {
      console.error('Stats: cloudValidatePlayer failed', err);
    }

    // Fallback local if needed
    if (!ok) {
      const locals = getSavedPlayers();
      const found  = locals.find(p => p.name === name);
      if (!found || found.password !== pass) {
        toast('Incorrect name or password');
        return;
      }
    }

    overlay.remove();
    openPlayerStatsDialog(name);
  };
}
async function showSelectPlayerDialog(index){
  const select = byId('existingPlayerSelect');
  select.innerHTML = '<option value="">Select a saved player...</option>';

  let cloudList = [];
  try {
    cloudList = await cloudListPlayers();
  } catch (err) {
    console.error(err);
    // ignore here â€“ weâ€™ll fall back to local
  }

  let any = false;

  // If we got cloud players, use them
  if (cloudList && cloudList.length) {
    cloudList.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      select.appendChild(opt);
    });
    any = true;
  } else {
    // Fallback: local saved players
    const local = getSavedPlayers();
    if (local && local.length) {
      local.forEach(p => {
        const opt = document.createElement('option');
        opt.value = p.name;
        opt.textContent = p.name;
        select.appendChild(opt);
      });
      any = true;
    }
  }

  if (!any) {
    toast('No saved players found');
    return;
  }

  const modal = byId('selectPlayerModal');
  modal.dataset.playerIndex = String(index);
  modal.classList.remove('hidden');
}

byId('cancelSelectPlayerBtn').addEventListener('click', ()=>{
  byId('existingPlayerSelect').value='';
  byId('playerPassword').value='';
  byId('selectPlayerModal').classList.add('hidden');
});

byId('confirmSelectPlayerBtn').onclick = async () => {
  const modal = byId('selectPlayerModal');
  const idx   = parseInt(modal.dataset.playerIndex || '0', 10) || 1;

 const name = byId('existingPlayerSelect').value;
  const pass = byId('playerPassword').value.trim();

  if (!name || !pass) {
    toast('Enter player & PIN');
    return;
  }
  if (!/^\d{4}$/.test(pass)) {
    toast('PIN must be exactly 4 digits');
    return;
  }

  let ok = false;

  // Try cloud first
  try {
    ok = await cloudValidatePlayer(name, pass);
  } catch (err) {
    console.error(err);
  }

  // Fallback to local cache if cloud fails or returns false
  if (!ok) {
    const players = getSavedPlayers();
    const found   = players.find(p => p.name === name);
    if (!found || found.password !== pass) {
      toast('Incorrect name or password');
      return;
    }
  }

  // Write back into the correct Player Select row
  const row =
    document.querySelector(`#psPlayerFields .pf[data-index="${idx}"]`) ||
    document.querySelector(`.pf[data-index="${idx}"]`);
  const input = row?.querySelector('input[data-role="display"]');
  if (input) input.value = name;

  byId('playerPassword').value = '';
  byId('existingPlayerSelect').value = '';
  modal.classList.add('hidden');
  toast('Player selected');
};

byId('startMatchBtn').addEventListener('click', ()=>{
  const games = parseInt(psNumGamesSel.value,10) || 1;

  const rows = [...psPlayerFields.querySelectorAll('.pf')];
  const ppl = rows.map((row,i)=>({
    name:(row.querySelector('input[data-role="display"]').value||'').trim() || `Player ${i+1}`
  }));
  if (!ppl.length){ toast('Add at least 1 player'); return; }

  state.players = ppl.map(p=>({ name:p.name, color:null }));
  assignUniqueColors(state.players);

  state.match = {
    id: genUuidV4(),
    createdAtIso: _tsOverride || new Date().toISOString(),
    targetWins: games,            // first to X wins
    gameNumber: 1,
    wins: Array.from({length: state.players.length}, () => 0),
    history: [],
    completedLogged: false
  };

  state.matchAgg = null;
  ensureMatchAgg();

  // Will open the throw-order dialog first
  startNewGame(false);
  setupStartMenuButtons();
  save();
});

/*****************
 * BUILDERS
 *****************/
const thead=byId('thead'), tbody=byId('tbody');
const statsThead=byId('statsThead'), statsTbody=byId('statsTbody');
const mstatsThead=byId('mstatsThead'), mstatsTbody=byId('mstatsTbody');
const floatThead=byId('floatThead');

function buildScoreHeader(){ 
  // Main scoreboard header is now minimal â€“ only used for layout/scroll sync.
  thead.innerHTML = '';

  const tr = document.createElement('tr');

  // Left column label
 const thRound = document.createElement('th');
thRound.textContent = '';   // no "Round" label
tr.appendChild(thRound);

  // One blank header cell per player (no Game Wins / names / totals here)
  for (let i = 0; i < state.players.length; i++) {
    const th = document.createElement('th');
    th.className = 'player';
    th.textContent = ''; // keep it visually empty; floating header shows the info
    tr.appendChild(th);
  }

  thead.appendChild(tr);
}

function buildScoreBody(){ 
  tbody.innerHTML = ''; 

  for (let r = 0; r < MAX_ROUNDS; r++) {
    const tr = document.createElement('tr'); 

    // Left-hand round label
    const th = document.createElement('th'); 
    th.textContent = (
      ROUNDS[r].type === 'number'
        ? (ROUNDS[r].target + 's')
        : (ROUNDS[r].type === 'doubles'
            ? "D's"
            : (ROUNDS[r].type === 'triples' ? "T's" : 'Bull'))
    );
    tr.appendChild(th); 

    // Cells: now have main (rolling total) + sub (round total)
    for (let p = 0; p < state.players.length; p++) { 
      const td = document.createElement('td'); 
      td.className = 'center num player'; 
      td.id = `cell-${p}-${r}`;
      td.innerHTML = `
        <div class="cell-wrap">
          <div class="cell-main" id="cell-main-${p}-${r}">â€“</div>
          <div class="cell-sub" id="cell-sub-${p}-${r}"></div>
        </div>
      `;
      tr.appendChild(td);
    } 

    tbody.appendChild(tr);
  } 
}

function buildFloatingHeader(){ 
  floatThead.innerHTML = '';

  // ROW 1: Wins (left cell spans all rows and shows the current round label)
  const trWins = document.createElement('tr');

  const thRound = document.createElement('th');
  thRound.id = 'froundlabel';
  thRound.rowSpan = 3;          // â† one column, spans all 3 rows
  thRound.textContent = '';     // filled by updateUI()
  trWins.appendChild(thRound);

  for (let i = 0; i < state.players.length; i++) { 
    const th = document.createElement('th'); 
    th.className = 'player'; 
    th.style.color = state.players[i].color; 

    const wins = document.createElement('div'); 
    wins.className = 'th-beers'; 
    wins.id = 'fbeers-' + i; 
    wins.textContent = ''; 
    th.appendChild(wins); 

    trWins.appendChild(th);
  }  

  // ROW 2: player names + throws (no left label here because the left cell spans)
  const trNames = document.createElement('tr'); 
  // (no first-cell here)
  for (let i = 0; i < state.players.length; i++) { 
    const th = document.createElement('th'); 
    th.className = 'player'; 
    th.style.color = state.players[i].color; 

    const wrap = document.createElement('div'); 
    wrap.className = 'th-wrap'; 

    const name = document.createElement('div'); 
    name.className = 'th-name'; 
    name.textContent = state.players[i].name; 

    const throws = document.createElement('div');
    throws.className = 'th-throws';
    throws.id = 'fthrows-' + i;
    throws.textContent = '';

    wrap.append(name, throws);
    th.appendChild(wrap); 
    trNames.appendChild(th);
  }  

  // ROW 3: totals + diff
  const trTotals = document.createElement('tr');
  // (no first-cell here)
  for (let i = 0; i < state.players.length; i++) { 
    const th = document.createElement('th'); 
    th.className = 'player'; 

    const total = document.createElement('div'); 
    total.className = 'th-total th-name num'; 
    total.id = 'ftotal-' + i; 
    total.textContent = '0'; 

    const diff = document.createElement('div'); 
    diff.className = 'th-diff'; 
    diff.id = 'fdiff-' + i; 
    diff.textContent = '0'; 

    th.append(total, diff);
    trTotals.appendChild(th);
  }  

  floatThead.append(trWins, trNames, trTotals);
}

/*****************
 * STATS (modal compute)
 *****************/
const METRICS = [
  { key: 'miss',         label: '% Miss',           fmt: v => v + '%' },
  { key: 'single',       label: '% Singles',        fmt: v => v + '%' },
  { key: 'double',       label: '% Doubles',        fmt: v => v + '%' },
  { key: 'treble',       label: '% Trebles',        fmt: v => v + '%' },
  { key: 'bulls',        label: '% Bulls (I+O)',    fmt: v => v + '%' },

  // NEW: per-round power scoring
  { key: 'sixtyPlus',    label: '60+ Rounds',       fmt: v => String(v) },
  { key: 'hundredPlus',  label: '100+ Rounds',      fmt: v => String(v) },
  { key: 'oneFortyPlus', label: '140+ Rounds',      fmt: v => String(v) },

  { key: 'avg9',         label: 'Avg (last 9)',     fmt: v => v.toFixed(1) },
  { key: 'avgRound',     label: 'Avg (round)',      fmt: v => v.toFixed(1) },
  { key: 'avgGame',      label: 'Avg (throw)',      fmt: v => v.toFixed(1) },
  { key: 'singleStreak', label: 'Single Streak',    fmt: v => String(v) },
  { key: 'roundStreak',  label: 'Round Streak',     fmt: v => String(v) },
  { key: 'bestNumber',   label: 'Best Number',      fmt: v => v || 'â€”' }
];
function computeStatsFromBoards(boards, pIdx) {
  // boards: array of [player][round] objects in the same shape as state.score

  const dartsFlat = [];
  const perNumberTotals = {};
  const perRoundHit = [];

  let completedRounds = 0;
  let completedPoints = 0;
  let rounds60 = 0, rounds100 = 0, rounds140 = 0;

  boards.forEach(board => {
    if (!board || !board[pIdx]) return;

    for (let r = 0; r < MAX_ROUNDS; r++) {
      const roundDef = ROUNDS[r];
      const entry = board[pIdx][r];
      if (!entry) continue;

      const d = entry.darts || [];
      const roundIndex = perRoundHit.length;
      perRoundHit.push(false);

      const roundTotal = entry.roundTotal || 0;

      // Track individual darts
      d.forEach(dart => {
        if (!dart) return;
        const p = dart.points || 0;

        dartsFlat.push({ dart, roundIndex, roundDef });

        if (p > 0) {
          perRoundHit[roundIndex] = true;
        }
      });

      // Fully completed round (3 darts thrown) â€“ for avg-round calc
      if (d[0] && d[1] && d[2]) {
        completedRounds++;
        completedPoints += roundTotal;
      }

      // --- 60 / 100 / 140+ are based on ROUND TOTAL ---
      if (roundTotal >= 60)  rounds60++;
      if (roundTotal >= 100) rounds100++;
      if (roundTotal >= 140) rounds140++;

      // Best-number tracking (accumulate by number/sector/bull)
      d.forEach(dart => {
        if (!dart || !(dart.points > 0)) return;
        let key = null;

        if (roundDef.type === 'number') {
          key = String(roundDef.target);
        } else if (roundDef.type === 'doubles' || roundDef.type === 'triples') {
          if (dart.sector) key = String(dart.sector);
        } else if (roundDef.type === 'bull') {
          key = 'Bull';
        }

        if (key) {
          perNumberTotals[key] = (perNumberTotals[key] || 0) + (dart.points || 0);
        }
      });
    }
  });

  const n = dartsFlat.length;
  let miss = 0, singles = 0, doubles = 0, trebles = 0, bulls = 0, pts = 0;

  let currentHitStreak = 0;
  let bestHitStreak = 0;

  for (const { dart } of dartsFlat) {
    const p = dart.points || 0;
    pts += p;

    const isHit = p > 0;
    if (isHit) {
      currentHitStreak++;
      if (currentHitStreak > bestHitStreak) bestHitStreak = currentHitStreak;
    } else {
      currentHitStreak = 0;
    }

    if (dart.kind === 'Miss') miss++;
    else if (dart.kind === 'Bull') bulls++;
    else if (dart.kind === 'S' || dart.kind === 'Single') singles++;
    else if (dart.kind === 'D' || dart.kind === 'Double') doubles++;
    else if (dart.kind === 'T' || dart.kind === 'Triple') trebles++;
  }

  const pct = v => n ? Math.round((v / n) * 100) : 0;

  const last9 = dartsFlat.slice(-9);
  const sum9  = last9.reduce((a, x) => a + (x.dart.points || 0), 0);
  const avg9  = last9.length ? (sum9 / last9.length) : 0;

  const avgGame  = n ? (pts / n) : 0;
  const avgRound = completedRounds ? (completedPoints / completedRounds) : 0;

  // Round streak across all rounds in all boards
  let currentRoundStreak = 0;
  let bestRoundStreak = 0;
  for (const hit of perRoundHit) {
    if (hit) {
      currentRoundStreak++;
      if (currentRoundStreak > bestRoundStreak) bestRoundStreak = currentRoundStreak;
    } else {
      currentRoundStreak = 0;
    }
  }

  // Best number
  let bestNumberKey = null;
  let bestNumberScore = 0;
  Object.keys(perNumberTotals).forEach(key => {
    const total = perNumberTotals[key];
    if (total > bestNumberScore) {
      bestNumberScore = total;
      bestNumberKey = key;
    }
  });
  const bestNumberLabel = bestNumberKey
    ? (bestNumberKey === 'Bull'
        ? `Bull (${bestNumberScore})`
        : `${bestNumberKey} (${bestNumberScore})`)
    : 'â€”';

  return {
    miss: pct(miss),
    single: pct(singles),
    double: pct(doubles),
    treble: pct(trebles),
    bulls: pct(bulls),

    sixtyPlus:    rounds60,
    hundredPlus:  rounds100,
    oneFortyPlus: rounds140,

    avg9,
    avgRound,
    avgGame,
    singleStreak: bestHitStreak,
    roundStreak:  bestRoundStreak,
    bestNumber:   bestNumberLabel,

    totalThrows:  n,
    totalHits:    n - miss,
    totalMisses:  miss,
    bestNumberKey,
    bestNumberScore
  };
}

// Per-game stats (current board only)
function computeStatsForPlayerGame(pIdx) {
  return computeStatsFromBoards([state.score], pIdx);
}

// Per-match stats (all finished games + current game)
function computeStatsForPlayerMatch(pIdx) {
  const boards = [];

  if (state.match && Array.isArray(state.match.history)) {
    state.match.history.forEach(g => {
      if (g && Array.isArray(g.board)) boards.push(g.board);
    });
  }

  if (state.score && state.score[pIdx]) {
    boards.push(state.score);
  }

  if (!boards.length) {
    return computeStatsFromBoards([], pIdx);
  }
  return computeStatsFromBoards(boards, pIdx);
}
function buildStatsHeader(){ 
  statsThead.innerHTML = '';
  const tr = document.createElement('tr');

  const thLabel = document.createElement('th');
  thLabel.textContent = 'Game Stats';
  tr.appendChild(thLabel);

  // one column per player (we keep header blank â€“ names are in the popup)
  for (let i = 0; i < state.players.length; i++) {
    const th = document.createElement('th');
    th.className = 'player';
    tr.appendChild(th);
  }

  statsThead.appendChild(tr);
}

function buildStatsBody(){ 
  statsTbody.innerHTML = '';

  METRICS.forEach(m => {
    const tr = document.createElement('tr');

    const th = document.createElement('th');
    th.className = 'stats-th';
    th.textContent = m.label;
    tr.appendChild(th);

    for (let p = 0; p < state.players.length; p++) {
      const td = document.createElement('td');
      td.className = 'center num player';
      td.id = `stat-${m.key}-${p}`;    // used by updateStatsRows()
      td.textContent = 'â€”';
      tr.appendChild(td);
    }

    statsTbody.appendChild(tr);
  });
}

function buildMatchStatsHeader(){ 
  mstatsThead.innerHTML = '';
  const tr = document.createElement('tr');

  const thLabel = document.createElement('th');
  thLabel.textContent = 'Match Stats';
  tr.appendChild(thLabel);

  for (let i = 0; i < state.players.length; i++) {
    const th = document.createElement('th');
    th.className = 'player';
    tr.appendChild(th);
  }

  mstatsThead.appendChild(tr);
}

function buildMatchStatsBody(){ 
  mstatsTbody.innerHTML = '';

  METRICS.forEach(m => {
    const tr = document.createElement('tr');

    const th = document.createElement('th');
    th.className = 'stats-th';
    th.textContent = m.label;
    tr.appendChild(th);

    for (let p = 0; p < state.players.length; p++) {
      const td = document.createElement('td');
      td.className = 'center num player';
      td.id = `mstat-${m.key}-${p}`;   // used by updateMatchStats()
      td.textContent = 'â€”';
      tr.appendChild(td);
    }

    mstatsTbody.appendChild(tr);
  });
}

// Fill the hidden match-stats table so widths stay in sync and data is there if needed
function updateMatchStats(){ 
  for (let i = 0; i < state.players.length; i++) {
    const v = computeStatsForPlayerMatch(i);
    for (const m of METRICS) {
      const td = byId(`mstat-${m.key}-${i}`);
      if (td) td.textContent = m.fmt(v[m.key]);
    }
  }
}
/*****************
 * UI UPDATE
 *****************/
function buildPad(){ 
  if (!pad) return; 
  pad.innerHTML = ''; 

  const page = document.body.getAttribute('data-page');

  // Leaderboard: no throw pad content
  if (page === 'leaderboard') {
    padHint.textContent = '';
    return;
  }

  // Other non-game pages: no pad
  if (page !== 'game') {
    padHint.textContent = '';
    return;
  }

  // Game page
  padHint.textContent = state.finished ? 'Game finished.' : '';

  if (!state.finished) {
    const r = ROUNDS[state.currentRound];
    if (!r) return;

    // ----- NUMBER ROUNDS (10â€“20) -----
    if (r.type === 'number') {
      const topRow = document.createElement('div');
      topRow.style.display = 'flex';
      topRow.style.gap = '8px';
      topRow.style.width = '100%';

      ['S','D','T'].forEach(k => {
  const b = document.createElement('button');
  b.className = 'btn primary letter-throw';
  b.textContent = k;
        b.style.flex = '1 1 0';
        b.style.minWidth = '0';
        b.onclick = () => recordThrow({ kind: k });
        topRow.appendChild(b);
      });

      pad.appendChild(topRow);

      const bottomRow = document.createElement('div');
bottomRow.style.display = 'flex';
bottomRow.style.gap = '8px';
bottomRow.style.width = '100%';

const miss = document.createElement('button');
miss.className = 'btn danger letter-throw';
miss.textContent = 'Miss';
miss.style.flex = '1 1 0';
miss.style.minWidth = '0';
miss.onclick = () => recordThrow({ kind: 'Miss' });
bottomRow.appendChild(miss);

const undoBtn = document.createElement('button');
undoBtn.className = 'btn warn letter-throw';
undoBtn.textContent = 'Undo';
undoBtn.style.flex = '1 1 0';
undoBtn.style.minWidth = '0';
undoBtn.onclick = undo;
bottomRow.appendChild(undoBtn);

const missGoBtn = document.createElement('button');
missGoBtn.className = 'btn letter-throw';
missGoBtn.textContent = 'Skip Go';
missGoBtn.style.flex = '1 1 0';
missGoBtn.style.minWidth = '0';
missGoBtn.onclick = missGo;
bottomRow.appendChild(missGoBtn);

      pad.appendChild(bottomRow);
      return;
    }

    // ----- DOUBLES / TRIPLES ROUNDS -----
    if (r.type === 'doubles' || r.type === 'triples') {
      padHint.textContent =
        (r.type === 'doubles')
          ? "Doubles round â€“ choose sector"
          : "Triples round â€“ choose sector";

      const grid = document.createElement('div');
      grid.style.display = 'flex';
      grid.style.flexWrap = 'wrap';
      grid.style.gap = '6px';
      grid.style.justifyContent = 'center';

      for (let s = 1; s <= 20; s++) {
        const b = document.createElement('button');
        b.className = 'btn primary small';
        b.textContent = String(s);
        b.style.flex = '0 0 calc(20% - 6px)'; // ~5 columns
        b.onclick = () => recordThrow({ sector: s });
        grid.appendChild(b);
      }

      pad.appendChild(grid);

      const bottomRow = document.createElement('div');
bottomRow.style.display = 'flex';
bottomRow.style.gap = '8px';
bottomRow.style.marginTop = '6px';
bottomRow.style.width = '100%';

const miss = document.createElement('button');
miss.className = 'btn danger letter-throw';
miss.textContent = 'Miss';
miss.style.flex = '1 1 0';
miss.style.minWidth = '0';
miss.onclick = () => recordThrow({ kind: 'Miss' });
bottomRow.appendChild(miss);

const undoBtn = document.createElement('button');
undoBtn.className = 'btn warn letter-throw';
undoBtn.textContent = 'Undo';
undoBtn.style.flex = '1 1 0';
undoBtn.style.minWidth = '0';
undoBtn.onclick = undo;
bottomRow.appendChild(undoBtn);

const missGoBtn = document.createElement('button');
missGoBtn.className = 'btn letter-throw';
missGoBtn.textContent = 'Skip Go';
missGoBtn.style.flex = '1 1 0';
missGoBtn.style.minWidth = '0';
missGoBtn.onclick = missGo;
bottomRow.appendChild(missGoBtn);

      pad.appendChild(bottomRow);
      return;
    }

    // ----- BULL ROUND -----
    if (r.type === 'bull') {
      padHint.textContent = 'Bull round â€“ Outer (25) or Inner (50).';

      const topRow = document.createElement('div');
      topRow.style.display = 'flex';
      topRow.style.gap = '8px';
      topRow.style.width = '100%';

      const outerBtn = document.createElement('button');
      outerBtn.className = 'btn primary';
      outerBtn.textContent = 'Outer Bull (25)';
      outerBtn.style.flex = '1 1 0';
      outerBtn.onclick = () => recordThrow({ bull: 'Outer' });
      topRow.appendChild(outerBtn);

      const innerBtn = document.createElement('button');
      innerBtn.className = 'btn primary';
      innerBtn.textContent = 'Inner Bull (50)';
      innerBtn.style.flex = '1 1 0';
      innerBtn.onclick = () => recordThrow({ bull: 'Inner' });
      topRow.appendChild(innerBtn);

      pad.appendChild(topRow);

      const bottomRow = document.createElement('div');
bottomRow.style.display = 'flex';
bottomRow.style.gap = '8px';
bottomRow.style.marginTop = '6px';
bottomRow.style.width = '100%';

const miss = document.createElement('button');
miss.className = 'btn danger letter-throw';
miss.textContent = 'Miss';
miss.style.flex = '1 1 0';
miss.style.minWidth = '0';
miss.onclick = () => recordThrow({ kind: 'Miss' });
bottomRow.appendChild(miss);

const undoBtn = document.createElement('button');
undoBtn.className = 'btn warn letter-throw';
undoBtn.textContent = 'Undo';
undoBtn.style.flex = '1 1 0';
undoBtn.style.minWidth = '0';
undoBtn.onclick = undo;
bottomRow.appendChild(undoBtn);

const missGoBtn = document.createElement('button');
missGoBtn.className = 'btn letter-throw';
missGoBtn.textContent = 'Skip Go';
missGoBtn.style.flex = '1 1 0';
missGoBtn.style.minWidth = '0';
missGoBtn.onclick = missGo;
bottomRow.appendChild(missGoBtn);

      pad.appendChild(bottomRow);
      return;
    }
  }

  // Finished game: show button to go to leaderboard
  const finishBtn = document.createElement('button');
  finishBtn.className = 'btn good';
  finishBtn.style.minWidth = '220px';
  finishBtn.textContent = 'Finish Game â†’ Leaderboard';
  finishBtn.onclick = async () => {
    state.finished = false;
    await awardAndShowLeaderboard();
  };
  pad.appendChild(finishBtn);
}

/*****************
 * DIALOGS (Stats / Race / High Scores)
 *****************/
function openStatsHubDialog(){
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Stats Hub';

  const body = document.createElement('div');
  body.className = 'modal-body';

  const row = document.createElement('div');
  row.className = 'row';
  row.style.flexWrap = 'wrap';
  row.style.gap = '8px';

  function addBtn(label, handler){
    const b = document.createElement('button');
    b.className = 'btn';
    b.textContent = label;
    b.style.flex = '1 1 45%';
    b.onclick = () => {
      overlay.remove();
      handler();
    };
    row.appendChild(b);
  }

  addBtn('Game Stats',  openGameStatsDialog);
  addBtn('Match Stats', openMatchStatsDialog);
  addBtn('Game Race',   openGameRaceDialog);
  addBtn('High Scores (League)',  () => openHighScoresDialog(false));
  addBtn('High Scores (Practice)', () => openHighScoresDialogSP(true));
  addBtn('Low Scores (League)',   openLowScoresDialog);

  body.appendChild(row);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();
  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}

function openGameStatsDialog(){
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Game Stats';

  const body = document.createElement('div');
  body.className = 'modal-body';

  const table = document.createElement('table');
  table.className = 'hs-table';

  const thead = document.createElement('thead');
  const trh   = document.createElement('tr');

  const metricTh = document.createElement('th');
  metricTh.textContent = 'Metric';
  trh.appendChild(metricTh);

  state.players.forEach(p => {
    const th = document.createElement('th');
    th.textContent = p.name;
    th.style.textAlign = 'center';
    trh.appendChild(th);
  });

  thead.appendChild(trh);
  table.appendChild(thead);

  const tb = document.createElement('tbody');
  const vByP = state.players.map((_, i) => computeStatsForPlayerGame(i));

  METRICS.forEach(m => {
    const tr = document.createElement('tr');

    const th = document.createElement('th');
    th.className = 'stats-th';
    th.textContent = m.label;
    tr.appendChild(th);

    state.players.forEach((_, i) => {
      const td = document.createElement('td');
      td.className = 'center num';
      td.textContent = m.fmt(vByP[i][m.key]);
      tr.appendChild(td);
    });

    tb.appendChild(tr);
  });

  table.appendChild(tb);
  body.appendChild(table);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = () => {
    overlay.remove();
    openStatsHubDialog();
  };

  footer.appendChild(backBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
 overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}

function openMatchStatsDialog(){ 
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Match Stats';

  const body = document.createElement('div');
  body.className = 'modal-body';

  const table = document.createElement('table');
  table.className = 'hs-table';

  const thead = document.createElement('thead');
  const trh   = document.createElement('tr');

  const metricTh = document.createElement('th');
  metricTh.textContent = 'Metric';
  trh.appendChild(metricTh);

  state.players.forEach(p => {
    const th = document.createElement('th');
    th.textContent = p.name;
    th.style.textAlign = 'center';
    trh.appendChild(th);
  });

  thead.appendChild(trh);
  table.appendChild(thead);

  const tb  = document.createElement('tbody');
  const vByP = state.players.map((_, i) => computeStatsForPlayerMatch(i));

  METRICS.forEach(m => {
    const tr = document.createElement('tr');

    const th = document.createElement('th');
    th.textContent = m.label;
    th.className   = 'stats-th';
    tr.appendChild(th);

    state.players.forEach((_, i) => {
      const td = document.createElement('td');
      td.className = 'center num';
      td.textContent = m.fmt(vByP[i][m.key]);
      tr.appendChild(td);
    });

    tb.appendChild(tr);
  });

  table.appendChild(tb);
  body.appendChild(table);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = () => overlay.remove();
  footer.appendChild(backBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });
}
function openHighScoresMenuDialog() {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'High Scores';

  const body = document.createElement('div');
  body.className = 'modal-body';
  body.style.display = 'flex';
  body.style.flexDirection = 'column';
  body.style.alignItems = 'center';
  body.style.justifyContent = 'center';
  body.style.gap = '10px';

  // 1) High Scores Official
  const officialBtn = document.createElement('button');
  officialBtn.className = 'btn primary big';
  officialBtn.textContent = 'High Scores (Official)';
  officialBtn.style.minWidth = '220px';
  officialBtn.onclick = () => {
    overlay.remove();
    openHighScoresDialog();      // existing function â€“ official / league table
  };

  // 2) High Scores Practice
  const practiceBtn = document.createElement('button');
  practiceBtn.className = 'btn big';
  practiceBtn.textContent = 'High Scores (Practice)';
  practiceBtn.style.minWidth = '220px';
  practiceBtn.onclick = () => {
    overlay.remove();
    openHighScoresDialogSP();    // existing function â€“ practice table
  };

  // Separator line: the "---"
  const sep = document.createElement('hr');
  sep.style.width = '100%';
  sep.style.borderColor = '#23284a';
  sep.style.margin = '10px 0';

  // 3) Top 10 â€“ Avg Round (opens sub-menu)
  const top10Btn = document.createElement('button');
  top10Btn.className = 'btn';
  top10Btn.textContent = 'Top 10 â€“ Avg Round';
  top10Btn.style.minWidth = '220px';
  top10Btn.onclick = () => {
    overlay.remove();
    openTopTenAvgRoundMenuDialog();   // new sub-menu (Last 10 Games / Lifetime)
  };

  body.appendChild(officialBtn);
  body.appendChild(practiceBtn);
  body.appendChild(sep);
  body.appendChild(top10Btn);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();

  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });

  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });
}

// >>> ADD THESE TWO NEW FUNCTIONS HERE <<<

function openTopTenAvgRoundMenuDialog() {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Top 10 â€“ Avg Round';

  const body = document.createElement('div');
  body.className = 'modal-body';
  body.style.display = 'flex';
  body.style.flexDirection = 'column';
  body.style.alignItems = 'center';
  body.style.justifyContent = 'center';
  body.style.gap = '10px';

  const last10Btn = document.createElement('button');
  last10Btn.className = 'btn primary big';
  last10Btn.textContent = 'Last 10 Games';
  last10Btn.style.minWidth = '220px';
  last10Btn.onclick = () => {
    overlay.remove();
    openTopTenAvgRoundDialog('last10');
  };

  const lifetimeBtn = document.createElement('button');
  lifetimeBtn.className = 'btn big';
  lifetimeBtn.textContent = 'Lifetime';
  lifetimeBtn.style.minWidth = '220px';
  lifetimeBtn.onclick = () => {
    overlay.remove();
    openTopTenAvgRoundDialog('lifetime');
  };

  body.appendChild(last10Btn);
  body.appendChild(lifetimeBtn);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = () => {
    overlay.remove();
    openHighScoresMenuDialog();
  };

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();

  footer.appendChild(backBtn);
  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });
}

function openTopTenAvgRoundDialog(mode) {
  // mode = 'last10' | 'lifetime'
  const games = getGameLog();   // uses your existing long-term game log
  if (!games || !games.length) {
    toast('No recorded games yet.');
    return;
  }

  // Choose which games to include
  let sourceGames;
  if (mode === 'last10') {
    const sorted = games.slice().sort((a, b) => {
      const ta = a.ts ? new Date(a.ts).getTime() : 0;
      const tb = b.ts ? new Date(b.ts).getTime() : 0;
      return ta - tb;
    });
    sourceGames = sorted.slice(-10);   // last 10 games
  } else {
    sourceGames = games;               // all games (lifetime)
  }

  // Build per-game, per-player entries ranked by average per round
  const entries = [];

  sourceGames.forEach(g => {
    if (!g || !Array.isArray(g.players) || !Array.isArray(g.totals)) return;

    const board = g.board || [];
    g.players.forEach((p, idx) => {
      if (!p) return;

      const total = Number(g.totals[idx] || 0);
      if (!total) return;

      let roundsPlayed = 0;

      // Try to count actual rounds with any darts for this player
      if (board[idx] && Array.isArray(board[idx])) {
        for (let r = 0; r < MAX_ROUNDS; r++) {
          const entry = board[idx][r];
          if (entry && entry.darts && entry.darts.some(d => d)) {
            roundsPlayed++;
          }
        }
      }

      if (!roundsPlayed) {
        roundsPlayed = MAX_ROUNDS; // fallback: full game
      }

      if (!roundsPlayed) return;

      const avgRound = total / roundsPlayed;

      entries.push({
        name: p.name,
        score: total,
        avgRound,
        ts: g.ts || null
      });
    });
  });

  if (!entries.length) {
    toast('No scoring data for this view.');
    return;
  }

  // Sort by average per round (desc), then by total score
  entries.sort((a, b) => {
    if (b.avgRound !== a.avgRound) return b.avgRound - a.avgRound;
    return b.score - a.score;
  });

  const top = entries.slice(0, 10);  // Top 10

  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent =
    mode === 'last10'
      ? 'Top 10 â€“ Avg Round (Last 10 Games)'
      : 'Top 10 â€“ Avg Round (Lifetime)';

  const body = document.createElement('div');
  body.className = 'modal-body';

  const table = document.createElement('table');
  table.className = 'hs-table';

  const thead = document.createElement('thead');
  const trh   = document.createElement('tr');

  ['#','Player','Avg / Round','Total Score','When'].forEach(h => {
    const th = document.createElement('th');
    th.textContent = h;
    trh.appendChild(th);
  });

  thead.appendChild(trh);
  table.appendChild(thead);

  const tb = document.createElement('tbody');

  top.forEach((row, idx) => {
    const tr = document.createElement('tr');

    const tdRank = document.createElement('td');
    tdRank.textContent = String(idx + 1);

    const tdName = document.createElement('td');
    tdName.textContent = row.name;

    const tdAvg = document.createElement('td');
    tdAvg.textContent = row.avgRound.toFixed(1);

    const tdScore = document.createElement('td');
    tdScore.textContent = String(row.score);

    const tdWhen = document.createElement('td');
    if (row.ts) {
      const d = new Date(row.ts);
      tdWhen.textContent = !Number.isNaN(d.getTime())
        ? d.toLocaleString(undefined, {
            year: '2-digit',
            month: 'short',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
          })
        : '';
    } else {
      tdWhen.textContent = '';
    }
    tdWhen.style.fontSize = '0.8rem';

    tr.append(tdRank, tdName, tdAvg, tdScore, tdWhen);
    tb.appendChild(tr);
  });

  table.appendChild(tb);
  body.appendChild(table);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = () => {
    overlay.remove();
    openTopTenAvgRoundMenuDialog();
  };

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();

  footer.appendChild(backBtn);
  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });
}
async function openHighScoresDialog(){ 
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'High Scores (Official)';

  const body = document.createElement('div');
  body.className = 'modal-body';

  try {
    const list = await cloudListHighScores(false, 20); // TOP 20 ONLY

    if (!list.length) {
      const p = document.createElement('p');
      p.textContent = 'No high scores yet.';
      body.appendChild(p);
    } else {
      const table = document.createElement('table');
      table.className = 'hs-table';

      const thead = document.createElement('thead');
      const trh   = document.createElement('tr');

      ['#','Player','Score','Avg / Round','When'].forEach(h => {
        const th = document.createElement('th');
        th.textContent = h;
        trh.appendChild(th);
      });

      thead.appendChild(trh);
      table.appendChild(thead);

      const tb = document.createElement('tbody');

      list.forEach((row, idx) => {
        const tr = document.createElement('tr');

        const td1 = document.createElement('td');
        td1.textContent = String(idx + 1);

        const td2 = document.createElement('td');
        td2.textContent = row.name;

        const td3 = document.createElement('td');
        td3.textContent = String(row.score);

        const td4 = document.createElement('td');
        const avgRound = typeof MAX_ROUNDS === 'number' && MAX_ROUNDS > 0
          ? (Number(row.score || 0) / MAX_ROUNDS)
          : 0;
        td4.textContent = avgRound.toFixed(1);

        const td5 = document.createElement('td');
        const d = new Date(row.ts);
        td5.textContent = !Number.isNaN(d.getTime())
          ? d.toLocaleString(undefined, {
              year: '2-digit',
              month: 'short',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit'
            })
          : '';
        td5.style.fontSize = '0.8rem';

        tr.append(td1, td2, td3, td4, td5);
        tb.appendChild(tr);
      });

      table.appendChild(tb);
      body.appendChild(table);
    }
  } catch (err) {
    console.error(err);
    const p = document.createElement('p');
    p.textContent = 'Failed to load high scores.';
    body.appendChild(p);
  }

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();
  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });
}
async function openHighScoresDialogSP(){ 
  const overlay=document.createElement('div'); overlay.className='modal-backdrop'; 
  const modal=document.createElement('div'); modal.className='modal'; 
  const title=document.createElement('h3'); 
  title.textContent='High Scores (Practice)'; 
  const body=document.createElement('div'); body.className='modal-body'; 

  try{
    // practice = single-player table
    const list = await cloudListHighScores(true, 20);   // TOP 20 ONLY
    if(!list.length){ 
      const p=document.createElement('p'); 
      p.textContent='No high scores yet.'; 
      body.appendChild(p); 
    } else {
      const table=document.createElement('table'); 
      table.className='hs-table';
      const thead=document.createElement('thead'); 
      const trh=document.createElement('tr');

      ['#','Player','Score','Avg / Round','When'].forEach(h=>{
        const th=document.createElement('th'); 
        th.textContent=h; 
        trh.appendChild(th);
      }); 
      thead.appendChild(trh); 
      table.appendChild(thead);

      const tb=document.createElement('tbody');
      list.forEach((row,idx)=>{ 
        const tr=document.createElement('tr'); 

        const td1=document.createElement('td'); 
        td1.textContent=String(idx+1);

        const td2=document.createElement('td'); 
        td2.textContent=row.name;

        const td3=document.createElement('td'); 
        td3.textContent=String(row.score);

        const td4=document.createElement('td');
        const avgRound = MAX_ROUNDS ? (Number(row.score || 0) / MAX_ROUNDS) : 0;
        td4.textContent = avgRound.toFixed(1);

        const td5=document.createElement('td'); 
        const d = new Date(row.ts);
        td5.textContent = !Number.isNaN(d.getTime())
          ? d.toLocaleString(undefined, {
              year: '2-digit',
              month: 'short',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit'
            })
          : '';
        td5.style.fontSize = '0.8rem';

        tr.append(td1,td2,td3,td4,td5); 
        tb.appendChild(tr);
      });
      table.appendChild(tb); 
      body.appendChild(table);
    }
  }catch(err){ 
    console.error(err); 
    const p=document.createElement('p'); 
    p.textContent='Failed to load high scores.'; 
    body.appendChild(p); 
  }

  const footer=document.createElement('div'); 
  footer.className='modal-footer'; 
  const closeBtn=document.createElement('button'); 
  closeBtn.className='btn'; 
  closeBtn.textContent='Close'; 
  closeBtn.onclick=()=>overlay.remove(); 
  footer.appendChild(closeBtn); 

  modal.append(title,body,footer); 
  overlay.appendChild(modal); 
  document.body.appendChild(overlay); 

  modal.tabIndex=0; 
  modal.focus(); 

  overlay.addEventListener('click',e=>{ if(e.target===overlay) overlay.remove();}); 
  overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') overlay.remove();});
}
async function openLowScoresDialog(){ 
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop'; 

  const modal = document.createElement('div');
  modal.className = 'modal'; 

  const title = document.createElement('h3');
  title.textContent = 'Low Scores (Official)'; 

  const body = document.createElement('div');
  body.className = 'modal-body'; 

  try {
    // League low scores = official high_scores table sorted ASCENDING
    const { data, error } = await sb
      .from(TABLE_HS_LEAGUE)
      .select('name, score, ts')
      .order('score', { ascending: true })   // lowest first
      .order('ts',    { ascending: true })   // oldest first for ties
      .limit(20);                            // bottom 20

    if (error) throw error;

    const list = data || [];

    if (!list.length) { 
      const p = document.createElement('p'); 
      p.textContent = 'No scores recorded yet.'; 
      body.appendChild(p); 
    } else {
      const table = document.createElement('table'); 
      table.className = 'hs-table';

      const thead = document.createElement('thead'); 
      const trh   = document.createElement('tr');

      ['#','Player','Score','Avg / Round','When'].forEach(h => {
        const th = document.createElement('th'); 
        th.textContent = h; 
        trh.appendChild(th);
      }); 

      thead.appendChild(trh); 
      table.appendChild(thead);

      const tb = document.createElement('tbody');

      list.forEach((row, idx) => { 
        const tr = document.createElement('tr'); 

        const td1 = document.createElement('td'); 
        td1.textContent = String(idx + 1);

        const td2 = document.createElement('td'); 
        td2.textContent = row.name;

        const td3 = document.createElement('td'); 
        td3.textContent = String(row.score);

        const td4 = document.createElement('td');
        const avgRound = MAX_ROUNDS
          ? (Number(row.score || 0) / MAX_ROUNDS)
          : 0;
        td4.textContent = avgRound.toFixed(1);

        const td5 = document.createElement('td'); 
        const d = new Date(row.ts);
        td5.textContent = !Number.isNaN(d.getTime())
          ? d.toLocaleString(undefined, {
              year: '2-digit',
              month: 'short',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit'
            })
          : '';
        td5.style.fontSize = '0.8rem';

        tr.append(td1, td2, td3, td4, td5); 
        tb.appendChild(tr);
      });

      table.appendChild(tb); 
      body.appendChild(table);
    }
  } catch (err) { 
    console.error(err); 
    const p = document.createElement('p'); 
    p.textContent = 'Failed to load low scores.'; 
    body.appendChild(p); 
  }

  const footer = document.createElement('div'); 
  footer.className = 'modal-footer'; 

  const closeBtn = document.createElement('button'); 
  closeBtn.className = 'btn'; 
  closeBtn.textContent = 'Close'; 
  closeBtn.onclick = () => overlay.remove(); 

  footer.appendChild(closeBtn); 

  modal.append(title, body, footer); 
  overlay.appendChild(modal); 
  document.body.appendChild(overlay); 

  modal.tabIndex = 0; 
  modal.focus(); 

  overlay.addEventListener('click', e => { 
    if (e.target === overlay) overlay.remove();
  }); 

  overlay.addEventListener('keydown', e => { 
    if (e.key === 'Escape') overlay.remove();
  });
}
function updateUI() {
  if (!tbody) return;

  // Clear previous highlights
  document.querySelectorAll('.current-cell, .current-col').forEach(el => {
    el.classList.remove('current-cell', 'current-col');
  });

  // --- Precompute per-round totals to find best round per row ---
  const roundTotals    = Array.from({ length: MAX_ROUNDS }, () => Array(state.players.length).fill(0));
  const roundHasScore  = Array.from({ length: MAX_ROUNDS }, () => Array(state.players.length).fill(false));

  for (let p = 0; p < state.players.length; p++) {
    for (let r = 0; r < MAX_ROUNDS; r++) {
      const entry   = state.score?.[p]?.[r];
      const hasDart = !!(entry && entry.darts && entry.darts.some(d => d));

      if (!entry || !hasDart) continue;

      const rt = entry.roundTotal || 0;
      roundTotals[r][p]   = rt;
      roundHasScore[r][p] = true;
    }
  }

  const maxRoundTotals = roundTotals.map(row =>
    row.length ? Math.max(...row) : 0
  );

  // --- Fill cells: rolling total + (round score) + best-round highlight ---
  for (let p = 0; p < state.players.length; p++) {
    let running = 0;

    for (let r = 0; r < MAX_ROUNDS; r++) {
      const td = byId(`cell-${p}-${r}`);
      if (!td) continue;

      const entry      = state.score?.[p]?.[r];
      const hasDart    = roundHasScore[r][p];
      const roundTotal = hasDart ? (entry?.roundTotal || 0) : 0;

      const mainEl = byId(`cell-main-${p}-${r}`);
      const subEl  = byId(`cell-sub-${p}-${r}`);

      if (hasDart) {
        running += roundTotal;
        if (mainEl) mainEl.textContent = String(running);
        if (subEl) {
          subEl.textContent = `(${roundTotal})`;
          subEl.classList.remove('sub-win');
          if (roundTotal > 0 && roundTotal === maxRoundTotals[r]) {
            // highest round score this row â€“ green
            subEl.classList.add('sub-win');
          }
        }
      } else {
        if (mainEl) mainEl.textContent = 'â€“';
        if (subEl) {
          subEl.textContent = '';
          subEl.classList.remove('sub-win');
        }
      }

      td.classList.remove('current-cell', 'current-col');
      if (p === state.currentPlayer) {
        td.classList.add('current-col');
      }
    }
  }

  // Highlight the current cell (round + player)
  const cp = state.currentPlayer;
  const cr = state.currentRound;
  const currentCell = byId(`cell-${cp}-${cr}`);
  if (currentCell) {
    currentCell.classList.add('current-cell');
    currentCell.classList.add('current-col');
  }
  
 // Current round label in floating header (single column)
const roundLabelEl = byId('froundlabel');
if (roundLabelEl) {
  const lbl = labelForRound(ROUNDS[state.currentRound]) || '';
  roundLabelEl.innerHTML = `
    <div class="round-now">
      <div class="rn-label">TARGET</div>
      <div class="rn-value">${lbl}</div>
    </div>
  `;
}

  // --- update floating header (wins, totals, diffs, turn arrow, throws remaining) ---
  const totals = state.players.map((_, i) => totalScoreForPlayer(i));
  const max    = totals.length ? Math.max(...totals) : 0;
  const targetWins = state.match.targetWins || 1;
  for (let i = 0; i < state.players.length; i++) {
    
    // Totals
    const totalEl = byId('ftotal-' + i);
    if (totalEl) {
      totalEl.textContent = String(totals[i] || 0);
      totalEl.classList.remove('leader-total');
      if (max > 0 && totals[i] === max) {
        // overall leader(s) â€“ green total
        totalEl.classList.add('leader-total');
      }
    }

    // Diff
    const diffEl = byId('fdiff-' + i);
    if (diffEl) {
      const diff = totals[i] - max;
      diffEl.textContent = String(diff);
    }

  // Wins â€“ trophies for wins, circles for remaining games
    const winsEl = byId('fbeers-' + i);
    if (winsEl) {
      const wins = state.match.wins?.[i] || 0;
      let bubbles = '';
      for (let k = 0; k < targetWins; k++) {
        bubbles += k < wins ? 'ðŸ†' : 'â—‹';
      }
      winsEl.textContent = bubbles;
    }

    // Throws remaining (targets)
    const throwsEl = byId('fthrows-' + i);
    if (throwsEl) {
      throwsEl.textContent = '';
      if (!state.finished && i === state.currentPlayer) {
        const remaining = 3 - state.currentDart;   // 3, 2, or 1
        let icons = '';
        for (let k = 0; k < remaining; k++) icons += 'ðŸŽ¯';
        throwsEl.textContent = icons;
      }
    }
  }

  // --- end-of-game banner ---
 const banner = byId('endBanner');
  if (banner) {
    banner.classList.add('hidden');
    banner.textContent = '';
  }

  // --- match stats table (hidden but kept in sync) ---
  try {
    updateMatchStats();
  } catch (e) {
    console.error(e);
  }

  // --- rebuild throw pad + layout + save ---
  buildPad();
  updatePadSpacer();
  save();
}


/* >>> INSERT THESE TWO NEW FUNCTIONS <<< */
function recordThrow(spec){
  // Ignore input if game is finished or in sudden death
  if (state.finished || state.suddenDeath.active) return;

  const rIndex    = state.currentRound;
  const pIndex    = state.currentPlayer;
  const dartIndex = state.currentDart;

  if (rIndex < 0 || rIndex >= MAX_ROUNDS) return;
  if (pIndex < 0 || pIndex >= state.players.length) return;
  if (dartIndex < 0 || dartIndex > 2) return;

  const wasFinished = state.finished;

  const board = state.score[pIndex];
  if (!board) return;
  const entry = board[rIndex];
  if (!entry) return;
  if (!entry.darts) entry.darts = [null, null, null];

  const roundDef = ROUNDS[rIndex];

  let points = 0;
  let hitKey = null;
  let dartObj;

  if (spec.kind === 'Miss') {
    dartObj = { kind: 'Miss', points: 0 };
  } else if (roundDef.type === 'number') {
    const base = roundDef.target;
    if (spec.kind === 'S')      points = base;
    else if (spec.kind === 'D') points = base * 2;
    else if (spec.kind === 'T') points = base * 3;

    dartObj = { kind: spec.kind, points };
    hitKey  = String(base);
  } else if (roundDef.type === 'doubles' || roundDef.type === 'triples') {
    const sector = spec.sector || 0;
    if (!sector) {
      dartObj = { kind: 'Miss', points: 0 };
    } else {
      const mult = roundDef.type === 'doubles' ? 2 : 3;
      points = sector * mult;
      dartObj = {
        kind: roundDef.type === 'doubles' ? 'Double' : 'Triple',
        sector,
        points
      };
      hitKey = String(sector);
    }
  } else if (roundDef.type === 'bull') {
    const bull = spec.bull || 'Outer';
    points = bull === 'Inner' ? 50 : 25;
    dartObj = { kind: 'Bull', bull, points };
    hitKey  = 'Bull';
  } else {
    dartObj = { kind: 'Miss', points: 0 };
  }

  // Write dart
  entry.darts[dartIndex] = dartObj;
  entry.roundTotal =
    (entry.darts[0]?.points || 0) +
    (entry.darts[1]?.points || 0) +
    (entry.darts[2]?.points || 0);

  // History (for Undo)
  state.history.push({
    player:    pIndex,
    round:     rIndex,
    dartIndex: dartIndex,
    throw:     dartObj
  });

  // Match aggregates
  ensureMatchAgg();

  if (hitKey && points > 0) {
    const hitsMap =
      state.matchAgg.hits[pIndex] ||
      (state.matchAgg.hits[pIndex] = {});
    hitsMap[hitKey] = (hitsMap[hitKey] || 0) + 1;
  }

  // Recompute 60+/100+/140+ for this player
  recomputeMatchAggTotalsForPlayer(pIndex);

  // Advance dart / player / round
  if (state.currentDart < 2) {
    state.currentDart++;
  } else {
    state.currentDart = 0;
    if (state.currentPlayer < state.players.length - 1) {
      state.currentPlayer++;
    } else {
      state.currentPlayer = 0;
      if (state.currentRound < MAX_ROUNDS - 1) {
        state.currentRound++;
      } else {
        // Game done â€“ completion dialog will open
        state.finished = true;
      }
    }
  }

  updateUI();

  if (!wasFinished && state.finished) {
    openGameCompleteDialog();
  }
}
function recomputeMatchAggTotalsForPlayer(pIdx){
  ensureMatchAgg();

  let c60  = 0;
  let c100 = 0;
  let c140 = 0;

  for (let r = 0; r < MAX_ROUNDS; r++) {
    const rt =
      state.score?.[pIdx]?.[r]?.roundTotal ||
      0;

    if (rt >= 60)  c60++;
    if (rt >= 100) c100++;
    if (rt >= 140) c140++;
  }

  state.matchAgg.totals60[pIdx]  = c60;
  state.matchAgg.totals100[pIdx] = c100;
  state.matchAgg.totals140[pIdx] = c140;
}
function recomputeMatchAggHitsForPlayer(pIdx){
  ensureMatchAgg();

  const map = {};

  for (let r = 0; r < MAX_ROUNDS; r++) {
    const roundDef = ROUNDS[r];
    const entry = state.score?.[pIdx]?.[r];
    if (!entry) continue;

    const darts = entry.darts || [];
    darts.forEach(dart => {
      if (!dart || !(dart.points > 0)) return;

      let key = null;

      if (roundDef.type === 'number') {
        key = String(roundDef.target);
      } else if (roundDef.type === 'doubles' || roundDef.type === 'triples') {
        if (dart.sector) key = String(dart.sector);
      } else if (roundDef.type === 'bull') {
        key = 'Bull';
      }

      if (key) {
        map[key] = (map[key] || 0) + 1;
      }
    });
  }

  state.matchAgg.hits[pIdx] = map;
}

function undo(){
  if (!state.history.length) {
    toast('Nothing to undo');
    return;
  }

  const last = state.history.pop();
  const { player, round, dartIndex } = last;

  const entry = state.score?.[player]?.[round];
  if (!entry) {
    updateUI();
    return;
  }

  state.currentPlayer = player;
  state.currentRound  = round;
  state.currentDart   = dartIndex;
  state.finished      = false;

  entry.darts[dartIndex] = null;
  entry.roundTotal =
    (entry.darts[0]?.points || 0) +
    (entry.darts[1]?.points || 0) +
    (entry.darts[2]?.points || 0);

  recomputeMatchAggHitsForPlayer(player);
  recomputeMatchAggTotalsForPlayer(player);

  updateUI();
}

function missGo(){
  if (state.finished || state.suddenDeath.active) return;

  const startPlayer = state.currentPlayer;
  const startRound  = state.currentRound;

  while (
    !state.finished &&
    !state.suddenDeath.active &&
    state.currentPlayer === startPlayer &&
    state.currentRound === startRound &&
    state.currentDart < 3
  ) {
    recordThrow({ kind: 'Miss' });
  }
}
// --- GAME LOGGING TO SUPABASE (real) + HIGH SCORES ---
async function recordFullGameToSupabase(createdAtOverride) {
  try {
    const totals = state.players.map((_, i) => totalScoreForPlayer(i));
    const boardClone = JSON.parse(JSON.stringify(state.score || []));
    const payload = {
      match_id: state.match?.id || null,                     // uuid
      game_number: state.match?.history?.length ? state.match.history.length : 1,
      created_at: createdAtOverride || new Date().toISOString(),
      state: { players: state.players.map(p => ({ name: p.name })), board: boardClone },
      totals,
      finished: true
    };
    const { error } = await sb.from(TABLE_GAMES).insert(payload);
    if (error) throw error;
  } catch (e) {
    console.error('recordFullGameToSupabase failed', e);
  }
}

// Insert every finished game into the appropriate high scores table.
// Multi-player -> League (TABLE_HS_LEAGUE), single-player -> Practice (TABLE_HS_PRACTICE).
async function recordGameToHighScores() {
  if (!state.players || !state.players.length) return;

  const totals   = state.players.map((_, i) => totalScoreForPlayer(i));
  const isSingle = state.players.length === 1;

  const tasks = [];

  for (let i = 0; i < state.players.length; i++) {
    const name  = state.players[i].name || `Player ${i + 1}`;
    const score = totals[i] || 0;

    // Donâ€™t log ghost/zero scores
    if (!name || score <= 0) continue;

    tasks.push(
      cloudInsertHighScore(name, score, isSingle).catch(err => {
        console.error('High score insert failed', err);
      })
    );
  }

  await Promise.all(tasks);
}

async function awardAndShowLeaderboard(){
  // prevent double-award if called twice for same game
  if (state.gameAwarded) {
    showLeaderboard();
    return;
  }
  state.gameAwarded = true;

  const totals  = state.players.map((_,i)=> totalScoreForPlayer(i));
  const max     = Math.max(...totals);
  const winners = totals.map((t,i)=> t===max?i:null).filter(x=>x!==null);

  // Ensure wins array exists
  if (!state.match.wins || state.match.wins.length !== state.players.length) {
    state.match.wins = Array.from({length: state.players.length}, () => 0);
  }
  winners.forEach(i => state.match.wins[i]++);

  // Snapshot board for history/stats
  const boardClone = JSON.parse(JSON.stringify(state.score));
  state.match.history.push({ totals: totals.slice(), board: boardClone });

  // Long-term local logs
  logCompletedGame(totals, winners, boardClone);

  const targetWins = state.match.targetWins || 1;
  const maxWins    = state.match.wins.length ? Math.max(...state.match.wins) : 0;
  const matchDone  = maxWins >= targetWins;

  if (matchDone && !state.match.completedLogged) {
    logCompletedMatch();
    state.match.completedLogged = true;
  }

  // Cloud writes (best-effort)
  try { await recordFullGameToSupabase(); } catch (e) {
    console.error(e); toast('Game saved to local only (cloud failed)');
  }
  try { await recordGameToHighScores(); } catch (e) {
    console.error(e);
  }

  state.match.gameNumber = state.match.history.length + 1;

  save();
  showLeaderboard();
}
// next line should exist already in your file:
const lbTable = byId('lbTable');
const lbTHead=lbTable.querySelector('thead'); 
const lbTBody=lbTable.querySelector('tbody');
const lbMatchInfo=byId('lbMatchInfo'); 
const nextGameBtn=byId('nextGameBtn'); 
const gameScoresBtn=byId('gameScoresBtn'); 
const newMatchBtn=byId('newMatchBtn'); 
const gamesRemainTag=byId('gamesRemainTag');

const lbGameStatsBtn  = byId('lbGameStatsBtn');
const lbMatchStatsBtn = byId('lbMatchStatsBtn');
const lbGameRaceBtn   = byId('lbGameRaceBtn');
function updateLeaderboardTable(){ 
  lbTHead.innerHTML=''; lbTBody.innerHTML=''; 
  const trh=document.createElement('tr');
trh.appendChild(Object.assign(document.createElement('th'),{textContent:'Player'}));

// one column per game actually played
const gamesPlayed = state.match.history.length;
for(let g=0; g<gamesPlayed; g++){
  const th=document.createElement('th');
  th.textContent='G'+(g+1);
  trh.appendChild(th);
}

trh.appendChild(Object.assign(document.createElement('th'),{textContent:'Match Total'}));
trh.appendChild(Object.assign(document.createElement('th'),{textContent:'Win'}));
  lbTHead.appendChild(trh); 
  state.players.forEach((player, idx)=>{ 
    const tr=document.createElement('tr'); 
    const nameTd=document.createElement('td'); nameTd.textContent=player.name; nameTd.style.color=player.color; tr.appendChild(nameTd); 
   let matchTotal=0;
for(let g=0; g<gamesPlayed; g++){
  const td=document.createElement('td');
  td.className='center';
  const t = (state.match.history[g]?.totals?.[idx]) || 0;
  td.textContent = String(t);
  matchTotal += t;
  tr.appendChild(td);
}
    const totalTd=document.createElement('td'); totalTd.className='center'; totalTd.textContent=String(matchTotal); tr.appendChild(totalTd); 
    const winsTd=document.createElement('td'); winsTd.className='center'; winsTd.textContent=String(state.match.wins[idx]||0); tr.appendChild(winsTd); 
    lbTBody.appendChild(tr); 
  }); 
}
function showLeaderboard(){ 
  show('leaderboard'); 
  updateLeaderboardTable(); 

  const target    = state.match.targetWins || 1;
  const gamesPlayed = state.match.history.length;
  const maxWins  = state.match.wins.length ? Math.max(...state.match.wins) : 0;
  const matchDone = maxWins >= target;

  lbMatchInfo.textContent =
    `Games played: ${gamesPlayed} â€¢ Target wins: ${target} â€¢ Current best: ${maxWins}`;
  
  gamesRemainTag.textContent = matchDone
    ? 'Match complete'
    : (target - maxWins) + ' to win';

  nextGameBtn.disabled = matchDone;
}
nextGameBtn.addEventListener('click',()=>{ 
  const target  = state.match.targetWins || 1;
  const maxWins = state.match.wins.length ? Math.max(...state.match.wins) : 0;

  if (maxWins >= target) {
    alert('Match complete! Start a new match from the details screen.');
    return;
  }

  const completedGames = state.match.history.length; 
  state.finished=false; 
  state.suddenDeath={active:false,participants:[],turnIndex:0,throws:[],round:1}; 

  // simple rotation: next game starts with next player
  const rot=completedGames % state.players.length; 
  startNewGame(false); 
  state.currentPlayer=rot; 
  show('game'); 
  updateUI(); 
});
newMatchBtn.addEventListener('click',()=>{ 
  if (!confirm('End current match and return to details?')) return; 

  safeClear(STORAGE_KEY); 

  // Reset full state to baseState
  Object.assign(state, JSON.parse(JSON.stringify(baseState)));

  show('details');
  setupStartMenuButtons();
});

function openGameScoresDialog() {
  if (!state.match || !Array.isArray(state.match.history) || !state.match.history.length) {
    toast('No completed games yet.');
    return;
  }

  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Game Scores';

  const body = document.createElement('div');
  body.className = 'modal-body';

  state.match.history.forEach((game, idx) => {
    const heading = document.createElement('h4');
    heading.textContent = `Game ${idx + 1}`;
    heading.style.margin = '8px 0 4px';
    body.appendChild(heading);

    const wrap = document.createElement('div');
    wrap.className = 'table-wrap';
    wrap.style.marginBottom = '8px';

    const table = document.createElement('table');
    table.className = 'hs-table';

    // Header row: Round + each player
    const thead = document.createElement('thead');
    const trHead = document.createElement('tr');

    const thRound = document.createElement('th');
    thRound.textContent = 'Round';
    trHead.appendChild(thRound);

    state.players.forEach(p => {
      const th = document.createElement('th');
      th.textContent = p.name;
      th.style.textAlign = 'center';
      trHead.appendChild(th);
    });

    thead.appendChild(trHead);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    const board = game.board || [];
    const runningTotals = state.players.map(() => 0);

    for (let r = 0; r < MAX_ROUNDS; r++) {
      const tr = document.createElement('tr');

      const roundDef = ROUNDS[r];
      const roundTh = document.createElement('th');
      roundTh.textContent =
        roundDef.type === 'number'
          ? (roundDef.target + 's')
          : (roundDef.type === 'doubles'
              ? "D's"
              : (roundDef.type === 'triples' ? "T's" : 'Bull'));
      tr.appendChild(roundTh);

      for (let p = 0; p < state.players.length; p++) {
        const td = document.createElement('td');
        td.className = 'center num';

        const entry = board[p]?.[r];
        const hasDarts = entry && entry.darts && entry.darts.some(d => d);
        const rt = entry?.roundTotal || 0;

        if (hasDarts) {
          runningTotals[p] += rt;

          const main = document.createElement('div');
          main.className = 'cell-main';
          main.textContent = String(runningTotals[p]);

          const sub = document.createElement('div');
          sub.className = 'cell-sub';
          sub.textContent = rt ? `(${rt})` : '';

          td.appendChild(main);
          td.appendChild(sub);
        } else {
          td.textContent = 'â€“';
        }

        tr.appendChild(td);
      }

      tbody.appendChild(tr);
    }

    table.appendChild(tbody);
    wrap.appendChild(table);
    body.appendChild(wrap);
  });

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();

  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });
}

gameScoresBtn.addEventListener('click', openGameScoresDialog);

/*****************
 * SCROLL SYNC (keeps columns aligned)
 *****************/
let _scrollSyncSet=false; 
function setupScrollSync(){ 
  if(_scrollSyncSet) return; 
  const sw=byId('scoreWrap'), st=byId('statsWrap'), fh=byId('floatWrap'), ms=byId('mstatsWrap'); 
  if(!sw||!st||!fh||!ms) return; 
  let syncing=false; 
  function mirror(from){ 
    if(syncing) return; syncing=true; 
    const x=from.scrollLeft; [sw,st,fh,ms].forEach(el=>{ if(el!==from) el.scrollLeft=x; }); syncing=false; 
  } 
  [sw,st,fh,ms].forEach(el=> el.addEventListener('scroll',()=>mirror(el),{passive:true})); 
  _scrollSyncSet=true; 
  requestAnimationFrame(()=>{ 
    const sRow=thead?.querySelector('tr'), tRow=statsThead?.querySelector('tr'), fRow=floatThead?.querySelector('tr'); 
    if(!sRow||!tRow||!fRow) return; 
    const sCells=sRow.children, tCells=tRow.children, fCells=fRow.children; 
    const leftW=sCells[0].getBoundingClientRect().width; 
    document.documentElement.style.setProperty('--left-col-w', leftW+'px'); 
    const n=Math.min(sCells.length,tCells.length,fCells.length); 
    for(let i=1;i<n;i++){ 
      const w=sCells[i].getBoundingClientRect().width; 
      [tCells[i], fCells[i]].forEach(cell=>{ if(cell){ cell.style.width=w+'px'; cell.style.minWidth=w+'px'; cell.style.maxWidth=w+'px'; } }); 
    } 
  }); 
}

/*****************
 * START/RESET + ORDER DIALOG
 *****************/
function buildEverything(){ 
  buildScoreHeader(); 
  buildScoreBody(); 
  buildFloatingHeader(); 
  buildStatsHeader(); 
  buildStatsBody(); 
  buildMatchStatsHeader(); 
  buildMatchStatsBody(); 
  setupScrollSync(); 
}
async function openGameRaceDialog() {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Game Race';

  const body = document.createElement('div');
  body.className = 'modal-body';

  const info = document.createElement('p');
  info.textContent = 'Round-by-round cumulative scores. Dotted line shows the #1 high score pace.';
  info.style.fontSize = '0.82rem';
  info.style.color = '#a8acc3';
  info.style.marginBottom = '6px';
  body.appendChild(info);

  const canvas = document.createElement('canvas');
  canvas.width  = 640;
  canvas.height = 320;
  canvas.style.width  = '100%';
  canvas.style.height = 'auto';
  body.appendChild(canvas);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = () => {
    overlay.remove();
    openStatsHubDialog();
  };

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();

  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });

  // --- Build series for current game ---
  const roundsCount = MAX_ROUNDS;
  const series = [];

  for (let p = 0; p < state.players.length; p++) {
    const player = state.players[p];
    const data = [];
    let running = 0;

    for (let r = 0; r < roundsCount; r++) {
      const entry = state.score?.[p]?.[r];
      const rt = entry ? (entry.roundTotal || 0) : 0;
      running += rt;
      data.push(running);
    }

    series.push({
      name: player.name,
      color: player.color || '#7bdcff',
      data,
      dotted: false
    });
  }

    // --- Add dotted #1 high score line (Supabase: high_scores, league) ---
  let recordRow = null;
  try {
    const list = await cloudListHighScores(false, 1);
    if (list && list.length) {
      recordRow = list[0];
    }
  } catch (err) {
    console.error('Race: failed to load high score', err);
  }

  if (recordRow) {
    const bestTotal = Number(recordRow.score) || 0;
    let recData = [];

    // Try to find the actual game locally so we can use the *true* pace
    const match = findGameForHighScore(recordRow);

    if (match && match.game && Array.isArray(match.game.board)) {
      const board = match.game.board;
      const pIdx  = match.playerIndex;
      let running = 0;

      for (let r = 0; r < roundsCount; r++) {
        const entry = board[pIdx]?.[r];
        const rt    = entry?.roundTotal || 0;
        running += rt;
        recData.push(running);
      }
    } else {
      // Fallback: old behaviour â€“ straight interpolated line
      for (let r = 0; r < roundsCount; r++) {
        const frac = (r + 1) / roundsCount;
        recData.push(Math.round(bestTotal * frac));
      }
    }

    series.push({
      name: `Record: ${recordRow.name} (${bestTotal})`,
      color: '#ffffff',
      data: recData,
      dotted: true
    });
  }

  // If no data at all, just bail
  const anyPoints = series.some(s => s.data.some(v => v > 0));
  if (!anyPoints) {
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#a8acc3';
    ctx.font = '12px system-ui';
    ctx.fillText('No scoring data yet for this game.', 20, 40);
    return;
  }

  // --- Draw chart ---
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  const marginLeft = 40;
  const marginRight = 10;
  const marginTop = 20;
  const marginBottom = 30;

  ctx.clearRect(0, 0, w, h);

  const maxY = Math.max(
    ...series.flatMap(s => s.data),
    10
  );

  const plotW = w - marginLeft - marginRight;
  const plotH = h - marginTop - marginBottom;

  function xForRound(r) {
    if (roundsCount <= 1) return marginLeft;
    const t = r / (roundsCount - 1);
    return marginLeft + t * plotW;
  }

  function yForScore(v) {
    const t = v / maxY;
    return marginTop + (1 - t) * plotH;
  }

  // Grid + axes
  ctx.strokeStyle = '#2b3050';
  ctx.lineWidth = 1;
  ctx.setLineDash([]);

  // Y-axis
  ctx.beginPath();
  ctx.moveTo(marginLeft, marginTop);
  ctx.lineTo(marginLeft, marginTop + plotH);
  ctx.stroke();

  // X-axis
  ctx.beginPath();
  ctx.moveTo(marginLeft, marginTop + plotH);
  ctx.lineTo(marginLeft + plotW, marginTop + plotH);
  ctx.stroke();

  ctx.fillStyle = '#a8acc3';
  ctx.font = '10px system-ui';

  // Y labels (4 ticks)
  for (let i = 0; i <= 4; i++) {
    const v = (maxY / 4) * i;
    const y = yForScore(v);
    ctx.fillText(String(Math.round(v)), 4, y + 3);

    ctx.strokeStyle = 'rgba(43,48,80,0.4)';
    ctx.beginPath();
    ctx.moveTo(marginLeft, y);
    ctx.lineTo(marginLeft + plotW, y);
    ctx.stroke();
  }

  // X labels (rounds)
  ctx.textAlign = 'center';
  for (let r = 0; r < roundsCount; r++) {
    const x = xForRound(r);
    const label = ROUNDS[r].type === 'number'
      ? String(ROUNDS[r].target)
      : (ROUNDS[r].type === 'doubles'
          ? 'D'
          : (ROUNDS[r].type === 'triples' ? 'T' : 'Bull'));
    ctx.fillText(label, x, marginTop + plotH + 12);
  }
  ctx.textAlign = 'left';

  // Lines
  series.forEach(s => {
    if (!s.data || !s.data.length) return;

    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.setLineDash(s.dotted ? [5, 4] : []);

    // pick line colour
    ctx.strokeStyle = s.color || '#7bdcff';

    s.data.forEach((v, idx) => {
      const x = xForRound(idx);
      const y = yForScore(v);
      if (idx === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });

    ctx.stroke();
  });

  // Legend
  let legendX = marginLeft;
  let legendY = marginTop - 6;

  series.forEach(s => {
    ctx.setLineDash(s.dotted ? [5, 4] : []);
    ctx.strokeStyle = s.color || '#7bdcff';
    ctx.lineWidth = 2;

    const lineW = 24;
    ctx.beginPath();
    ctx.moveTo(legendX, legendY);
    ctx.lineTo(legendX + lineW, legendY);
    ctx.stroke();

    ctx.setLineDash([]);
    ctx.fillStyle = '#e7e9f5';
    ctx.font = '10px system-ui';
    ctx.fillText(' ' + s.name, legendX + lineW + 4, legendY + 3);

    legendY += 14;
  });
}

// Throw order selection
function showPlayerOrderDialog() {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';
  const modal = document.createElement('div');
  modal.className = 'modal';
  const title = document.createElement('h3'); title.textContent = 'Select Throwing Order';
  const body = document.createElement('div'); body.className = 'modal-body';
  const instructions = document.createElement('p'); instructions.textContent = 'Use up/down buttons to set the throwing order:'; instructions.style.marginBottom='15px'; body.appendChild(instructions);
  const playerList = document.createElement('div'); playerList.id='playerOrderList'; playerList.style.display='flex'; playerList.style.flexDirection='column'; playerList.style.gap='8px'; body.appendChild(playerList);

  function renderList(){
    playerList.innerHTML='';
    state.players.forEach((player, index) => {
      const item = document.createElement('div');
      item.className = 'player-order-item';
      item.dataset.index = index;
      item.innerHTML = `
        <span style="background:${player.color}; color:white; padding:4px 8px; border-radius:4px; margin-right:8px;">${player.name.charAt(0)}</span>
        ${player.name}
        <div style="margin-left: auto; display:flex; gap:4px;">
          <button class="btn small" data-action="up" data-index="${index}">â†‘</button>
          <button class="btn small" data-action="down" data-index="${index}">â†“</button>
        </div>
      `;
      playerList.appendChild(item);
    });
    playerList.querySelectorAll('button[data-action]').forEach(b=>{
      b.onclick = (e) => {
        const idx = parseInt(e.currentTarget.dataset.index, 10);
        const act = e.currentTarget.dataset.action;

        if (act === 'up' && idx > 0) {
          swapPlayers(idx, idx - 1);
          renderList();
        }

        if (act === 'down' && idx < state.players.length - 1) {
          swapPlayers(idx, idx + 1);
          renderList();
        }
      };
    });
  }
  renderList();

  const footer = document.createElement('div'); footer.className='modal-footer';
  const cancelBtn = document.createElement('button'); cancelBtn.className='btn'; cancelBtn.textContent = 'Cancel'; cancelBtn.onclick = () => overlay.remove();
  const confirmBtn = document.createElement('button'); confirmBtn.className='btn primary'; confirmBtn.textContent = 'Confirm Order';
  confirmBtn.onclick = () => { overlay.remove(); startNewGame(true); };
  footer.append(cancelBtn,confirmBtn);

  modal.append(title, body, footer); overlay.appendChild(modal); document.body.appendChild(overlay);
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
  modal.tabIndex = 0; modal.focus();
}

function startNewGame(setOrder=false){
  if(!setOrder){ showPlayerOrderDialog(); return; }
  state.score = Array.from({length:state.players.length},()=>Array.from({length:MAX_ROUNDS},()=>({darts:[null,null,null],roundTotal:0})));
  state.currentRound = 0; 
  state.currentPlayer = 0; 
  state.currentDart = 0; 
  state.history = []; 
  state.finished = false;
  state.suddenDeath = {active:false,participants:[],turnIndex:0,throws:[],round:1};
  state.gameAwarded = false;
  state.currentRound = 0; state.currentPlayer = 0; state.currentDart = 0; state.history = []; state.finished = false;
  state.suddenDeath = {active:false,participants:[],turnIndex:0,throws:[],round:1};
  ensureMatchAgg();
  show('game'); buildEverything(); updateUI(); save();
}

function restartGame() {
  if (!confirm('Are you sure you want to restart this game? All progress will be lost.')) return;
  state.finished = false;
  state.suddenDeath = {active:false, participants:[], turnIndex:0, throws:[], round:1};
  startNewGame();
  show('game'); updateUI();
}

function swapPlayers(i, j) {
  // Swap players themselves
  [state.players[i], state.players[j]] = [state.players[j], state.players[i]];

  // Swap match wins
  if (state.match && Array.isArray(state.match.wins)) {
    [state.match.wins[i], state.match.wins[j]] =
      [state.match.wins[j], state.match.wins[i]];
  }

  // Swap per-game totals already stored
  if (state.match && Array.isArray(state.match.history)) {
    state.match.history.forEach(g => {
      if (g && Array.isArray(g.totals)) {
        [g.totals[i], g.totals[j]] = [g.totals[j], g.totals[i]];
      }
    });
  }

  // Swap matchAgg stats so favourites / 60+ / 100+ / 140+ stay with the player
  if (state.matchAgg) {
    if (Array.isArray(state.matchAgg.hits)) {
      [state.matchAgg.hits[i], state.matchAgg.hits[j]] =
        [state.matchAgg.hits[j], state.matchAgg.hits[i]];
    }
    ['totals60', 'totals100', 'totals140'].forEach(key => {
      if (Array.isArray(state.matchAgg[key])) {
        [state.matchAgg[key][i], state.matchAgg[key][j]] =
          [state.matchAgg[key][j], state.matchAgg[key][i]];
      }
    });
  }
}
/*****************
 * ADMIN HUB + ADMIN PANELS
 *****************/
 function findGameForHighScore(row) {
  const games = getGameLog();
  if (!games || !games.length) return null;

  const targetName  = row.name;
  const targetScore = Number(row.score) || 0;
  const targetTs    = row.ts ? new Date(row.ts).getTime() : null;
  const windowMs    = 5 * 60 * 1000; // 5 minutes either side

  for (const g of games) {
    if (!g || !Array.isArray(g.players) || !Array.isArray(g.totals)) continue;

    const pIdx = g.players.findIndex(p => p && p.name === targetName);
    if (pIdx === -1) continue;

    const scoreHere = Number(g.totals[pIdx] || 0);
    if (scoreHere !== targetScore) continue;

    if (targetTs && g.ts) {
      const gt = new Date(g.ts).getTime();
      if (Math.abs(gt - targetTs) > windowMs) continue;
    }

    // Found a matching game + player index
    return { game: g, playerIndex: pIdx };
  }

  return null;
}
 
 function deleteLocalStatsForHighScore(row) {
  const games = getGameLog();
  if (!games || !games.length) return;

  const targetName  = row.name;
  const targetScore = Number(row.score) || 0;
  const targetTs    = row.ts ? new Date(row.ts).getTime() : null;
  const windowMs    = 5 * 60 * 1000; // 5 minutes either side

  const filtered = [];

  for (const g of games) {
    let matches = false;

    if (g && Array.isArray(g.players) && Array.isArray(g.totals)) {
      g.players.forEach((p, idx) => {
        if (!p) return;
        if (p.name !== targetName) return;

        const scoreHere = Number(g.totals[idx] || 0);
        if (scoreHere !== targetScore) return;

        if (targetTs && g.ts) {
          const gt = new Date(g.ts).getTime();
          if (Math.abs(gt - targetTs) <= windowMs) {
            matches = true;
          }
        } else {
          matches = true;
        }
      });
    }

    if (!matches) filtered.push(g);
  }

  if (filtered.length !== games.length) {
    setGameLog(filtered);
  }
}
function openAdminHub(){
  const hub = byId('adminHubModal');
  hub.classList.remove('hidden');
  byId('openHsLeagueAdmin').onclick = ()=>{ hub.classList.add('hidden'); openHighScoresAdminDialog(false); };
  byId('openHsPracticeAdmin').onclick = ()=>{ hub.classList.add('hidden'); openHighScoresAdminDialog(true); };
  byId('openSavedPlayersAdmin').onclick = ()=>{ hub.classList.add('hidden'); openSavedPlayersAdmin(); };
  byId('closeAdminHubBtn').onclick = ()=> hub.classList.add('hidden');

  // Add Backdate buttons once
  const row = hub.querySelector('.modal-body .row');
  if (row && !byId('backdateNextSaveBtn')) {
    const bd = document.createElement('button');
    bd.id = 'backdateNextSaveBtn';
    bd.className = 'btn warn';
    bd.textContent = 'Backdate Next Cloud Save';
    bd.title = 'Sets created_at for the next Game & Match write';
    bd.onclick = setBackdateInteractive;
    row.appendChild(bd);

    const clr = document.createElement('button');
    clr.id = 'clearBackdateBtn';
    clr.className = 'btn';
    clr.textContent = 'Clear Backdate';
    clr.onclick = () => { clearBackdate(); toast('Backdate cleared'); };
    row.appendChild(clr);
  }
}

async function openHighScoresAdminDialog(single=false){ 
  const overlay=document.createElement('div'); overlay.className='modal-backdrop'; 
  const modal=document.createElement('div'); modal.className='modal'; 
  const title=document.createElement('h3'); title.textContent=`High Scores â€” Admin (${single?'Practice':'League'})`; 
  const body=document.createElement('div'); body.className='modal-body'; 
  const footer=document.createElement('div'); footer.className='modal-footer';

  async function render(){
    body.innerHTML='';
    try{
      const list = await cloudListHighScores(single, 50);
      if(!list.length){ const p=document.createElement('p'); p.textContent='No high scores.'; body.appendChild(p); return; }
      const table=document.createElement('table'); table.className='hs-table compact';
      const thead=document.createElement('thead'); const trh=document.createElement('tr');
      ['#','Player','Score','When'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);}); thead.appendChild(trh); table.appendChild(thead);
      const tb=document.createElement('tbody');
      list.forEach((row,idx)=>{ 
        const tr=document.createElement('tr'); tr.style.cursor='pointer'; tr.title='Click to delete'; 
        const td1=document.createElement('td'); td1.textContent=String(idx+1);
        const td2=document.createElement('td'); td2.textContent=row.name;
        const td3=document.createElement('td'); td3.textContent=String(row.score);
        const td4=document.createElement('td'); td4.textContent=new Date(row.ts).toLocaleString();
        tr.append(td1,td2,td3,td4);
tr.onclick = async () => {
  if (!confirm(`Delete ${row.name} â€” ${row.score}?`)) return;

  try {
    await cloudDeleteHighScore(row, single);

    // Also remove any matching games from local stats log
    deleteLocalStatsForHighScore(row);

    await render();
  } catch (e) {
    console.error(e);
    toast('Delete failed');
  }
};        tb.appendChild(tr);
      });
      table.appendChild(tb); body.appendChild(table);
    }catch(err){ console.error(err); const p=document.createElement('p'); p.textContent='Failed to load.'; body.appendChild(p); }
  }
  await render();
  const closeBtn=document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Exit'; closeBtn.onclick=()=>overlay.remove(); footer.appendChild(closeBtn); 
  modal.append(title,body,footer); overlay.appendChild(modal); document.body.appendChild(overlay); 
  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); }); 
  modal.tabIndex=0; modal.focus(); 
}

async function openSavedPlayersAdmin(){
  const modalWrap = byId('savedPlayersAdminModal');
  const body = byId('savedPlayersAdminBody');
  modalWrap.classList.remove('hidden');
  byId('closeSavedPlayersAdminBtn').onclick = ()=> modalWrap.classList.add('hidden');

  async function render(){
    body.innerHTML='';
    try{
      const list = await cloudListPlayers();
      if(!list.length){ body.innerHTML = '<p>No players saved.</p>'; return; }
      const table = document.createElement('table'); table.className='hs-table compact';
      const thead=document.createElement('thead'); const trh=document.createElement('tr');
      ['Player','Actions'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); }); thead.appendChild(trh); table.appendChild(thead);
      const tb=document.createElement('tbody');
      list.forEach(row=>{
        const tr=document.createElement('tr');
        const tdName=document.createElement('td'); tdName.textContent=row.name; tr.appendChild(tdName);
        const tdAct=document.createElement('td'); tdAct.className='center';
        const editBtn=document.createElement('button'); editBtn.className='btn small'; editBtn.textContent='Set Password';
        editBtn.onclick=async()=>{
          const np = prompt(`New password for ${row.name}:`);
          if(!np) return;
          try{ await cloudUpdatePlayerPassword(row.name, np); toast('Updated'); }catch(e){ console.error(e); toast('Update failed'); }
        };
        const delBtn=document.createElement('button'); delBtn.className='btn small danger'; delBtn.textContent='Delete';
        delBtn.onclick=async()=>{ if(confirm(`Delete player ${row.name}?`)){ try{ await cloudDeletePlayer(row.name); await render(); }catch(e){ console.error(e); toast('Delete failed'); } } };
        tdAct.append(editBtn,' ',delBtn); tr.appendChild(tdAct); tb.appendChild(tr);
      });
      table.appendChild(tb); body.appendChild(table);
    }catch(err){ console.error(err); body.innerHTML='<p>Failed to load players.</p>'; }
  }
  await render();
}

/*****************
 * BOOT
 *****************/
document.addEventListener('DOMContentLoaded', () => {
  // Start on details screen
  show('details');
  updatePadSpacer();
  setupStartMenuButtons();

  // Default Player Select rows
  drawPsRows();

  // Kick off initial cloud connectivity check
  initialCloudCheck();

// Restart buttons (Player Select + Game + Leaderboard)
  ['restartGameBtn', 'restartGameBtnLB'].forEach(id => {
    document.querySelectorAll('#' + id).forEach(btn => {
      btn.onclick = restartGame;
    });
  });

 // Stats buttons in top rows (game + final leaderboard)
  const statsHubBtnGame  = byId('statsHubBtnLB');      // game screen
  const statsHubBtnFinal = byId('statsHubBtnFinal');   // leaderboard screen

  if (statsHubBtnGame)  statsHubBtnGame.onclick  = openStatsHubDialog;
  if (statsHubBtnFinal) statsHubBtnFinal.onclick = openStatsHubDialog;
  if (lbGameStatsBtn)  lbGameStatsBtn.onclick  = openGameStatsDialog;
  if (lbMatchStatsBtn) lbMatchStatsBtn.onclick = openMatchStatsDialog;
  if (lbGameRaceBtn)   lbGameRaceBtn.onclick   = openGameRaceDialog;

  // Global ESC/click-outside for add/select/admin modals
  document.addEventListener('click', function(event) {
    const addPlayerModal      = byId('addPlayerModal');
    const selectPlayerModal   = byId('selectPlayerModal');
    const adminHub            = byId('adminHubModal');
    const savedPlayersAdmin   = byId('savedPlayersAdminModal');

    if (addPlayerModal &&
        !addPlayerModal.classList.contains('hidden') &&
        event.target === addPlayerModal) {
      addPlayerModal.classList.add('hidden');
    }

    if (selectPlayerModal &&
        !selectPlayerModal.classList.contains('hidden') &&
        event.target === selectPlayerModal) {
      selectPlayerModal.classList.add('hidden');
    }

    if (adminHub &&
        !adminHub.classList.contains('hidden') &&
        event.target === adminHub) {
      adminHub.classList.add('hidden');
    }

    if (savedPlayersAdmin &&
        !savedPlayersAdmin.classList.contains('hidden') &&
        event.target === savedPlayersAdmin) {
      savedPlayersAdmin.classList.add('hidden');
    }
  });

  document.addEventListener('keydown', function(event) {
    if (event.key !== 'Escape') return;

    const addPlayerModal    = byId('addPlayerModal');
    const selectPlayerModal = byId('selectPlayerModal');
    const adminHub          = byId('adminHubModal');
    const savedPlayersAdmin = byId('savedPlayersAdminModal');

    if (addPlayerModal &&
        !addPlayerModal.classList.contains('hidden')) {
      addPlayerModal.classList.add('hidden');
    }

    if (selectPlayerModal &&
        !selectPlayerModal.classList.contains('hidden')) {
      selectPlayerModal.classList.add('hidden');
    }

    if (adminHub &&
        !adminHub.classList.contains('hidden')) {
      adminHub.classList.add('hidden');
    }

    if (savedPlayersAdmin &&
        !savedPlayersAdmin.classList.contains('hidden')) {
      savedPlayersAdmin.classList.add('hidden');
    }
  });
});
</script>
</body>
</html>