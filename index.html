<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shateki Quest Scorer</title>

<!-- Supabase JS v2 -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script async src="https://tenor.com/embed.js"></script>

<style>
:root{
  /* Theme */
  --bg:#0f1220;
  --card:#171a2b;
  --ink:#e7e9f5;
  --muted:#a8acc3;
  --accent:#7bdcff;
  --accent-2:#8cff9e;
  --danger:#ff6b6b;
  --warn:#ffcc66;
  --good:#7fffd4;
  --shadow:0 10px 30px rgba(0,0,0,.35);
  --radius:14px;

  /* Layout */
  --pad-h:148px;
  --left-col-w:96px;
  --start-btn-h:52px;
  --title-w:640px;      /* fallback until JS measures */
  --section-gap:10px;   /* global vertical spacing */

  /* Leaderboard widths */
  --lb-num-w:72px;      /* each G# */
  --lb-pct-w:86px;      /* Match % */
  --lb-total-w:96px;    /* Match Total */
  --lb-win-w:56px;      /* Win */
}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; min-height:100dvh; overflow-x:hidden;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,"Apple Color Emoji","Segoe UI Emoji";
    background:radial-gradient(1000px 600px at 0% 0%,#1b1f36 0%,#0f1220 45%,#0b0e1a 100%); color:var(--ink);
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
  }
  /* Start/Back buttons under the player box (scope to #players only) */
#players #startMatchRow,
#players #backRow{
  max-width: 640px;
  width: 100%;
  margin: 12px auto 0;
}

/* Make the buttons themselves fill those rows */
#players #startMatchBtn,
#players #startScreenBtn{
  width: 100%;
}

/* Add into the same <style id="xmasStyles"> block if wanted */
body.xmas td, body.xmas th { text-shadow: 0 0 0 transparent; }
body.xmas .medal-gold  { filter: drop-shadow(0 0 6px rgba(255,215,0,.45)); }
body.xmas .medal-silver{ filter: drop-shadow(0 0 6px rgba(210,210,210,.35)); }
body.xmas .medal-bronze{ filter: drop-shadow(0 0 6px rgba(205,127,50,.35)); }

body.xmas #newGameBtn {
  border-image: repeating-linear-gradient(
    45deg, #e44343 0 8px, #ffffff 8px 16px, #28b35e 16px 24px, #ffffff 24px 32px
  ) 8 / 1.5px / 0 stretch;
  border-style: solid; border-width: 1.5px;
}

#startMatchBtn{
  width:100%;          /* same width as the box */
}
 .wrap{max-width:1100px;margin-inline:auto;padding:16px; padding-bottom:calc(var(--pad-h) + 16px)}
.start-actions{
  display:flex;
  flex-direction:column;
  align-items:center;
  margin:0 auto;
  text-align:center;
}
/* Game Details layout tweaks */
#details h2 {
  display: none;
}
#details #appTitle {
  display: block;               /* override the display:none */
  font-size: 2.6rem;
  font-weight: 800;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  text-align: center;
  margin-bottom: 24px;
  color: #e7e9f5;
}
/* Game Details screen: content aligned towards top with some breathing room */
#details {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;           /* no vertical centering */
  min-height: calc(100vh - var(--pad-h));
  padding-top: 32px;                     /* move SHATEKI-QUEST / New / Resume closer to top */
}

/* Center the main buttons block */
#details .start-actions {
  margin: 0 auto;
}

/* Player Select layout tweaks */
#players h2{
  display:none;              /* hide "Player Select" text */
}


/* Center the Player Select screen vertically like page 1 */
#players{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  min-height:calc(100vh - var(--pad-h));
}

/* Box wrappers on Player Select: games/players + player list */
.ps-config-row{
  padding:12px;
  border-radius:12px;
  background:#101533;
  border:1px solid #23284a;
  display:flex;
  flex-direction:column;
  gap:10px;
  max-width:640px;
  width:100%;
  margin:12px auto 0;
}
  /* Player Select: steppers for games/players instead of native selects */
.setup-row {
  display: flex;
  gap: 18px;
  margin-bottom: 4px;
}

.setup-field {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.setup-label {
  font-size: 0.75rem;
  letter-spacing: 0.04em;
  text-transform: uppercase;
  color: var(--muted);
  text-align: center;
}

.setup-stepper {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 10px;
  border-radius: 999px;
  background:
    radial-gradient(circle at 0 0, rgba(255,255,255,0.03), transparent 55%),
    rgba(12, 15, 32, 0.95);
  box-shadow:
    0 0 0 1px rgba(124, 142, 255, 0.25),
    var(--shadow);
  gap: 8px;
}

.stepper-btn {
  border: none;
  outline: none;
  width: 26px;
  height: 26px;
  border-radius: 999px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  font-weight: 700;
  background: linear-gradient(
    135deg,
    rgba(123, 220, 255, 0.18),
    rgba(140, 255, 158, 0.12)
  );
  color: var(--ink);
  cursor: pointer;
  transition:
    transform 0.1s ease,
    box-shadow 0.1s ease,
    background 0.15s ease;
}

.stepper-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
}

.stepper-btn:active {
  transform: translateY(0);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
}

.stepper-value {
  flex: 1;
  display: flex;
  align-items: baseline;
  justify-content: center;
  gap: 4px;
  font-variant-numeric: tabular-nums;
}

.stepper-number {
  font-size: 1rem;
  font-weight: 700;
  color: var(--ink);
}

.stepper-suffix {
  font-size: 0.75rem;
  color: var(--muted);
}

.native-select-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0 0 0 0);
  border: 0;
}

@media (max-width: 600px) {
  .setup-row {
    flex-direction: column;
  }
}

/* Box each player row (guest name + select/save buttons) */
#psPlayerFields .pf{
  padding:10px 12px;
  border-radius:12px;
  border:1px solid #23284a;
  background:#101533;
}
.th-throws{
  font-size: 11px;
  line-height: 1;
  color: var(--muted);
  min-height: 14px;
}
.leader-total{
  color: var(--accent-2) !important;
}

#psPlayerFields .pf input[data-role="display"]{
  background:#ffffff;
  color:#000000;
}

#psPlayerFields .pf .btn{
  min-width:120px;
}

#adminCodeRow {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin-top: 24px;
  max-width: 260px;
  margin-inline: auto;
}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .column{display:flex;flex-direction:column;gap:10px}
  .grow{flex:1}
  .hidden{display:none!important}
  .tag{font-size:.78rem;color:var(--muted);padding:.15rem .45rem;border:1px solid #2b3050;border-radius:999px}
  .banner{background:linear-gradient(180deg,#14284a,#12213d);border:1px solid #2a4777;border-radius:12px;padding:12px;margin-top:10px}

  input[type="text"],select,input[type="password"]{
    background:#101329;border:1px solid #2b3050;color:var(--ink);padding:.65rem .8rem;border-radius:10px;outline:none;width:100%
  }
  .btn{appearance:none;border:1px solid #2b3050;border-radius:12px;background:#131733;color:var(--ink);
       padding:.7rem 1rem;cursor:pointer;transition:.15s transform,.15s background,.15s border-color,.15s opacity;font-weight:700}
  .btn:hover{transform:translateY(-1px);background:#161a3a}
  .btn:disabled{opacity:.55;cursor:not-allowed;transform:none}
  .btn.primary{background:linear-gradient(180deg,#1d255a,#19214f);border-color:#32407a}
  .btn.good{background:linear-gradient(180deg,#1b3d2e,#183628);border-color:#2e6a4f}
  .btn.warn{background:linear-gradient(180deg,#3a3219,#2f2914);border-color:#6b5821}
  .btn.danger{background:linear-gradient(180deg,#47212a,#3c1b23);border-color:#7a2e3f}
  .btn.big{font-size:1.15rem;padding:1rem 1.25rem;border-radius:14px}
  .btn.small { padding: 4px 8px; font-size: 0.8rem; min-width: 30px; min-height: 24px; }

  /* Tables */
  .table-wrap{overflow:auto;border-radius:12px;border:1px solid #2a2e48}
  table{width:100%;border-collapse:separate;border-spacing:0;background:#0f1329;table-layout:fixed}
  thead th{
    background:#14183a;border-bottom:1px solid #2a2e48;padding:.6rem .5rem;text-align:left;font-weight:700;
    position:sticky; top:0; z-index:5;
  }
  #scoreWrap thead th:first-child{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w)}
  #scoreWrap tbody th{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w);
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-right:6px}
  thead th.player, tbody td.player{min-width:120px; text-align:center}
  tbody td,tbody th{padding:.55rem .5rem;border-bottom:1px dashed #23284a;text-align:left;vertical-align:middle}
  tbody td{white-space:nowrap; overflow:hidden; text-overflow:clip}
  tbody tr:last-child td{border-bottom:none}
  tbody th{font-weight:600;color:#cfd3ee;background:#101533;border-right:1px solid #22264a}
  .num{font-variant-numeric:tabular-nums}
  .center{text-align:center}
  .current-cell{background:linear-gradient(180deg,#1e2450,#171d45)!important;box-shadow:inset 0 0 0 1px #4050a7}
  .current-col{background:rgba(64,80,167,.07)}

  /* Header content */
  thead th .th-wrap{display:flex;flex-direction:column;align-items:center;gap:2px}
  thead th .th-name{font-weight:800;letter-spacing:.02em}
  thead th .th-beers{font-size:12px;line-height:1;min-height:14px;letter-spacing:.5px;filter:drop-shadow(0 0 6px rgba(255,204,102,.35)); text-align:center}
  .th-throw-arrow{font-size:13px; line-height:1}

  /* Base total style (used everywhere) */
  .th-total{
    font-weight:800;
    letter-spacing:.02em;
  }

/* Floating header: hero total score */
.float-head .th-total{
  font-size:34px;
  line-height:1.1;
  display:block;
  margin:0;
  text-align:center;
}
  
  .th-diff{
    font-size:10px;
    line-height:1;
    font-weight:400 !important;
    color:var(--muted);
    text-align:center;
  }
  .th-diff-label{font-size:11px; font-weight:400 !important; color:var(--muted)}

/* Floating header: layout under player names */
.float-head thead th .th-wrap{
  border-bottom:none;
  padding-bottom:2px;
  margin-bottom:0;
}

  /* Score cell */
  .cell-wrap{display:inline-flex;flex-direction:column;align-items:center;gap:1px;line-height:1}
  .cell-main{font-weight:800;line-height:1.1}
  .cell-sub{color:var(--muted);font-size:.60em;font-weight:500;opacity:.95;letter-spacing:-0.01em;line-height:1}
  .sub-win{color:var(--accent-2)!important;font-weight:700}

  /* Stats (kept for layout sync; shown via modals) */
  .stats-box{display:none}
  #statsWrap thead th:first-child,
  #mstatsWrap thead th:first-child{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w)}
  #statsWrap tbody th.stats-th,
  #mstatsWrap tbody th.stats-th{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w);
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-right:8px}
  .stats-th{background:#101533;color:#cfd3ee}
  .stats-row th,.stats-row td{font-size:.86rem;line-height:1.15;padding:.45rem .5rem}
  .stats-row td{color:#e1e4fb}

  /* Floating names header */
  .float-head{position:sticky; top:0; z-index:200000;
    background:rgba(17,19,38,.96); backdrop-filter:blur(6px);
    border:1px solid #2a2e48; border-radius:12px; margin-bottom:10px}
  .float-head .table-wrap{
    border:none;
    border-radius:12px;
    overflow:hidden; /* allow horizontal sync scrolling of header */
  }
  #floatWrap thead th:first-child{width:var(--left-col-w);min-width:var(--left-col-w);max-width:var(--left-col-w)}

/* Vertical divider after the TARGET column in floating header */
.float-head thead th:first-child{
  border-right:1px solid #22264a;
}

/* Floating header: base header cells */
.float-head thead th{
  border-bottom:none;
  vertical-align:middle;
}

/* Row 1 (names): divider line just under player names */
.float-head thead tr:nth-child(1) th{
  border-bottom:1px solid #2a2e48;
  padding-bottom:4px;
}

/* Row 2 (totals): even vertical padding so score + diff sit centrally */
.float-head thead tr:nth-child(2) th{
  padding-top:8px;
  padding-bottom:8px;
  text-align:center;
}
#floatWrap #froundlabel .round-now{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  padding:8px 4px;
}
#floatWrap #froundlabel .rn-label{
  font-size:11px;
  font-weight:700;
  letter-spacing:.18em;
  color:var(--muted);
  margin-bottom:4px;
  text-transform:uppercase;
}
#floatWrap #froundlabel .rn-value{
  font-weight:900;
  line-height:1;
  /* Big, but responsive so it nearly fills the cell */
  font-size:clamp(28px, 6.5vw, 64px);
  letter-spacing:.01em;
}
/* Bigger, bold S / D / T buttons + match size for pad actions & top bar */
.btn.letter-throw{
  font-size: 1.25rem;
  font-weight: 700;
}
.pad .btn.letter-throw{
  min-height: 46px;
  
}
/* Center + bold the "10s…Bull" row labels in the main scoreboard */
#scoreWrap tbody th{
  text-align:center;
  font-weight:800;   /* bold target labels (10–Bull) */
}

/* round sub-value (the bracketed "(30)") defaults to muted */
.round-sub { color: var(--hint, rgba(255,255,255,.65)); }

/* only the top per-round score(s) get green */
.round-sub.is-round-high { color: var(--green, #37d67a); font-weight: 600; }

/* Reverted: show cumulative total as main and round score in parentheses below */
#scoreWrap .cell-main{
  display:block !important;
  font-size:1.6rem;
  font-weight:900;
  line-height:1.1;
}
  #scoreWrap .cell-sub{
    display:block !important;
    font-size:.9rem;
    font-weight:700;
    color: var(--accent-2);
    line-height:1.1;
  }


/* Per-dart markers under each round score */
.cell-throws{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  margin-top:4px;
  font-weight:800;
  font-size:.95rem;
  letter-spacing:.02em;
  line-height:1;
}
.cell-throws span{ user-select:none; }
.cell-throws .miss{ color: var(--danger); }  /* red X for a miss */

/* Revert UI: hide per‑dart markers */
.cell-throws{ display:none !important; }

  /* Round rows height – reverted to original sizing */
  #scoreWrap tbody th,
  #scoreWrap tbody td{
    padding-top: 0.55rem;
    padding-bottom: 0.55rem;
  }

/* Landscape: keep TARGET cell (float header) aligned with the round-label column */
@media (orientation: landscape){
  #floatWrap thead th:first-child,
  #scoreWrap thead th:first-child,
  #scoreWrap tbody th{
    width: var(--left-col-w);
    min-width: var(--left-col-w);
    max-width: var(--left-col-w);
  }
}
#leaderboardTopRow .btn.top-throw{
  flex: 1 1 0;
  min-width: 0;
  min-height: 35px;
  font-size: 1rem;
  font-weight: 500;
}
  /* Hide Throw Pad off non-game pages */
  body[data-page="details"] .pad-bar,
  body[data-page="players"] .pad-bar,
  body[data-page="leaderboard"] .pad-bar.hidden { display:none; }
  body[data-page="game"] .pad-bar { display:block; }

  /* Fixed Throw Pad */
  .pad-bar{position:fixed;left:0;right:0;bottom:0;background:rgba(17,19,38,.96);backdrop-filter:blur(6px);
    border-top:1px solid #23284a;z-index:100000;padding-bottom:max(8px, env(safe-area-inset-bottom))}
  .pad-inner{max-width:1100px;margin:0 auto;padding:8px 10px}
  .pad-head{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:6px}
  .pad-left{display:flex;align-items:center;gap:10px}
  .pad-hint{color:#a8acc3;font-size:.82rem}
.pad{
  display:flex;
  flex-direction:column;
  align-items:stretch;
  gap:6px;
  max-height:140px;
  overflow:auto;
}  
.pad .btn{min-width:52px;min-height:38px}
  .pad-spacer{flex:1 1 auto}
  .pad .btn.main-throw{
    min-width:104px;
  }

  /* Modal */
  .modal-backdrop{position:fixed; inset:0; background:rgba(0,0,0,.5); display:flex; align-items:center; justify-content:center; z-index:400000}
  .modal{background:#0f1329; border:1px solid #2a2e48; border-radius:14px; box-shadow:var(--shadow); padding:12px; width:92%; max-width:640px}
  .modal h3{ margin:0 0 8px 0; font-size:1.02rem }
  .modal-body{ max-height:60vh; overflow:auto; padding-right:2px; }
  .modal-footer{ margin-top:10px; display:flex; gap:8px; }

  /* Game Complete popup hierarchy */
  .modal.game-complete h3.gc-title{
    font-size:1rem;
    font-weight:600;
    letter-spacing:0.04em;
    text-transform:uppercase;
    opacity:.9;
  }

  .modal.game-complete .gc-result{
    margin-top:6px;
    margin-bottom:10px;
    font-size:1.35rem;
    font-weight:700;
  }

  .modal.game-complete .gc-standings{
    margin-top:4px;
    font-size:.9rem;
    opacity:.9;
  }


  .hs-table{ width:100%; border-collapse:separate; border-spacing:0 }
  .hs-table th, .hs-table td{ padding:.5rem .5rem; border-bottom:1px dashed #23284a; }
  .hs-table th{ text-align:left; color:#cfd3ee; }

/* >>> PATCH:hs-league-layout START — tidy High Score League columns */
.hs-table.hs-league-table{
  table-layout:fixed;
  width:100%;
}
.hs-table.hs-league-table th,
.hs-table.hs-league-table td{
  font-variant-numeric:tabular-nums;
}
/* # column: a bit wider, right-aligned, not crushed against the edge */
.hs-table.hs-league-table th:first-child,
.hs-table.hs-league-table td:first-child{
  width:3.5ch;
  min-width:3.5ch;
  max-width:4ch;
  text-align:right;
  padding-right:0.75rem;
}
/* Player column: main label */
.hs-table.hs-league-table th:nth-child(2),
.hs-table.hs-league-table td:nth-child(2){
  text-align:left;
}
/* High Score: align numbers to the right */
.hs-table.hs-league-table th:nth-child(3),
.hs-table.hs-league-table td:nth-child(3){
  text-align:right;
}
/* When: readable date/time */
.hs-table.hs-league-table th:nth-child(4),
.hs-table.hs-league-table td:nth-child(4){
  text-align:left;
}
/* >>> PATCH:hs-league-layout END */

  .row-practice {
  box-shadow: inset 4px 0 0 0 #ff8a00;
}

  /* Add / Select Player Modals */
  #addPlayerModal.hidden, #selectPlayerModal.hidden, #adminHubModal.hidden, #savedPlayersAdminModal.hidden { display:none; }

  /* Compact admin tables */
  .compact * { font-size: 12px !important; }
  .compact .btn { padding: 4px 8px; font-weight: 600; }
  .compact table th, .compact table td { padding: .35rem .4rem; }
  
  
  /* Latest Scores table tweaks */
.table-wrap th.col-idx, .table-wrap td.col-idx{
  width:1%;
  white-space:nowrap;
  text-align:center;
}
.table-wrap th.when-col, .table-wrap td.when-col{
  white-space:nowrap;
}
  
  </style>
<style>
  /* Cloud status pill (top-right) */
.cloud-status {
  position: fixed;
  right: 12px;
  top: 12px;          /* moved from bottom to top */
  bottom: auto;
  background: rgba(10, 12, 30, .92);
  border: 1px solid #2b3050;
  color: var(--muted);
  font-size: 11px;
  padding: 4px 8px;
  border-radius: 999px;
  display: flex;
  align-items: center;
  gap: 6px;
  z-index: 500000;
  pointer-events: none;
}

.cloud-status .cloud-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #666;
}

/* States */
.cloud-status.checking .cloud-dot { background: var(--warn); }
.cloud-status.ok       .cloud-dot { background: var(--accent-2); }
.cloud-status.error    .cloud-dot { background: var(--danger); }


/* Top row of buttons: keep spacing on leaderboard etc. */
#leaderboardTopRow,
#gameTopRow{
margin-bottom: var(--section-gap);
}


/* Main game: stick the scoreboard (Game Wins row) directly to the bottom
   of the floating score block above it. */
.float-head{
  margin-bottom: 0;
}

/* Remove extra top margin on the scoreboard so it touches the float-head */
#scoreWrap{
  margin-top: 0 !important;
}

/* keep these tiny + shorter */
#leaderboardTopRow .btn,
#gameTopRow .btn{
  font-size: 0.9rem;
  min-height: 34px;
  padding: 6px 10px;
}

/* ===== Start Screen sizing (page: #details) ===== */
#details #appTitle{ display:inline-block; } /* measurable text width */

#details .start-actions{ max-width:none; }

/* Big buttons: 2/3 of title width, max 820px */
#details #questBtn,
#details #resumeBtn{
  width: min(calc(var(--title-w) * 0.6667), 820px);
  margin-inline:auto;
}

/* High Scores + Player Stats row: same width as big buttons */
#details .start-actions > .row:first-of-type{
  width: min(calc(var(--title-w) * 0.6667), 820px);
  margin-inline:auto;
}

/* Small screens */
@media (max-width:560px){
  #details #questBtn,
  #details #resumeBtn,
  #details .start-actions > .row:first-of-type{ width:92vw; }
}


/* Make each button line fill that width */
#details .start-actions .btn.big{ width: 100%; }
#details .start-actions .row{ width: 100%; }     /* High Scores / Player Stats row */
#details .start-actions .row .btn{ width: 100%; }

/* Start screen: stack Latest / High Scores / Player Stats with equal gaps */
#details .start-secondary-row{
  display:flex;
  flex-direction:column;
  align-items:stretch;
  justify-content:center;
  gap:8px;                 /* small, consistent gap between medium buttons */
  margin-top:72px;         /* push secondary buttons lower so they sit roughly central */
}

/* Medium buttons: same visual width as the big ones, centred */
#details .start-secondary-row .btn{
  width:min(calc(var(--title-w) * 0.6667), 820px);
  margin-inline:auto;
}

/* GAP below the medium buttons before the Admin button */
#adminCodeRow{
  margin-top:16px;
}

/* Final Leaderboard layout */
#leaderboard .lb-box{
  padding:12px;
  border-radius:12px;
  background:linear-gradient(180deg,#14284a,#12213d);
  border:1px solid #2a4777;
}

/* Leaderboard action buttons: full width of the leaderboard table */
#leaderboard .lb-box .stacked-actions{
  display:flex;
  flex-direction:column;
  gap:8px;
  width:100%;
  margin-top:8px;
}

#leaderboard .lb-box .stacked-actions .btn.big{
  width:100%;
  max-width:none;
  display:block;
}

/* table layout + no-wrap for player names */
#leaderboard #lbTable{
  table-layout: fixed; /* respect colgroup widths */
  width: 100%;
}
#leaderboard #lbTable thead th:first-child,
#leaderboard #lbTable tbody td:first-child{
  white-space: nowrap;
  border-right: 1px solid #2a2e48; /* vertical divider after Player */
}

/* divider after the LAST G# column */
#leaderboard #lbTable thead th.after-games-sep,
#leaderboard #lbTable tbody td.after-games-sep{
  border-right: 1px solid #2a2e48;
}

/* widths for numeric columns */
#lbTable thead th:first-child{
  text-align:left;
}

/* keep names tidy on small screens */
#leaderboard #lbTable th:first-child,
#leaderboard #lbTable td:first-child{
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}

/* numbers look better with tabular figures */
#leaderboard #lbTable td,
#leaderboard #lbTable th{ font-variant-numeric: tabular-nums; }

/* subtle zebra + hover */
#leaderboard #lbTable tbody tr:nth-child(odd) td{ background: rgba(255,255,255,.02); }
#leaderboard #lbTable tbody tr:hover td{ background: rgba(255,255,255,.03); }

/* === Start screen Game Ticker (single-line vertical scroll) === */
#psTicker{
  width: 100vw;
  max-width: none;
  margin: 0;

  /* full-bleed even inside centred layout */
  margin-left: calc(50% - 50vw);
  margin-right: calc(50% - 50vw);

  /* Videprinter styling */
  background: linear-gradient(180deg,#fdd45c,#f7b733);
  border-top: 2px solid #b98b00;
  border-bottom: 2px solid #b98b00;
  color: #111;

  /* Single-line strip; one score at a time */
  height: 32px;
  overflow: hidden;

  padding: 0;
  font-size: 0.85rem;
  font-weight: 700;
  font-variant-numeric: tabular-nums;

  /* Pin to bottom on the Start screen */
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  border-radius: 0;
  border-left: 0;
  border-right: 0;
  z-index: 300000;
}

#psTicker.hidden{
  display:none;
}

/* Each line inside the ticker (we use two and slide them) */
#psTicker .track{
  position: absolute;
  left: 14px;
  right: 14px;
  top: 0;
  height: 100%;
  display: flex;
  align-items: center;
  white-space: nowrap;
  font-size: 0.85rem;     /* slightly smaller text */
  font-weight: 500;       /* base (normal) weight; winners boosted via <strong> */
  letter-spacing: 0.01em;
  line-height: 32px;      /* vertically centred in the 32px strip */
  will-change: transform;
  transform: translateY(0);
}

/* === Triple-Trebles celebration overlay === */
.gif-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:600000;pointer-events:none;}
.gif-overlay.hidden{display:none;}
.gif-overlay .gif-box{width:min(540px,84vw);max-height:80vh;display:block}
/* Hide Tenor fallback link text so no raw anchor text shows */
#gifOverlay .tenor-gif-embed a { display: none !important; }
#gifOverlay .tenor-gif-embed { font-size: 0 !important; line-height: 0 !important; }

</style>
</head>
<body data-page="details">
  <div class="wrap">

    <!-- PAGE 1: GAME DETAILS -->
    <section id="details" class="card section">
<h2 id="appTitle">SHATEKI-QUEST</h2>
      <div class="start-actions column" style="gap:8px">
        <button id="questBtn" class="btn primary big" type="button">New game ▶</button>
        <button id="resumeBtn" class="btn good big" type="button" disabled title="No saved match">Resume game ▶</button>

        <div class="row start-secondary-row">
          <button id="latestScoresBtn" class="btn" type="button">Latest Scores</button>
          <button id="hsMainBtn" class="btn" type="button">High Scores (Match)</button>
          <button id="shotgunBtn" class="btn" type="button">High Scores (Round)</button>
          <button id="playerStatsBtn" class="btn" type="button">Player Stats</button>
        </div>

        <!-- Single Admin row -->
        <div class="row" id="adminCodeRow" style="margin-top:16px; justify-content:center;">
          <button id="adminCodeBtn" class="btn small" type="button">Admin</button>
        </div>
      </div>

<!-- Start-screen rolling banner: last 10 completed games -->

<!-- Start-screen rolling banner: last 10 completed matches -->
<div id="psTickerMatch" class="hidden"><div class="track"></div></div>

<div id="psTicker" class="hidden"><div class="track"></div></div>
</section>

<!-- PAGE 2: PLAYER SELECT -->
<section id="players" class="card section hidden">
  <h2>Player Select</h2>

<!-- BOX 1: Number of games / Number of players -->
<div class="ps-config-row">
  <div class="setup-row">
    <!-- Games -->
    <div class="setup-field">
      <label class="setup-label" for="psNumGames">Number of games</label>

      <!-- custom stepper hooked to #psNumGames -->
      <div class="setup-stepper" data-select-id="psNumGames" data-suffix=" games">
        <button type="button" class="stepper-btn" data-delta="-1">−</button>
        <div class="stepper-value">
          <span class="stepper-number"></span>
          <span class="stepper-suffix"></span>
        </div>
        <button type="button" class="stepper-btn" data-delta="1">+</button>
      </div>

      <!-- original select, now visually hidden but still used by JS -->
      <select id="psNumGames" class="native-select-hidden">
        <option value="1">1 game</option>
        <option value="2">2 games</option>
        <option value="3">3 games</option>
        <option value="4">4 games</option>
        <option value="5" selected>5 games</option>
      </select>
    </div>

    <!-- Players -->
    <div class="setup-field">
      <label class="setup-label" for="psNumPlayers">Number of players</label>

      <!-- custom stepper hooked to #psNumPlayers -->
      <div class="setup-stepper" data-select-id="psNumPlayers" data-suffix=" players">
        <button type="button" class="stepper-btn" data-delta="-1">−</button>
        <div class="stepper-value">
          <span class="stepper-number"></span>
          <span class="stepper-suffix"></span>
        </div>
        <button type="button" class="stepper-btn" data-delta="1">+</button>
      </div>

      <!-- original select, hidden -->
      <select id="psNumPlayers" class="native-select-hidden">
        <option value="1">1 player (Training)</option>
        <option value="2" selected>2 players</option>
        <option value="3">3 players</option>
        <option value="4">4 players</option>
        <option value="5">5 players</option>
        <option value="6">6 players</option>
      </select>
    </div>
  </div>
</div>

  <!-- BOX 2: Player rows (guest / saved players) -->
  <div class="ps-config-row">
    <div id="psPlayerFields" class="column" style="width:100%;">
      <!-- Rows injected -->
    </div>
  </div>

 <!-- Start Match button – full width under the boxes -->
<div class="row" id="startMatchRow">
  <button id="startMatchBtn" class="btn good big" type="button">Start Match ➡</button>
</div>

<!-- Back button – same width/size as Start Match -->
<div class="row" id="backRow">
  <button id="startScreenBtn" class="btn big" type="button">⬅ Back</button>
</div>
</section> <!-- end #players -->

   <!--PAGE3: GAME -->
<section id="game" class="hidden">
  <div class="card section">
    <div class="row" id="gameTopRow">
      <button id="startScreenBtnGame" class="btn letter-throw top-throw">Start Screen</button>
      <button id="restartGameBtnGame" class="btn letter-throw top-throw">Restart Game</button>
      <button id="statsHubBtnGame" class="btn letter-throw top-throw">Stats</button>
    </div>

        <!-- Floating names + wins + totals -->
        <div class="float-head" id="floatHead">
          <div class="table-wrap" id="floatWrap">
            <table aria-hidden="true"><thead id="floatThead"></thead></table>
          </div>
        </div>

        <!-- Scoreboard -->
        <div class="table-wrap" id="scoreWrap" style="margin-top:10px">
          <table aria-label="Scoreboard">
            <thead id="thead"></thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>

        <!-- Hidden stats tables used to keep column widths aligned -->
        <div class="stats-box">
          <div class="table-wrap" id="statsWrap">
            <table aria-label="Player statistics">
              <thead id="statsThead"></thead>
              <tbody id="statsTbody"></tbody>
            </table>
          </div>
        </div>
        <div class="stats-box">
          <div class="table-wrap" id="mstatsWrap">
            <table aria-label="Match statistics">
              <thead id="mstatsThead"></thead>
              <tbody id="mstatsTbody"></tbody>
            </table>
          </div>
        </div>

        <div id="endBanner" class="banner hidden"></div>
      </div>
    </section>

<section id="leaderboard" class="card section hidden">
  <!-- Mirror the in-game top row (3 buttons, same sizing) -->
  <div class="row" id="leaderboardTopRow">
    <button id="startScreenBtnLB" class="btn letter-throw top-throw">Start Screen</button>
    <button id="restartGameBtnLB" class="btn letter-throw top-throw">Restart Game</button>
    <button id="statsHubBtnFinal" class="btn letter-throw top-throw">Stats</button>
  </div>

  <!-- Leaderboard in its own box -->
  <div class="lb-box" style="margin-top:8px;">
    <h2 style="margin-top:0;">Leaderboard</h2>
 <p class="tag hidden" style="margin-top:6px;"><span id="lbMatchInfo"></span></p>

    <div class="table-wrap" style="margin-top:8px">
      <table id="lbTable">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
      <!-- Stacked, centered actions -->
  <div class="stacked-actions">
    <button id="gameScoresBtn" class="btn big" type="button">GAME SCORES</button>
    <button id="highScoresMenuBtnLB" class="btn big" type="button">HIGH SCORES</button>

    <!-- NEXT GAME (shown while match ongoing) -->
    <button id="nextGameBtn" class="btn primary big" type="button">NEXT GAME ▶</button>

    <!-- END MATCH (replaces NEXT GAME when match complete) -->
    <button id="newMatchBtn" class="btn danger big hidden" type="button">END MATCH</button>

  </div>
  </div>

</section>

    <!-- Fixed Throw Pad (Game Stats / Match Stats / High Scores / Race appear here) -->
    <div class="pad-bar" id="padBar">
      <!-- keep your existing inner markup exactly as it is -->
      <div class="pad-inner">
        <div class="pad-head">
          <div class="pad-left">
            <div id="padHint" class="pad-hint"></div>
          </div>
        </div>
        <div id="pad" class="pad"></div>
      </div>
    </div>
    
    <div id="gifOverlay" class="gif-overlay hidden"></div>

    <!-- Add Player Modal -->
    <div id="addPlayerModal" class="modal-backdrop hidden">
      <div class="modal">
        <h3>Add New Player</h3>
        <div class="modal-body">
          <div class="stack">
            <label class="tag" for="newPlayerName">Player Name</label>
            <input id="newPlayerName" type="text" placeholder="Enter player name" />
          </div>
          <div class="stack" style="margin-top: 15px;">
            <label class="tag" for="newPlayerPassword">Password</label>
            <input
              id="newPlayerPassword"
              type="tel"
              inputmode="numeric"
              pattern="\d{4}"
              maxlength="4"
              placeholder="4-digit PIN"
            />
          </div>
        </div>
        <div class="modal-footer">
          <button id="cancelAddPlayerBtn" class="btn" type="button">Cancel</button>
          <button id="savePlayerBtn" class="btn primary" type="button">Save Player</button>
        </div>
      </div>
    </div>

<!-- Select Player Modal -->
<div id="selectPlayerModal" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Select Player</h3>
    <div class="modal-body">
      <div class="stack">
        <label class="tag">Player Name</label>
        <select id="existingPlayerSelect" style="width: 100%;">
          <option value="">Select a saved player...</option>
        </select>
      </div>
      <div class="stack ps-password-row" style="margin-top: 15px;">
        <label class="tag" for="playerPassword">Password</label>
        <input
          id="playerPassword"
          type="tel"
          inputmode="numeric"
          pattern="\d{4}"
          maxlength="4"
          placeholder="4-digit PIN"
        />
      </div>
    </div>
    <div class="modal-footer">
      <button id="cancelSelectPlayerBtn" class="btn" type="button">Cancel</button>
<button id="confirmSelectPlayerBtn" class="btn primary" type="button">Enter</button>

    </div>
  </div>
</div>

<!-- Admin Hub Modal -->
<div id="adminHubModal" class="modal-backdrop hidden">
  <div class="modal">
    <h3>Admin Hub</h3>
    <div class="modal-body">
      <div class="column" style="align-items:center; gap:8px;">
        <button id="openAllGamesBtn" class="btn" style="width:min(360px,92%);">All Games</button>
        <hr style="width:min(360px,92%); border:0; border-top:1px solid #23284a; margin:6px 0;">

        <button id="openHsLeagueAdmin"   class="btn" style="width:min(360px,92%);">League High Scores</button>
        <button id="openHsPracticeAdmin" class="btn" style="width:min(360px,92%);">Practice High Scores</button>
        <button id="openLeagueLowsAdmin" class="btn" style="width:min(360px,92%);">League Low Scores</button>
        <hr style="width:min(360px,92%); border:0; border-top:1px solid #23284a; margin:6px 0;">

        <button id="openSavedPlayersAdminBtn" class="btn" style="width:min(360px,92%);">Saved Player Admin</button>

        <hr style="width:min(360px,92%); border:0; border-top:1px solid #23284a; margin:6px 0;">
        
        <button id="openPBGRAdminBtn" class="btn" style="width:min(360px,92%);">PB / GR Admin</button>

        <hr style="width:min(360px,92%); border:0; border-top:1px solid #23284a; margin:6px 0;">

        <button id="fixDuplicatesBtn" class="btn danger" style="width:min(360px,92%);">Remove Duplicate High Scores</button>

        <hr style="width:min(360px,92%); border:0; border-top:1px solid #23284a; margin:6px 0;">

        <button id="closeAdminHubBtn" class="btn" type="button" style="width:min(360px,92%);">Return</button>
      </div>
    </div>
  </div>
</div>

<!-- All Games Modal -->
<div id="allGamesModal" class="modal-backdrop hidden">
  <div class="modal compact">
    <h3>All Games</h3>
    <div class="modal-body" id="allGamesBody">
      <div id="allGamesTableWrap"></div>
    </div>
    <div class="modal-footer">
      <button id="allGamesBackBtn" class="btn" type="button">Back</button>
      <button id="allGamesCloseBtn" class="btn" type="button">Close</button>
    </div>
  </div>
</div>

<!-- League Low Scores Admin Modal -->
<div id="leagueLowsAdminModal" class="modal-backdrop hidden">
  <div class="modal compact">
    <h3>League Low Scores — Admin</h3>
    <div class="modal-body" id="leagueLowsAdminBody">
      <p class="tag">Loading league low scores…</p>
    </div>
    <div class="modal-footer">
      <button id="leagueLowsBackBtn" class="btn" type="button">Back</button>
      <button id="leagueLowsCloseBtn" class="btn" type="button">Close</button>
    </div>
  </div>
</div>

<!-- PB / GR Admin Modal -->
<div id="pbgrAdminModal" class="modal-backdrop hidden">
  <div class="modal compact">
    <h3>PB / GR Admin</h3>
    <div class="modal-body">
      <p class="tag">Manage Personal Bests and Game Records. Deleting a row will remove the underlying round from the cloud.</p>
      <h4 style="margin-top:8px;">World Records (All Players)</h4>
      <div id="pbgrGlobal"></div>
      <hr style="margin:10px 0;">
      <div class="row" style="align-items:center; gap:8px;">
        <select id="pbgrPlayerSelect" style="flex:1; min-width: 180px;">
          <option value="">Select a saved player…</option>
        </select>
        <button id="pbgrRefreshBtn" class="btn" type="button">Refresh</button>
      </div>
      <div class="row" style="margin-top:10px; gap:8px; align-items:center;">
        <button id="pbgrBackfillBtn" class="btn warn" type="button">Backdate PB / WR</button>
        <span class="tag">Scan cloud throws (saved players, official games) and write PBs + WRs to cloud tables.</span>
      </div>
      <div id="pbgrPlayer" style="margin-top:8px;"></div>
    </div>
    <div class="modal-footer">
      <button id="pbgrBackBtn" class="btn" type="button">Back</button>
      <button id="pbgrCloseBtn" class="btn" type="button">Close</button>
    </div>
  </div>
</div>

  <!-- Round High Scores (public) -->
  <div id="roundHighScoresModal" class="modal-backdrop hidden">
    <div class="modal compact">
      <h3>Round High Scores</h3>
      <div class="modal-body" id="roundHSBody">
        <p class="tag">Loading…</p>
      </div>
      <div class="modal-footer">
        <button id="roundHSBackBtn" class="btn" type="button">Back</button>
        <button id="roundHSCloseBtn" class="btn" type="button">Close</button>
      </div>
    </div>
  </div>

    <!-- Saved Players Admin Modal -->
    <div id="savedPlayersAdminModal" class="modal-backdrop hidden">
      <div class="modal compact">
        <h3>Saved Players Admin</h3>
        <div class="modal-body">
          <div id="savedPlayersAdminBody"></div>
        </div>
        <div class="modal-footer">
          <button id="backSavedPlayersAdminBtn" class="btn" type="button">Back</button>
          <button id="closeSavedPlayersAdminBtn" class="btn" type="button">Close</button>
        </div>
      </div>
    </div>

    <!-- Cloud Status -->
    <div id="cloudStatus" class="cloud-status checking">
      <span class="cloud-dot"></span>
      <span id="cloudStatusText">Checking cloud…</span>
    </div>
    <script>
// Global guard: some third‑party embeds reference a global `F`; define a harmless fallback
if (typeof window.F === 'undefined') {
  window.F = function(){ /* no-op */ };
}
// --- Round score only (DOM promotion + cleanup) ---
function promoteRoundOnly(){
  // Reverted: keep cumulative main + (round) sub rendering.
  return;
}

// Compute the per-dart symbol for a given dart + round
function symbolForDart(d, rd){
  // No dart thrown yet
  if (!d || (typeof d.points === 'undefined' && !d.kind)) return { ch: '○', cls: '' };
  // Miss (no points registered)
  if (!d || Number(d.points || 0) === 0){
    // Bulls: if it's marked as a Bull hit, show 50 / 25 even if points weren’t recorded
    if (rd && rd.type === 'bull' && d && d.kind === 'Bull'){
      const isInner = (d.bull === 'Inner');
      return { ch: isInner ? '50' : '25', cls: '' };
    }
    return { ch: '✕', cls: 'miss' };
  }

  // Number rounds
  if (rd && rd.type === 'number'){
    const k = (d.kind || '').toUpperCase();
    if (k === 'TRIPLE' || k === 'T') return { ch: 'T', cls: '' };
    if (k === 'DOUBLE' || k === 'D') return { ch: 'D', cls: '' };
    return { ch: 'S', cls: '' };
  }

  // Doubles / Triples with explicit numbers
  if (rd && rd.type === 'doubles'){
    const pts = Number(d.points || 0);
    let n = pts ? pts / 2 : null;
    if (!Number.isInteger(n) || n < 1 || n > 20){
      const t = Number(d.target ?? d.num ?? d.number ?? NaN);
      if (Number.isInteger(t) && t >= 1 && t <= 20) n = t;
    }
    const label = Number.isInteger(n) ? `D${n}` : 'D?';
    return { ch: label, cls: '' };
  }
  if (rd && rd.type === 'triples'){
    const pts = Number(d.points || 0);
    let n = pts ? pts / 3 : null;
    if (!Number.isInteger(n) || n < 1 || n > 20){
      const t = Number(d.target ?? d.num ?? d.number ?? NaN);
      if (Number.isInteger(t) && t >= 1 && t <= 20) n = t;
    }
    const label = Number.isInteger(n) ? `T${n}` : 'T?';
    return { ch: label, cls: '' };
  }

  // Bull round – show 50/25
  if (rd && rd.type === 'bull'){
    if (d.kind === 'Bull'){
      const isInner = (d.bull === 'Inner');
      return { ch: isInner ? '50' : '25', cls: '' };
    }
    const pts = Number(d.points || 0);
    if (pts === 50 || pts === 25) return { ch: String(pts), cls: '' };
    return { ch: '✕', cls: 'miss' };
  }

  // Fallback
  return { ch: '○', cls: '' };
}

// Mark the highest bracketed value per round as green.
// Works on any score-sheet markup as long as the bracket text contains a number.
window.markRoundHighs = function markRoundHighs(root = document) {
  // cover 10..20 + D/T/B = 14 rows => indexes 0..13
  for (let r = 0; r <= 13; r++) {
    // try to find bracketed elements; prefer ones tagged with data-round if present
    const subs = Array.from(
      root.querySelectorAll(`.round-sub[data-round="${r}"], [data-round="${r}"] .round-sub`)
    );

    // fallback: just grab all .round-sub in the table section for this round
    const bucket = subs.length ? subs :
      Array.from(root.querySelectorAll(`.round-sub`))
        .filter(el => el.closest('[data-round-index]')?.getAttribute('data-round-index') == String(r));

    if (!bucket.length) continue;

    // read a numeric value from data-points if provided, else parse `(123)`
    const values = bucket.map(el => {
      const v = Number(el.dataset.points);
      if (Number.isFinite(v)) return v;
      const m = (el.textContent || '').match(/-?\d+(?:\.\d+)?/);
      return m ? Number(m[0]) : 0;
    });

    const max = Math.max(0, ...values);

    bucket.forEach((el, i) => {
      el.classList.toggle('is-round-high', values[i] === max && max > 0);
    });
  }
};

// Fetch per-dart pattern for a specific game/player/round (e.g. "S/S/D" or "x/T/T")
async function fetchRoundPattern(gameId, playerName, ridx){
  if (!gameId || playerName == null || ridx == null) return '';
  // 1) Preferred: throws table
  try{
    const { data, error } = await sb
      .from(TABLE_GAME_THROWS)
      .select('dart_index, points, kind, bull')
      .eq('game_id', gameId)
      .eq('player', playerName)
      .eq('round_index', ridx)
      .order('dart_index', { ascending: true });
    if (error) throw error;

    const rd = ROUNDS[ridx];
    const chars = [];
    for (let i = 0; i < 3; i++){
      const d = (data || []).find(r => Number(r.dart_index) === i) || null;
      const sym = symbolForDart(d, rd);
      let ch = sym && sym.ch ? sym.ch : 'x';
      if (ch === '✕') ch = 'x';
      chars.push(ch);
    }
    return chars.join('/');
  } catch(e){
    // 2) Fallback: games.state.board (if stored)
    try{
      const { data, error } = await sb.from(TABLE_GAMES).select('state').eq('id', gameId).single();
      if (error) throw error;
      const rd = ROUNDS[ridx];
      const players = (data?.state?.players || []).map(p => (typeof p === 'string' ? { name:p } : p));
      const pIdx = players.findIndex(p => eqName(p.name, playerName));
      const ent  = pIdx >= 0 ? (data?.state?.board?.[pIdx] || [])[ridx] : null;
      const chars = [];
      for (let i = 0; i < 3; i++){
        const d = ent && Array.isArray(ent.darts) ? ent.darts[i] : null;
        const sym = symbolForDart(d, rd);
        let ch = sym && sym.ch ? sym.ch : 'x';
        if (ch === '✕') ch = 'x';
        chars.push(ch);
      }
      return chars.join('/');
    }catch(_){
      return '';
    }
  }
}
window.fetchRoundPattern = fetchRoundPattern;

// Fetch a game's timestamp from the cloud (with fallbacks)
async function fetchGameTS(gameId){
  try{
    const { data, error } = await sb
      .from(TABLE_GAMES)
      .select('ts, created_at, inserted_at')
      .eq('id', gameId)
      .single();
    if (error) throw error;
    return data?.ts || data?.created_at || data?.inserted_at || null;
  }catch(_){
    return null;
  }
}

// Earliest TS for a specific game/player/round (fallback for Date/Time column)
async function fetchRoundTS(gameId, playerName, ridx){
  try{
    const { data, error } = await sb
      .from(TABLE_GAME_THROWS)
      .select('ts')
      .eq('game_id', gameId)
      .eq('player', playerName)
      .eq('round_index', ridx)
      .order('ts', { ascending: true })
      .limit(1);
    if (error) throw error;
    return (data && data[0] && data[0].ts) ? data[0].ts : null;
  }catch(_){
    return null;
  }
}

// Inject/update the three per-dart markers under each round score cell
function injectThrowMarkers(){
  // Reverted: per‑dart markers disabled.
  return;
}
function setupRoundScoreObserver(){
  // PB/GR disabled on the scoreboard: scrub any tokens that might be rendered by legacy code
  const tbody = document.getElementById('tbody');
  if (!tbody) { setTimeout(setupRoundScoreObserver, 250); return; }

  function scrub(){
    const subs = tbody.querySelectorAll('.cell-sub');
    subs.forEach(sub => {
      // Flatten to plain text and strip (PB) / (GR) tokens, preserving the round score e.g. (30)
      const raw = (sub.textContent || '');
      const cleaned = raw
        .replace(/\s*\(PB\)\s*/gi, ' ')
        .replace(/\s*\(GR\)\s*/gi, ' ')
        .replace(/\s{2,}/g, ' ')
        .trim();
      if (cleaned !== raw) sub.textContent = cleaned;

      // Remove any leftover elements used by older implementations
      sub.querySelectorAll('.pbgr, .pb-badge').forEach(n => {
        try {
          // If it wraps text like "(30) (PB) (GR)", keep the text but without tokens
          const txt = (n.textContent || '')
            .replace(/\s*\(PB\)\s*/gi, ' ')
            .replace(/\s*\(GR\)\s*/gi, ' ')
            .replace(/\s{2,}/g, ' ')
            .trim();
          n.replaceWith(document.createTextNode(txt));
        } catch(_) { try { n.remove(); } catch(_){} }
      });
    });
  }

  // Observe scoreboard updates and continuously scrub
  try {
    const mo = new MutationObserver(() => scrub());
    mo.observe(tbody, { childList: true, subtree: true, characterData: true });
  } catch(_){}

  // Initial + delayed passes
  scrub();
  setTimeout(scrub, 300);
  setTimeout(scrub, 1000);
}
// --- Global high-score de-dup helpers ---
function _keyNameScore(row){
  const n = String(row?.name || '').trim().toLowerCase();
  const s = Number(row?.score || 0);
  return `${n}|${s}`;
}
function dedupeRowsByNameScoreKeepEarliest(rows){
  const map = new Map(); // key => row with earliest ts
  for (const r of (rows || [])){
    if (!r) continue;
    const key = _keyNameScore(r);
    const existing = map.get(key);
    const tNew = r?.ts ? Date.parse(r.ts) : Infinity;
    if (!existing){
      map.set(key, r);
    } else {
      const tOld = existing?.ts ? Date.parse(existing.ts) : Infinity;
      if (tNew < tOld) map.set(key, r); // keep the earliest/original
    }
  }
  return [...map.values()];
}
async function dedupeTableHighScores(table){
  const { data, error } = await sb
    .from(table)
    .select('name, score, ts')
    .order('ts', { ascending: true })
    .limit(10000);
  if (error) { markCloudError(error); throw error; }
  const groups = new Map();
  for (const r of (data || [])){
    const key = _keyNameScore(r);
    const arr = groups.get(key) || [];
    arr.push(r);
    groups.set(key, arr);
  }
  let deleted = 0;
  for (const [, arr] of groups){
    if (arr.length <= 1) continue;
    arr.sort((a,b)=> (Date.parse(a.ts||'')||0) - (Date.parse(b.ts||'')||0));
    // keep earliest (index 0), delete the rest
    for (let i = 1; i < arr.length; i++){
      const row = arr[i];
      const { error: delErr } = await sb.from(table)
        .delete()
        .eq('name', row.name)
        .eq('score', row.score)
        .eq('ts', row.ts);
      if (!delErr) deleted++;
    }
  }
  markCloudOk();
  return deleted;
}
async function dedupeAllHighScores(){
  let total = 0;
  try { total += await dedupeTableHighScores(TABLE_HS_LEAGUE); } catch(e){ console.error(e); }
  try { total += await dedupeTableHighScores(TABLE_HS_PRACTICE); } catch(e){ console.error(e); }
  return total;
}
// ---- Admin Hub ----
function openAdminHub(){
  const hub = document.getElementById('adminHubModal');
  if (!hub) return;
  hub.classList.remove('hidden');

  // Buttons
  const btnAll   = document.getElementById('openAllGamesBtn');
  const btnLHS   = document.getElementById('openHsLeagueAdmin');
  const btnPHS   = document.getElementById('openHsPracticeAdmin');
  const btnLLS   = document.getElementById('openLeagueLowsAdmin');
  const btnSave  = document.getElementById('openSavedPlayersAdminBtn');
  const btnClose = document.getElementById('closeAdminHubBtn');
  const btnFix   = document.getElementById('fixDuplicatesBtn');
  const btnPBGR  = document.getElementById('openPBGRAdminBtn');

if (btnAll)  btnAll.onclick  = ()=>{ hub.classList.add('hidden'); openAllGamesDialog(); };
if (btnLHS)  btnLHS.onclick  = ()=>{ hub.classList.add('hidden'); openHighScoresAdminDialog(false); };
if (btnPHS)  btnPHS.onclick  = ()=>{ hub.classList.add('hidden'); openHighScoresAdminDialog(true); };
if (btnLLS)  btnLLS.onclick  = () => {
  hub.classList.add('hidden');
  openLeagueLowsAdminDialog();
};
if (btnSave) btnSave.onclick = ()=>{ hub.classList.add('hidden'); openSavedPlayersAdminDialog(); };
  if (btnPBGR) btnPBGR.onclick = ()=>{ hub.classList.add('hidden'); openPBGRAdminDialog(); };

  if (btnFix) btnFix.onclick = async ()=>{
    hub.classList.add('hidden');
    try{
      const removed = await dedupeAllHighScores();
      toast(`Removed ${removed} duplicate row${removed===1?'':'s'}.`);
    }catch(e){
      console.error(e);
      toast('Dedupe failed');
    }
  };

  if (btnClose) btnClose.onclick = ()=>{ hub.classList.add('hidden'); };
}

// === All Games modal (simple list) ===
function openAllGamesDialog(){
  const modal = document.getElementById('allGamesModal');
  if (!modal) return;
  modal.classList.remove('hidden');

  const wrap   = document.getElementById('allGamesTableWrap');
  const back   = document.getElementById('allGamesBackBtn');
  const close  = document.getElementById('allGamesCloseBtn');
  if (back)  back.onclick  = () => { modal.classList.add('hidden'); openAdminHub(); };
  if (close) close.onclick = () => { modal.classList.add('hidden'); };

  // Hard cleanup: remove any rogue Official/Practice filter buttons injected by older code
  function __stripAllGamesFilterButtons(){
    try{
      const btns = Array.from(modal.querySelectorAll('button'));
      btns.forEach(b=>{
        const t = (b.textContent || '').trim().toLowerCase();
        if (t === 'official' || t === 'practice') {
          b.remove();
        }
      });
      // If their parent container is now empty and only existed for those buttons, remove it too
      Array.from(modal.querySelectorAll('.filters, .row, .header, div')).forEach(node=>{
        if (!node || node === modal) return;
        // Only consider small containers near the heading
        const isSmall = node.childElementCount <= 1;
        if (isSmall) {
          const hasButtons = Array.from(node.querySelectorAll('button')).length === 0;
          if (hasButtons && /^\s*$/.test(node.textContent || '')) {
            // empty and had no other content
            // (wrapped containers that are now empty)
            try { node.remove(); } catch(_) {}
          }
        }
      });
    }catch(_){}
  }
  __stripAllGamesFilterButtons();

  const toTS = (g)=> {
    const t = g?.ts || g?.created_at || g?.inserted_at || (g?.meta && (g.meta.ts || g.meta.date)) || null;
    const n = t ? Date.parse(t) : NaN;
    return Number.isFinite(n) ? n : 0;
  };

  async function render(){
    if (wrap) wrap.innerHTML = '<p class="tag">Loading…</p>';

    let games = [];
    try { games = await cloudFetchAllGamesAsLocal(); } catch(e){ console.error(e); }

    games = (games || []).filter(Boolean).sort((a,b)=> toTS(b) - toTS(a));

    // Build table
    const table = document.createElement('table');
    table.className = 'hs-table';

    const colgroup = document.createElement('colgroup');
    const maxDigits = Math.max(2, String(games.length || 0).length);
    const colNum  = document.createElement('col');  colNum.style.width  = `${Math.min(3, maxDigits)}ch`;
    const colWhen = document.createElement('col');  colWhen.style.width = '10ch';
    const colRes  = document.createElement('col');
    colgroup.append(colNum, colWhen, colRes);
    table.appendChild(colgroup);

    const thead = document.createElement('thead');
    const trh   = document.createElement('tr');
    ['#','When','Result'].forEach(h => {
      const th = document.createElement('th'); th.textContent = h; trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');

    games.forEach((g, idx) => {
      const tr  = document.createElement('tr');

      // #
      const td1 = document.createElement('td'); td1.textContent = String(idx + 1);

      // When (locale short form; original behaviour)
      const td2 = document.createElement('td');
      const tsVal = g.ts || g.created_at || g.inserted_at || (g.meta && (g.meta.ts || g.meta.date)) || null;
      if (tsVal){
        const d = new Date(tsVal);
        td2.textContent = !Number.isNaN(d.getTime())
          ? d.toLocaleString(undefined,{year:'2-digit',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit'})
          : '';
      } else {
        td2.textContent = '';
      }

      // Result
      const players = (g.players || []).map(p => (p && p.name) ? p.name : '');
      const totals  = Array.isArray(g.totals) ? g.totals : [];
      const ordered = players
        .map((name, i) => ({ name, score: Number(totals[i] || 0) }))
        .filter(x => x.name)
        .sort((a, b) => b.score - a.score);

      let result = '—';
      if (ordered.length >= 2) {
        result = `${ordered[0].name} ${ordered[0].score} beat ${ordered[1].name} ${ordered[1].score}`;
        if (ordered.length > 2) {
          result += ' ' + ordered.slice(2).map(o => `${o.name} ${o.score}`).join(' ');
        }
      } else if (ordered.length === 1) {
        result = `${ordered[0].name} ${ordered[0].score}`;
      }

      const td3 = document.createElement('td'); td3.textContent = result;

      tr.append(td1, td2, td3);

      // Click row to open the score sheet if available
      tr.style.cursor = 'pointer';
      tr.title = 'Open score sheet';
      tr.onclick = () => { try { if (typeof openSingleGameScoreSheet === 'function') openSingleGameScoreSheet(g); } catch(_) {} };

      tbody.appendChild(tr);
    });

    table.appendChild(tbody);

    if (wrap) {
      wrap.innerHTML = '';
      const tw = document.createElement('div'); tw.className = 'table-wrap';
      tw.appendChild(table);
      wrap.appendChild(tw);
      // After DOM insert, clean up any rogue filter buttons
      __stripAllGamesFilterButtons();
    }
  }

  render();
}

// League Low Scores Admin dialog (global)
function openLeagueLowsAdminDialog(){
  const modal = document.getElementById('leagueLowsAdminModal');
  const body  = document.getElementById('leagueLowsAdminBody');
  const back  = document.getElementById('leagueLowsBackBtn');
  const close = document.getElementById('leagueLowsCloseBtn');
  if (!modal || !body) return;

  modal.classList.remove('hidden');

  if (back)  back.onclick  = () => { modal.classList.add('hidden'); openAdminHub(); };
  if (close) close.onclick = () => { modal.classList.add('hidden'); };

  (async () => {
    body.innerHTML = '<p class="tag">Loading league low scores…</p>';

    try {
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()){
        body.innerHTML = '<p>Cloud not initialised.</p>';
        return;
      }
    } catch(_) {}

    let rows = [];
    try {
      const { data, error } = await sb
        .from(TABLE_PLAYER_GAMES)
        .select('sheet_id, player, score, ts, is_practice, rounds')
        .eq('is_practice', false)
        .order('score', { ascending: true })
        .order('ts',    { ascending: true })
        .limit(1000);
      if (error) throw error;
      rows = data || [];
    } catch(e) {
      console.error('League low scores fetch failed', e);
      const msg = (e && e.message) ? e.message : 'Unknown error';
      body.innerHTML = '<p>Failed to load league low scores.</p>' +
        '<p class="tag">' + msg + '</p>';
      return;
    }

    if (!rows.length){
      body.innerHTML = '<p>No league low scores found.</p>';
      return;
    }

    const table = document.createElement('table');
    table.className = 'hs-table compact';

    const thead = document.createElement('thead');
    const trh   = document.createElement('tr');
    ['#','Player','Score','Avg / Round','When','Actions'].forEach(h=>{
      const th = document.createElement('th');
      th.textContent = h;
      trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    rows.forEach((row, idx) => {
      const tr    = document.createElement('tr');

      const tdIdx = document.createElement('td');
      tdIdx.textContent = String(idx + 1);

      const tdName = document.createElement('td');
      tdName.textContent = row.player || '';

      const tdScore = document.createElement('td');
      tdScore.textContent = String(row.score ?? '');

      const tdAvg = document.createElement('td');
      const rounds = Number(row.rounds || 0);
      if (rounds > 0) {
        const avg = row.score / rounds;
        tdAvg.textContent = avg.toFixed(1);
      } else {
        tdAvg.textContent = '—';
      }

      const tdWhen = document.createElement('td');
      if (row.ts){
        const d = new Date(row.ts);
        tdWhen.textContent = !Number.isNaN(d.getTime())
          ? d.toLocaleString(undefined,{
              year: '2-digit',
              month: 'short',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit'
            })
          : '';
      } else {
        tdWhen.textContent = '';
      }

      const tdAct = document.createElement('td');
      tdAct.className = 'center';

      const delBtn = document.createElement('button');
      delBtn.className = 'btn small danger';
      delBtn.textContent = 'Delete game';
      delBtn.onclick = async (e) => {
        e.stopPropagation();
        const sheetId = row.sheet_id;
        if (!sheetId){
          if (typeof toast === 'function') toast('Missing game id for this row');
          return;
        }
        const msg = `Delete game ${sheetId} for ${row.player || 'Unknown'} (score ${row.score})?\n\nThis will remove the game and all related stats from the cloud.`;
        if (!confirm(msg)) return;
        try{
          // Delete throws first, then game record
          try {
            await sb.from(TABLE_GAME_THROWS).delete().eq('game_id', sheetId);
          } catch(e1){
            console.error('Delete game_throws failed', e1);
          }
          const { error: delErr } = await sb.from(TABLE_GAMES).delete().eq('id', sheetId);
          if (delErr) throw delErr;
          if (typeof toast === 'function') toast('Game deleted');
          // re-render list
          openLeagueLowsAdminDialog();
        }catch(err){
          console.error('Delete league low game failed', err);
          if (typeof toast === 'function') toast('Delete failed');
        }
      };

      tdAct.appendChild(delBtn);
      tr.append(tdIdx, tdName, tdScore, tdAvg, tdWhen, tdAct);
      tbody.appendChild(tr);
    });

    table.appendChild(tbody);
    body.innerHTML = '';
    body.appendChild(table);
  })();
}

// Player Stats — Select Player flow (uses the generic Select Player modal)
function openPlayerStatsSelectDialog(){
  const modal     = document.getElementById('selectPlayerModal');
  const title     = modal ? modal.querySelector('h3') : null;
  const sel       = document.getElementById('existingPlayerSelect');
  const pwdRow    = modal ? modal.querySelector('.ps-password-row') : null;
  const cancelBtn = document.getElementById('cancelSelectPlayerBtn');
  const confirmBtn= document.getElementById('confirmSelectPlayerBtn');
  if (!modal || !sel || !cancelBtn || !confirmBtn) return;

  // Configure modal for Player Stats
  if (title)  title.textContent = 'Player Stats – Select Player';
  if (pwdRow) pwdRow.classList.add('hidden');   // PIN not required for viewing stats
  confirmBtn.textContent = 'View Stats';

  // Populate saved players
  (async () => {
    try{
      const items = await cloudListPlayers(); // [{name}]
      sel.innerHTML = '<option value="">Select a saved player...</option>' +
        (items || []).map(p => `<option value="${p.name}">${p.name}</option>`).join('');
    }catch(e){
      console.error('Stats: load players failed', e);
    }
  })();

  // Wire buttons (override only for this open)
  cancelBtn.onclick = () => { modal.classList.add('hidden'); };

  confirmBtn.onclick = () => {
    const name = (sel.value || '').trim();
    if (!name){ try{ toast('Pick a player'); }catch(_){} return; }
    modal.classList.add('hidden');

    // Open the actual Player Stats modal/hub (support either function name)
    try{
      if (typeof openPlayerStatsHub === 'function') {
        openPlayerStatsHub(name);
      } else if (typeof openPlayerStatsDialog === 'function') {
        openPlayerStatsDialog(name);
      } else {
        console.warn('No player stats dialog function found');
      }
    }catch(err){
      console.error('Open Player Stats failed', err);
    }
  };

  modal.classList.remove('hidden');
}

// Ensure the Start screen button opens the Stats select flow
document.addEventListener('DOMContentLoaded', function(){
  const btn = document.getElementById('playerStatsBtn');
  if (btn) btn.onclick = () => openPlayerStatsSelectDialog();
});

// --- PB / GR Admin: open/close + minimal render ---
function openPBGRAdminDialog(){
  const modal = document.getElementById('pbgrAdminModal');
  if (!modal) return;
  modal.classList.remove('hidden');

  const back  = document.getElementById('pbgrBackBtn');
  const close = document.getElementById('pbgrCloseBtn');
  const sel   = document.getElementById('pbgrPlayerSelect');
  const ref   = document.getElementById('pbgrRefreshBtn');

  if (back)  back.onclick  = () => { modal.classList.add('hidden'); openAdminHub(); };
  if (close) close.onclick = () => { modal.classList.add('hidden'); };

  // Populate dropdown once per open
  (async () => {
    try{
      const items = await cloudListPlayers(); // [{name}]
      if (sel){
        sel.innerHTML = '<option value="">Select a saved player…</option>' +
          (items||[]).map(p => `<option value="${p.name}">${p.name}</option>`).join('');
      }
    }catch(e){ console.error(e); }
  })();

  if (ref) ref.onclick = () => { try{ if (typeof refreshPBGRCloud === 'function') refreshPBGRCloud(); }catch(_){ } };
}

// Saved Players Admin
async function openSavedPlayersAdminDialog(){
  const modal = document.getElementById('savedPlayersAdminModal');
  const body  = document.getElementById('savedPlayersAdminBody');
  const back  = document.getElementById('backSavedPlayersAdminBtn');
  const close = document.getElementById('closeSavedPlayersAdminBtn');
  if (!modal || !body) return;

  modal.classList.remove('hidden');
  if (back)  back.onclick  = () => { modal.classList.add('hidden'); openAdminHub(); };
  if (close) close.onclick = () => { modal.classList.add('hidden'); };

  await renderSavedPlayersAdmin();
}

// Generic renderer that can write the PB/GR table into any mount id
async function renderPBGRTableInto(mountId){
  const mount = document.getElementById(mountId);
  if (!mount) return;
  mount.innerHTML = '<p class="tag">Loading…</p>';
  try{
    const snap = await (typeof getPBGRSnapshot === 'function' ? getPBGRSnapshot() : Promise.resolve({ byTargetMeta: {} }));
    const order = [...Array.from({length:11},(_,i)=>10+i), 'D','T','B'];

    // Build table with Date / Time column included
    const table = document.createElement('table'); table.className='hs-table';
    const thead = document.createElement('thead');
    const trh = document.createElement('tr');
    ['Round','WR','Darts','Date / Time','Holder'].forEach(h=>{
      const th = document.createElement('th');
      th.textContent = h;
      trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    table.appendChild(tbody);

    const fmtDate = (ts) => {
      if (!ts) return '—';
      const d = new Date(ts);
      if (Number.isNaN(d.getTime())) return '—';
      return d.toLocaleString('en-GB', {
        year: 'numeric',
        month: 'short',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    };

    const pending = [];

    order.forEach(key=>{
      const meta = (snap.byTargetMeta && snap.byTargetMeta[key]) ? snap.byTargetMeta[key] : { val:0, player:'', game_id:null, ridx:null, ts:null };
      const tr   = document.createElement('tr');

      const tdR  = document.createElement('td'); tdR.textContent = String(key);
      const tdV  = document.createElement('td'); tdV.textContent = String(meta.val || 0);
      const tdD  = document.createElement('td'); tdD.textContent = '—'; // async filled with S/D/T/x pattern
      const tdT  = document.createElement('td'); tdT.textContent = fmtDate(meta.ts);
      const tdN  = document.createElement('td'); tdN.textContent = meta.player ? meta.player : '—';

      tr.append(tdR, tdV, tdD, tdT, tdN);
      tbody.appendChild(tr);

      // Fetch the per-dart pattern (S/D/T etc.)
      if (meta && meta.game_id != null && meta.player && (meta.ridx || meta.ridx === 0)){
        pending.push(
          fetchRoundPattern(meta.game_id, meta.player, meta.ridx)
            .then(pat => { tdD.textContent = pat || '—'; })
            .catch(()=>{ tdD.textContent = '—'; })
        );
      }

      // Fill Date/Time if missing: try Games.ts -> earliest throw ts
      if (!meta?.ts && meta?.game_id){
        pending.push(
          (async ()=>{
            const gts = await fetchGameTS(meta.game_id);
            if (gts){
              tdT.textContent = fmtDate(gts);
              return;
            }
            if (meta.player && (meta.ridx || meta.ridx === 0)){
              const rts = await fetchRoundTS(meta.game_id, meta.player, meta.ridx);
              if (rts) tdT.textContent = fmtDate(rts);
            }
          })()
        );
      }
    });

    if (pending.length){ try{ await Promise.allSettled(pending); }catch(_){ /* ignore */ } }
    mount.innerHTML = '';
    mount.appendChild(table);
  }catch(e){
    console.error('renderPBGRTableInto failed', e);
    mount.innerHTML = '<p>Unable to load World Records right now.</p>';
  }
}

// Keep admin renderer for pb/gr admin modal
async function renderPBGRGlobalTable(){
  return renderPBGRTableInto('pbgrGlobal');
}
// Public Round High Scores modal
function openRoundHighScoresDialog(){
  const modal = document.getElementById('roundHighScoresModal');
  const body  = document.getElementById('roundHSBody');
  const btnBack  = document.getElementById('roundHSBackBtn');
  const btnClose = document.getElementById('roundHSCloseBtn');
  if (!modal || !body) return;

  modal.classList.remove('hidden');
  if (btnBack)  btnBack.onclick  = () => { modal.classList.add('hidden'); };
  if (btnClose) btnClose.onclick = () => { modal.classList.add('hidden'); };

  // Re-use the generic PB/GR table builder
  renderPBGRTableInto('roundHSBody').catch(()=>{
    body.innerHTML = '<p>Unable to load right now.</p>';
  });
}

async function renderSavedPlayersAdmin(){
  const body = document.getElementById('savedPlayersAdminBody');
  if (!body) return;
  body.innerHTML = '<p class="tag">Loading players…</p>';
  let players = [];
  try { players = await cloudListPlayers(); } catch(e){ console.error(e); body.innerHTML = '<p>Failed to load players.</p>'; return; }

  if (!Array.isArray(players) || players.length === 0){
    body.innerHTML = '<p>No players found.</p>';
    return;
  }

  const table = document.createElement('table');
  table.className = 'hs-table';
  const thead = document.createElement('thead');
  const hr = document.createElement('tr');
  ['Name','New PIN','Actions'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; hr.appendChild(th); });
  thead.appendChild(hr); table.appendChild(thead);
  const tbody = document.createElement('tbody');

  players.forEach(p=>{
    const tr = document.createElement('tr');

    // Name input
    const nameTd = document.createElement('td');
    const nameIn = document.createElement('input');
    nameIn.type = 'text';
    nameIn.value = p.name;
    nameIn.style.width = '100%';
    nameTd.appendChild(nameIn);

    // PIN input
    const pinTd = document.createElement('td');
    const pinIn = document.createElement('input');
    pinIn.type = 'tel'; pinIn.inputMode='numeric'; 
    pinIn.pattern='\\d{4}'; // 4 digits
    pinIn.placeholder = '4-digit';
    pinIn.maxLength = 4;
    pinIn.style.width = '100%';
    pinTd.appendChild(pinIn);

    // Actions
    const actTd = document.createElement('td');
    const saveNameBtn = document.createElement('button');
    saveNameBtn.className='btn small'; saveNameBtn.textContent='Save Name';
    const savePinBtn = document.createElement('button');
    savePinBtn.className='btn small'; savePinBtn.textContent='Update PIN';
    const delBtn = document.createElement('button');
    delBtn.className='btn small danger'; delBtn.textContent='Delete';
    actTd.append(saveNameBtn, document.createTextNode(' '), savePinBtn, document.createTextNode(' '), delBtn);

    // Wire actions
    saveNameBtn.onclick = async ()=>{
      const newName = (nameIn.value||'').trim();
      if (!newName){ toast('Enter a name'); return; }
      if (newName === p.name){ toast('No change'); return; }
      try { await cloudRenamePlayer(p.name, newName); toast('Name updated'); await renderSavedPlayersAdmin(); }
      catch(e){ console.error(e); toast('Rename failed'); }
    };

    savePinBtn.onclick = async ()=>{
      const pin = (pinIn.value||'').trim();
if (!/^\d{4}$/.test(pin)){ toast('PIN must be 4 digits'); return; }      try { await cloudUpdatePlayerPassword(p.name, pin); pinIn.value=''; toast('PIN updated'); }
      catch(e){ console.error(e); toast('PIN update failed'); }
    };

    delBtn.onclick = async ()=>{
      if (!confirm(`Delete ${p.name}?`)) return;
      try { await cloudDeletePlayer(p.name); toast('Deleted'); await renderSavedPlayersAdmin(); }
      catch(e){ console.error(e); toast('Delete failed'); }
    };

    tr.append(nameTd, pinTd, actTd); tbody.appendChild(tr);
  });

  table.appendChild(tbody);
    body.innerHTML = '';
    body.appendChild(table);
}

// === Final version: single-line psTicker vertical scroller ===
(function () {
  const IN_MS   = 800;   // time for the scroll animation (ms)
  const HOLD_MS = 3000;  // time each score stays fully visible (ms)

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  function formatGameForTicker(g) {
    if (!g) return '';

    const players = (g.players || []).map(p =>
      (p && typeof p === 'object' && 'name' in p) ? p.name : String(p || '')
    );
    const totals  = Array.isArray(g.totals) ? g.totals : [];

    const ordered = players
      .map((name, i) => ({ name, score: Number(totals[i] || 0) }))
      .filter(x => x.name)
      .sort((a, b) => b.score - a.score);

    let resultHtml = '—';
    if (ordered.length >= 2) {
      const winnerLabel = `${ordered[0].name} ${ordered[0].score}`;
      const losersLabel = ordered
        .slice(1)
        .map(o => `${o.name} ${o.score}`)
        .join(' ');

      // Winner name + score in bold, losers normal, with extra gap before bts
      resultHtml = `<strong>${winnerLabel}</strong>&nbsp;&nbsp;bts ${losersLabel}`;
    } else if (ordered.length === 1) {
      const winnerLabel = `${ordered[0].name} ${ordered[0].score}`;
      resultHtml = `<strong>${winnerLabel}</strong>`;
    }

    const tsVal =
      g.ts ||
      g.created_at ||
      g.inserted_at ||
      (g.meta && (g.meta.ts || g.meta.date)) ||
      null;

    let when = '';
    if (tsVal) {
      const d = new Date(tsVal);
      if (!Number.isNaN(d.getTime())) {
        when = d.toLocaleString('en-GB', {
          day:    '2-digit',
          month:  '2-digit',
          hour:   '2-digit',
          minute: '2-digit'
        }).replace(',', '');
      }
    }

    // Date/time in bold, followed by the formatted result with extra gap
    if (when) {
      return `<strong>${when}</strong>&nbsp;&nbsp;&nbsp;&nbsp;${resultHtml}`;
    }
    return resultHtml;
  }

  async function startPsTicker(container, items) {
    if (!container || !items || !items.length) return;

    // Prevent multiple ticker loops if init is ever called twice
    if (container.dataset.vtickerRunning === '1') return;
    container.dataset.vtickerRunning = '1';

    // Clear any legacy content and create two stacked lines
    container.innerHTML = '';
    const lineA = document.createElement('div');
    const lineB = document.createElement('div');
    lineA.className = 'track';
    lineB.className = 'track';
    container.appendChild(lineA);
    container.appendChild(lineB);

    const height = container.clientHeight || 32;

    let currentIdx = 0;
    let active = lineA;
    let next   = lineB;

    // Initial state: first score visible, second line parked just below
    active.innerHTML = items[currentIdx];
    active.style.transition = 'none';
    next.style.transition   = 'none';
    active.style.transform  = 'translateY(0)';
    next.style.transform    = `translateY(${height}px)`;
    // Force a reflow so the browser applies initial transforms
    void active.offsetHeight;

    while (container.isConnected && items.length) {
      // Hold the current score fully visible
      await sleep(HOLD_MS);

      const nextIdx = (currentIdx + 1) % items.length;
      next.innerHTML = items[nextIdx];

      // Reset start positions (active in centre, next just below)
      active.style.transition = 'none';
      next.style.transition   = 'none';
      active.style.transform  = 'translateY(0)';
      next.style.transform    = `translateY(${height}px)`;
      void active.offsetHeight; // reflow

      // Animate both lines upwards together
      const dur = IN_MS;
      active.style.transition = `transform ${dur}ms ease-in-out`;
      next.style.transition   = `transform ${dur}ms ease-in-out`;
      active.style.transform  = `translateY(-${height}px)`;
      next.style.transform    = 'translateY(0)';

      // Wait for the animation to finish
      await sleep(dur);

      // Swap roles: the line that just slid in becomes the new active line
      const tmp = active;
      active = next;
      next   = tmp;
      currentIdx = nextIdx;
    }
  }

  async function initSingleLinePsTicker() {
    const ticker = document.getElementById('psTicker');
    if (!ticker) return;

    try {
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) {
        ticker.classList.add('hidden');
        return;
      }
    } catch (_) {}

    let games = [];
    try {
      if (typeof cloudFetchAllGamesAsLocal === 'function') {
        games = await cloudFetchAllGamesAsLocal();
      }
    } catch (e) {
      console.error('psTicker: failed to fetch games', e);
    }

    if (!Array.isArray(games) || !games.length) {
      ticker.classList.add('hidden');
      return;
    }

    const toTS = (g) => {
      const t =
        g?.ts ||
        g?.created_at ||
        g?.inserted_at ||
        (g?.meta && (g.meta.ts || g.meta.date)) ||
        null;
      const n = t ? Date.parse(t) : NaN;
      return Number.isFinite(n) ? n : 0;
    };

    games = games
      .filter(Boolean)
      .sort((a, b) => toTS(b) - toTS(a))
      .slice(0, 25);

    const items = games
      .map(formatGameForTicker)
      .filter(line => line && line.trim().length > 0);

    if (!items.length) {
      ticker.classList.add('hidden');
      return;
    }

    ticker.classList.remove('hidden');
    startPsTicker(ticker, items).catch(err => {
      console.error('psTicker loop error', err);
    });
  }

  // Remove any legacy ticker entry points so they can't interfere
  window.buildStartTicker = function () {};
  window.initVerticalGameTicker = function () {};

  document.addEventListener('DOMContentLoaded', function () {
    initSingleLinePsTicker().catch(function (err) {
      console.error('psTicker init failed', err);
    });
  });
})();

// Rename helper (updates `name` column)
async function cloudRenamePlayer(oldName, newName){
  const { error } = await sb.from(TABLE_PLAYERS).update({ name: newName }).eq('name', oldName);
  if (error) { markCloudError(error); throw error; }
  markCloudOk();
}

// Game Complete modal hierarchy tweak (title + big result + smaller standings)
(function(){
  if (window.__gameCompleteModalPatch) return;
  window.__gameCompleteModalPatch = true;

  function patchGameCompleteModal(root){
    try{
      const modal = root.querySelector('.modal');
      if (!modal) return;

      const titleEl = modal.querySelector('h3');
      if (!titleEl) return;
      const titleText = (titleEl.textContent || '').trim();
      if (!/game complete/i.test(titleText)) return; // only touch the Game Complete popup

      // Tag modal + title for CSS
      modal.classList.add('game-complete');
      titleEl.classList.add('gc-title');

      const body = modal.querySelector('.modal-body') || modal;
      if (!body) return;

      // Find the existing winners line (WINNER: / JOINT WINNERS: ...)
      const children = Array.from(body.children || []);
      let resultEl = children.find(el => /winner/i.test((el.textContent || '')));

      // Fallback: first strong/heading that mentions winner
      if (!resultEl){
        const candidate = body.querySelector('strong, h1, h2, h3');
        if (candidate && /winner/i.test((candidate.textContent || ''))) {
          resultEl = candidate;
        }
      }

      if (resultEl){
        resultEl.classList.add('gc-result');
      }

      // Style the standings list (ordered or unordered list)
      const list = body.querySelector('ol, ul');
      if (list){
        list.classList.add('gc-standings');
      }
    } catch(e){
      console.error('patchGameCompleteModal error', e);
    }
  }

  // Watch for modals being added; when a Game Complete popup appears, patch it
  const mo = new MutationObserver(muts => {
    for (const m of muts){
      for (const n of m.addedNodes){
        if (!(n instanceof HTMLElement)) continue;
        if (n.classList.contains('modal-backdrop')){
          // Let the modal render fully, then patch it
          setTimeout(() => patchGameCompleteModal(n), 0);
        }
      }
    }
  });

  try {
    mo.observe(document.body, { childList: true, subtree: true });
  } catch(_) {}
})();

// Patch Player Stats hub modal to inject a PROGRESSION button after STATS
(function () {
  if (window.__playerStatsProgressionPatch) return;
  window.__playerStatsProgressionPatch = true;

  function tryPatchPlayerStatsModal(root) {
    try {
      const modal = root.querySelector('.modal');
      if (!modal) return;

      const titleEl = modal.querySelector('h3');
      if (!titleEl) return;
      const titleText = (titleEl.textContent || '').trim();

      // Only touch Player Stats modals
      if (!/^Player Stats\s*[\u2013\u2014-]/i.test(titleText)) return;

      // Find GAMES and STATS buttons
      const buttons = Array.from(modal.querySelectorAll('button'));
      const gamesBtn = buttons.find(
        b => (b.textContent || '').trim().toUpperCase() === 'GAMES'
      );
      const statsBtn = buttons.find(
        b => (b.textContent || '').trim().toUpperCase() === 'STATS'
      );

      if (!gamesBtn || !statsBtn) return;

      // If PROGRESSION already exists, do nothing
      const existingProg = buttons.find(
        b => (b.textContent || '').trim().toUpperCase() === 'PROGRESSION'
      );
      if (existingProg) return;

      // Clone STATS style to keep look identical
      const progBtn = statsBtn.cloneNode(true);
      progBtn.textContent = 'PROGRESSION';
      if (progBtn.dataset) {
        progBtn.dataset.view = 'progression';
      }

      // Insert immediately after STATS
      if (statsBtn.parentNode) {
        statsBtn.parentNode.insertBefore(progBtn, statsBtn.nextSibling);
      }
    } catch (e) {
      console.error('Player Stats progression patch failed', e);
    }
  }

  const mo = new MutationObserver(muts => {
    for (const m of muts) {
      for (const n of m.addedNodes) {
        if (!(n instanceof HTMLElement)) continue;

        // Modal added directly
        if (n.classList.contains('modal-backdrop')) {
          tryPatchPlayerStatsModal(n);
        } else if (n.querySelector) {
          // Or nested within some other added node
          const backdrop = n.querySelector('.modal-backdrop');
          if (backdrop) tryPatchPlayerStatsModal(backdrop);
        }
      }
    }
  });

  try {
    mo.observe(document.body, { childList: true, subtree: true });
  } catch (_) {}
})();

// Patch High Score League modal 'Back' button to return to League / Rankings
(function () {
  if (window.__hsLeagueBackPatch) return;
  window.__hsLeagueBackPatch = true;

  function tryPatchHsLeagueModal(root) {
    try {
      const modal = root.querySelector
        ? root.querySelector('.modal')
        : null;
      if (!modal) return;

      const titleEl = modal.querySelector('h3');
      if (!titleEl) return;

      const titleText = (titleEl.textContent || '').toLowerCase();
      // Only touch "High Scores" modals that look like the league/match view,
      // and skip anything clearly labeled as "Round High Scores".
      if (!titleText.includes('high') || !titleText.includes('score')) return;
      if (titleText.includes('round')) return;
      if (!titleText.includes('league') && !titleText.includes('match')) return;

      const buttons = Array.from(modal.querySelectorAll('button'));
      const backBtn = buttons.find(
        b => (b.textContent || '').trim().toLowerCase() === 'back'
      );
      if (!backBtn) return;

      backBtn.onclick = () => {
        let backdrop = root;
        if (!(backdrop instanceof HTMLElement) || !backdrop.classList.contains('modal-backdrop')) {
          backdrop = modal.closest('.modal-backdrop') || backdrop;
        }
        if (backdrop && backdrop.classList) {
          try { backdrop.classList.add('hidden'); } catch (_) {}
          try { backdrop.remove(); } catch (_) {}
        }
        if (typeof window.openLeagueRankingsDialog === 'function') {
          try { window.openLeagueRankingsDialog(); } catch (_) {}
        }
      };
    } catch (e) {
      try { console.error('HS League back patch failed', e); } catch (_) {}
    }
  }

  const mo = new MutationObserver(muts => {
    for (const m of muts) {
      for (const n of m.addedNodes) {
        if (!(n instanceof HTMLElement)) continue;
        if (n.classList.contains('modal-backdrop')) {
          tryPatchHsLeagueModal(n);
        } else if (n.querySelector) {
          const backdrop = n.querySelector('.modal-backdrop');
          if (backdrop) tryPatchHsLeagueModal(backdrop);
        }
      }
    }
  });

  try {
    mo.observe(document.body, { childList: true, subtree: true });
  } catch (_) {}
})();

// >>> PATCH:power-league-rounds START — treat full game as 14 rounds
(function(){
  if (window.__powerLeagueRoundsPatch) return;
  window.__powerLeagueRoundsPatch = true;

  // Interpret recorded rounds (10–20 only) as part of a 14‑round game (10–20 + D + T + Bull)
  const RAW_ROUNDS_PER_GAME   = 11;
  const FULL_ROUNDS_PER_GAME  = 14;
  const SCALE = FULL_ROUNDS_PER_GAME / RAW_ROUNDS_PER_GAME;

  function rescaleRow(row){
    if (!row) return row;
    const raw = Number(row.rounds || 0);
    if (!raw || !Number.isFinite(raw)) return row;

    const scaled = Math.round(raw * SCALE);
    if (!scaled || !Number.isFinite(scaled)) return row;

    const next = Object.assign({}, row);

    // Try to preserve the original total by adjusting the average
    const avgKeys = ['avg_per_round','avgPerRound','avgRound','avg'];
    let totalScore = null;
    let avgKeyUsed = null;

    for (const k of avgKeys){
      if (!(k in next)) continue;
      const val = Number(next[k]);
      if (!Number.isFinite(val) || val <= 0) continue;
      totalScore = val * raw;
      avgKeyUsed = k;
      break;
    }

    next.rounds = scaled;
    if (avgKeyUsed && totalScore != null && scaled > 0){
      next[avgKeyUsed] = totalScore / scaled;
    }

    return next;
  }

  const orig = window.computePowerLeagueRows;
  if (typeof orig === 'function'){
    window.computePowerLeagueRows = async function(){
      const rows = await orig();
      if (!Array.isArray(rows)) return rows;
      return rows.map(rescaleRow);
    };
  }
})();
// >>> PATCH:power-league-rounds END


// === Player Summary Stats dialog (cloud-only, extended aggregate) ===
// Temporary stub so the game runs while this feature is unfinished.
window.openPlayerSummaryStatsDialog = async function openPlayerSummaryStatsDialog(playerName, mode){
  console.warn('openPlayerSummaryStatsDialog is not implemented yet.', { playerName, mode });
};

// === Player Progression dialog (per-game line graph) ===
window.openPlayerProgressionDialog = async function openPlayerProgressionDialog(playerName, mode) {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';
  const modal = document.createElement('div');
  modal.className = 'modal compact';
  const title = document.createElement('h3');
  const body = document.createElement('div');
  body.className = 'modal-body';
  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const isPractice = (mode === 'practice' || mode === true);
  const labelMode = isPractice ? 'Practice' : 'Official';
  const safeName = playerName || 'Unknown';

  title.textContent = `Progression — ${safeName} (${labelMode})`;

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  modal.tabIndex = 0;
  modal.focus();

  const close = () => { overlay.remove(); };

  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = close;

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = close;

  footer.append(backBtn, closeBtn);

  // Top controls + chart area
body.innerHTML = `
  <div class="row" style="gap:8px; margin-bottom:8px;">
    <button class="btn primary" data-metric="score">Game Score</button>
    <button class="btn" data-metric="avg">5 Game Average</button>
    <button class="btn" data-metric="target">Target %</button>
  </div>
  <p class="tag" id="progHint">Vertical: Score / %, Horizontal: Games (1, 2, 3, …)</p>
`;

  const metricButtons = Array.from(body.querySelectorAll('button[data-metric]'));
  const canvas = body.querySelector('#progChartCanvas');
  const ctx = canvas && canvas.getContext ? canvas.getContext('2d') : null;

  if (!ctx) {
    const wrap = body.querySelector('#progChartWrap');
    if (wrap) wrap.innerHTML = '<p>Canvas not supported in this browser.</p>';
    return;
  }

  // ---- Fetch per-game data for this player ----
  async function loadData() {
    try {
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) {
        return { labels: [], scores: [], avgs: [], targetPct: [] };
      }
    } catch (_) {}

    const tableName = (typeof TABLE_PLAYER_GAMES !== 'undefined' && TABLE_PLAYER_GAMES)
      ? TABLE_PLAYER_GAMES
      : 'player_games_union';

    let games = [];
    try {
      const { data, error } = await sb
        .from(tableName)
        .select('sheet_id, player, score, rounds, ts, is_practice')
        .eq('player', safeName)
        .eq('is_practice', !!isPractice)
        .order('ts', { ascending: true })
        .limit(200);
      if (error) throw error;
      games = (data || []).filter(Boolean);
    } catch (e) {
      console.error('Progression: games fetch failed', e);
      return { labels: [], scores: [], avgs: [], targetPct: [] };
    }

    if (!games.length) {
      return { labels: [], scores: [], avgs: [], targetPct: [] };
    }

    // x-axis: game index 1..N
    const labels = games.map((_, idx) => idx + 1);

// Fixed Y-axis (same across all modes) + overall average of all games
const avgAll = scores.length ? (scores.reduce((s,v)=>s+v,0) / scores.length) : 0;
const baseMaxScore = scores.length ? Math.max(...scores) : 0;
const FIXED_Y_MAX = Math.max(25, Math.ceil(baseMaxScore / 25) * 25);

const scores = games.map(g => Number(g.score || 0));

// 5 Game Average: only at games 5, 10, 15…
// game 5 = avg of game 1–5, game 10 = avg of 6–10, etc.
const avgs = scores.map((_, idx) => {
  const gameNo = idx + 1;          // 1-based game index
  if (gameNo % 5 !== 0) return NaN; // only plot at 5, 10, 15, ...
  const start = idx - 4;           // start of the 5-game block
  if (start < 0) return NaN;
  let sum = 0;
  for (let i = start; i <= idx; i++) {
    sum += Number(scores[i] || 0);
  }
  return sum / 5;
});

    // Overall target hit % per game (all darts)
    let targetPct = new Array(games.length).fill(0);

    try {
      const gameIds = games.map(g => g.sheet_id).filter(Boolean);
      if (gameIds.length && typeof TABLE_GAME_THROWS !== 'undefined') {
        const { data: throwsRaw, error: tErr } = await sb
          .from(TABLE_GAME_THROWS)
          .select('game_id, points')
          .in('game_id', gameIds)
          .eq('player', safeName);
        if (!tErr && Array.isArray(throwsRaw)) {
          const byGame = new Map();
          throwsRaw.forEach(row => {
            const gid = row.game_id;
            if (!gid) return;
            let agg = byGame.get(gid);
            if (!agg) {
              agg = { hits: 0, attempts: 0 };
              byGame.set(gid, agg);
            }
            agg.attempts += 1;
            const pts = Number(row.points || 0);
            if (pts > 0) agg.hits += 1;
          });

          targetPct = games.map(g => {
            const agg = byGame.get(g.sheet_id);
            if (!agg || !agg.attempts) return 0;
            return (agg.hits * 100) / agg.attempts;
          });
        }
      }
    } catch (e) {
      console.error('Progression: target% fetch failed', e);
    }

    return { labels, scores, avgs, targetPct };
  }

  const data = await loadData();

  if (!data.labels.length) {
    const wrap = body.querySelector('#progChartWrap');
    if (wrap) wrap.innerHTML = '<p>No games found for this player/mode.</p>';
    return;
  }

  function setActiveMetricButton(metric) {
    metricButtons.forEach(btn => {
      const m = btn.getAttribute('data-metric');
      if (m === metric) btn.classList.add('primary');
      else btn.classList.remove('primary');
    });
  }

  function drawLineChart(values, metric) {
    const labels = data.labels;
    const W = canvas.width;
    const H = canvas.height;
    const paddingLeft = 40;
    const paddingRight = 10;
    const paddingTop = 10;
    const paddingBottom = 28;

    ctx.clearRect(0, 0, W, H);

    if (!labels.length || !values.length) return;

const finiteVals = values.filter(v => Number.isFinite(v));
if (!finiteVals.length) return;
const maxValRaw = Math.max(...finiteVals);
const maxVal = maxValRaw > 0 ? maxValRaw : 1;

    const xMin = 0;
    const xMax = labels.length > 1 ? labels.length - 1 : 1;

    const plotW = W - paddingLeft - paddingRight;
    const plotH = H - paddingTop - paddingBottom;

    function xForIndex(i) {
      if (xMax === xMin) return paddingLeft + plotW / 2;
      return paddingLeft + ((i - xMin) / (xMax - xMin)) * plotW;
    }
    function yForValue(v) {
      const clamped = v < 0 ? 0 : v;
      return paddingTop + (1 - clamped / maxVal) * plotH;
    }

    // Axes
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 1;

    // Y-axis
    ctx.beginPath();
    ctx.moveTo(paddingLeft, paddingTop);
    ctx.lineTo(paddingLeft, H - paddingBottom);
    ctx.stroke();

    // X-axis
    ctx.beginPath();
    ctx.moveTo(paddingLeft, H - paddingBottom);
    ctx.lineTo(W - paddingRight, H - paddingBottom);
    ctx.stroke();

    // Y ticks
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.font = '10px system-ui';
    const steps = 4;
    for (let i = 0; i <= steps; i++) {
      const v = (maxVal * i) / steps;
      const y = yForValue(v);
      ctx.beginPath();
      ctx.moveTo(paddingLeft - 3, y);
      ctx.lineTo(W - paddingRight, y);
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.fillText(metric === 'target' ? v.toFixed(0) + '%' : v.toFixed(0), 4, y + 3);
    }

    // X labels
    for (let i = 0; i < labels.length; i++) {
      const x = xForIndex(i);
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.fillText(String(labels[i]), x - 4, H - paddingBottom + 14);
    }
// Average line across the chart for the current metric (finite values only)
const sum = values.reduce((acc, v) => acc + (Number.isFinite(v) ? v : 0), 0);
const mean = finiteVals.length ? (sum / finiteVals.length) : 0;
const yMean = yForValue(mean);

ctx.save();
ctx.strokeStyle = 'rgba(255,255,255,0.35)';
ctx.lineWidth = 1;
ctx.setLineDash([4, 4]);
ctx.beginPath();
ctx.moveTo(paddingLeft, yMean);
ctx.lineTo(W - paddingRight, yMean);
ctx.stroke();
ctx.restore();

// Line (skip positions without data, e.g. non-5th games for 5 Game Average)
ctx.strokeStyle = '#7bdcff';
ctx.lineWidth = 2;
ctx.beginPath();
let started = false;
values.forEach((v, i) => {
  if (!Number.isFinite(v)) return;
  const x = xForIndex(i);
  const y = yForValue(v);
  if (!started) {
    ctx.moveTo(x, y);
    started = true;
  } else {
    ctx.lineTo(x, y);
  }
});
if (started) ctx.stroke();

// Points
ctx.fillStyle = '#8cff9e';
values.forEach((v, i) => {
  if (!Number.isFinite(v)) return;
  const x = xForIndex(i);
  const y = yForValue(v);
  ctx.beginPath();
  ctx.arc(x, y, 3, 0, Math.PI * 2);
  ctx.fill();
});
  }

 function render(metric) {
  let values = data.scores;
  if (metric === 'target') values = data.targetPct;
  setActiveMetricButton(metric);
  drawLineChart(values, metric);
}

  // Wire metric buttons
  metricButtons.forEach(btn => {
    const metric = btn.getAttribute('data-metric');
    btn.onclick = () => render(metric);
  });

  // Initial render
  render('score');
};

// Player Stats overlay: wire the STATS tab via global click delegation
(function wirePlayerStatsStatsButton(){
  if (window.__playerStatsStatsWired) return;
  window.__playerStatsStatsWired = true;

  document.addEventListener('click', function(e){
    try {
      const btn = e.target.closest('button, .btn');
      if (!btn) return;
      const label = (btn.textContent || '').trim().toLowerCase();
      if (label !== 'stats') return;

      // Only act if this STATS control lives inside a Player Stats modal
      const modal = btn.closest('.modal');
      if (!modal) return;
      const h3 = modal.querySelector('h3');
      if (!h3 || !/player stats/i.test((h3.textContent || ''))) return;

      const titleText = h3.textContent || '';
      let playerName = '';

      // Extract the bit after "Player Stats –" / "Player Stats —" / "Player Stats -"
      const m = titleText.match(/player stats\s*[\u2013\u2014-]\s*(.+)$/i);
      if (m && m[1]) {
        playerName = m[1].trim();
      }

      // Fallback: strip the "Player Stats" prefix if present
      if (!playerName) {
        playerName = titleText.replace(/player stats/i, '').trim();
      }

      if (typeof window.openPlayerSummaryStatsDialog === 'function'){
        window.openPlayerSummaryStatsDialog(playerName || '');
      }
    } catch(err){
      console.error('wirePlayerStatsStatsButton error', err);
    }
  }, true); // capture so we see it before other handlers
})();

      console.log('SQ build: script wrapped OK');
if (!window.buildStartTicker) { window.buildStartTicker = async function(){}; }

// Start PB annotation on load (safe to call multiple times)
document.addEventListener('DOMContentLoaded', () => {
  try { setupRoundScoreObserver(); } catch(_) {}
  try { wireTopRowButtons(); } catch(_) {}
  try { initSetupSteppers(); } catch(_) {}
});

// --- Top row buttons: compatibility wiring for new + legacy IDs ---
function _showPageSafe(id){
  // Prefer existing app router, else do a minimal local switch
  if (typeof window.showPage === 'function') { try { window.showPage(id); return; } catch(_){ } }
  const sections = ['details','players','game','leaderboard'];
  sections.forEach(sid => {
    const sec = document.getElementById(sid);
    if (sec) {
      if (sid === id) sec.classList.remove('hidden');
      else sec.classList.add('hidden');
    }
  });
  try { document.body.dataset.page = id; } catch(_){}
}

function navigateToStartScreen(){
  _showPageSafe('details');
}

function restartGameSafe(){
  // Try known hooks if they exist, else reload as a last resort
  const candidates = ['restartGame', 'startNewGame', 'initMatch', 'beginNewGame'];
  for (const name of candidates){
    const fn = window[name];
    if (typeof fn === 'function'){
      try { fn(); return; } catch(_){}
    }
  }
  // Fallback: hard reset
  location.reload();
}

function openStatsHubSafe(){
  const candidates = ['openStatsHub', 'openStatsHubDialog', 'openStatsMenu', 'openStats', 'showStatsHub'];
  for (const name of candidates){
    const fn = window[name];
    if (typeof fn === 'function'){
      try { fn(); return; } catch(_){}
    }
  }
  if (typeof toast === 'function') toast('Stats panel not available on this build');
}
function wireTopRowButtons(){
  // Support both the new IDs and legacy IDs if they exist
  const startIds   = [
    'startScreenBtnFromGame',
    'startScreenBtnFromLB',
    'startScreenBtnLB',
    'startScreenBtnGame'
  ];
  const restartIds = [
    'restartGameBtnFromGame',
    'restartGameBtnFromLB',
    'restartGameBtnLB',
    'restartGameBtnGame'
  ];
  const statsIds   = [
    'statsHubBtnFromGame',
    'statsHubBtnFinal',
    'statsHubBtnLB',
    'statsHubBtnGame'
  ];

  startIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.onclick = navigateToStartScreen;
  });
  restartIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.onclick = restartGameSafe;
  });
  statsIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.onclick = openStatsHubSafe;
  });
}

// --- Stepper bootstrap (must exist before any DOMContentLoaded references) ---
(function(){
  if (typeof window.initSetupSteppers === 'function') return;
  window.initSetupSteppers = function initSetupSteppers(){
    const steppers = document.querySelectorAll('.setup-stepper');
    steppers.forEach(stepper => {
      const selectId = stepper.getAttribute('data-select-id');
      const suffix   = stepper.getAttribute('data-suffix') || '';
      const select   = document.getElementById(selectId);
      const numEl    = stepper.querySelector('.stepper-number');
      const sufEl    = stepper.querySelector('.stepper-suffix');
      if (sufEl) sufEl.textContent = suffix;
      if (!select || !numEl) return;
      

/* === Admin → Button + Password Popup (final) === */
(function adminButton(){
  const expected = (window.ADMIN_PASSWORD || 'hownowbrowncow'); // change if needed

  // 1) Ensure we have a single Admin button
  const row = document.getElementById('adminCodeRow');
  let btn = document.getElementById('adminCodeBtn');

  function ensureButton() {
    if (!btn) {
      btn = document.createElement('button');
      btn.id = 'adminCodeBtn';
      btn.className = 'btn';
      if (row) { row.innerHTML = ''; row.appendChild(btn); }
      else document.body.appendChild(btn); // fallback (shouldn’t be used)
    }
    btn.textContent = 'Admin';
    btn.title = 'Admin';
    btn.setAttribute('aria-label', 'Admin');
    btn.onclick = openAdminPasswordModal;
  }

  // 2) Remove any standalone "Admin Code" heading/label left in the markup
  function removeStandaloneLabel(){
    const candidates = Array.from(document.querySelectorAll(
      '#details h1, #details h2, #details h3, #details h4, #details .muted, #details label'
    ));
    candidates.forEach(el => {
      const t = (el.textContent || '').trim();
      if (/^admin\s*code$/i.test(t)) el.remove();
    });
  }

  // 3) Password popup → on success open the standard Admin panel
  function openAdminPasswordModal(){
    const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
    const modal   = document.createElement('div'); modal.className = 'modal';

    const title = document.createElement('h3'); title.textContent = 'Admin Login';
    const body  = document.createElement('div'); body.className = 'modal-body';

    const label = document.createElement('label');
    label.textContent = 'Enter password:';
    label.className = 'muted';
    label.style.display = 'block';
    label.style.marginBottom = '6px';

    const input = document.createElement('input');
    input.type = 'password';
    input.className = 'input';
    input.autocomplete = 'current-password';
    input.placeholder = 'Password';
    input.style.minWidth = '220px';

    body.append(label, input);

    const footer = document.createElement('div'); footer.className = 'modal-footer';
    const cancel = document.createElement('button'); cancel.className = 'btn';         cancel.textContent = 'Cancel';
    const enter  = document.createElement('button'); enter.className  = 'btn primary'; enter.textContent  = 'Enter';

    function close(){ overlay.remove(); }
    function deny(){
      if (typeof toast === 'function') toast('Incorrect password');
      else alert('Incorrect password');
      input.focus(); input.select();
    }
    function grant(){
      close();
      if (typeof window.openAdminHub === 'function') window.openAdminHub();
      else if (typeof openAdminHub === 'function') openAdminHub();
    }
    function submit(){
      const v = (input.value || '').trim();
      if (!expected || v === expected) grant(); else deny();
    }

    cancel.onclick = close;
    enter.onclick  = submit;
    input.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') submit(); });

    footer.append(cancel, enter);
    modal.append(title, body, footer);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    modal.tabIndex = 0; modal.focus();
    overlay.addEventListener('click', e => { if (e.target === overlay) close(); });
    overlay.addEventListener('keydown', e => { if (e.key === 'Escape') close(); });

    setTimeout(()=> input.focus(), 0);
  }
    // Export for other wiring (e.g. start-screen Admin button)
    window.openAdminPasswordModal = openAdminPasswordModal;

  removeStandaloneLabel();
  ensureButton();
})();

// Start screen: simple High Scores hub (two choices)
function openHighScoresHubDialog(){
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
   const modal   = document.createElement('div'); modal.className   = 'modal compact';
  const title   = document.createElement('h3');  title.textContent = 'High Scores';
  const body    = document.createElement('div'); body.className = 'modal-body';
  const col     = document.createElement('div'); col.className = 'column'; col.style.gap = '8px';

  const btnMatch = document.createElement('button');
  btnMatch.className = 'btn big';
  btnMatch.textContent = 'High Scores (Match)';
  btnMatch.onclick = () => {
    try {
      if (typeof openHighScoresMenuDialog === 'function') openHighScoresMenuDialog(false);
      else if (typeof openHighScoresMenu === 'function') openHighScoresMenu(false);
      else if (typeof openHighScoresDialog === 'function') openHighScoresDialog(false);
      else if (typeof toast === 'function') toast('Match high scores not available');
      else alert('Match high scores not available');
    } finally { overlay.remove(); }
  };

  const btnRound = document.createElement('button');
  btnRound.className = 'btn big';
  btnRound.textContent = 'High Scores (Round)';
  btnRound.onclick = () => {
    try {
      if (typeof openRoundHighScoresDialog === 'function') openRoundHighScoresDialog();
      else if (typeof toast === 'function') toast('Round high scores not available');
      else alert('Round high scores not available');
    } finally { overlay.remove(); }
  };

  col.append(btnMatch, btnRound);
  body.appendChild(col);

  const footer = document.createElement('div'); footer.className = 'modal-footer';
  const close  = document.createElement('button'); close.className = 'btn'; close.textContent = 'Close';
  close.onclick = () => overlay.remove();
  footer.appendChild(close);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  modal.tabIndex = 0; modal.focus();

  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', (e) => { if (e.key === 'Escape') overlay.remove(); });
}

      // Prevent duplicate bindings (which caused skipping: 1→3→5…)
      if (stepper.dataset.bound === '1') return;
      stepper.dataset.bound = '1';

      // Determine min/max from the select's option values
      const values = [...select.options].map(o => parseInt(o.value, 10)).filter(n => !Number.isNaN(n));
      const minVal = Math.min(...values);
      const maxVal = Math.max(...values);

      function syncFromSelect(){
        const val = parseInt(select.value, 10);
        if (!Number.isNaN(val)) {
          numEl.textContent = String(val);
        } else {
          const opt = select.options[select.selectedIndex];
          const txt = opt ? opt.textContent : '';
          const m = txt && txt.match(/\d+/);
          numEl.textContent = m ? m[0] : txt;
        }
      }

      function setTo(v){
        const targetIdx = [...select.options].findIndex(o => parseInt(o.value, 10) === v);
        if (targetIdx >= 0) {
          select.selectedIndex = targetIdx;
          select.dispatchEvent(new Event('change', { bubbles: true }));
          syncFromSelect();
        }
      }

      // Bind buttons using `onclick` (overwrites any prior handlers)
      stepper.querySelectorAll('.stepper-btn').forEach(btn => {
        const delta = parseInt(btn.getAttribute('data-delta') || '0', 10);
        btn.onclick = () => {
          const cur = parseInt(select.value, 10);
          const next = Math.min(maxVal, Math.max(minVal, cur + (delta > 0 ? 1 : -1)));
          setTo(next);
        };
      });

      select.addEventListener('change', syncFromSelect);
      syncFromSelect();
    });

    // Ensure initial player rows render to match default "players" count
    try { if (typeof drawPsRows === 'function') drawPsRows(); } catch(_) {}
  };
})();
/**********************
 * CONFIG: Supabase
 **********************/
const SUPABASE_URL = "https://vvfqumgtasuacpggdmxx.supabase.co";
const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ2ZnF1bWd0YXN1YWNwZ2dkbXh4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5NTk0MDMsImV4cCI6MjA3ODUzNTQwM30.8NblWOwEsY1FP1hxvO6isQ908NyxkTgntnZZiXIFPHE";
const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);

const TABLE_PLAYERS = "players";
// View/table that lists every player's game across Official + Practice.
const TABLE_PLAYER_GAMES = 'player_games_union';
const TABLE_HS_LEAGUE = "high_scores";
const TABLE_HS_PRACTICE = "high_scores_sp";
const TABLE_LEAGUE_LOW_SCORES = "league_low_scores";
const TABLE_GAME_THROWS = "game_throws";

// PB/WR storage (targets for the backfill)
const TABLE_PB_ROUNDS = 'player_pb_rounds';    // columns: player, cat, val, game_id, ridx, ts
const TABLE_WR_ROUNDS = 'world_record_rounds'; // columns: cat, val, player, game_id, ridx, ts

// Extra tables used for cloud-backed stats
const TABLE_GAMES   = "games";
const TABLE_MATCHES = "matches";

/**********************
 * SAFETY + TOAST
 **********************/
(function(){
  window.addEventListener('error', function(e){
    var b=document.getElementById('__err_banner')||document.createElement('div');
    b.id='__err_banner';
    b.style.cssText='position:fixed;left:0;right:0;top:0;background:#7a2e3f;color:#fff;padding:8px 12px;z-index:999999;font-weight:800';
    b.textContent='JS error: ' + (e.message||'(open console)');
    document.body.appendChild(b);
  });
  if(!window.toast){
    window.toast=function(msg){
      var d=document.createElement('div');
      d.textContent=msg;
      d.style.cssText='position:fixed;left:50%;top:16px;transform:translateX(-50%);background:#121735;border:1px solid #2b3050;color:#e7e9f5;padding:8px 12px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.35);z-index:110000';
      document.body.appendChild(d); setTimeout(function(){d.remove();},1700);
    };
  }
})();

/*****************
 * CORE HELPERS
 *****************/
const byId = id => document.getElementById(id);
const STORAGE_KEY='shateki_quest_scorer_v6';
const HS_KEY='shateki_quest_highscores_v1';       // kept for backward-compat local
const HS_KEY_SP='shateki_quest_highscores_sp_v1'; // kept for backward-compat local
// Long-term history logs (not cleared when a match ends)
const GAMES_LOG_KEY   = 'shateki_quest_games_log_v1';
const MATCHES_LOG_KEY = 'shateki_quest_matches_log_v1';
const safeSave=(k,o)=>{try{localStorage.setItem(k,JSON.stringify(o));}catch(e){}};
const safeLoad=k=>{try{const r=localStorage.getItem(k);return r?JSON.parse(r):null;}catch(e){return null;}};
const safeClear=k=>{try{localStorage.removeItem(k);}catch(e){}};

function syncStartTitleWidth(){
  const t = document.getElementById('appTitle');
  if (!t) return;
  const w = Math.ceil(t.getBoundingClientRect().width);
  document.documentElement.style.setProperty('--title-w', w + 'px');
  
}

// Return matches for official mode, merging local + cloud
async function getMatchesOfficial(){
  const localMatches = getMatchLog() || [];
  let cloudMatches = [];
  try { cloudMatches = await cloudFetchAllMatchesAsLocal(); } catch(_) {}

  const map = new Map();
  const stableKey = (m) => {
    const players = (m.players || [])
      .map(p => (p && p.name) ? String(p.name).trim().toLowerCase() : '')
      .join(',');
    return [m.ts || '', players].join('|');
  };
  [...cloudMatches, ...localMatches].forEach(m => {
    if (!m) return;
    const key = stableKey(m);
    if (!map.has(key)) map.set(key, m);
  });
  return [...map.values()];
}

// Build per-target counters for one player
function accumulateTargetCounters(playerName, games){
  const keys = {};
  // init keys 10..20, 'D','T','B'
  for (let n=10;n<=20;n++) keys[String(n)] = { thrown:0, hits:0, dHits:0, tHits:0 };
  keys.D = { thrown:0, hits:0 };
  keys.T = { thrown:0, hits:0 };
  keys.B = { thrown:0, hits:0, inner:0, outer:0 };

  games.forEach(g=>{
    if (!g || !Array.isArray(g.players) || !g.board) return;
    const pIdx = g.players.findIndex(p=>p && eqName(p.name, playerName));
    if (pIdx === -1) return;
    const board = g.board[pIdx]; if (!board) return;

    for (let r=0; r<MAX_ROUNDS; r++){
      const rd  = ROUNDS[r];
      const ent = board[r]; if (!ent || !ent.darts) continue;
      const darts = ent.darts;

      if (rd.type === 'number'){
        const key = String(rd.target);
        darts.forEach(d=>{
          if (!d) return;
          keys[key].thrown++;
          if ((d.points||0) > 0) keys[key].hits++;
          if (d.kind==='Double' || d.kind==='D') keys[key].dHits++;
          if (d.kind==='Triple' || d.kind==='T') keys[key].tHits++;
        });
      } else if (rd.type === 'doubles'){
        darts.forEach(d=>{
          if (!d) return;
          keys.D.thrown++;
          if ((d.points||0) > 0) keys.D.hits++;
        });
      } else if (rd.type === 'triples'){
        darts.forEach(d=>{
          if (!d) return;
          keys.T.thrown++;
          if ((d.points||0) > 0) keys.T.hits++;
        });
      } else if (rd.type === 'bull'){
        darts.forEach(d=>{
          if (!d) return;
          keys.B.thrown++;
          if (d.kind==='Bull'){
            keys.B.hits++;
            if (d.bull==='Inner') keys.B.inner++;
            else keys.B.outer++;
          }
        });
      }
    }
  });

  return keys;
}
// Put this at top-level (outside any function)
function openScoreSheetFromHistory(gIndex){
  const game = state.match.history[gIndex];
  if (!game || !game.board) { toast('No score sheet for that game.'); return; }
  const local = { ts: null, players: state.players.map(p=>({name:p.name})), board: game.board };
  openSingleGameScoreSheet(local, -1);
}

/* ===== PB / GR from Supabase (Saved Players + official games only; 10–20 + D/T/B) ===== */
(function(){
  const PBGR = {
    ready:false, fetching:false, fetchedAt:0,
    byPlayer:new Map(),           // player(lower) -> { [key]: best }
    byPlayerMeta:new Map(),       // player(lower) -> { [key]: {val, game_id, ridx, ts} }
    byTarget:{},                  // key -> best value (global)
    byTargetMeta:{}               // key -> { val, player, game_id, ridx, ts }
  };

  (function initGlobals(){
    for (let n=10;n<=20;n++) { PBGR.byTarget[n]=0; PBGR.byTargetMeta[n]={val:0,player:'',game_id:null,ridx:null,ts:null}; }
    ['D','T','B'].forEach(k=>{ PBGR.byTarget[k]=0; PBGR.byTargetMeta[k]={val:0,player:'',game_id:null,ridx:null,ts:null}; });
  })();

  const toNameKey = n => String(n||'').trim().toLowerCase();
  const toTarget  = t => {
    if (t==null) return null;
    if (typeof t === 'number') return t;
    const m = String(t).match(/\d+/);
    return m ? parseInt(m[0],10) : null;
  };

  async function fetchSavedPlayerNames(){
    try{
      const { data, error } = await sb.from(TABLE_PLAYERS).select('name').order('name');
      if (error) throw error;
      return (data||[]).map(r => String(r.name)).filter(Boolean);
    }catch(e){
      console.error('Saved players fetch failed', e);
      return [];
    }
  }

  async function findOfficialGameIds(){
    try{
      const { data, error } = await sb
        .from(TABLE_GAMES)
        .select('id, players, pcount')
        .limit(100000);
      if (error) throw error;
      const ids = new Set();
      for (const g of (data||[])){
        let n = 0;
        if (Array.isArray(g.players)) n = g.players.length;
        else if (typeof g.pcount === 'number') n = g.pcount;
        else if (typeof g.players === 'string'){
          try { const arr = JSON.parse(g.players); if (Array.isArray(arr)) n = arr.length; } catch(_){}
        }
        if (n >= 2 && g.id) ids.add(g.id);
      }
      return ids;
    }catch(e){
      console.warn('Could not read official game IDs from GAMES; will try is_practice on throws', e);
      return null;
    }
  }

  async function fetchPBGRFromCloud(limit = 100000){
    if (PBGR.fetching) return;
    PBGR.fetching = true;
    try{
      const savedNames = await fetchSavedPlayerNames();
      if (!savedNames.length){
        PBGR.byPlayer = new Map();
        PBGR.byPlayerMeta = new Map();
        PBGR.ready = true;
        PBGR.fetchedAt = Date.now();
        return;
      }

      const officialIds = await findOfficialGameIds();
      let rows = [];
      try{
        let q = sb.from(TABLE_GAME_THROWS)
          .select('player, game_id, round_index, target, points, round_total, ts, is_practice')
          .in('player', savedNames)
          .limit(limit);

        if (officialIds && officialIds.size){
          q = q.in('game_id', Array.from(officialIds));
        } else {
          q = q.eq('is_practice', false);
        }

        const { data, error } = await q;
        if (error) throw error;
        rows = data || [];
      }catch(e1){
        console.error('Primary throws fetch failed; falling back to saved players only', e1);
        const { data } = await sb.from(TABLE_GAME_THROWS)
          .select('player, game_id, round_index, target, points, round_total, ts')
          .in('player', savedNames)
          .limit(limit);
        rows = data || [];
      }

      const bestPerPlayerVal  = new Map();  // key: name|key -> val
      const bestPerPlayerMeta = new Map();  // key: name|key -> {val, game_id, ridx, ts}
      const bestGlobalVal     = { ...PBGR.byTarget };
      const bestGlobalMeta    = JSON.parse(JSON.stringify(PBGR.byTargetMeta));

      const bucket = new Map(); // key: game|name|ridx -> { ridx, target, total, ts }

      for (const row of (rows||[])){
        const nameKey = toNameKey(row.player || row.name);
        if (!nameKey) continue;

        const ridx = (typeof row.round_index === 'number') ? row.round_index : (row.round_index!=null ? Number(row.round_index) : null);
        const tNum = toTarget(row.target);
        const rt   = (row.round_total != null) ? Number(row.round_total) : null;
        const ts   = row.ts || null;

        function catFrom(ridxLocal, tLocal){
          if (tLocal!=null && tLocal>=10 && tLocal<=20) return tLocal;
          if (ridxLocal==null) return null;
          if (ridxLocal === 11) return 'D';
          if (ridxLocal === 12) return 'T';
          if (ridxLocal === 13) return 'B';
          if (ridxLocal>=0 && ridxLocal<=10) return 10 + ridxLocal;
          return null;
        }

        if (rt != null){
          const key = catFrom(ridx, tNum);
          if (key==null) continue;
          const val = rt;
          const pKey = `${nameKey}|${key}`;

          if (val > (bestPerPlayerVal.get(pKey) || 0)){
            bestPerPlayerVal.set(pKey, val);
            bestPerPlayerMeta.set(pKey, { val, game_id: row.game_id || null, ridx, ts });
          }
          if (val > (bestGlobalVal[key] || 0)){
            bestGlobalVal[key] = val;
            bestGlobalMeta[key] = { val, player: nameKey, game_id: row.game_id || null, ridx, ts };
          }
        } else {
          const gId = row.game_id || row.game || '';
          if (!gId || ridx==null) continue;
          const k = `${gId}|${nameKey}|${ridx}`;
          const cur = bucket.get(k) || { ridx, target: (tNum!=null ? tNum : null), total: 0, ts: ts };
          cur.total += Number(row.points || 0);
          if (cur.target==null && tNum!=null) cur.target = tNum;
          if (!cur.ts && ts) cur.ts = ts;
          bucket.set(k, cur);
        }
      }

      for (const [k, obj] of bucket){
        const [gId, nameKey, ridxStr] = k.split('|');
        const ridx = Number(ridxStr);
        const key  = (obj.target!=null && obj.target>=10 && obj.target<=20)
          ? obj.target
          : (ridx===11 ? 'D' : ridx===12 ? 'T' : ridx===13 ? 'B' : (ridx>=0 && ridx<=10 ? 10+ridx : null));
        if (key==null) continue;
        const val  = Number(obj.total || 0);
        const ts   = obj.ts || null;
        const pKey = `${nameKey}|${key}`;

        if (val > (bestPerPlayerVal.get(pKey) || 0)){
          bestPerPlayerVal.set(pKey, val);
          bestPerPlayerMeta.set(pKey, { val, game_id: gId, ridx, ts });
        }
        if (val > (bestGlobalVal[key] || 0)){
          bestGlobalVal[key] = val;
          bestGlobalMeta[key] = { val, player: nameKey, game_id: gId, ridx, ts };
        }
      }

      const byPlayer = new Map();
      const byPlayerMeta = new Map();
      for (const [key, v] of bestPerPlayerVal){
        const idx = key.lastIndexOf('|');
        const pKey = key.slice(0, idx);
        const cat  = key.slice(idx+1);
        const isNum = /^\d+$/.test(cat);
        const normKey = isNum ? parseInt(cat,10) : cat;
        if (!byPlayer.has(pKey)) byPlayer.set(pKey, {});
        if (!byPlayerMeta.has(pKey)) byPlayerMeta.set(pKey, {});
        byPlayer.get(pKey)[normKey] = v;
        byPlayerMeta.get(pKey)[normKey] = bestPerPlayerMeta.get(key);
      }

      PBGR.byPlayer     = byPlayer;
      PBGR.byPlayerMeta = byPlayerMeta;
      PBGR.byTarget     = bestGlobalVal;
      PBGR.byTargetMeta = bestGlobalMeta;
      PBGR.ready        = true;
      PBGR.fetchedAt    = Date.now();
    }catch(e){
      console.error('PBGR cloud build failed', e);
      PBGR.ready = false;
    }finally{
      PBGR.fetching = false;
    }
  }

  async function ensurePBGRCache(){
    if (PBGR.ready && Date.now() - PBGR.fetchedAt < 5*60*1000) return;
    await fetchPBGRFromCloud();
  }

  window.updatePBGRBadges = async function updatePBGRBadges(){
    if (document.body.getAttribute('data-page') !== 'game') return;
    await ensurePBGRCache();
    if (!PBGR.ready) return;
    try{
      for (let p=0; p<(state.players||[]).length; p++){
        const nameKey = toNameKey(state.players[p]?.name);
        const rounds  = state.score?.[p] || [];
        const pbMap   = PBGR.byPlayer.get(nameKey) || {};
        for (let r=0; r<Math.min(rounds.length, MAX_ROUNDS); r++){
          const rdDef = ROUNDS[r];
          if (!rdDef) continue;
          let key = null;
          if (rdDef.type === 'number')  key = rdDef.target;
          if (rdDef.type === 'doubles') key = 'D';
          if (rdDef.type === 'triples') key = 'T';
          if (rdDef.type === 'bull')    key = 'B';
          if (key==null) continue;
          const rt = Number(rounds[r]?.roundTotal||0);
          if (!rt) continue;
          const priorPB = Number(pbMap[key] || 0);
          const priorGR = Number(PBGR.byTarget[key] || 0);
          const isPB = rt > priorPB;
          const isGR = rt > priorGR;
          const tbody = document.getElementById('tbody'); if (!tbody) continue;
          const tr = tbody.rows?.[r]; if (!tr) continue;
          const td = tr.children?.[p+1]; if (!td) continue;
          const sub = td.querySelector('.cell-sub') || td;
          sub.querySelectorAll('.pbgr').forEach(n => n.remove());
          if (isPB){
            const b = document.createElement('span');
            b.className = 'pbgr pb'; b.textContent = ' (PB)'; sub.appendChild(b);
          }
          if (isGR){
            const g = document.createElement('span');
            g.className = 'pbgr gr'; g.textContent = ' (GR)'; sub.appendChild(g);
          }
        }
      }
    }catch(_){}
  };

  window.refreshPBGRCloud = async function(){
    PBGR.ready=false;
    await ensurePBGRCache();
    await window.updatePBGRBadges();
  };

  // Expose a read-only snapshot for admin UI
  window.getPBGRSnapshot = async function(){
    await ensurePBGRCache();
    return {
      byTarget: Object.assign({}, PBGR.byTarget),
      byTargetMeta: JSON.parse(JSON.stringify(PBGR.byTargetMeta)),
      byPlayer: new Map(PBGR.byPlayer),
      byPlayerMeta: new Map(PBGR.byPlayerMeta)
    };
  };
})();

// Percent helper
function pctStr(num, den){
  if (!den) return '—';
  return Math.round((num/den)*100) + '%';
}

function isOfficialGame(g){
  return g && Array.isArray(g.players) && g.players.length >= 2;
}
function isPracticeGame(g){
  return g && Array.isArray(g.players) && g.players.length === 1;
}
function filterByMode(games, matches, mode){
  const gm = (games || []).filter(mode === 'official' ? isOfficialGame : isPracticeGame);
  const mm = (mode === 'official') ? (matches || []) : []; // practice ignores matches
  return { games: gm, matches: mm };
}

// Case/whitespace-insensitive player name compare
function eqName(a, b){
  return String(a || '').trim().toLowerCase() === String(b || '').trim().toLowerCase();
}

// Legacy log keys (fallback/migration)
const LEGACY_GAME_KEYS  = ['shateki_quest_games_log', 'shateki_quest_games_log_v0'];
const LEGACY_MATCH_KEYS = ['shateki_quest_matches_log', 'shateki_quest_matches_log_v0'];

// UUID v4 for Supabase match IDs (uuid column)
function genUuidV4() {
  const a = crypto.getRandomValues(new Uint8Array(16));
  a[6] = (a[6] & 0x0f) | 0x40;  // version
  a[8] = (a[8] & 0x3f) | 0x80;  // variant
  const h = [...a].map(b => b.toString(16).padStart(2,'0')).join('');
  return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
}

// Backdate (applies to the NEXT cloud save only)
let _tsOverride = null;

function setBackdateInteractive() {
  const v = prompt('Enter local date/time for *next* cloud save (YYYY-MM-DD HH:MM)');
  if (!v) return;
  const m = v.trim().replace(' ', 'T');
  const dt = new Date(m);
  if (isNaN(dt.getTime())) { toast('Bad date/time'); return; }
  _tsOverride = dt.toISOString();
  toast('Backdate set for next save');
}
function clearBackdate(){ _tsOverride = null; }

// ---------- CORE STATE ----------
const baseState = {
  players: [],
  score: [],
  currentRound: 0,
  currentPlayer: 0,
  currentDart: 0,
  history: [],
  finished: false,
  suddenDeath: { active: false, participants: [], turnIndex: 0, throws: [], round: 1 },
  match: {
    id: null,
    targetWins: 4,      // default "first to 4 wins" – overwritten when you start a match
    gameNumber: 1,
    wins: [],
    history: [],
    completedLogged: false
  },
  matchAgg: null,
  gameAwarded: false
};

let state = JSON.parse(JSON.stringify(baseState));
const COLOR_PALETTE=['#7bdcff','#8cff9e','#ffcc66','#ff9bd6','#f8d66d','#a6b3ff','#7fffd4','#ffb27b','#ffd166','#06d6a0','#118ab2','#ef476f'];
function assignUniqueColors(arr){ for(let i=0;i<arr.length;i++){ arr[i].color = COLOR_PALETTE[i % COLOR_PALETTE.length]; } }

// Cloud status indicator
const cloudStatusEl     = byId('cloudStatus');
const cloudStatusTextEl = byId('cloudStatusText');

function setCloudStatus(mode, text) {
  if (!cloudStatusEl || !cloudStatusTextEl) return;
  cloudStatusEl.classList.remove('ok', 'error', 'checking');
  cloudStatusEl.classList.add(mode);
  cloudStatusTextEl.textContent = text;
}

function markCloudOk() {
  setCloudStatus('ok', 'Cloud: connected');
}
function openGameCompleteDialog() {
  const totals = state.players.map((_, i) => totalScoreForPlayer(i));
  if (!totals.length) return;
  
  const max = Math.max(...totals);
  const winnerIdx = [];
  totals.forEach((t, i) => {
    if (t === max) winnerIdx.push(i);
  });

  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Game Complete';
  title.style.textAlign = 'center';
  title.style.fontSize = '1.6rem';
  title.style.marginBottom = '10px';

  const body = document.createElement('div');
  body.className = 'modal-body';

  // BIG winner line in the centre
  const winnerP = document.createElement('p');
  winnerP.style.fontWeight = '900';
  winnerP.style.fontSize = '1.8rem';
  winnerP.style.textAlign = 'center';
  winnerP.style.margin = '4px 0 12px';
  winnerP.style.letterSpacing = '0.03em';

  const winnerNames = winnerIdx.map(i => state.players[i].name);
  if (winnerNames.length === 1) {
    winnerP.textContent = `${winnerNames[0]} WINS (${max})`;
  } else {
    winnerP.textContent = `JOINT WINNERS: ${winnerNames.join(' · ')} (${max})`;
  }
  body.appendChild(winnerP);

  // Ranked list underneath
  const list = document.createElement('ol');
  list.style.paddingLeft = '20px';
  list.style.margin = '0';

  const ranking = totals
    .map((score, index) => ({ index, score }))
    .sort((a, b) => b.score - a.score);

  ranking.forEach(row => {
    const li = document.createElement('li');
    const name = state.players[row.index].name;
    li.textContent = `${name} – ${row.score}`;
    list.appendChild(li);
  });

  body.appendChild(list);

 const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const returnBtn = document.createElement('button');
  returnBtn.textContent = 'Close';
returnBtn.onclick = () => overlay.remove();

  footer.appendChild(returnBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });

  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });
}

function markCloudError(err) {
  console.error('[Supabase]', err);
  setCloudStatus('error', 'Cloud: problem – using local');
}

function show(id){
  ['details','players','game','leaderboard'].forEach(x=>byId(x)?.classList.add('hidden'));
  byId(id)?.classList.remove('hidden');
  document.body.setAttribute('data-page', id);
  updatePadSpacer();
  const fh=byId('floatHead');
  if(fh) fh.classList.toggle('hidden', id!=='game');
  buildPad();
  if (id === 'details') {
    try {
      if (typeof window.buildStartTicker === 'function') { window.buildStartTicker(); }
    } catch(e) { console.error(e); }
  }
  if (id === 'game') {
    // Reverted: rely on default scoreboard rendering.
    if (window.__marksKick) { clearInterval(window.__marksKick); window.__marksKick = null; }
    try { if (typeof scanForTripleHatAndCelebrate === 'function') scanForTripleHatAndCelebrate(); } catch(_) {}
  try { if (typeof updatePBGRBadges === 'function') updatePBGRBadges(); } catch(_) {}
  }
}
const padBar = byId('padBar');
const pad     = byId('pad');
const padHint = byId('padHint');
function updatePadSpacer(){ try{ const h=padBar?padBar.getBoundingClientRect().height:148; document.documentElement.style.setProperty('--pad-h', h+'px'); }catch(e){} }
addEventListener('resize',updatePadSpacer,{passive:true}); addEventListener('orientationchange',updatePadSpacer,{passive:true});
window.addEventListener('load', syncStartTitleWidth, { passive: true });

/*****************
 * GAME & STATE
 *****************/
const ROUNDS = (()=>{ const a=[]; for(let i=0;i<11;i++) a.push({type:'number',target:10+i}); a.push({type:'doubles'},{type:'triples'},{type:'bull'}); return a; })();
function labelForRound(def){
  if (!def) return '';
  if (def.type === 'number')  return String(def.target);
  if (def.type === 'doubles') return 'D';
  if (def.type === 'triples') return 'T';
  if (def.type === 'bull')    return 'B';
  return '';
}
const MAX_ROUNDS=ROUNDS.length;
const totalScoreForPlayer = i => (state.score[i]||[]).reduce((s,row)=>s+(row?.roundTotal||0),0);
const save = () => {
  safeSave(STORAGE_KEY, state);
  try { if (typeof onStateSaved === 'function') onStateSaved(); } catch(_) {}
};
function ensureMatchAgg(){ if(state.matchAgg && state.matchAgg.hits) return; state.matchAgg={ hits:Array.from({length:state.players.length},()=>({})), totals60:Array.from({length:state.players.length},()=>0), totals100:Array.from({length:state.players.length},()=>0), totals140:Array.from({length:state.players.length},()=>0) }; }

function getGameLog() {
  const v1 = safeLoad(GAMES_LOG_KEY);
  if (Array.isArray(v1) && v1.length) return v1;

  // Fallback to legacy keys; if found, migrate to v1 for future reads
  for (const k of (LEGACY_GAME_KEYS || [])) {
    const v = safeLoad(k);
    if (Array.isArray(v) && v.length) {
      setGameLog(v);
      return v;
    }
  }
  return [];
}

function setGameLog(arr) {
  safeSave(GAMES_LOG_KEY, arr || []);
}

function getMatchLog() {
  const v1 = safeLoad(MATCHES_LOG_KEY);
  if (Array.isArray(v1) && v1.length) return v1;

  for (const k of (LEGACY_MATCH_KEYS || [])) {
    const v = safeLoad(k);
    if (Array.isArray(v) && v.length) {
      setMatchLog(v);
      return v;
    }
  }
  return [];
}

function setMatchLog(arr) {
  safeSave(MATCHES_LOG_KEY, arr || []);
}

function logCompletedGame(totals, winners, boardClone) {
  const games  = getGameLog();
  const nowIso = _tsOverride || new Date().toISOString();

  // Build a single game record object we can reuse
  const gameRecord = {
    id: `g-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
    ts: nowIso,
    matchId: state.match.id || null,
    players: state.players.map(p => ({ name: p.name })),
    totals: totals.slice(),
    winners: winners.slice(),
    board: boardClone
  };

  games.push(gameRecord);
  setGameLog(games);
    // Persist each player's total as a High Score row (respects backdate)
  (async () => {
    try {
      await cloudSaveHighScoresForGame(totals, nowIso);
    } catch (e) {
      console.error('High score cloud save failed', e);
    }
  })();
};

function logCompletedMatch() {
  const matches = getMatchLog();
  const nowIso = new Date().toISOString();
  const gamesInMatch = state.match.history.length;

  const players = state.players.map(p => ({ name: p.name }));
  const wins    = (state.match.wins || []).slice();

  const matchTotals = state.players.map((_, idx) =>
    state.match.history.reduce((sum, g) => sum + (g.totals?.[idx] || 0), 0)
  );

  matches.push({
    id: state.match.id || `m-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
    ts: nowIso,
    players,
    wins,
    targetWins: state.match.targetWins || 1,
    games: gamesInMatch,
    matchTotals
  });

  setMatchLog(matches);
}

/*****************
 * SUPABASE HELPERS
 *****************/
// simple SHA-256 hex for demo auth (client-side)
async function sha256Hex(text){
  const enc = new TextEncoder().encode(text);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,'0')).join('');
}

async function cloudSynthAllGamesFromHighScores(limit = 500) {
  const items = [];
  async function fetchTbl(tbl) {
    const { data, error } = await sb
      .from(tbl)
      .select('name, score, ts')
      .order('ts', { ascending: true })
      .limit(limit);
    if (error) throw error;
    return data || [];
  }
  try {
    const league   = await fetchTbl(TABLE_HS_LEAGUE);
    const practice = await fetchTbl(TABLE_HS_PRACTICE);
    [...league, ...practice].forEach(row => {
      items.push({
        ts: row.ts || null,
        players: [{ name: row.name }],
        totals:  [Number(row.score) || 0],
        board:   null
      });
    });
  } catch (e) {
    console.error('cloudSynthAllGamesFromHighScores failed', e);
  }
  return items;
}

// PLAYERS
async function cloudListPlayers(){
  const { data, error } = await sb.from(TABLE_PLAYERS).select('name').order('name');
  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
  return data || [];
}

// Create / update a player by name only (no password)
async function cloudCreatePlayer(name){
  const { error } = await sb
    .from(TABLE_PLAYERS)
    .upsert({ name }, { onConflict: 'name' });   // only name is stored

  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
}


async function cloudValidatePlayer(name, password){
  const hash = await sha256Hex(password);
  const { data, error } = await sb.from(TABLE_PLAYERS)
    .select('name, password_hash')
    .eq('name', name)
    .maybeSingle();
  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
  if (!data) return false;
  return data.password_hash === hash;
}

async function cloudDeletePlayer(name){
  const { error } = await sb.from(TABLE_PLAYERS).delete().eq('name', name);
  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
}

async function cloudUpdatePlayerPassword(name, newPassword){
  const password_hash = await sha256Hex(newPassword);
  const { error } = await sb.from(TABLE_PLAYERS).update({ password_hash }).eq('name', name);
  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
}

// Fetch high scores from Supabase (league or practice)
async function cloudListHighScores(isPractice = false, limit = 500){
  const table = isPractice ? TABLE_HS_PRACTICE : TABLE_HS_LEAGUE;
  const { data, error } = await sb
    .from(table)
    .select('name, score, ts')
    .order('score', { ascending: false })  // highest first
    .order('ts',    { ascending: false })  // newest first tie-break
    .limit(limit);
  if (error) { markCloudError(error); throw error; }
  markCloudOk();
  return (data || []).map(r => ({ name: r.name, score: Number(r.score) || 0, ts: r.ts }));
}

// Insert (name, score, ts) if not already present in the table
async function cloudInsertHighScoreIfMissing(table, name, score, ts){
  try {
    const { data, error } = await sb
      .from(table)
      .select('name', { count: 'exact' })
      .eq('name', name)
      .eq('score', score)
      .eq('ts', ts)
      .limit(1);
    if (error) { markCloudError(error); return false; }
    if (Array.isArray(data) && data.length) return false; // already exists
    const { error: insErr } = await sb.from(table).insert({ name, score, ts });
    if (insErr) { markCloudError(insErr); return false; }
    markCloudOk();
    return true;
  } catch (e){
    console.error('cloudInsertHighScoreIfMissing failed', e);
    return false;
  }
}

// From a finished game, write one HS row per player to the correct table
async function cloudSaveHighScoresForGame(totals, tsIso){
  try {
    const isPractice = (state.players || []).length === 1;
    const table = isPractice ? TABLE_HS_PRACTICE : TABLE_HS_LEAGUE;
    const when = tsIso || new Date().toISOString();

    for (let i = 0; i < (state.players || []).length; i++){
      const name  = state.players[i]?.name || '';
      const score = Number(totals?.[i] || 0);
      if (!name || score <= 0) continue;
      await cloudInsertHighScoreIfMissing(table, name, score, when);
    }
  } catch (e) {
    console.error('cloudSaveHighScoresForGame failed', e);
  }
}

// Simple initial Supabase connectivity check
async function initialCloudCheck() {
  try {
    setCloudStatus('checking', 'Checking cloud…');
    const { error } = await sb
      .from(TABLE_PLAYERS)
      .select('name', { head: true, count: 'exact' });
    if (error) throw error;
    markCloudOk();
  } catch (err) {
    markCloudError(err);
  }
}

// --- Bootstrap wiring once the DOM is ready ---
/* Fallback: define initSetupSteppers if missing */
if (typeof window.initSetupSteppers !== 'function') {
  window.initSetupSteppers = function initSetupSteppers(){
    const steppers = document.querySelectorAll('.setup-stepper');
    steppers.forEach(stepper => {
      const selectId = stepper.getAttribute('data-select-id');
      const suffix   = stepper.getAttribute('data-suffix') || '';
      const select   = document.getElementById(selectId);
      const numEl    = stepper.querySelector('.stepper-number');
      const sufEl    = stepper.querySelector('.stepper-suffix');
      if (sufEl) sufEl.textContent = suffix;
      if (!select || !numEl) return;

      // Prevent duplicate bindings (which caused skipping: 1→3→5…)
      if (stepper.dataset.bound === '1') return;
      stepper.dataset.bound = '1';

      // Determine min/max from the select's option values
      const values = [...select.options].map(o => parseInt(o.value, 10)).filter(n => !Number.isNaN(n));
      const minVal = Math.min(...values);
      const maxVal = Math.max(...values);

      function syncFromSelect(){
        const val = parseInt(select.value, 10);
        if (!Number.isNaN(val)) {
          numEl.textContent = String(val);
        } else {
          const opt = select.options[select.selectedIndex];
          const txt = opt ? opt.textContent : '';
          const m = txt && txt.match(/\d+/);
          numEl.textContent = m ? m[0] : txt;
        }
      }

      function setTo(v){
        const targetIdx = [...select.options].findIndex(o => parseInt(o.value, 10) === v);
        if (targetIdx >= 0) {
          select.selectedIndex = targetIdx;
          select.dispatchEvent(new Event('change', { bubbles: true }));
          syncFromSelect();
        }
      }

      // Bind buttons using `onclick` (overwrites any prior handlers)
      stepper.querySelectorAll('.stepper-btn').forEach(btn => {
        const delta = parseInt(btn.getAttribute('data-delta') || '0', 10);
        btn.onclick = () => {
          const cur = parseInt(select.value, 10);
          const next = Math.min(maxVal, Math.max(minVal, cur + (delta > 0 ? 1 : -1)));
          setTo(next);
        };
      });

      select.addEventListener('change', syncFromSelect);
      syncFromSelect();
    });

    // Ensure initial player rows render to match default "players" count
    try { if (typeof drawPsRows === 'function') drawPsRows(); } catch(_) {}
  };
}
document.addEventListener('DOMContentLoaded', () => {
  try { if (typeof setupStartMenuButtons === 'function') setupStartMenuButtons(); } catch (e) { console.error(e); }
  try { if (typeof initSetupSteppers   === 'function') initSetupSteppers();   } catch (e) { console.error(e); }
  try { if (typeof initialCloudCheck   === 'function') initialCloudCheck();   } catch (e) { console.error(e); }
  try { updatePadSpacer(); } catch (e) {}
  try { bindScoreHeaderScrollSync(); } catch (e) {}
  // Build the rolling ticker on first load of the Start screen
  try { if (typeof window.buildStartTicker === 'function') { window.buildStartTicker(); } } catch (e) { console.error(e); }
});
// --- Period filter helper (Today / 1 Week / 1 Month / All Time) ---
function periodStartIso(key){
  const now = new Date();
  if (key === 'today') {
    const d = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    return d.toISOString();
  }
  if (key === 'week') {
    const d = new Date(now.getTime() - 7*24*60*60*1000);
    return d.toISOString();
  }
  if (key === 'month') {
    const d = new Date(now.getTime() - 30*24*60*60*1000);
    return d.toISOString();
  }
  return null; // all time
}
// --- Date formatter: dd/mm/yy @ 24h:mm ---
function fmtDdMmYyAtTime(d){
  const dd = String(d.getDate()).padStart(2,'0');
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const yy = String(d.getFullYear()).slice(-2);
  const hh = String(d.getHours()).padStart(2,'0');
  const mi = String(d.getMinutes()).padStart(2,'0');
  return `${dd}/${mm}/${yy} @ ${hh}:${mi}`;
}

// --- Start-screen rolling banner (last 10 completed games) ---
function _psHumanList(parts){
  if (!parts || !parts.length) return '';
  if (parts.length === 1) return parts[0];
  if (parts.length === 2) return parts[0] + ' and ' + parts[1];
  return parts.slice(0, -1).join(', ') + ' and ' + parts[parts.length - 1];
}

function _psFormatLine(game){
  try{
    const list = (game.players || []).map((p, i) => ({
      name: (p && p.name) ? String(p.name) : `Player ${i + 1}`,
      score: Number(Array.isArray(game.totals) ? (game.totals[i] || 0) : 0)
    }));
    if (!list.length) return '';
    list.sort((a,b)=> b.score - a.score);      // winner first
    const winner = list[0];
    const others = list.slice(1).map(o => `${o.name} (${o.score})`);
    return others.length
      ? `${winner.name} (${winner.score}) beats ${_psHumanList(others)}`
      : `${winner.name} (${winner.score}) wins`;
  }catch(_){ return ''; }
}

// Expose globally so `show()` can always reach it, even if the code is wrapped.
window.buildStartTicker = async function buildStartTicker(){
  const wrap  = document.getElementById('psTicker');
  const track = wrap ? wrap.querySelector('.track') : null;
  if (!wrap || !track){ return; }

  try{
    // Merge local + cloud; then newest first; take last 10 completed official games
    let games = await getGamesForMode('official');
    games = (games || [])
      .filter(g => g && Array.isArray(g.players) && Array.isArray(g.totals))
      .sort((a,b) => (Date.parse(b.ts || 0) || 0) - (Date.parse(a.ts || 0) || 0))
      .slice(0, 10);

    if (!games.length){
      wrap.classList.add('hidden');
      return;
    }

    const parts = games.map(_psFormatLine).filter(Boolean);
    if (!parts.length){
      wrap.classList.add('hidden');
      return;
    }

    track.textContent = parts.join('🔴 🔴 🔴');
    wrap.classList.remove('hidden');
  }catch(e){
    console.error('buildStartTicker failed', e);
    wrap.classList.add('hidden');
  }
};
// High Scores dialog — deduped + period buttons
async function openHighScoresDialog(isPractice = false, range = 'all') {
  // range helpers
  function rangePassFactory(r){
    const now = new Date();
    if (r==='today'){ const s=new Date(now); s.setHours(0,0,0,0); return d=>d>=s && d<=now; }
    if (r==='yesterday'){ const y0=new Date(now); y0.setDate(y0.getDate()-1); y0.setHours(0,0,0,0); const y1=new Date(y0); y1.setHours(23,59,59,999); return d=>d>=y0 && d<=y1; }
    if (r==='1w'){ const s=new Date(now); s.setDate(s.getDate()-7); return d=>d>=s && d<=now; }
    if (r==='1m'){ const s=new Date(now); s.setMonth(s.getMonth()-1); return d=>d>=s && d<=now; }
    if (r==='6m'){ const s=new Date(now); s.setMonth(s.getMonth()-6); return d=>d>=s && d<=now; }
    return _=>true;
  }

  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className='modal';
  const title   = document.createElement('h3');  title.textContent = `High Scores (${isPractice? 'Practice' : 'Official'})`;
  const body    = document.createElement('div'); body.className='modal-body';
  const footer  = document.createElement('div'); footer.className='modal-footer';
  modal.append(title, body, footer); overlay.appendChild(modal); document.body.appendChild(overlay);
  modal.tabIndex = 0; modal.focus();
  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); });

// --- Shotgun Leaderboard (3-dart avg over last 28 rounds = last 2 official games) ---
async function cloudListPlayerRecentOfficialGames(name, limitGames = 2){
  const { data, error } = await sb
    .from(TABLE_PLAYER_GAMES) // 'player_games_union'
    .select('player, score, rounds, ts, is_practice')
    .eq('player', name)
    .eq('is_practice', false) // official only
    .order('ts', { ascending: false })
    .limit(limitGames);
  if (error) { console.error(error); return []; }
  return data || [];
}
  async function render(){
    body.innerHTML = '';
    let rows = [], loadErr = null;
    try { rows = await cloudListHighScores(isPractice, 1000); }
    catch(e){ console.error(e); loadErr = e; rows = []; }

    if (loadErr){
      const p=document.createElement('p'); p.textContent='Failed to load high scores.'; body.appendChild(p); return;
    }

    // Robust client-side de-dup: one row per (name,score), keep original (earliest ts)
    rows = dedupeRowsByNameScoreKeepEarliest(rows);

    // Filter by requested window
    const pass = rangePassFactory(range);
    rows = rows.filter(r=> r?.ts ? pass(new Date(r.ts)) : true);

    // Sort: highest score first, then newest, then name
    rows.sort((a, b) => {
      const sa = Number(a?.score || 0);
      const sb = Number(b?.score || 0);
      if (sb !== sa) return sb - sa;
      const ta = a?.ts ? Date.parse(a.ts) : 0;
      const tb = b?.ts ? Date.parse(b.ts) : 0;
      if (tb !== ta) return tb - ta;
      const na = String(a?.name || '');
      const nb = String(b?.name || '');
      return na.localeCompare(nb);
    });

    if (!rows.length){
      const p=document.createElement('p'); p.textContent='No scores recorded for this period.'; body.appendChild(p); return;
    }

    const table=document.createElement('table'); table.className='hs-table';
    const thead=document.createElement('thead'); const trh=document.createElement('tr');
    ;['#','Player','Score','Avg / Round','When'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
    thead.appendChild(trh); table.appendChild(thead);
    const tb=document.createElement('tbody');

    rows.forEach((r, idx)=>{
      const tr=document.createElement('tr');
      const td1=document.createElement('td'); td1.textContent=String(idx+1);
      const td2=document.createElement('td'); td2.textContent=String(r.name||'');
      const td3=document.createElement('td'); td3.textContent=String(r.score);
      const td4=document.createElement('td');
      const avg=(typeof MAX_ROUNDS==='number'&&MAX_ROUNDS>0)?(Number(r.score||0)/MAX_ROUNDS):0; td4.textContent=avg.toFixed(1);
      const td5=document.createElement('td');
      const d=r.ts?new Date(r.ts):null; td5.textContent=(d&&!Number.isNaN(d.getTime()))? d.toLocaleString(undefined,{year:'2-digit',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit'}) : '';
      td5.style.fontSize='0.8rem';
      tr.append(td1,td2,td3,td4,td5);
      tb.appendChild(tr);
    });

    table.appendChild(tb); body.appendChild(table);
  }

  function mkBtn(lbl,val,primary=false){
    const b=document.createElement('button'); b.className='btn'; if(primary) b.classList.add('primary'); b.textContent=lbl;
    b.onclick=()=>{ if(val==='__back__'){ overlay.remove(); return; } range=val; render(); };
    return b;
  }
  footer.append(
    mkBtn('Today','today'),
    mkBtn('Yesterday','yesterday'),
    mkBtn('1 Week','1w'),
    mkBtn('1 Month','1m'),
    mkBtn('6 Month','6m'),
    mkBtn('All Time','all', true),
    mkBtn('Back','__back__',false)
  );

  await render();
}
/*****************
 * CLOUD STATS HELPERS
 *****************/

async function computeSprintLeagueAsync() {
  try {
    const { data, error } = await sb
      .from('sprint_league_last5')
      .select('player, rounds_used, total_points, avg_per_round')
      .order('avg_per_round', { ascending: false })
      .limit(10);
    if (error) throw error;

    return (data || []).map(r => ({
      name: r.player,
      roundsUsed: r.rounds_used,
      totalPoints: r.total_points,
      avgRound: Number(r.avg_per_round)
    }));
  } catch (e) {
    console.error('sprint_league_last5 fetch failed', e);
    return [];
  }
}

async function openSprintLeagueDialog() {
  // CLEANUP: if you still have any stray header code at the very start of the old
  // function that references `trh` before it's defined, delete it.

  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Sprint League';

  const body = document.createElement('div');
  body.className = 'modal-body';

  // Updated bio
  const info = document.createElement('p');
  info.textContent =
    'Ranking by average points per round from the most recent 2–5 games (28–70 rounds). Minimum 2 games. One entry per player.';
  info.style.fontSize = '0.82rem';
  info.style.color = '#a8acc3';
  info.style.marginBottom = '6px';
  body.appendChild(info);

  // Table shell
  const table = document.createElement('table');
  table.className = 'hs-table';

  const thead = document.createElement('thead');
  const trh   = document.createElement('tr');
  ['#', 'Player', 'Rounds', 'Points', 'Avg PPR'].forEach(h => {
    const th = document.createElement('th');
    th.textContent = h;
    trh.appendChild(th);
  });
  thead.appendChild(trh);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  table.appendChild(tbody);
  body.appendChild(table);

  // Fetch rows (your computeSprintLeagueAsync now reads from the SQL view)
  let rows = [];
  try {
    rows = await computeSprintLeagueAsync();
  } catch (e) {
    console.error(e);
  }

  if (!rows || !rows.length) {
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = 5;
    td.textContent = 'No qualifying players yet.';
    tr.appendChild(td);
    tbody.appendChild(tr);
  } else {
    // Already sorted by avgRound desc in computeSprintLeagueAsync; keep it.
    rows.forEach((row, idx) => {
      const tr = document.createElement('tr');

      const rank   = document.createElement('td'); rank.textContent = String(idx + 1);
      const name   = document.createElement('td'); name.textContent = row.name;
      const rounds = document.createElement('td'); rounds.className = 'num'; rounds.textContent = String(row.roundsUsed);
      const points = document.createElement('td'); points.className = 'num'; points.textContent = String(Math.round(row.totalPoints));
      const avg    = document.createElement('td'); avg.className = 'num';  avg.textContent = (Number(row.avgRound) || 0).toFixed(1);

      tr.append(rank, name, rounds, points, avg);
      tbody.appendChild(tr);
    });
  }

  // Footer
  const footer  = document.createElement('div');
  footer.className = 'modal-footer';
  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();
  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}

// (cloudSynthGamesFromHighScores remains unchanged)
// If a wrapper exists for openHighScoresMenuDialog, patch it to call the new dialog:
function openHighScoresMenuDialog(){ openHighScoresDialog(false, 'all'); }


/*****************
 * CLOUD MATCH HELPERS
 *****************/
async function upsertMatchToSupabase(createdAtOverride) {
  try {
    const payload = {
      id: state.match.id,                                                // uuid
      created_at: state.match.createdAtIso || createdAtOverride || new Date().toISOString(),
      total_games: state.match.history.length,
      players: state.players.map(p => ({ name: p.name })),               // [{name}]
      wins: (state.match.wins || []).slice(),
      history: state.match.history.map(g => ({ totals: (g?.totals || []).slice() }))
    };
    const { error } = await sb.from(TABLE_MATCHES).upsert(payload);
    if (error) throw error;
  } catch (e) {
    console.error('upsertMatchToSupabase failed', e);
  }
}

// Map Supabase -> local shapes the stats code already understands
function mapCloudGameRowToLocal(row){
  const players = (row?.state?.players || []).map(p => ({ name: p.name }));
  const totals  = Array.isArray(row?.totals) ? row.totals.slice() : [];
  let max = -Infinity, winners = [];
  totals.forEach((t,i)=>{ if (t>max){max=t; winners=[i];} else if (t===max){ winners.push(i);} });
  return { ts: row?.created_at || null, players, totals, winners, board: row?.state?.board || null };
}
async function cloudFetchAllGamesAsLocal(){
  const { data, error } = await sb
    .from(TABLE_GAMES)
    .select('created_at,state,totals')
    .order('created_at', { ascending: true });
  if (error) throw error;
  return (data || []).map(mapCloudGameRowToLocal);
}

function mapCloudMatchRowToLocal(row){
  const playersArr = Array.isArray(row?.players) ? row.players : [];
  const players = playersArr.map(p => (typeof p === 'string') ? { name: p } : { name: p?.name });
  const wins = Array.isArray(row?.wins) ? row.wins.slice() : [];
  const games = row?.total_games || (Array.isArray(row?.history) ? row.history.length : 0);
  const matchTotals = [];
  if (Array.isArray(row?.history)) {
    row.history.forEach(g => {
      (g?.totals || []).forEach((v,i) => { matchTotals[i] = (matchTotals[i] || 0) + (Number(v)||0); });
    });
  }
  return { id: row?.id, ts: row?.created_at || null, players, wins, targetWins: null, games, matchTotals };
}
async function cloudFetchAllMatchesAsLocal(){
  const { data, error } = await sb
    .from(TABLE_MATCHES)
    .select('id,created_at,players,wins,history,total_games')
    .order('created_at', { ascending: true });
  if (error) throw error;
  return (data || []).map(mapCloudMatchRowToLocal);
}

async function computePlayerWindowStatsAsync(playerName, mode = 'official') {
  // 0) Load sources
  let cloudGames = [];
  let cloudMatches = [];
  try { cloudGames = await cloudFetchAllGamesAsLocal(); } catch (_) {}
  try { cloudMatches = await cloudFetchAllMatchesAsLocal(); } catch (_) {}

  const localGames   = getGameLog()   || [];
  const localMatches = getMatchLog()  || [];

  // 1) Merge (cloud first, then local) – oldest→newest order
  let games   = [...cloudGames, ...localGames];
  let matches = (mode === 'official') ? [...cloudMatches, ...localMatches] : [];

  // 2) Filter by mode
  const byMode = (g) => (mode === 'official' ? isOfficialGame(g) : isPracticeGame(g));
  games = games.filter(byMode);
  if (mode !== 'official') matches = [];

  // 3) If still no games for this player, synth from high_scores tables
  const hasAnyForPlayer = games.some(g => (g.players || []).some(p => p && eqName(p.name, playerName)));
  if (!hasAnyForPlayer) {
    try {
      const synth = await cloudSynthGamesFromHighScores(playerName);
      games = games.concat((synth || []).filter(byMode));
    } catch (_) {}
  }

  // 4) Windows
  const now = new Date();
  const out = {};
  STAT_WINDOWS.forEach(w => {
    const gWin = games.filter(g => g.ts && w.test(new Date(g.ts), now));
    const mWin = matches.filter(m => m.ts && w.test(new Date(m.ts), now));
    out[w.key] = computeSingleWindowStats(playerName, gWin, mWin, w, now);
  });
  out.life = computeSingleWindowStats(playerName, games, matches, { test: () => true }, now);
  return out;
}

// === Mode chooser (top-level) ===
function openModeChooser(onPick, onCancel){
  const ov = document.createElement('div'); ov.className='modal-backdrop';
  const m  = document.createElement('div'); m.className='modal';
  const h  = document.createElement('h3'); h.textContent='Choose Mode';
  const b  = document.createElement('div'); b.className='modal-body';
  const r  = document.createElement('div'); r.className='row';
  r.style.gap='8px'; r.style.justifyContent='center';

  const o  = document.createElement('button'); o.className='btn primary big'; o.textContent='Official';
  const p  = document.createElement('button'); p.className='btn big';         p.textContent='Practice';
  o.onclick = ()=>{ ov.remove(); onPick && onPick('official'); };
  p.onclick = ()=>{ ov.remove(); onPick && onPick('practice'); };
  r.append(o,p); b.appendChild(r);

  const f  = document.createElement('div'); f.className='modal-footer';
  const c  = document.createElement('button'); c.className='btn'; c.textContent='Return';
  c.onclick = ()=>{ ov.remove(); onCancel && onCancel(); };
  f.appendChild(c);

  m.append(h,b,f); ov.appendChild(m); document.body.appendChild(ov); m.tabIndex=0; m.focus();
  ov.addEventListener('click', e=>{ if(e.target===ov) ov.remove(); });
  ov.addEventListener('keydown', e=>{ if(e.key==='Escape'){ ov.remove(); onCancel && onCancel(); }});
}

// === Target Hit Rate ===
async function openTargetHitRateDialog(playerName, mode){
  const games = await getGamesForMode(mode);
  const counters = accumulateTargetCounters(playerName, games);

  const ov = document.createElement('div'); ov.className='modal-backdrop';
  const md = document.createElement('div'); md.className='modal';
  const h  = document.createElement('h3');  h.textContent = `Target Hit Rate – ${playerName} (${mode==='official'?'Official':'Practice'})`;
  const body = document.createElement('div'); body.className='modal-body';

  const tbl = document.createElement('table'); tbl.className='hs-table';
  const thead=document.createElement('thead'); const trh=document.createElement('tr');
  ['Target','Thrown','Hits','Hit %'].forEach(s=>{ const th=document.createElement('th'); th.textContent=s; trh.appendChild(th); });
  thead.appendChild(trh); tbl.appendChild(thead);
  const tb = document.createElement('tbody');

  for (let n=10;n<=20;n++){
    const c = counters[String(n)];
    const tr=document.createElement('tr');
    tr.append(
      Object.assign(document.createElement('td'),{textContent:String(n)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:String(c.thrown)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:String(c.hits)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:pctStr(c.hits, c.thrown)})
    );
    tb.appendChild(tr);
  }

  [['D', counters.D], ['T', counters.T]].forEach(([label,c])=>{
    const tr=document.createElement('tr');
    tr.append(
      Object.assign(document.createElement('td'),{textContent:label}),
      Object.assign(document.createElement('td'),{className:'num', textContent:String(c.thrown)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:String(c.hits)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:pctStr(c.hits, c.thrown)})
    );
    tb.appendChild(tr);
  });

  // Bulls summary row
  {
    const c = counters.B;
    const tr=document.createElement('tr');
    tr.append(
      Object.assign(document.createElement('td'),{textContent:'B'}),
      Object.assign(document.createElement('td'),{className:'num', textContent:String(c.thrown)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:String(c.hits)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:`${pctStr(c.hits, c.thrown)} (I:${pctStr(c.inner,c.thrown)} · O:${pctStr(c.outer,c.thrown)})`})
    );
    tb.appendChild(tr);
  }

  tbl.appendChild(tb); body.appendChild(tbl);

  const ft = document.createElement('div'); ft.className='modal-footer';
  const back=document.createElement('button'); back.className='btn'; back.textContent='Return';
  back.onclick=()=>{ ov.remove(); openPlayerStatsModePicker(playerName); };
  ft.appendChild(back);

  md.append(h, body, ft); ov.appendChild(md); document.body.appendChild(ov);
  md.tabIndex=0; md.focus(); ov.addEventListener('click', e=>{ if(e.target===ov) ov.remove(); });
  ov.addEventListener('keydown', e=>{ if(e.key==='Escape') ov.remove(); });
}

// Official-only head-to-head summary
async function openH2HDialog(playerName){
  const games = await getGamesForMode('official');   // uses official games

  const vs = new Map(); // name -> aggregate
  for (const g of (games || [])) {
    if (!g || !Array.isArray(g.players) || !Array.isArray(g.totals)) continue;
    const me = g.players.findIndex(p => p && eqName(p.name, playerName));
    if (me === -1) continue;

    const myTotal = Number(g.totals[me] || 0);
    const dt = g.ts ? new Date(g.ts) : null;

    for (let j = 0; j < g.players.length; j++){
      if (j === me) continue;
      const oppName = (g.players[j]?.name || '').trim();
      if (!oppName) continue;

      const oppTotal = Number(g.totals[j] || 0);
      const rec = vs.get(oppName) || { opp: oppName, games: 0, wins: 0, losses: 0, for: 0, against: 0, last: null };
      rec.games++;
      if (myTotal > oppTotal) rec.wins++; else if (myTotal < oppTotal) rec.losses++;
      rec.for += myTotal; rec.against += oppTotal;
      if (dt && (!rec.last || dt > rec.last)) rec.last = dt;
      vs.set(oppName, rec);
    }
  }

  const rows = [...vs.values()].map(r => ({
    name: r.opp,
    gp: r.games,
    w: r.wins,
    l: r.losses,
    winPct: r.games ? (r.wins / r.games * 100) : 0,
    avgDiff: r.games ? ((r.for - r.against) / r.games) : 0,
    last: r.last
  })).sort((a,b)=> (b.gp - a.gp) || (b.winPct - a.winPct) || a.name.localeCompare(b.name));

  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal';
  const title   = document.createElement('h3');  title.textContent = `Head-to-Head — ${playerName}`;
  const body    = document.createElement('div'); body.className    = 'modal-body';

  if (!rows.length) {
    const p = document.createElement('p'); p.textContent = 'No head-to-head data (official games only).'; body.appendChild(p);
  } else {
    const table = document.createElement('table'); table.className = 'hs-table';
    const thead = document.createElement('thead'); const trh = document.createElement('tr');
    ['Opponent','GP','W','L','Win %','Avg Diff','Last'].forEach(h=>{
      const th = document.createElement('th'); th.textContent = h; trh.appendChild(th);
    });
    thead.appendChild(trh); table.appendChild(thead);

    const tbody = document.createElement('tbody');
    rows.forEach(r=>{
      const tr = document.createElement('tr');
      const td = (t,c)=>Object.assign(document.createElement('td'),{textContent:t, className:c||''});
      tr.append(
        td(r.name),
        td(String(r.gp),'num'),
        td(String(r.w),'num'),
        td(String(r.l),'num'),
        td(r.winPct.toFixed(1)+'%','num'),
        td((r.avgDiff>=0?'+':'')+r.avgDiff.toFixed(1),'num'),
        td(r.last && !Number.isNaN(r.last.getTime())
          ? r.last.toLocaleDateString(undefined,{year:'2-digit',month:'short',day:'2-digit'})
          : '—')
      );
      tbody.appendChild(tr);
    });
    table.appendChild(tbody); body.appendChild(table);
  }

  const footer = document.createElement('div'); footer.className = 'modal-footer';
  const back   = document.createElement('button'); back.className='btn'; back.textContent='Return';
 back.onclick = () => {
  overlay.remove();
  if (typeof openPlayerStatsModePicker === 'function') {
    openPlayerStatsModePicker(playerName);
  } else {
    // safe fallback: go to the player lookup
    if (typeof openPlayerStatsLookupDialog === 'function') {
      openPlayerStatsLookupDialog();
    }
  }
};
  const close  = document.createElement('button'); close.className='btn'; close.textContent='Close';
  close.onclick = () => overlay.remove();
  footer.append(back, close);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  modal.tabIndex = 0; modal.focus();
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}

// === T-D-B ===
async function openTDHDialog(playerName, mode){
  const games = await getGamesForMode(mode);
  const counters = accumulateTargetCounters(playerName, games);

  const ov = document.createElement('div'); ov.className='modal-backdrop';
  const md = document.createElement('div'); md.className='modal';
  const h  = document.createElement('h3');  h.textContent = `T-D-B – ${playerName} (${mode==='official'?'Official':'Practice'})`;
  const body = document.createElement('div'); body.className='modal-body';

  const tbl = document.createElement('table'); tbl.className='hs-table';
  const thead=document.createElement('thead'); const trh=document.createElement('tr');
  ['Target','Thrown','Treble %','Double %'].forEach(s=>{
    const th=document.createElement('th'); th.textContent=s; trh.appendChild(th);
  });
  thead.appendChild(trh); tbl.appendChild(thead);

  const tb = document.createElement('tbody');
  for (let n=10;n<=20;n++){
    const c = counters[String(n)];
    const tr=document.createElement('tr');
    tr.append(
      Object.assign(document.createElement('td'),{textContent:String(n)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:String(c.thrown)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:pctStr(c.tHits, c.thrown)}),
      Object.assign(document.createElement('td'),{className:'num', textContent:pctStr(c.dHits, c.thrown)})
    );
    tb.appendChild(tr);
  }
  tbl.appendChild(tb); body.appendChild(tbl);

  const ft = document.createElement('div'); ft.className='modal-footer';
  const back=document.createElement('button'); back.className='btn'; back.textContent='Return';
  back.onclick=()=>{ ov.remove(); openPlayerStatsModePicker(playerName); };
  ft.appendChild(back);

  md.append(h, body, ft); ov.appendChild(md); document.body.appendChild(ov);
  md.tabIndex=0; md.focus();
  ov.addEventListener('click', e=>{ if(e.target===ov) ov.remove(); });
  ov.addEventListener('keydown', e=>{ if(e.key==='Escape') ov.remove(); });
}

/*****************
 * DETAILS PAGE (page 1)
 *****************/
const resumeBtn=byId('resumeBtn');
function getSavedState(){ 
  try{
    const raw=localStorage.getItem(STORAGE_KEY); 
    if(!raw) return null; 
    const saved=JSON.parse(raw); 
    if(!saved||!Array.isArray(saved.players)||!saved.players.length) return null; 
    return saved;
  }catch(e){ 
    return null; 
  } 
}
function setupStartMenuButtons(){ 
  const saved   = getSavedState(); 
  const hasSaved = !!saved; 

  resumeBtn.disabled = !hasSaved; 
  resumeBtn.title    = hasSaved ? 'Resume last match' : 'No saved match'; 

  if (hasSaved){ 
    resumeBtn.onclick = () => { 
      Object.assign(state, saved); 
      show('game'); 
      assignUniqueColors(state.players); 
      buildEverything(); 
      updateUI(); 
      toast('Resumed last match'); 
    }; 
  } else { 
    resumeBtn.onclick = null; 
  }

  const hsMainBtn = byId('hsMainBtn');
  if (hsMainBtn) {
    hsMainBtn.onclick = openHighScoresMenuDialog;
  }

// === Player Stats: simple name-only picker (no PIN) ===
async function openPlayerStatsLookupDialog() {
  // Create basic modal shell
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Player Stats \u2013 Select Player';

  const body = document.createElement('div');
  body.className = 'modal-body';

  // Player name dropdown
  const nameWrap = document.createElement('div');
  nameWrap.className = 'stack';

  const nameLabel = document.createElement('label');
  nameLabel.className = 'tag';
  nameLabel.textContent = 'Player Name';

  const nameSelect = document.createElement('select');
  nameSelect.id = 'statsPlayerSelect';
  nameSelect.style.width = '100%';

  nameWrap.append(nameLabel, nameSelect);
  body.append(nameWrap);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'btn';
  cancelBtn.textContent = 'Cancel';
  cancelBtn.type = 'button';
  cancelBtn.onclick = () => overlay.remove();

  const viewBtn = document.createElement('button');
  viewBtn.className = 'btn primary';
  viewBtn.textContent = 'View Stats';
  viewBtn.type = 'button';

  footer.append(cancelBtn, viewBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });

  // Populate players: cloud first, then local saved players
  nameSelect.innerHTML = '<option value="">Select a saved player...</option>';
  let anyPlayers = false;

  try {
    if (typeof cloudListPlayers === 'function') {
      const cloudPlayers = await cloudListPlayers();
      (cloudPlayers || []).forEach(p => {
        if (!p || !p.name) return;
        const opt = document.createElement('option');
        opt.value = p.name;
        opt.textContent = p.name;
        nameSelect.appendChild(opt);
        anyPlayers = true;
      });
    }
  } catch (err) {
    console.error('Stats: cloudListPlayers failed', err);
  }

  if (!anyPlayers && typeof getSavedPlayers === 'function') {
    const local = getSavedPlayers();
    (local || []).forEach(p => {
      if (!p || !p.name) return;
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      nameSelect.appendChild(opt);
      anyPlayers = true;
    });
  }

  if (!anyPlayers) {
    body.innerHTML = '<p>No saved players found. Save a player from the Player Select screen first.</p>';
    viewBtn.disabled = true;
    return;
  }

  // Confirm: open stats for selected player, no PIN check
  viewBtn.onclick = () => {
    const name = nameSelect.value;
    if (!name) {
      if (typeof toast === 'function') toast('Select a saved player');
      return;
    }

    overlay.remove();

    if (typeof openPlayerStatsModePicker === 'function') {
      openPlayerStatsModePicker(name);
    } else {
      console.warn('openPlayerStatsModePicker is not defined; cannot show stats for', name);
    }
  };
}

// === Player Stats: simple name-only picker (no PIN) ===
async function openPlayerStatsLookupDialog() {
  // Create basic modal shell
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Player Stats – Select Player';

  const body = document.createElement('div');
  body.className = 'modal-body';

  // Player name dropdown
  const nameWrap = document.createElement('div');
  nameWrap.className = 'stack';

  const nameLabel = document.createElement('label');
  nameLabel.className = 'tag';
  nameLabel.textContent = 'Player Name';

  const nameSelect = document.createElement('select');
  nameSelect.id = 'statsPlayerSelect';
  nameSelect.style.width = '100%';

  nameWrap.append(nameLabel, nameSelect);
  body.append(nameWrap);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'btn';
  cancelBtn.textContent = 'Cancel';
  cancelBtn.type = 'button';
  cancelBtn.onclick = () => overlay.remove();

  const viewBtn = document.createElement('button');
  viewBtn.className = 'btn primary';
  viewBtn.textContent = 'View Stats';
  viewBtn.type = 'button';

  footer.append(cancelBtn, viewBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });

  // Populate players: cloud first, then local saved players
  nameSelect.innerHTML = '<option value="">Select a saved player...</option>';
  let anyPlayers = false;

  try {
    if (typeof cloudListPlayers === 'function') {
      const cloudPlayers = await cloudListPlayers();
      (cloudPlayers || []).forEach(p => {
        if (!p || !p.name) return;
        const opt = document.createElement('option');
        opt.value = p.name;
        opt.textContent = p.name;
        nameSelect.appendChild(opt);
        anyPlayers = true;
      });
    }
  } catch (err) {
    console.error('Stats: cloudListPlayers failed', err);
  }

  if (!anyPlayers && typeof getSavedPlayers === 'function') {
    const local = getSavedPlayers();
    (local || []).forEach(p => {
      if (!p || !p.name) return;
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      nameSelect.appendChild(opt);
      anyPlayers = true;
    });
  }

  if (!anyPlayers) {
    body.innerHTML = '<p>No saved players found. Save a player from the Player Select screen first.</p>';
    viewBtn.disabled = true;
    return;
  }

  // Confirm: open stats for selected player, no PIN check
  viewBtn.onclick = () => {
    const name = nameSelect.value;
    if (!name) {
      if (typeof toast === 'function') toast('Select a saved player');
      return;
    }

    overlay.remove();

    if (typeof openPlayerStatsModePicker === 'function') {
      openPlayerStatsModePicker(name);
    } else {
      console.warn('openPlayerStatsModePicker is not defined; cannot show stats for', name);
    }
  };
}

  const playerStatsBtn = byId('playerStatsBtn');
  if (playerStatsBtn) {
    playerStatsBtn.onclick = openPlayerStatsLookupDialog;
  }
}

const questBtnEl = byId('questBtn');
if (questBtnEl) questBtnEl.addEventListener('click', ()=>{
  show('players');
});

['startScreenBtn', 'startScreenBtnLB', 'backToDetailsBtn'].forEach(id => {
  document.querySelectorAll('#' + id).forEach(btn => {
    btn.addEventListener('click', () => show('details'));
  });
});

/*****************
 * PLAYER SELECT (page 2)
 *****************/
 const psNumGamesSel   = byId('psNumGames');
const psNumPlayersSel = byId('psNumPlayers');
const psPlayerFields  = byId('psPlayerFields');
function drawPsRows() {
  const count = parseInt(psNumPlayersSel.value, 10) || 2;
  psPlayerFields.innerHTML = '';

  for (let i = 1; i <= count; i++) {
   const row = document.createElement('div');
row.className = 'row pf';
row.style.justifyContent = 'center';
row.style.flexWrap = 'wrap';
row.style.gap = '8px';
    row.style.justifyContent = 'center';
    row.style.gap = '8px';
    row.style.flexWrap = 'wrap';
    row.dataset.index = String(i);

    row.innerHTML = `
      <div class="grow">
        <input placeholder="Guest Player Name" data-role="display">
      </div>
      <button class="btn select-player-btn" type="button">Select Player</button>
      <button class="btn primary save-player-btn" type="button">Save Player</button>
    `;

    psPlayerFields.appendChild(row);
  }

  // Wire buttons for each row
  [...psPlayerFields.querySelectorAll('.pf')].forEach(row => {
    const idx = parseInt(row.dataset.index, 10);
    row.querySelector('.select-player-btn').onclick =
      () => showSelectPlayerDialog(idx);
    row.querySelector('.save-player-btn').onclick =
      () => showAddPlayerDialog(idx);
  });
}

psNumPlayersSel.addEventListener('change', drawPsRows);
psNumGamesSel.addEventListener('change', ()=>{/* nothing else; read on start */});

// ---- Saved players helpers (shared by Add + Select modals) ----
function getSavedPlayers(){
  try {
    return JSON.parse(localStorage.getItem('shateki_players') || '[]');
  } catch(e){
    return [];
  }
}

function setSavedPlayers(arr){
  try {
    localStorage.setItem('shateki_players', JSON.stringify(arr));
  } catch(e){}
}

function populateSavedPlayersSelects(){
  const arr  = getSavedPlayers();
  const sel1 = document.getElementById('existingPlayers');      // Add Player modal
  const sel2 = document.getElementById('existingPlayerSelect'); // Select Player modal

  [sel1, sel2].forEach(sel => {
    if (!sel) return;
    sel.innerHTML =
      '<option value="">Select a saved player...</option>' +
      arr.map(p => `<option value="${p.name}">${p.name}</option>`).join('');
  });
}

// Add / Save Player – name only, no PIN
async function showAddPlayerDialog(index){
  const modal = byId('addPlayerModal');
  if (!modal) { toast('Add Player modal missing'); return; }

  let chosenName = '';

  function finish(msg){
    const idx = parseInt(modal.dataset.playerIndex || '0', 10) || 1;
    const row =
      document.querySelector(`#psPlayerFields .pf[data-index="${idx}"]`) ||
      document.querySelector(`.pf[data-index="${idx}"]`);
    const input = row?.querySelector('input[data-role="display"]');
    if (input) input.value = chosenName || '';

    // close + reset
    modal.classList.add('hidden');
    const nameEl = byId('newPlayerName');
    const passEl = byId('newPlayerPassword');
    if (nameEl) nameEl.value = '';
    if (passEl) passEl.value = '';
    toast(msg);
  }

  // Reset fields
  const nameEl = byId('newPlayerName');
  const passEl = byId('newPlayerPassword');
  if (nameEl) nameEl.value = '';
  if (passEl) {
    passEl.value = '';
    // Hide the password row visually (if present)
    const row = passEl.closest('.stack') || passEl.parentElement;
    if (row) row.style.display = 'none';
  }

  // Remember which row invoked the dialog
  modal.dataset.playerIndex = index ? String(index) : '';

  // Show
  modal.classList.remove('hidden');

  // Wire buttons
  const saveBtn   = byId('savePlayerBtn');
  const cancelBtn = byId('cancelAddPlayerBtn');

  if (cancelBtn) {
    cancelBtn.onclick = () => {
      modal.classList.add('hidden');
    };
  }

  if (saveBtn) {
    saveBtn.onclick = async () => {
      const newName = (nameEl?.value || '').trim();

      if (!newName) {
        toast('Enter a player name');
        return;
      }

      chosenName = newName;

      // Save to local storage
      const arr = getSavedPlayers();
      const idxExisting = arr.findIndex(p => p && p.name === newName);
      if (idxExisting === -1) arr.push({ name: newName });
      else arr[idxExisting].name = newName;
      setSavedPlayers(arr);
      populateSavedPlayersSelects();

      // Save to Supabase (name only)
      try {
        await cloudCreatePlayer(newName);
      } catch (e) {
        console.error('cloudCreatePlayer failed', e);
      }

      finish('Player saved');
    };
  }
}

// Select a saved player for a match – name only, no PIN
async function showSelectPlayerDialog(index){
  const select = byId('existingPlayerSelect');
  if (!select) { toast('Select list missing'); return; }
  select.innerHTML = '<option value="">Select a saved player...</option>';

  let any = false;

  // Try cloud players first
  try {
    const cloudList = await cloudListPlayers();
    (cloudList || []).forEach(p => {
      if (!p || !p.name) return;
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      select.appendChild(opt);
    });
    any = !!(cloudList && cloudList.length);
  } catch (err) {
    console.error('cloudListPlayers failed', err);
  }

  // Fallback: local saved players
  if (!any) {
    const local = getSavedPlayers();
    (local || []).forEach(p => {
      if (!p || !p.name) return;
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      select.appendChild(opt);
    });
    any = !!(local && local.length);
  }

  if (!any) {
    toast('No saved players found');
    return;
  }

  const modal = byId('selectPlayerModal');
  if (!modal) { toast('Select Player modal missing'); return; }

  // Hide password row if it exists
  const passInput = byId('playerPassword');
  if (passInput) {
    const row = passInput.closest('.stack') || passInput.parentElement;
    if (row) row.style.display = 'none';
    passInput.value = '';
  }

  modal.dataset.playerIndex = String(index);
  modal.classList.remove('hidden');

  let cancelBtn  = byId('cancelSelectPlayerBtn');
  let confirmBtn = byId('confirmSelectPlayerBtn');

  // 🔧 Strip any old listeners completely (stats two-step etc.)
  if (cancelBtn) {
    const clone = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(clone, cancelBtn);
    cancelBtn = clone;
  }
  if (confirmBtn) {
    const clone = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(clone, confirmBtn);
    confirmBtn = clone;
  }

  if (cancelBtn) {
    cancelBtn.textContent = 'Cancel';
    cancelBtn.onclick = () => {
      select.value = '';
      modal.classList.add('hidden');
    };
  }

  if (confirmBtn) {
    confirmBtn.textContent = 'Enter';   // make sure it doesn’t say "View Stats"
    confirmBtn.onclick = () => {
      const name = select.value;
      if (!name) { toast('Select a saved player'); return; }

      const idx = parseInt(modal.dataset.playerIndex || '0', 10) || 1;
      const row =
        document.querySelector(`#psPlayerFields .pf[data-index="${idx}"]`) ||
        document.querySelector(`.pf[data-index="${idx}"]`);
      const input = row?.querySelector('input[data-role="display"]');
      if (input) input.value = name;

      select.value = '';
      modal.classList.add('hidden');
      toast('Player selected');
    };
  }
}








byId('startMatchBtn').addEventListener('click', ()=>{
  const games = parseInt(psNumGamesSel.value,10) || 1;

  const rows = [...psPlayerFields.querySelectorAll('.pf')];
  const ppl = rows.map((row,i)=>({
    name:(row.querySelector('input[data-role="display"]').value||'').trim() || `Player ${i+1}`
  }));
  if (!ppl.length){ toast('Add at least 1 player'); return; }

  state.players = ppl.map(p=>({ name:p.name, color:null }));
  assignUniqueColors(state.players);

  state.match = {
    id: genUuidV4(),
    createdAtIso: _tsOverride || new Date().toISOString(),
    targetWins: games,            // first to X wins
    gameNumber: 1,
    wins: Array.from({length: state.players.length}, () => 0),
    history: [],
    completedLogged: false
  };

  state.matchAgg = null;
  ensureMatchAgg();

  // Will open the throw-order dialog first
  startNewGame(false);
  setupStartMenuButtons();
  save();
});

/*****************
 * BUILDERS
 *****************/
const thead=byId('thead'), tbody=byId('tbody');
const statsThead=byId('statsThead'), statsTbody=byId('statsTbody');
const mstatsThead=byId('mstatsThead'), mstatsTbody=byId('mstatsTbody');
const floatThead=byId('floatThead');

function buildScoreHeader(){ 
  // Main scoreboard header: thin strip just above 10s/Bull.
  thead.innerHTML = '';

  const tr = document.createElement('tr');

  // Left column header above "10s" (leave blank for now)
  const thRound = document.createElement('th');
  thRound.textContent = '';
  tr.appendChild(thRound);

  // Per-player header cells: show game wins as cups here
  for (let i = 0; i < state.players.length; i++) {
    const th = document.createElement('th');
    th.className = 'player';
    th.style.color = state.players[i].color;

    const wins = document.createElement('div');
    wins.className = 'th-beers';
    wins.id = 'beers-' + i;      // NEW: main header wins row
    wins.textContent = '';

    th.appendChild(wins);
    tr.appendChild(th);
  }

  thead.appendChild(tr);
}

function buildScoreBody(){ 
  tbody.innerHTML = ''; 

  for (let r = 0; r < MAX_ROUNDS; r++) {
    const tr = document.createElement('tr'); 

    // Left-hand round label
    const th = document.createElement('th'); 
    th.textContent = (
      ROUNDS[r].type === 'number'
        ? (ROUNDS[r].target + 's')
        : (ROUNDS[r].type === 'doubles'
            ? "D's"
            : (ROUNDS[r].type === 'triples' ? "T's" : 'Bull'))
    );
    tr.appendChild(th); 

    // Cells: now have main (rolling total) + sub (round total)
    for (let p = 0; p < state.players.length; p++) { 
      const td = document.createElement('td'); 
      td.className = 'center num player'; 
      td.id = `cell-${p}-${r}`;
      td.innerHTML = `
        <div class="cell-wrap">
          <div class="cell-main" id="cell-main-${p}-${r}">–</div>
          <div class="cell-sub" id="cell-sub-${p}-${r}"></div>
        </div>
      `;
      tr.appendChild(td);
    } 

    tbody.appendChild(tr);
  } 
}

function buildFloatingHeader(){ 
  floatThead.innerHTML = '';

  // ROW 1: round label (left) + player names + throws
  const trNames = document.createElement('tr');

  const thRound = document.createElement('th');
  thRound.id = 'froundlabel';
  thRound.rowSpan = 2;          // now only 2 rows in the floating header
  thRound.textContent = '';     // filled by updateUI()
  trNames.appendChild(thRound);

  for (let i = 0; i < state.players.length; i++) { 
    const th = document.createElement('th'); 
    th.className = 'player'; 
    th.style.color = state.players[i].color; 

    const wrap = document.createElement('div'); 
    wrap.className = 'th-wrap'; 

    const name = document.createElement('div'); 
    name.className = 'th-name'; 
    name.textContent = state.players[i].name; 

    const throws = document.createElement('div');
    throws.className = 'th-throws';
    throws.id = 'fthrows-' + i;
    throws.textContent = '';

    wrap.append(name, throws);
    th.appendChild(wrap); 
    trNames.appendChild(th);
  }  

  // ROW 2: totals + diff
  const trTotals = document.createElement('tr');
  for (let i = 0; i < state.players.length; i++) { 
    const th = document.createElement('th'); 
    th.className = 'player'; 

    const total = document.createElement('div'); 
    total.className = 'th-total th-name num'; 
    total.id = 'ftotal-' + i; 
    total.textContent = '0'; 

    const diff = document.createElement('div'); 
    diff.className = 'th-diff'; 
    diff.id = 'fdiff-' + i; 
    diff.textContent = '0'; 

    th.append(total, diff);
    trTotals.appendChild(th);
  }  

  floatThead.append(trNames, trTotals);
}

function formatTop3Inline(list){
  if (!Array.isArray(list) || !list.length) return '—';
  const pick = i => list[i] || '—';
  return `1st ${pick(0)} | 2nd ${pick(1)} | 3rd ${pick(2)}`;
}

/*****************
 * STATS (modal compute)
 *****************/
const METRICS = [
  { key: 'miss',         label: '% Miss',           fmt: v => v + '%' },
  { key: 'single',       label: '% Singles',        fmt: v => v + '%' },
  { key: 'double',       label: '% Doubles',        fmt: v => v + '%' },
  { key: 'treble',       label: '% Trebles',        fmt: v => v + '%' },
  { key: 'bulls',        label: '% Bulls (I+O)',    fmt: v => v + '%' },

  { key: 'sixtyPlus',    label: '60+ Rounds',       fmt: v => String(v) },
  { key: 'hundredPlus',  label: '100+ Rounds',      fmt: v => String(v) },
  { key: 'oneFortyPlus', label: '140+ Rounds',      fmt: v => String(v) },

  { key: 'avg9',         label: 'Avg (last 9)',     fmt: v => v.toFixed(1) },
  { key: 'avgRound',     label: 'Avg (round)',      fmt: v => v.toFixed(1) },
  { key: 'avgGame',      label: 'Avg (throw)',      fmt: v => v.toFixed(1) },
  { key: 'singleStreak', label: 'Single Streak',    fmt: v => String(v) },
  { key: 'roundStreak',  label: 'Round Streak',     fmt: v => String(v) },

  // NEW: top-3 lists
  { key: 'bestNumbers',  label: 'Best Numbers',     fmt: formatTop3Inline },
  { key: 'worstNumbers', label: 'Worst Numbers',    fmt: formatTop3Inline },
];

// What the popups actually render
const DISPLAY_METRICS = [
  { key: 'wins',          label: 'Game Wins',              kind: 'wins' },
  { sep: true },

  { key: 'miss',          label: 'Miss %',                 fmt: v => v + '%' },
  { key: 'single',        label: 'Single %',               fmt: v => v + '%' },
  { key: 'double',        label: 'Double %',               fmt: v => v + '%' },
  { key: 'treble',        label: 'Trebles %',              fmt: v => v + '%' },
  { key: 'bulls',         label: 'Bulls % (I+O)',          fmt: v => v + '%' },
  { sep: true },

  { key: 'sixtyPlus',     label: '60+ Round',              fmt: v => String(v) },
  { key: 'hundredPlus',   label: '100+ Round',             fmt: v => String(v) },
  { key: 'oneFortyPlus',  label: '140+ Round',             fmt: v => String(v) },
  { sep: true },

  { key: 'avgGame',       label: 'Avg Throw',              fmt: v => v.toFixed(1) },
  { key: 'avgRound',      label: 'Avg Round',              fmt: v => v.toFixed(1) },
  { key: 'avg9',          label: 'Avg Last 9',             fmt: v => v.toFixed(1) },
  { sep: true },

  { key: 'singleStreak',  label: 'Single Streak',          fmt: v => String(v) },
  { key: 'roundStreak',   label: 'Round Streak',           fmt: v => String(v) },
  { sep: true },

  // NEW: multi-line rows rendered specially in the popups
  { key: 'bestNumbers',   label: 'Best Numbers',           multi: true },
  { key: 'worstNumbers',  label: 'Worst Numbers',          multi: true },
];

function computeStatsFromBoards(boards, pIdx) {
  // Flatten darts (in order) and collect per-round info
  const dartsFlat = [];
  const perRoundHit = [];          // boolean per round (any scoring dart)
  let rounds60 = 0, rounds100 = 0, rounds140 = 0;
  let completedRounds = 0, completedPoints = 0;

  // Weighted-hit tracking for 10..20 (S=1, D=2, T=3); bulls excluded
  const numAttempts = {};       // total darts aimed at that number
  const numWeightedHits = {};   // sum of weights of successful hits

  function addAttempt(n){ numAttempts[n] = (numAttempts[n] || 0) + 1; }
  function addWeighted(n,w){ numWeightedHits[n] = (numWeightedHits[n] || 0) + w; }

  (boards || []).forEach(board => {
    const playerBoard = board?.[pIdx];
    if (!playerBoard) return;

    for (let r = 0; r < MAX_ROUNDS; r++) {
      const roundDef = ROUNDS[r];
      const entry = playerBoard[r];
      const darts = entry?.darts || [];
      const rt = entry?.roundTotal || 0;

      if (rt > 0) { completedRounds++; completedPoints += rt; }
      if (rt >=  60) rounds60++;
      if (rt >= 100) rounds100++;
      if (rt >= 140) rounds140++;

      let anyHit = false;

      darts.forEach(d => {
        if (!d) return;
        dartsFlat.push({ dart: d, roundDef });
        const points = d.points || 0;
        if (points > 0) anyHit = true;

        // Attempts/weighted hits by number (10..20)
        if (roundDef.type === 'number') {
          const n = roundDef.target;
          if (n >= 10 && n <= 20) {
            addAttempt(n);
            if (points > 0) {
              const w = (d.kind === 'T' || d.kind === 'Triple') ? 3 :
                        (d.kind === 'D' || d.kind === 'Double') ? 2 : 1;
              addWeighted(n, w);
            }
          }
        } else if ((roundDef.type === 'doubles' || roundDef.type === 'triples') && d.sector) {
          const n = d.sector;
          if (n >= 10 && n <= 20) {
            addAttempt(n); // only count when we know the sector
            if (points > 0) addWeighted(n, roundDef.type === 'doubles' ? 2 : 3);
          }
        }
        // Bulls are ignored for best/worst number calc (by design)
      });

      perRoundHit.push(anyHit);
    }
  });

  const n = dartsFlat.length;
  let miss=0, single=0, double=0, treble=0, bulls=0, pts=0;
  let curHitStreak=0, bestHitStreak=0;

  dartsFlat.forEach(({ dart }) => {
    const p = dart.points || 0;
    pts += p;
    if (p > 0) { curHitStreak++; bestHitStreak = Math.max(bestHitStreak, curHitStreak); }
    else curHitStreak = 0;

    if (dart.kind === 'Miss') miss++;
    else if (dart.kind === 'Bull') bulls++;
    else if (dart.kind === 'S' || dart.kind === 'Single') single++;
    else if (dart.kind === 'D' || dart.kind === 'Double') double++;
    else if (dart.kind === 'T' || dart.kind === 'Triple') treble++;
  });

  const pct = v => n ? Math.round((v / n) * 100) : 0;

  // Avg of last 9 throws
  const last9 = dartsFlat.slice(-9);
  const sum9  = last9.reduce((a, x) => a + (x.dart.points || 0), 0);
  const avg9  = last9.length ? (sum9 / last9.length) : 0;

  const avgGame  = n ? (pts / n) : 0;
  const avgRound = completedRounds ? (completedPoints / completedRounds) : 0;

  // Round streak (consecutive rounds with any score)
  let curR = 0, bestR = 0;
  perRoundHit.forEach(hit => {
    if (hit) { curR++; bestR = Math.max(bestR, curR); } else curR = 0;
  });

  // Best / Worst numbers by weighted hit % (10..20 only)
  const scored = [];
  for (let num = 10; num <= 20; num++) {
    const att = numAttempts[num] || 0;
    if (!att) continue;
    const p = (numWeightedHits[num] || 0) / (3 * att); // 0..1
    scored.push({ num, pct: p });
  }
  scored.sort((a, b) => b.pct - a.pct);
  const best3  = scored.slice(0, 3).map(x => `${x.num} (${Math.round(x.pct * 100)}%)`);
  const worst3 = scored.slice(-3).reverse().map(x => `${x.num} (${Math.round(x.pct * 100)}%)`);

  return {
    miss: pct(miss),
    single: pct(single),
    double: pct(double),
    treble: pct(treble),
    bulls: pct(bulls),

    sixtyPlus:    rounds60,
    hundredPlus:  rounds100,
    oneFortyPlus: rounds140,

    avg9,
    avgRound,
    avgGame,

    singleStreak: bestHitStreak,
    roundStreak:  bestR,

    // top-3 lists + backward-compat single value
    bestNumber:   best3[0] || '—',
    worstNumber:  worst3[0] || '—',
    bestNumbers:  best3,
    worstNumbers: worst3,

    totalThrows:  n,
    totalHits:    n - miss,
    totalMisses:  miss
  };
}


// Per-game stats (current board only)
function computeStatsForPlayerGame(pIdx) {
  return computeStatsFromBoards([state.score], pIdx);
}

// Per-match stats (all finished games + current game)
function computeStatsForPlayerMatch(pIdx) {
  const boards = [];

  if (state.match && Array.isArray(state.match.history)) {
    state.match.history.forEach(g => {
      if (g && Array.isArray(g.board)) boards.push(g.board);
    });
  }

  if (state.score && state.score[pIdx]) {
    boards.push(state.score);
  }

  if (!boards.length) {
    return computeStatsFromBoards([], pIdx);
  }
  return computeStatsFromBoards(boards, pIdx);
}
function buildStatsHeader(){ 
  statsThead.innerHTML = '';
  const tr = document.createElement('tr');

  const thLabel = document.createElement('th');
  thLabel.textContent = 'Game Stats';
  tr.appendChild(thLabel);

  // one column per player (we keep header blank – names are in the popup)
  for (let i = 0; i < state.players.length; i++) {
    const th = document.createElement('th');
    th.className = 'player';
    tr.appendChild(th);
  }

  statsThead.appendChild(tr);
}

function buildStatsBody(){ 
  statsTbody.innerHTML = '';

  METRICS.forEach(m => {
    const tr = document.createElement('tr');

    const th = document.createElement('th');
    th.className = 'stats-th';
    th.textContent = m.label;
    tr.appendChild(th);

    for (let p = 0; p < state.players.length; p++) {
      const td = document.createElement('td');
      td.className = 'center num player';
      td.id = `stat-${m.key}-${p}`;    // used by updateStatsRows()
      td.textContent = '—';
      tr.appendChild(td);
    }

    statsTbody.appendChild(tr);
  });
}

function buildMatchStatsHeader(){ 
  mstatsThead.innerHTML = '';
  const tr = document.createElement('tr');

  const thLabel = document.createElement('th');
  thLabel.textContent = 'Match Stats';
  tr.appendChild(thLabel);

  for (let i = 0; i < state.players.length; i++) {
    const th = document.createElement('th');
    th.className = 'player';
    tr.appendChild(th);
  }

  mstatsThead.appendChild(tr);
}

function buildMatchStatsBody(){ 
  mstatsTbody.innerHTML = '';

  METRICS.forEach(m => {
    const tr = document.createElement('tr');

    const th = document.createElement('th');
    th.className = 'stats-th';
    th.textContent = m.label;
    tr.appendChild(th);

    for (let p = 0; p < state.players.length; p++) {
      const td = document.createElement('td');
      td.className = 'center num player';
      td.id = `mstat-${m.key}-${p}`;   // used by updateMatchStats()
      td.textContent = '—';
      tr.appendChild(td);
    }

    mstatsTbody.appendChild(tr);
  });
}

// Fill the hidden match-stats table so widths stay in sync and data is there if needed
function updateMatchStats(){ 
  for (let i = 0; i < state.players.length; i++) {
    const v = computeStatsForPlayerMatch(i);
    for (const m of METRICS) {
      const td = byId(`mstat-${m.key}-${i}`);
      if (td) td.textContent = m.fmt(v[m.key]);
    }
  }
}
/*****************
 * UI UPDATE
 *****************/
function buildPad(){ 
  if (!pad) return; 
  pad.innerHTML = ''; 

  const page = document.body.getAttribute('data-page');

  // Leaderboard: no throw pad content
  if (page === 'leaderboard') {
    padHint.textContent = '';
    return;
  }

  // Other non-game pages: no pad
  if (page !== 'game') {
    padHint.textContent = '';
    return;
  }

  // Game page
  padHint.textContent = state.finished ? 'Game finished.' : '';

  if (!state.finished) {
    const r = ROUNDS[state.currentRound];
    if (!r) return;

    // ----- NUMBER ROUNDS (10–20) -----
    if (r.type === 'number') {
      const topRow = document.createElement('div');
      topRow.style.display = 'flex';
      topRow.style.gap = '8px';
      topRow.style.width = '100%';

      ['S','D','T'].forEach(k => {
  const b = document.createElement('button');
  b.className = 'btn primary letter-throw';
  b.textContent = k;
        b.style.flex = '1 1 0';
        b.style.minWidth = '0';
        b.onclick = () => recordThrow({ kind: k });
        topRow.appendChild(b);
      });

      pad.appendChild(topRow);

      const bottomRow = document.createElement('div');
bottomRow.style.display = 'flex';
bottomRow.style.gap = '8px';
bottomRow.style.width = '100%';

const miss = document.createElement('button');
miss.className = 'btn danger letter-throw';
miss.textContent = 'Miss';
miss.style.flex = '1 1 0';
miss.style.minWidth = '0';
miss.onclick = () => recordThrow({ kind: 'Miss' });
bottomRow.appendChild(miss);

const undoBtn = document.createElement('button');
undoBtn.className = 'btn warn letter-throw';
undoBtn.textContent = 'Undo';
undoBtn.style.flex = '1 1 0';
undoBtn.style.minWidth = '0';
undoBtn.onclick = undo;
bottomRow.appendChild(undoBtn);

const missGoBtn = document.createElement('button');
missGoBtn.className = 'btn letter-throw';
missGoBtn.textContent = 'Skip Go';
missGoBtn.style.flex = '1 1 0';
missGoBtn.style.minWidth = '0';
missGoBtn.onclick = missGo;
bottomRow.appendChild(missGoBtn);

      pad.appendChild(bottomRow);
      return;
    }

    // ----- DOUBLES / TRIPLES ROUNDS -----
    if (r.type === 'doubles' || r.type === 'triples') {
      padHint.textContent =
        (r.type === 'doubles')
          ? "Doubles round – choose sector"
          : "Triples round – choose sector";

      const grid = document.createElement('div');
      grid.style.display = 'flex';
      grid.style.flexWrap = 'wrap';
      grid.style.gap = '6px';
      grid.style.justifyContent = 'center';

      for (let s = 1; s <= 20; s++) {
        const b = document.createElement('button');
        b.className = 'btn primary small';
        b.textContent = String(s);
        b.style.flex = '0 0 calc(20% - 6px)'; // ~5 columns
        b.onclick = () => recordThrow({ sector: s });
        grid.appendChild(b);
      }

      pad.appendChild(grid);

      const bottomRow = document.createElement('div');
bottomRow.style.display = 'flex';
bottomRow.style.gap = '8px';
bottomRow.style.marginTop = '6px';
bottomRow.style.width = '100%';

const miss = document.createElement('button');
miss.className = 'btn danger letter-throw';
miss.textContent = 'Miss';
miss.style.flex = '1 1 0';
miss.style.minWidth = '0';
miss.onclick = () => recordThrow({ kind: 'Miss' });
bottomRow.appendChild(miss);

const undoBtn = document.createElement('button');
undoBtn.className = 'btn warn letter-throw';
undoBtn.textContent = 'Undo';
undoBtn.style.flex = '1 1 0';
undoBtn.style.minWidth = '0';
undoBtn.onclick = undo;
bottomRow.appendChild(undoBtn);

const missGoBtn = document.createElement('button');
missGoBtn.className = 'btn letter-throw';
missGoBtn.textContent = 'Skip Go';
missGoBtn.style.flex = '1 1 0';
missGoBtn.style.minWidth = '0';
missGoBtn.onclick = missGo;
bottomRow.appendChild(missGoBtn);

      pad.appendChild(bottomRow);
      return;
    }

    // ----- BULL ROUND -----
    if (r.type === 'bull') {
      padHint.textContent = 'Bull round – Outer (25) or Inner (50).';

      const topRow = document.createElement('div');
      topRow.style.display = 'flex';
      topRow.style.gap = '8px';
      topRow.style.width = '100%';

      const outerBtn = document.createElement('button');
      outerBtn.className = 'btn primary';
      outerBtn.textContent = 'Outer Bull (25)';
      outerBtn.style.flex = '1 1 0';
      outerBtn.onclick = () => recordThrow({ bull: 'Outer' });
      topRow.appendChild(outerBtn);

      const innerBtn = document.createElement('button');
      innerBtn.className = 'btn primary';
      innerBtn.textContent = 'Inner Bull (50)';
      innerBtn.style.flex = '1 1 0';
      innerBtn.onclick = () => recordThrow({ bull: 'Inner' });
      topRow.appendChild(innerBtn);

      pad.appendChild(topRow);

      const bottomRow = document.createElement('div');
bottomRow.style.display = 'flex';
bottomRow.style.gap = '8px';
bottomRow.style.marginTop = '6px';
bottomRow.style.width = '100%';

const miss = document.createElement('button');
miss.className = 'btn danger letter-throw';
miss.textContent = 'Miss';
miss.style.flex = '1 1 0';
miss.style.minWidth = '0';
miss.onclick = () => recordThrow({ kind: 'Miss' });
bottomRow.appendChild(miss);

const undoBtn = document.createElement('button');
undoBtn.className = 'btn warn letter-throw';
undoBtn.textContent = 'Undo';
undoBtn.style.flex = '1 1 0';
undoBtn.style.minWidth = '0';
undoBtn.onclick = undo;
bottomRow.appendChild(undoBtn);

const missGoBtn = document.createElement('button');
missGoBtn.className = 'btn letter-throw';
missGoBtn.textContent = 'Skip Go';
missGoBtn.style.flex = '1 1 0';
missGoBtn.style.minWidth = '0';
missGoBtn.onclick = missGo;
bottomRow.appendChild(missGoBtn);

      pad.appendChild(bottomRow);
      return;
    }
  }

  // Finished game: show button to go to leaderboard
  const finishBtn = document.createElement('button');
  finishBtn.className = 'btn good';
  finishBtn.style.minWidth = '220px';
  finishBtn.textContent = 'Finish Game → Leaderboard';
  finishBtn.onclick = async () => {
    state.finished = false;
    await awardAndShowLeaderboard();
  };
  pad.appendChild(finishBtn);
}

/*****************
 * DIALOGS (Stats / Race / High Scores)
 *****************/
function openStatsHubDialog(){
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'In Game Stats';

  const body = document.createElement('div');
  body.className = 'modal-body';
  body.style.display = 'flex';
  body.style.flexDirection = 'column';
  body.style.alignItems = 'center';
  body.style.gap = '8px';

  // uniform width for all main buttons
  const W = 'min(420px, 92vw)';
  const mkBtn = (label, extraClass, onClick) => {
    const b = document.createElement('button');
    b.className = `btn big ${extraClass || ''}`.trim();
    b.textContent = label;
    b.style.width = W;
    b.onclick = () => { overlay.remove(); onClick(); };
    return b;
  };
  const sep = () => {
    const hr = document.createElement('hr');
    hr.style.width = W;
    hr.style.borderColor = '#23284a';
    hr.style.margin = '6px 0';
    return hr;
  };

  // 1) GAME RACE (gold)
  body.appendChild(mkBtn('GAME RACE', 'warn', openGameRaceDialog));
  body.appendChild(sep());

  // 2) GAME STATS / MATCH STATS
  body.appendChild(mkBtn('GAME STATS', '', openGameStatsDialog));
  body.appendChild(mkBtn('MATCH STATS', '', openMatchStatsDialog));
  body.appendChild(sep());

  // 3) High/Low (Official)
  body.appendChild(mkBtn('HIGH SCORES (Official)', '', openHighScoresDialog));
  body.appendChild(mkBtn('LOW SCORES (Official)', '', openLowScoresDialog));
  
  

  // Footer: Close (original size)
  const footer = document.createElement('div');
  footer.className = 'modal-footer';
  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();
  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}

function openGameStatsDialog(){
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Game Stats';

  const body = document.createElement('div');
  body.className = 'modal-body';

  const table = document.createElement('table');
  table.className = 'hs-table';

  const thead = document.createElement('thead');
  const trh   = document.createElement('tr');

  const metricTh = document.createElement('th');
  metricTh.textContent = 'Metric';
  trh.appendChild(metricTh);

  state.players.forEach(p => {
    const th = document.createElement('th');
    th.textContent = p.name;
    th.style.textAlign = 'center';
    trh.appendChild(th);
  });

  thead.appendChild(trh);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  const statsByPlayer = state.players.map((_, i) => computeStatsForPlayerGame(i));
  const winsArr = (state.match?.wins || []).slice();

  DISPLAY_METRICS.forEach(m => {
    if (m.sep) {
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 1 + state.players.length;
      td.textContent = '';
      tr.appendChild(td);
      tbody.appendChild(tr);
      return;
    }

    // Collect raw numeric values (for highlighting)
    const rowNumeric = state.players.map((_, idx) => {
      if (m.kind === 'wins') return winsArr[idx] || 0;
      const v = statsByPlayer[idx][m.key];
      return (typeof v === 'number') ? v : Number.isFinite(Number(v)) ? Number(v) : -Infinity;
    });
    const maxVal = Math.max(...rowNumeric);

    const tr = document.createElement('tr');
    const th = document.createElement('th');
    th.className = 'stats-th';
    th.textContent = m.label;
    tr.appendChild(th);

    state.players.forEach((_, idx) => {
      const td = document.createElement('td');
      td.className = 'center num';

      if (m.multi) {
        const list = statsByPlayer[idx][m.key] || [];
        td.innerHTML = `
          <div>1st ${list[0] || '—'}</div>
          <div>2nd ${list[1] || '—'}</div>
          <div>3rd ${list[2] || '—'}</div>
        `;
      } else {
        let val;
        if (m.kind === 'wins') {
          val = winsArr[idx] || 0;
        } else {
          const v = statsByPlayer[idx][m.key];
          val = m.fmt ? m.fmt(v) : String(v);
        }
        td.textContent = val;
      }

      // Highlight highest numeric value(s) in the row
      const raw = (m.kind === 'wins') ? (winsArr[idx] || 0) : rowNumeric[idx];
      if (!m.multi && raw === maxVal && maxVal !== -Infinity) {
        td.style.color = 'var(--accent-2)';
        td.style.fontWeight = '800';
      }

      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  });

  table.appendChild(tbody);
  body.appendChild(table);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = () => {
    overlay.remove();
    openStatsHubDialog();
  };

  footer.appendChild(backBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0; modal.focus();

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}

function openMatchStatsDialog(){
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Match Stats';

  const body = document.createElement('div');
  body.className = 'modal-body';

  const table = document.createElement('table');
  table.className = 'hs-table';

  const thead = document.createElement('thead');
  const trh   = document.createElement('tr');

  const metricTh = document.createElement('th');
  metricTh.textContent = 'Metric';
  trh.appendChild(metricTh);

  state.players.forEach(p => {
    const th = document.createElement('th');
    th.textContent = p.name;
    th.style.textAlign = 'center';
    trh.appendChild(th);
  });

  thead.appendChild(trh);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  const vByP  = state.players.map((_, i) => computeStatsForPlayerMatch(i));
  const winsArr = (state.match?.wins || []).slice();

  DISPLAY_METRICS.forEach(m => {
    if (m.sep) {
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 1 + state.players.length;
      td.textContent = '';
      tr.appendChild(td);
      tbody.appendChild(tr);
      return;
    }

    // Gather raw numeric values for leader highlight
    const rowNumeric = state.players.map((_, idx) => {
      if (m.kind === 'wins') return winsArr[idx] || 0;
      const v = vByP[idx][m.key];
      return (typeof v === 'number') ? v : Number.isFinite(Number(v)) ? Number(v) : -Infinity;
    });
    const maxVal = Math.max(...rowNumeric);

    const tr = document.createElement('tr');

    const th = document.createElement('th');
    th.textContent = m.label;
    th.className   = 'stats-th';
    tr.appendChild(th);

    state.players.forEach((_, idx) => {
      const td = document.createElement('td');
      td.className = 'center num';

      if (m.multi) {
        const list = vByP[idx][m.key] || [];
        td.innerHTML = `
          <div>1st ${list[0] || '—'}</div>
          <div>2nd ${list[1] || '—'}</div>
          <div>3rd ${list[2] || '—'}</div>
        `;
      } else {
        let val;
        if (m.kind === 'wins') {
          val = winsArr[idx] || 0;
        } else {
          const v = vByP[idx][m.key];
          val = m.fmt ? m.fmt(v) : String(v);
        }
        td.textContent = val;
      }

      // Leader highlight
      const raw = (m.kind === 'wins') ? (winsArr[idx] || 0) : rowNumeric[idx];
      if (!m.multi && raw === maxVal && maxVal !== -Infinity) {
        td.style.color = 'var(--accent-2)';
        td.style.fontWeight = '800';
      }

      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  });

  table.appendChild(tbody);
  body.appendChild(table);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = () => overlay.remove();
  footer.appendChild(backBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}
function openHighScoresMenuDialog() {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'High Scores';

  const body = document.createElement('div');
  body.className = 'modal-body';
  body.style.display = 'flex';
  body.style.flexDirection = 'column';
  body.style.alignItems = 'center';
  body.style.gap = '8px';

  const W = 'min(420px, 92vw)';
  const mkBtn = (label, extraClass, onClick) => {
    const b = document.createElement('button');
    b.className = `btn big ${extraClass || ''}`.trim();
    b.textContent = label;
    b.style.width = W;
    b.onclick = () => { overlay.remove(); onClick(); };
    return b;
  };

  body.appendChild(mkBtn('Official (League)', 'primary', openHighScoresDialog));
  body.appendChild(mkBtn('Practice (Single)', '',        openHighScoresDialogSP));
  body.appendChild(mkBtn('Lowest (League)',  'warn',     openLowScoresDialog));
  
  // Practice (Single) High Scores dialog
function openHighScoresDialogSP(){ 
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal';
  const title   = document.createElement('h3');  title.textContent = 'High Scores (Practice)';
  const body    = document.createElement('div'); body.className    = 'modal-body';

  let period = 'all';

  async function render(){
    body.innerHTML = '';
    try{
      const since = periodStartIso(period);
      const list  = await cloudListHighScores(true, 20, since);

      if (!list.length){
        const p = document.createElement('p');
        p.textContent = 'No high scores in this period.';
        body.appendChild(p);
        return;
      }

      const table = document.createElement('table'); table.className='hs-table';
      const thead = document.createElement('thead'); const trh=document.createElement('tr');
      ['#','Player','Score','Avg / Round','When'].forEach(h=>{
        const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);
      });
      thead.appendChild(trh); table.appendChild(thead);

      const tb = document.createElement('tbody');
      list.forEach((row, idx) => {
        const tr = document.createElement('tr');

        const td1 = document.createElement('td'); td1.textContent = String(idx + 1);
        const td2 = document.createElement('td'); td2.textContent = row.name;
        const td3 = document.createElement('td'); td3.textContent = String(row.score);

        const td4 = document.createElement('td');
        const avgRound = (typeof MAX_ROUNDS === 'number' && MAX_ROUNDS > 0)
          ? (Number(row.score || 0) / MAX_ROUNDS) : 0;
        td4.textContent = avgRound.toFixed(1);

        const td5 = document.createElement('td');
        const d = new Date(row.ts);
        td5.textContent = !Number.isNaN(d.getTime())
          ? d.toLocaleString(undefined, {
              year:'2-digit', month:'short', day:'2-digit',
              hour:'2-digit', minute:'2-digit'
            })
          : '';
        td5.style.fontSize = '0.8rem';

        tr.append(td1, td2, td3, td4, td5);

        // click → score sheet (PRACTICE)
        tr.style.cursor = 'pointer';
        tr.title = 'Open score sheet';
        tr.onclick = () => openScoreSheetFromHighScore(row, /* isPractice */ true);

        tb.appendChild(tr);
      });

      table.appendChild(tb);
      body.appendChild(table);
    }catch(err){
      console.error(err);
      const p=document.createElement('p');
      p.textContent='Failed to load high scores.';
      body.appendChild(p);
    }
  }

  const footer = document.createElement('div'); footer.className='modal-footer';
  const backBtn=document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  backBtn.onclick = () => overlay.remove();
  footer.appendChild(backBtn);

  const periods = [
    { key:'today', label:'Today' },
    { key:'week',  label:'1 Week' },
    { key:'month', label:'1 Month' },
    { key:'all',   label:'All Time' },
  ];

  const periodBtns = periods.map(p=>{
    const b = document.createElement('button');
    b.className='btn';
    b.textContent = p.label;
    b.dataset.period = p.key;
    b.onclick = async () => { period = p.key; setActive(); await render(); };
    footer.appendChild(b);
    return b;
  });

  function setActive(){
    periodBtns.forEach(b=>{
      if (b.dataset.period === period) b.classList.add('primary');
      else b.classList.remove('primary');
    });
  }

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0; modal.focus();
  overlay.addEventListener('click', e=>{ if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if (e.key === 'Escape') overlay.remove(); });

  setActive();
  render();
}

  const footer = document.createElement('div');
  footer.className = 'modal-footer';
  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();
  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0; modal.focus();
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}
// List all games for a specific player, filtered by optional period
async function cloudListPlayerGames(playerName, sinceIso = null, limit = 200) {
  let q = sb.from(TABLE_PLAYER_GAMES)
    .select('sheet_id, player, score, position, ts, is_practice, rounds')
    .eq('player', playerName)
    .order('ts', { ascending: false })
    .limit(limit);

  if (sinceIso) q = q.gte('ts', sinceIso);

  const { data, error } = await q;
  if (error) {
    markCloudError(error);
    throw error;
  }
  markCloudOk();
  return data || [];
}

// Single, top-level definition only
async function openPlayerGamesDialog(playerName) {
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal';
  const title   = document.createElement('h3');  title.textContent = `Games – ${playerName}`;
  const body    = document.createElement('div'); body.className    = 'modal-body';

  let period = 'all';

  async function render(){
    body.innerHTML = '';
    try {
      const since = periodStartIso(period);
      const rows  = await cloudListPlayerGames(playerName, since);

      if (!rows.length){
        const p = document.createElement('p');
        p.textContent = 'No games in this period.';
        body.appendChild(p);
        return;
      }

      const table = document.createElement('table'); table.className='hs-table';
      const thead = document.createElement('thead'); const trh = document.createElement('tr');
      ['#','Pos','Score','Avg / Round','Date'].forEach(h=>{
        const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);
      });
      thead.appendChild(trh); table.appendChild(thead);

      const tb = document.createElement('tbody');
      rows.forEach((row, idx) => {
        const tr = document.createElement('tr');
        if (row.is_practice) tr.classList.add('row-practice');

        const tdIdx   = document.createElement('td'); tdIdx.textContent   = String(idx + 1);
        const tdPos   = document.createElement('td'); tdPos.textContent   = row.position ?? '';
        const tdScore = document.createElement('td'); tdScore.textContent = String(row.score ?? '');

        const rounds = Number(row.rounds || MAX_ROUNDS || 0);
        const avg    = rounds ? (Number(row.score || 0) / rounds) : 0;
        const tdAvg  = document.createElement('td'); tdAvg.textContent = avg.toFixed(1);

        const d = new Date(row.ts);
        const tdWhen = document.createElement('td');
        tdWhen.textContent = Number.isNaN(d.getTime()) ? '' : fmtDdMmYyAtTime(d);
        tdWhen.style.fontSize = '0.8rem';

        tr.append(tdIdx, tdPos, tdScore, tdAvg, tdWhen);

        // Open the scorecard
        tr.style.cursor = 'pointer';
        tr.title = 'Open scorecard';
        tr.onclick = () => openScoreSheetFromHighScore({ sheet_id: row.sheet_id }, !!row.is_practice);

        tb.appendChild(tr);
      });

      table.appendChild(tb);
      body.appendChild(table);
    } catch (err){
      console.error(err);
      const p = document.createElement('p');
      p.textContent = 'Failed to load games.';
      body.appendChild(p);
    }
  }

  const footer = document.createElement('div'); footer.className = 'modal-footer';
  const backBtn = document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  backBtn.onclick = () => overlay.remove();
  footer.appendChild(backBtn);

  const periods = [
    { key:'today', label:'Today' },
    { key:'week',  label:'1 Week' },
    { key:'month', label:'1 Month' },
    { key:'all',   label:'All Time' },
  ];
  const periodBtns = periods.map(p => {
    const b = document.createElement('button');
    b.className = 'btn';
    b.textContent = p.label;
    b.dataset.period = p.key;
    b.onclick = async () => { period = p.key; setActive(); await render(); };
    footer.appendChild(b);
    return b;
  });
  function setActive(){
    periodBtns.forEach(b => {
      if (b.dataset.period === period) b.classList.add('primary');
      else b.classList.remove('primary');
    });
  }

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0; modal.focus();
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });

  setActive();
  await render();
}

async function openHighScoresDialog(){ 
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal';
  const title   = document.createElement('h3');  title.textContent = 'High Scores (Official)';
  const body    = document.createElement('div'); body.className    = 'modal-body';

  let period = 'all';

  async function render(){
    body.innerHTML = '';
    try {
      // Compute lower-bound timestamp for this period.
      // For "yesterday" we still query since the start of yesterday, but we then
      // filter rows client-side to keep only that calendar day.
      let since;
      if (period === 'yesterday') {
        const today  = new Date();
        const startY = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 1);
        since = startY.toISOString();
      } else {
        since = periodStartIso(period);
      }

      let list = await cloudListHighScores(false, 20, since);

      // If "Yesterday", filter to scores from that day only (local time)
      if (period === 'yesterday') {
        const today   = new Date();
        const startY  = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 1);
        const endY    = new Date(today.getFullYear(), today.getMonth(), today.getDate());
        list = (list || []).filter(row => {
          const d = new Date(row.ts);
          if (Number.isNaN(d.getTime())) return false;
          return d >= startY && d < endY;
        });
      }

      if (!list.length){
        const p = document.createElement('p');
        p.textContent = 'No high scores in this period.';
        body.appendChild(p);
        return;
      }

      const table = document.createElement('table'); table.className='hs-table';
      const thead = document.createElement('thead'); const trh = document.createElement('tr');
      ['#','Player','Score','Avg / Round','When'].forEach(h=>{
        const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);
      });
      thead.appendChild(trh); table.appendChild(thead);

      const tb = document.createElement('tbody');
      list.forEach((row, idx) => {
        const tr  = document.createElement('tr');

        const td1 = document.createElement('td'); td1.textContent = String(idx + 1);
        const td2 = document.createElement('td'); td2.textContent = row.name;
        const td3 = document.createElement('td'); td3.textContent = String(row.score);

        const td4 = document.createElement('td');
        const avgRound = (typeof MAX_ROUNDS === 'number' && MAX_ROUNDS > 0)
          ? (Number(row.score || 0) / MAX_ROUNDS) : 0;
        td4.textContent = avgRound.toFixed(1);

        const td5 = document.createElement('td');
        const d = new Date(row.ts);
        td5.textContent = !Number.isNaN(d.getTime())
          ? d.toLocaleString(undefined, { year:'2-digit', month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit' })
          : '';
        td5.style.fontSize = '0.8rem';

        tr.append(td1, td2, td3, td4, td5);

        // click → score sheet (OFFICIAL)
        tr.style.cursor = 'pointer';
        tr.title = 'Open score sheet';
        tr.onclick = () => openScoreSheetFromHighScore(row, /* isPractice */ false);

        tb.appendChild(tr);
      });

      table.appendChild(tb);
      body.appendChild(table);
    } catch (err) {
      console.error(err);
      const p = document.createElement('p');
      p.textContent = 'Failed to load high scores.';
      body.appendChild(p);
    }
  }

  const footer = document.createElement('div');
  footer.className = 'modal-footer';
  footer.style.display = 'flex';
  footer.style.alignItems = 'center';
  footer.style.justifyContent = 'space-between';

  // Three flex regions: left spacer, centred period buttons, right-aligned Back
  const leftRegion = document.createElement('div');
  leftRegion.style.flex = '1';

  const centerRegion = document.createElement('div');
  centerRegion.style.display = 'flex';
  centerRegion.style.gap = '8px';
  centerRegion.style.justifyContent = 'center';

  const rightRegion = document.createElement('div');
  rightRegion.style.flex = '1';
  rightRegion.style.display = 'flex';
  rightRegion.style.justifyContent = 'flex-end';

  footer.append(leftRegion, centerRegion, rightRegion);

  // Period buttons (including Yesterday)
  const periods = [
    { key:'today',     label:'Today' },
    { key:'yesterday', label:'Yesterday' },
    { key:'week',      label:'1 Week' },
    { key:'month',     label:'1 Month' },
    { key:'all',       label:'All Time' },
  ];

  const periodBtns = periods.map(p => {
    const b = document.createElement('button');
    b.className = 'btn';
    b.textContent = p.label;
    b.dataset.period = p.key;
    b.onclick = async () => { period = p.key; setActive(); await render(); };
    centerRegion.appendChild(b);
    return b;
  });

  function setActive(){
    periodBtns.forEach(b => {
      if (b.dataset.period === period) b.classList.add('primary');
      else b.classList.remove('primary');
    });
  }

  // Back button on the right-hand side
  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = () => overlay.remove();
  rightRegion.appendChild(backBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0; modal.focus();
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });

  setActive();
  await render();

}
async function openLowScoresDialog(){ 
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop'; 

  const modal = document.createElement('div');
  modal.className = 'modal'; 

  const title = document.createElement('h3');
  title.textContent = 'Low Scores (Official)'; 

  const body = document.createElement('div');
  body.className = 'modal-body'; 

  try {
    // League low scores = official high_scores table sorted ASCENDING
    const { data, error } = await sb
      .from(TABLE_HS_LEAGUE)
      .select('name, score, ts')
      .order('score', { ascending: true })   // lowest first
      .order('ts',    { ascending: true })   // oldest first for ties
      .limit(20);                            // bottom 20

    if (error) throw error;

    const list = data || [];

    if (!list.length) { 
      const p = document.createElement('p'); 
      p.textContent = 'No scores recorded yet.'; 
      body.appendChild(p); 
    } else {
      const table = document.createElement('table'); 
      table.className = 'hs-table';

      const thead = document.createElement('thead'); 
      const trh   = document.createElement('tr');

      ['#','Player','Score','Avg / Round','When'].forEach(h => {
        const th = document.createElement('th'); 
        th.textContent = h; 
        trh.appendChild(th);
      }); 

      thead.appendChild(trh); 
      table.appendChild(thead);

      const tb = document.createElement('tbody');

      list.forEach((row, idx) => { 
        const tr = document.createElement('tr'); 

        const td1 = document.createElement('td'); 
        td1.textContent = String(idx + 1);

        const td2 = document.createElement('td'); 
        td2.textContent = row.name;

        const td3 = document.createElement('td'); 
        td3.textContent = String(row.score);

        const td4 = document.createElement('td');
        const avgRound = MAX_ROUNDS
          ? (Number(row.score || 0) / MAX_ROUNDS)
          : 0;
        td4.textContent = avgRound.toFixed(1);

        const td5 = document.createElement('td'); 
        const d = new Date(row.ts);
        td5.textContent = !Number.isNaN(d.getTime())
          ? d.toLocaleString(undefined, {
              year: '2-digit',
              month: 'short',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit'
            })
          : '';
        td5.style.fontSize = '0.8rem';

        tr.append(td1, td2, td3, td4, td5); 
        tb.appendChild(tr);
      });

      table.appendChild(tb); 
      body.appendChild(table);
    }
  } catch (err) { 
    console.error(err); 
    const p = document.createElement('p'); 
    p.textContent = 'Failed to load low scores.'; 
    body.appendChild(p); 
  }

  const footer = document.createElement('div'); 
  footer.className = 'modal-footer'; 

  const closeBtn = document.createElement('button'); 
  closeBtn.className = 'btn'; 
  closeBtn.textContent = 'Close'; 
  closeBtn.onclick = () => overlay.remove(); 

  footer.appendChild(closeBtn); 

  modal.append(title, body, footer); 
  overlay.appendChild(modal); 
  document.body.appendChild(overlay); 

  modal.tabIndex = 0; 
  modal.focus(); 

  overlay.addEventListener('click', e => { 
    if (e.target === overlay) overlay.remove();
  }); 

  overlay.addEventListener('keydown', e => { 
    if (e.key === 'Escape') overlay.remove();
  });
}
function updateUI() {
  if (!tbody) return;

  // Clear previous highlights
  document.querySelectorAll('.current-cell, .current-col').forEach(el => {
    el.classList.remove('current-cell', 'current-col');
  });

  // --- Precompute per-round totals to find best round per row ---
  const roundTotals    = Array.from({ length: MAX_ROUNDS }, () => Array(state.players.length).fill(0));
  const roundHasScore  = Array.from({ length: MAX_ROUNDS }, () => Array(state.players.length).fill(false));

  for (let p = 0; p < state.players.length; p++) {
    for (let r = 0; r < MAX_ROUNDS; r++) {
      const entry   = state.score?.[p]?.[r];
      const hasDart = !!(entry && entry.darts && entry.darts.some(d => d));

      if (!entry || !hasDart) continue;

      const rt = entry.roundTotal || 0;
      roundTotals[r][p]   = rt;
      roundHasScore[r][p] = true;
    }
  }

  const maxRoundTotals = roundTotals.map(row =>
    row.length ? Math.max(...row) : 0
  );

  // --- Fill cells: rolling total + (round score) + best-round highlight ---
  for (let p = 0; p < state.players.length; p++) {
    let running = 0;

    for (let r = 0; r < MAX_ROUNDS; r++) {
      const td = byId(`cell-${p}-${r}`);
      if (!td) continue;

      const entry      = state.score?.[p]?.[r];
      const hasDart    = roundHasScore[r][p];
      const roundTotal = hasDart ? (entry?.roundTotal || 0) : 0;

      const mainEl = byId(`cell-main-${p}-${r}`);
      const subEl  = byId(`cell-sub-${p}-${r}`);

      if (hasDart) {
        running += roundTotal;
        if (mainEl) mainEl.textContent = String(running);
        if (subEl) {
          subEl.textContent = `(${roundTotal})`;
          subEl.classList.remove('sub-win');
          if (roundTotal > 0 && roundTotal === maxRoundTotals[r]) {
            // highest round score this row – green
            subEl.classList.add('sub-win');
          }
        }
      } else {
        if (mainEl) mainEl.textContent = '–';
        if (subEl) {
          subEl.textContent = '';
          subEl.classList.remove('sub-win');
        }
      }

      td.classList.remove('current-cell', 'current-col');
      if (p === state.currentPlayer) {
        td.classList.add('current-col');
      }
    }
  }

  // Highlight the current cell (round + player)
  const cp = state.currentPlayer;
  const cr = state.currentRound;
  const currentCell = byId(`cell-${cp}-${cr}`);
  if (currentCell) {
    currentCell.classList.add('current-cell');
    currentCell.classList.add('current-col');
  }
  
 // Current round label in floating header (single column)
const roundLabelEl = byId('froundlabel');
if (roundLabelEl) {
  const lbl = labelForRound(ROUNDS[state.currentRound]) || '';
  roundLabelEl.innerHTML = `
    <div class="round-now">
      <div class="rn-label">TARGET</div>
      <div class="rn-value">${lbl}</div>
    </div>
  `;
}

  // --- update floating header (wins, totals, diffs, turn arrow, throws remaining) ---
  const totals = state.players.map((_, i) => totalScoreForPlayer(i));
  const max    = totals.length ? Math.max(...totals) : 0;
  const targetWins = state.match.targetWins || 1;
  for (let i = 0; i < state.players.length; i++) {
    
    // Totals
    const totalEl = byId('ftotal-' + i);
    if (totalEl) {
      totalEl.textContent = String(totals[i] || 0);
      totalEl.classList.remove('leader-total');
      if (max > 0 && totals[i] === max) {
        // overall leader(s) – green total
        totalEl.classList.add('leader-total');
      }
    }
F
    // Diff
    const diffEl = byId('fdiff-' + i);
    if (diffEl) {
      const diff = totals[i] - max;
      diffEl.textContent = String(diff);
    }
 // Wins – trophies for wins, circles for remaining games
    const winsElMain = byId('beers-' + i);     // NEW location: thin row above 10s
    if (winsElMain) {
      const wins = state.match.wins?.[i] || 0;
      let bubbles = '';
      for (let k = 0; k < targetWins; k++) {
        bubbles += k < wins ? '🏆' : '○';
      }
      winsElMain.textContent = bubbles;
    }

    // Throws remaining (targets)
    const throwsEl = byId('fthrows-' + i);
    if (throwsEl) {
      throwsEl.textContent = '';
      if (!state.finished && i === state.currentPlayer) {
        const remaining = 3 - state.currentDart;   // 3, 2, or 1
        let icons = '';
        for (let k = 0; k < remaining; k++) icons += '🎯';
        throwsEl.textContent = icons;
      }
    }
  }

  // --- end-of-game banner ---
 const banner = byId('endBanner');
  if (banner) {
    banner.classList.add('hidden');
    banner.textContent = '';
  }

  // --- match stats table (hidden but kept in sync) ---
  try {
    updateMatchStats();
  } catch (e) {
    console.error(e);
  }

  // --- rebuild throw pad + layout + save ---
  buildPad();
  updatePadSpacer();
  save();
}


/* >>> INSERT THESE TWO NEW FUNCTIONS <<< */
function recordThrow(spec){
  // Ignore input if game is finished or in sudden death
  if (state.finished || state.suddenDeath.active) return;

  const rIndex    = state.currentRound;
  const pIndex    = state.currentPlayer;
  const dartIndex = state.currentDart;

  if (rIndex < 0 || rIndex >= MAX_ROUNDS) return;
  if (pIndex < 0 || pIndex >= state.players.length) return;
  if (dartIndex < 0 || dartIndex > 2) return;

  const wasFinished = state.finished;

  const board = state.score[pIndex];
  if (!board) return;
  const entry = board[rIndex];
  if (!entry) return;
  if (!entry.darts) entry.darts = [null, null, null];

  const roundDef = ROUNDS[rIndex];

  let points = 0;
  let hitKey = null;
  let dartObj;

  if (spec.kind === 'Miss') {
    dartObj = { kind: 'Miss', points: 0 };
  } else if (roundDef.type === 'number') {
    const base = roundDef.target;
    if (spec.kind === 'S')      points = base;
    else if (spec.kind === 'D') points = base * 2;
    else if (spec.kind === 'T') points = base * 3;

    dartObj = { kind: spec.kind, points };
    hitKey  = String(base);
  } else if (roundDef.type === 'doubles' || roundDef.type === 'triples') {
    const sector = spec.sector || 0;
    if (!sector) {
      dartObj = { kind: 'Miss', points: 0 };
    } else {
      const mult = roundDef.type === 'doubles' ? 2 : 3;
      points = sector * mult;
      dartObj = {
        kind: roundDef.type === 'doubles' ? 'Double' : 'Triple',
        sector,
        points
      };
      hitKey = String(sector);
    }
  } else if (roundDef.type === 'bull') {
    const bull = spec.bull || 'Outer';
    points = bull === 'Inner' ? 50 : 25;
    dartObj = { kind: 'Bull', bull, points };
    hitKey  = 'Bull';
  } else {
    dartObj = { kind: 'Miss', points: 0 };
  }

  // Write dart
  entry.darts[dartIndex] = dartObj;
  entry.roundTotal =
    (entry.darts[0]?.points || 0) +
    (entry.darts[1]?.points || 0) +
    (entry.darts[2]?.points || 0);

  // flag if we just completed the 3rd dart in this round (used for GIF triggers)
  const __completedRoundNow = (state.currentDart === 2);

  // History (for Undo)
  state.history.push({
    player:    pIndex,
    round:     rIndex,
    dartIndex: dartIndex,
    throw:     dartObj
  });

  // Match aggregates
  ensureMatchAgg();

  if (hitKey && points > 0) {
    const hitsMap =
      state.matchAgg.hits[pIndex] ||
      (state.matchAgg.hits[pIndex] = {});
    hitsMap[hitKey] = (hitsMap[hitKey] || 0) + 1;
  }

  // Recompute 60+/100+/140+ for this player
  recomputeMatchAggTotalsForPlayer(pIndex);

  // --- Round-completion visual effects (Tenor GIFs) ---
  if (__completedRoundNow) {
    // If all 3 darts in the round were trebles, show the 180-style GIF overlay once
    maybePlayThreeTreblesGif(pIndex, rIndex);
  }
  // Advance dart / player / round
  if (state.currentDart < 2) {
    state.currentDart++;
  } else {
    state.currentDart = 0;
    if (state.currentPlayer < state.players.length - 1) {
      state.currentPlayer++;
    } else {
      state.currentPlayer = 0;
      if (state.currentRound < MAX_ROUNDS - 1) {
        state.currentRound++;
      } else {
        // Game done – completion dialog will open
        state.finished = true;
      }
    }
  }

  updateUI();

  if (!wasFinished && state.finished) {
    openGameCompleteDialog();
  }
}
function recomputeMatchAggTotalsForPlayer(pIdx){
  ensureMatchAgg();

  let c60  = 0;
  let c100 = 0;
  let c140 = 0;

  for (let r = 0; r < MAX_ROUNDS; r++) {
    const rt =
      state.score?.[pIdx]?.[r]?.roundTotal ||
      0;

    if (rt >= 60)  c60++;
    if (rt >= 100) c100++;
    if (rt >= 140) c140++;
  }

  state.matchAgg.totals60[pIdx]  = c60;
  state.matchAgg.totals100[pIdx] = c100;
  state.matchAgg.totals140[pIdx] = c140;
}
function recomputeMatchAggHitsForPlayer(pIdx){
  ensureMatchAgg();

  const map = {};

  for (let r = 0; r < MAX_ROUNDS; r++) {
    const roundDef = ROUNDS[r];
    const entry = state.score?.[pIdx]?.[r];
    if (!entry) continue;

    const darts = entry.darts || [];
    darts.forEach(dart => {
      if (!dart || !(dart.points > 0)) return;

      let key = null;

      if (roundDef.type === 'number') {
        key = String(roundDef.target);
      } else if (roundDef.type === 'doubles' || roundDef.type === 'triples') {
        if (dart.sector) key = String(dart.sector);
      } else if (roundDef.type === 'bull') {
        key = 'Bull';
      }

      if (key) {
        map[key] = (map[key] || 0) + 1;
      }
    });
  }

  state.matchAgg.hits[pIdx] = map;
}

function undo(){
  if (!state.history.length) {
    toast('Nothing to undo');
    return;
  }

  const last = state.history.pop();
  const { player, round, dartIndex } = last;

  const entry = state.score?.[player]?.[round];
  if (!entry) {
    updateUI();
    return;
  }

  state.currentPlayer = player;
  state.currentRound  = round;
  state.currentDart   = dartIndex;
  state.finished      = false;

  entry.darts[dartIndex] = null;
  entry.roundTotal =
    (entry.darts[0]?.points || 0) +
    (entry.darts[1]?.points || 0) +
    (entry.darts[2]?.points || 0);

  recomputeMatchAggHitsForPlayer(player);
  recomputeMatchAggTotalsForPlayer(player);

  updateUI();
}

function missGo(){
  if (state.finished || state.suddenDeath.active) return;

  const startPlayer = state.currentPlayer;
  const startRound  = state.currentRound;

  while (
    !state.finished &&
    !state.suddenDeath.active &&
    state.currentPlayer === startPlayer &&
    state.currentRound === startRound &&
    state.currentDart < 3
  ) {
    recordThrow({ kind: 'Miss' });
  }
}
  /*****************
   * TENOR GIF OVERLAY (plays once, then cleans up)
   *****************/
  function ensureTenorOverlayStyles(){
    if (document.getElementById('tenorOverlayStyles')) return;
    const st = document.createElement('style');
    st.id = 'tenorOverlayStyles';
    st.textContent = `
      .gif-overlay{
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        z-index: 9999;
        background: transparent;
      }
      .gif-overlay .tenor-gif-embed{
        max-width: 80vw;
        width: 60vw;
        pointer-events: none;
      }
      @media (max-width: 600px){
        .gif-overlay .tenor-gif-embed{ width: 88vw; }
      }
    `;
    document.head.appendChild(st);
  }

  // Inject a Tenor embed DIV and (re)load Tenor's script so it renders even when added dynamically.
  function showTenorOnce(postId, durationMs = 2600){
    try{
      ensureTenorOverlayStyles();
      const overlay = document.createElement('div');
      overlay.className = 'gif-overlay';
      overlay.innerHTML = `
        &lt;div class="tenor-gif-embed"
             data-postid="${postId}"
             data-share-method="host"
             data-aspect-ratio="1.777"
             data-width="100%"&gt;&lt;/div&gt;`;
      document.body.appendChild(overlay);

      // Force Tenor to parse the newly injected embed by adding a fresh script tag.
      const s = document.createElement('script');
      s.src = 'https://tenor.com/embed.js';
      s.async = true;
      s.onload = () => {
        setTimeout(() => {
          try { overlay.remove(); } catch(_) {}
          try { s.remove(); } catch(_) {}
        }, durationMs);
      };
      document.body.appendChild(s);
    } catch (e){
      console.warn('showTenorOnce error', e);
    }
  }

  // Check if a just-completed round was "three trebles" and, if so, play the GIF.
  function maybePlayThreeTreblesGif(pIndex, rIndex){
    try{
      const entry = state.score?.[pIndex]?.[rIndex];
      if (!entry) return;
      const d = entry.darts || [];
      if (d.length < 3) return;
      const isTriple = (x) => !!x && (x.kind === 'T' || x.kind === 'Triple');
      if (isTriple(d[0]) && isTriple(d[1]) && isTriple(d[2])) {
        // Gerwyn Price 180 GIF
        showTenorOnce('25741026', 2600);
      }
    } catch(_) {}
  }

// --- GAME LOGGING TO SUPABASE (real) + HIGH SCORES ---
async function recordFullGameToSupabase(createdAtOverride) {
  try {
    const isOfficial = (state.players?.length || 0) >= 2;

    // Prefer caller-provided timestamp, then global backdate (if present), else now.
    const ts =
      (typeof createdAtOverride !== 'undefined' && createdAtOverride) ? createdAtOverride :
      (typeof _tsOverride       !== 'undefined' && _tsOverride)       ? _tsOverride       :
      new Date().toISOString();

    if (isOfficial) {
      try {
        await upsertMatchToSupabase(ts);
      } catch (e) {
        console.warn('match upsert failed', e);
      }
    }

    const totals     = state.players.map((_, i) => totalScoreForPlayer(i));
    const boardClone = JSON.parse(JSON.stringify(state.score || []));

    const payload = {
      match_id:   isOfficial ? (state.match?.id || null) : null, // null for practice
      game_number: state.match?.history?.length ? state.match.history.length : 1,
      created_at: ts, // finish time (or backdated override)
      state:      { players: state.players.map(p => ({ name: p.name })), board: boardClone },
      totals,
      finished:   true
    };

    const { error } = await sb.from(TABLE_GAMES).insert(payload);
    if (error) throw error;
  } catch (e) {
    console.error('recordFullGameToSupabase failed', e);
    throw e;
  }
}

// Multi-player -> League (TABLE_HS_LEAGUE), single-player -> Practice (TABLE_HS_PRACTICE).
async function recordGameToHighScores() {
  if (!state.players || !state.players.length) return;

  const totals   = state.players.map((_, i) => totalScoreForPlayer(i));
  const isSingle = state.players.length === 1;

  const tasks = [];

  for (let i = 0; i < state.players.length; i++) {
    const name  = state.players[i].name || `Player ${i + 1}`;
    const score = totals[i] || 0;

    // Don’t log ghost/zero scores
    if (!name || score <= 0) continue;

    tasks.push(
      cloudInsertHighScore(name, score, isSingle).catch(err => {
        console.error('High score insert failed', err);
      })
    );
  }

  await Promise.all(tasks);
}

async function awardAndShowLeaderboard(){
  // prevent double-award if called twice for same game
  if (state.gameAwarded) {
    showLeaderboard();
    return;
  }
  state.gameAwarded = true;

  const totals  = state.players.map((_,i)=> totalScoreForPlayer(i));
  const max     = Math.max(...totals);
  const winners = totals.map((t,i)=> t===max?i:null).filter(x=>x!==null);

// before recordFullGameToSupabase();
if ((state.players?.length || 0) >= 2) {
  try { await upsertMatchToSupabase(); } catch (e) { console.warn(e); }
}

  // Ensure wins array exists
  if (!state.match.wins || state.match.wins.length !== state.players.length) {
    state.match.wins = Array.from({length: state.players.length}, () => 0);
  }
  winners.forEach(i => state.match.wins[i]++);

  // Snapshot board for history/stats
  const boardClone = JSON.parse(JSON.stringify(state.score));
  state.match.history.push({ totals: totals.slice(), board: boardClone });

  // Long-term local logs
  logCompletedGame(totals, winners, boardClone);

  const targetWins = state.match.targetWins || 1;
  const maxWins    = state.match.wins.length ? Math.max(...state.match.wins) : 0;
  const matchDone  = maxWins >= targetWins;

  if (matchDone && !state.match.completedLogged) {
    logCompletedMatch();
    state.match.completedLogged = true;
  }

  // Cloud writes (best-effort)
  try { await recordFullGameToSupabase(); } catch (e) {
    console.error(e); toast('Game saved to local only (cloud failed)');
  }
  try { await recordGameToHighScores(); } catch (e) {
    console.error(e);
  }

  state.match.gameNumber = state.match.history.length + 1;

  save();
  showLeaderboard();
}
// next line should exist already in your file:
const lbTable = byId('lbTable');
const lbTHead = lbTable ? lbTable.querySelector('thead') : null;
const lbTBody = lbTable ? lbTable.querySelector('tbody') : null;
const lbMatchInfo = byId('lbMatchInfo');
const nextGameBtn=byId('nextGameBtn'); 
const gameScoresBtn=byId('gameScoresBtn'); 
const newMatchBtn=byId('newMatchBtn'); 
const gamesRemainTag=byId('gamesRemainTag');

const lbGameStatsBtn  = byId('lbGameStatsBtn');
const lbMatchStatsBtn = byId('lbMatchStatsBtn');
const lbGameRaceBtn   = byId('lbGameRaceBtn');

function updateLeaderboardTable(){
  if (!lbTable || !lbTHead || !lbTBody) return;
  lbTHead.innerHTML = '';
  lbTBody.innerHTML = '';

  const gamesPlayed = state.match.history.length;

  /* ---------- measure Player column to fit largest name ---------- */
  function measureNameColWidthPx(){
    const labels = ['Player', ...state.players.map(p => p.name || '')];
    const cs = getComputedStyle(lbTable);
    const font = `${cs.fontWeight} ${cs.fontSize} ${cs.fontFamily}`;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = font;

    let max = 0;
    for (const t of labels){
      const w = ctx.measureText(t).width;
      if (w > max) max = w;
    }
    const padding = 24;  // left+right cell padding
    const border  = 1;   // right border separator
    // clamp to something sensible
    const px = Math.ceil(max + padding + border);
    return Math.min(Math.max(px, 100), 320);
  }
  const nameColWidth = measureNameColWidthPx();

  /* ---------- define column grid ---------- */
  let colgroup = lbTable.querySelector('colgroup');
  if (!colgroup) {
    colgroup = document.createElement('colgroup');
    lbTable.insertBefore(colgroup, lbTable.firstChild);
  }
  colgroup.innerHTML = '';

  // Player (exact width to longest name)
  const cName = document.createElement('col');
  cName.style.width = nameColWidth + 'px';
  colgroup.appendChild(cName);

  // G1..Gn
  for (let g = 0; g < gamesPlayed; g++) {
    const c = document.createElement('col');
    c.style.width = 'var(--lb-num-w)';
    colgroup.appendChild(c);
  }

 // Distinct columns for Match %, Match Total, Win – same width
const rightW = 'var(--lb-right-w)';
const cPct   = document.createElement('col'); cPct.style.width   = rightW; colgroup.appendChild(cPct);
const cTotal = document.createElement('col'); cTotal.style.width = rightW; colgroup.appendChild(cTotal);
const cWin   = document.createElement('col'); cWin.style.width   = rightW; colgroup.appendChild(cWin);

  /* ---------- header ---------- */
  const trh = document.createElement('tr');

  const thName = document.createElement('th');
  thName.scope = 'col';
  thName.textContent = 'Player';
  trh.appendChild(thName);

  for (let g = 0; g < gamesPlayed; g++) {
    const th = document.createElement('th');
    th.scope = 'col';
    th.className = 'center gcol' + (g === gamesPlayed - 1 ? ' after-games-sep' : '');
    th.textContent = 'G' + (g + 1);
    th.style.cursor = 'pointer';
    th.title = 'Open Game ' + (g + 1) + ' score sheet';
    th.onclick = () => openScoreSheetFromHistory(g);
    trh.appendChild(th);
  }

  const thPct = document.createElement('th');
  thPct.scope = 'col';
  thPct.className = 'center';
  thPct.textContent = 'Match %';
  trh.appendChild(thPct);

  const thTotal = document.createElement('th');
  thTotal.scope = 'col';
  thTotal.className = 'center';
  thTotal.textContent = 'Match Total';
  trh.appendChild(thTotal);

  const thWin = document.createElement('th');
  thWin.scope = 'col';
  thWin.className = 'center';
  thWin.textContent = 'Win';
  trh.appendChild(thWin);

  lbTHead.appendChild(trh);

  /* ---------- gather data ---------- */
  let bestMatchTotal = -Infinity;
  const perPlayerTotals = state.players.map((_, idx) => {
    let mt = 0;
    const perGame = [];
    for (let g = 0; g < gamesPlayed; g++) {
      const t = (state.match.history[g]?.totals?.[idx]) || 0;
      perGame.push(t);
      mt += t;
    }
    bestMatchTotal = Math.max(bestMatchTotal, mt);
    return { perGame, matchTotal: mt };
  });

  function dartsThrownForMatch(pIdx){
    let n = 0;
    for (let g = 0; g < gamesPlayed; g++) {
      const board = state.match.history[g]?.board?.[pIdx];
      if (!board) continue;
      for (let r = 0; r < MAX_ROUNDS; r++) {
        const darts = board[r]?.darts || [];
        darts.forEach(d => { if (d !== null) n++; });
      }
    }
    return n;
  }

  /* ---------- rows ---------- */
  state.players.forEach((player, idx) => {
    const tr = document.createElement('tr');

    // Player
    const nameTd = document.createElement('td');
    nameTd.textContent = player.name;
    nameTd.style.color = player.color;
    tr.appendChild(nameTd);

    // G1..Gn
    perPlayerTotals[idx].perGame.forEach((val, g) => {
      const td = document.createElement('td');
      td.className = 'center num gcol' + (g === gamesPlayed - 1 ? ' after-games-sep' : '');
      td.textContent = String(val);
      tr.appendChild(td);
    });

    // Match % (three-dart average across the whole match)
    const thrown = dartsThrownForMatch(idx);
    const total  = perPlayerTotals[idx].matchTotal;
    const avg3   = thrown ? (total / thrown) * 3 : 0;

    const pctTd = document.createElement('td');
    pctTd.className = 'center num';
    pctTd.textContent = avg3.toFixed(1);
    tr.appendChild(pctTd);

    // Match Total (highlight leader)
    const totalTd = document.createElement('td');
    totalTd.className = 'center num';
    totalTd.textContent = String(total);
    if (total === bestMatchTotal && bestMatchTotal > 0) {
      totalTd.classList.add('leader-total');
    }
    tr.appendChild(totalTd);

    // Win
    const winsTd = document.createElement('td');
    winsTd.className = 'center num';
    winsTd.textContent = String(state.match.wins[idx] || 0);
    tr.appendChild(winsTd);

    lbTBody.appendChild(tr);
  });
}

function showLeaderboard() {
  // Build table
  updateLeaderboardTable();

  // Decide which CTA to show
  const targetWins = state.match?.targetWins || 1;
  const winsArr    = state.match?.wins || [];
  const maxWins    = winsArr.length ? Math.max(...winsArr) : 0;
  const matchDone  = maxWins >= targetWins;

  // NEXT GAME button
  if (nextGameBtn) {
    nextGameBtn.classList.toggle('hidden', matchDone);
    nextGameBtn.onclick = () => {
      state.finished = false;
      startNewGame();      // opens throw-order dialog, then goes to Game
    };
  }

  // END MATCH button
  if (newMatchBtn) {
    newMatchBtn.classList.toggle('hidden', !matchDone);
    newMatchBtn.onclick = () => {
      // reset to start a fresh match
      state = JSON.parse(JSON.stringify(baseState));
      save();
      show('players');     // or: show('details');
      drawPsRows();
    };
  }

  // Optional info line
  if (lbMatchInfo) {
    const gamesPlayed = state.match?.history?.length || 0;
    const toWin = Math.max(0, targetWins - maxWins);
    lbMatchInfo.textContent = matchDone
      ? `Match complete — first to ${targetWins}`
      : `Games: ${gamesPlayed} · First to ${targetWins} · ${toWin} to win`;
    lbMatchInfo.parentElement?.classList.remove('hidden');
  }

  // Show the screen
  show('leaderboard');
}

function openGameScoresDialog() {
  if (!state.match || !Array.isArray(state.match.history) || !state.match.history.length) {
    toast('No completed games yet.');
    return;
  }

  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Game Scores';

  const body = document.createElement('div');
  body.className = 'modal-body';

  state.match.history.forEach((game, idx) => {
    const heading = document.createElement('h4');
    heading.textContent = `Game ${idx + 1}`;
    heading.style.margin = '8px 0 4px';
    body.appendChild(heading);

    const wrap = document.createElement('div');
    wrap.className = 'table-wrap';
    wrap.style.marginBottom = '8px';

    const table = document.createElement('table');
    table.className = 'hs-table';

    // Header row: Round + each player
    const thead = document.createElement('thead');
    const trHead = document.createElement('tr');

    const thRound = document.createElement('th');
    thRound.textContent = 'Round';
    trHead.appendChild(thRound);

    state.players.forEach(p => {
      const th = document.createElement('th');
      th.textContent = p.name;
      th.style.textAlign = 'center';
      trHead.appendChild(th);
    });

    thead.appendChild(trHead);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    const board = game.board || [];
    const runningTotals = state.players.map(() => 0);

    for (let r = 0; r < MAX_ROUNDS; r++) {
      const tr = document.createElement('tr');

      const roundDef = ROUNDS[r];
      const roundTh = document.createElement('th');
      roundTh.textContent =
        roundDef.type === 'number'
          ? (roundDef.target + 's')
          : (roundDef.type === 'doubles'
              ? "D's"
              : (roundDef.type === 'triples' ? "T's" : 'Bull'));
      tr.appendChild(roundTh);

      for (let p = 0; p < state.players.length; p++) {
        const td = document.createElement('td');
        td.className = 'center num';

        const entry = board[p]?.[r];
        const hasDarts = entry && entry.darts && entry.darts.some(d => d);
        const rt = entry?.roundTotal || 0;

        if (hasDarts) {
          runningTotals[p] += rt;

          const main = document.createElement('div');
          main.className = 'cell-main';
          main.textContent = String(runningTotals[p]);

          const sub = document.createElement('div');
          sub.className = 'cell-sub';
          sub.textContent = rt ? `(${rt})` : '';

          td.appendChild(main);
          td.appendChild(sub);
        } else {
          td.textContent = '–';
        }

        tr.appendChild(td);
      }

      tbody.appendChild(tr);
    }

    table.appendChild(tbody);
    wrap.appendChild(table);
    body.appendChild(wrap);
  });

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();

  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });
}

if (gameScoresBtn) gameScoresBtn.addEventListener('click', openGameScoresDialog);

/*****************
 * SCROLL SYNC (keeps columns aligned)
 *****************/
let _scrollSyncSet=false; 
function setupScrollSync(){ 
  if(_scrollSyncSet) return; 
  const sw=byId('scoreWrap'), st=byId('statsWrap'), fh=byId('floatWrap'), ms=byId('mstatsWrap'); 
  if(!sw||!st||!fh||!ms) return; 
  let syncing=false; 
  function mirror(from){ 
    if(syncing) return; syncing=true; 
    const x=from.scrollLeft; [sw,st,fh,ms].forEach(el=>{ if(el!==from) el.scrollLeft=x; }); syncing=false; 
  } 
  [sw,st,fh,ms].forEach(el=> el.addEventListener('scroll',()=>mirror(el),{passive:true})); 
  _scrollSyncSet=true; 
  requestAnimationFrame(()=>{ 
    // Safely resolve header elements even if global refs (thead, statsThead, floatThead) are undefined
    const thead      = document.querySelector('#scoreWrap thead')  || document.querySelector('#scoreTable thead') || window.thead      || null;
    const statsThead = document.querySelector('#statsWrap thead')  || window.statsThead  || null;
    const floatThead = document.querySelector('#floatWrap thead')  || window.floatThead  || null;
    const sRow=thead?.querySelector('tr'), tRow=statsThead?.querySelector('tr'), fRow=floatThead?.querySelector('tr'); 
    if(!sRow||!tRow||!fRow) return; 
    const sCells=sRow.children, tCells=tRow.children, fCells=fRow.children; 
    const leftW=sCells[0].getBoundingClientRect().width; 
    document.documentElement.style.setProperty('--left-col-w', leftW+'px'); 
    const n=Math.min(sCells.length,tCells.length,fCells.length); 
    for(let i=1;i<n;i++){ 
      const w=sCells[i].getBoundingClientRect().width; 
      [tCells[i], fCells[i]].forEach(cell=>{ if(cell){ cell.style.width=w+'px'; cell.style.minWidth=w+'px'; cell.style.maxWidth=w+'px'; } }); 
    } 
  }); 
}

/*****************
 * START/RESET + ORDER DIALOG
 *****************/
function buildEverything(){ 
  buildScoreHeader(); 
  buildScoreBody(); 
  buildFloatingHeader(); 
  buildStatsHeader(); 
  buildStatsBody(); 
  buildMatchStatsHeader(); 
  buildMatchStatsBody(); 
  setupScrollSync(); 
}

// GLOBAL — record pace (#1 league high score) from Supabase only
async function buildRecordPaceSeries(roundsCount) {
  try {
    // 1) Get #1 league high score from Supabase
    const list = await cloudListHighScores(false, 1);
    if (!list || !list.length) return null;

    const top = list[0];
    const target = Number(top.score) || 0;

    // 2) Try to find the exact game for that row using our cloud-first resolver
    let found = null;
    try {
      if (typeof findGameForHighScoreCloudFirst === 'function') {
        found = await findGameForHighScoreCloudFirst(
          { name: top.name, score: target, ts: top.ts },
          /* isPractice */ false
        );
      }
    } catch (e) {
      console.error('findGameForHighScoreCloudFirst failed', e);
    }

    // 3) If not found, fall back to scanning cloud games we have locally
    if (!found) {
      let games = [];
      try {
        games = await cloudFetchAllGamesAsLocal();
      } catch (_) {
        console.error('cloudFetchAllGamesAsLocal failed in buildRecordPaceSeries');
        games = [];
      }

      if (games && games.length) {
        const candidates = games
          .filter(isOfficialGame)
          .map(g => {
            const pIdx = (g.players || []).findIndex(p => p && eqName(p.name, top.name));
            if (pIdx === -1) return null;
            if ((g.totals?.[pIdx] || 0) !== target) return null;

            const delta =
              (top.ts && g.ts)
                ? Math.abs(new Date(g.ts) - new Date(top.ts))
                : Number.MAX_SAFE_INTEGER;

            return { game: g, playerIndex: pIdx, delta };
          })
          .filter(Boolean)
          .sort((a, b) => a.delta - b.delta)[0];

        if (candidates && candidates.game) {
          found = candidates;
        }
      }
    }

    // 4) If still not found or missing board, bail
    if (!found || !found.game || !Array.isArray(found.game.board?.[found.playerIndex])) {
      console.warn('No board data for top record game; skipping record pace line');
      return null;
    }

    // 5) Build true round-by-round cumulative totals for that player
    const data = [];
    let running = 0;
    const board = found.game.board[found.playerIndex];

    for (let r = 0; r < roundsCount; r++) {
      const rt = board?.[r]?.roundTotal || 0;
      running += rt;
      data.push(running);
    }

    return {
      name: `Record: ${top.name} (${target})`,
      color: '#ffffff',
      data,
      dotted: true
    };
  } catch (e) {
    console.error('buildRecordPaceSeries failed', e);
    return null;
  }
}
async function openGameRaceDialog() {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  title.textContent = 'Game Race';

  const body = document.createElement('div');
  body.className = 'modal-body';

  const info = document.createElement('p');
  info.textContent = 'Round-by-round cumulative scores. Dotted line shows the #1 high score pace.';
  info.style.fontSize = '0.82rem';
  info.style.color = '#a8acc3';
  info.style.marginBottom = '6px';
  body.appendChild(info);

  const canvas = document.createElement('canvas');
  canvas.width  = 640;
  canvas.height = 320;
  canvas.style.width  = '100%';
  canvas.style.height = 'auto';
  body.appendChild(canvas);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';
  backBtn.onclick = () => {
    overlay.remove();
    openStatsHubDialog();
  };

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();

  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();

  overlay.addEventListener('click', e => {
    if (e.target === overlay) overlay.remove();
  });
  overlay.addEventListener('keydown', e => {
    if (e.key === 'Escape') overlay.remove();
  });

  // --- Build series for current game ---
  const roundsCount = MAX_ROUNDS;
  const series = [];

  for (let p = 0; p < state.players.length; p++) {
    const player = state.players[p];
    const data = [];
    let running = 0;

    for (let r = 0; r < roundsCount; r++) {
      const entry = state.score?.[p]?.[r];
      const rt = entry ? (entry.roundTotal || 0) : 0;
      running += rt;
      data.push(running);
    }

    series.push({
      name: player.name,
      color: player.color || '#7bdcff',
      data,
      dotted: false
    });
  }
// --- Add dotted #1 high score line using the actual round-by-round board ---
const recordSeries = await buildRecordPaceSeries(roundsCount);
if (recordSeries) {
  series.push(recordSeries);
} else {
  info.textContent = 'Round-by-round cumulative scores.'; // no fake line
}

  // If no data at all, just bail
  const anyPoints = series.some(s => s.data.some(v => v > 0));
  if (!anyPoints) {
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#a8acc3';
    ctx.font = '12px system-ui';
    ctx.fillText('No scoring data yet for this game.', 20, 40);
    return;
  }

  // --- Draw chart ---
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  const marginLeft = 40;
  const marginRight = 10;
  const marginTop = 20;
  const marginBottom = 30;

  ctx.clearRect(0, 0, w, h);

  const maxY = Math.max(
    ...series.flatMap(s => s.data),
    10
  );

  const plotW = w - marginLeft - marginRight;
  const plotH = h - marginTop - marginBottom;

  function xForRound(r) {
    if (roundsCount <= 1) return marginLeft;
    const t = r / (roundsCount - 1);
    return marginLeft + t * plotW;
  }

  function yForScore(v) {
    const t = v / maxY;
    return marginTop + (1 - t) * plotH;
  }

  // Grid + axes
  ctx.strokeStyle = '#2b3050';
  ctx.lineWidth = 1;
  ctx.setLineDash([]);

  // Y-axis
  ctx.beginPath();
  ctx.moveTo(marginLeft, marginTop);
  ctx.lineTo(marginLeft, marginTop + plotH);
  ctx.stroke();

  // X-axis
  ctx.beginPath();
  ctx.moveTo(marginLeft, marginTop + plotH);
  ctx.lineTo(marginLeft + plotW, marginTop + plotH);
  ctx.stroke();

  ctx.fillStyle = '#a8acc3';
  ctx.font = '10px system-ui';

  // Y labels (4 ticks)
  for (let i = 0; i <= 4; i++) {
    const v = (maxY / 4) * i;
    const y = yForScore(v);
    ctx.fillText(String(Math.round(v)), 4, y + 3);

    ctx.strokeStyle = 'rgba(43,48,80,0.4)';
    ctx.beginPath();
    ctx.moveTo(marginLeft, y);
    ctx.lineTo(marginLeft + plotW, y);
    ctx.stroke();
  }

  // X labels (rounds)
  ctx.textAlign = 'center';
  for (let r = 0; r < roundsCount; r++) {
    const x = xForRound(r);
    const label = ROUNDS[r].type === 'number'
      ? String(ROUNDS[r].target)
      : (ROUNDS[r].type === 'doubles'
          ? 'D'
          : (ROUNDS[r].type === 'triples' ? 'T' : 'Bull'));
    ctx.fillText(label, x, marginTop + plotH + 12);
  }
  ctx.textAlign = 'left';

  // Lines
  series.forEach(s => {
    if (!s.data || !s.data.length) return;

    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.setLineDash(s.dotted ? [5, 4] : []);

    // pick line colour
    ctx.strokeStyle = s.color || '#7bdcff';

    s.data.forEach((v, idx) => {
      const x = xForRound(idx);
      const y = yForScore(v);
      if (idx === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });

    ctx.stroke();
  });

  // Legend
  let legendX = marginLeft;
  let legendY = marginTop - 6;

  series.forEach(s => {
    ctx.setLineDash(s.dotted ? [5, 4] : []);
    ctx.strokeStyle = s.color || '#7bdcff';
    ctx.lineWidth = 2;

    const lineW = 24;
    ctx.beginPath();
    ctx.moveTo(legendX, legendY);
    ctx.lineTo(legendX + lineW, legendY);
    ctx.stroke();

    ctx.setLineDash([]);
    ctx.fillStyle = '#e7e9f5';
    ctx.font = '10px system-ui';
    ctx.fillText(' ' + s.name, legendX + lineW + 4, legendY + 3);

    legendY += 14;
  });
}

// Throw order selection
function showPlayerOrderDialog() {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';
  const modal = document.createElement('div');
  modal.className = 'modal';
  const title = document.createElement('h3'); title.textContent = 'Select Throwing Order';
  const body = document.createElement('div'); body.className = 'modal-body';
  const instructions = document.createElement('p'); instructions.textContent = 'Use up/down buttons to set the throwing order:'; instructions.style.marginBottom='15px'; body.appendChild(instructions);
  const playerList = document.createElement('div'); playerList.id='playerOrderList'; playerList.style.display='flex'; playerList.style.flexDirection='column'; playerList.style.gap='8px'; body.appendChild(playerList);

  function renderList(){
    playerList.innerHTML='';
    state.players.forEach((player, index) => {
      const item = document.createElement('div');
      item.className = 'player-order-item';
      item.dataset.index = index;
      item.innerHTML = `
        <span style="background:${player.color}; color:white; padding:4px 8px; border-radius:4px; margin-right:8px;">${player.name.charAt(0)}</span>
        ${player.name}
        <div style="margin-left: auto; display:flex; gap:4px;">
          <button class="btn small" data-action="up" data-index="${index}">↑</button>
          <button class="btn small" data-action="down" data-index="${index}">↓</button>
        </div>
      `;
      playerList.appendChild(item);
    });
    playerList.querySelectorAll('button[data-action]').forEach(b=>{
      b.onclick = (e) => {
        const idx = parseInt(e.currentTarget.dataset.index, 10);
        const act = e.currentTarget.dataset.action;

        if (act === 'up' && idx > 0) {
          swapPlayers(idx, idx - 1);
          renderList();
        }

        if (act === 'down' && idx < state.players.length - 1) {
          swapPlayers(idx, idx + 1);
          renderList();
        }
      };
    });
  }
  renderList();

  const footer = document.createElement('div'); footer.className='modal-footer';
  const cancelBtn = document.createElement('button'); cancelBtn.className='btn'; cancelBtn.textContent = 'Cancel'; cancelBtn.onclick = () => overlay.remove();
  const confirmBtn = document.createElement('button'); confirmBtn.className='btn primary'; confirmBtn.textContent = 'Confirm Order';
  confirmBtn.onclick = () => { overlay.remove(); startNewGame(true); };
  footer.append(cancelBtn,confirmBtn);

  modal.append(title, body, footer); overlay.appendChild(modal); document.body.appendChild(overlay);
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
  modal.tabIndex = 0; modal.focus();
}

function startNewGame(setOrder=false){
  if(!setOrder){ showPlayerOrderDialog(); return; }
  state.score = Array.from({length:state.players.length},
    ()=>Array.from({length:MAX_ROUNDS},()=>({darts:[null,null,null],roundTotal:0})));
  state.currentRound = 0;
  state.currentPlayer = 0;
  state.currentDart = 0;
  state.history = [];
  state.finished = false;
  state.suddenDeath = {active:false,participants:[],turnIndex:0,throws:[],round:1};
  state.gameAwarded = false;
  ensureMatchAgg();
  show('game'); buildEverything(); updateUI(); save();
}

function restartGame() {
  if (!confirm('Are you sure you want to restart this game? All progress will be lost.')) return;
  state.finished = false;
  state.suddenDeath = {active:false, participants:[], turnIndex:0, throws:[], round:1};
  startNewGame();
  show('game'); updateUI();
}

function swapPlayers(i, j) {
  // Swap players themselves
  [state.players[i], state.players[j]] = [state.players[j], state.players[i]];

  // Swap match wins
  if (state.match && Array.isArray(state.match.wins)) {
    [state.match.wins[i], state.match.wins[j]] =
      [state.match.wins[j], state.match.wins[i]];
  }

  // Swap per-game totals already stored
  if (state.match && Array.isArray(state.match.history)) {
    state.match.history.forEach(g => {
      if (g && Array.isArray(g.totals)) {
        [g.totals[i], g.totals[j]] = [g.totals[j], g.totals[i]];
      }
    });
  }

  // Swap matchAgg stats so favourites / 60+ / 100+ / 140+ stay with the player
  if (state.matchAgg) {
    if (Array.isArray(state.matchAgg.hits)) {
      [state.matchAgg.hits[i], state.matchAgg.hits[j]] =
        [state.matchAgg.hits[j], state.matchAgg.hits[i]];
    }
    ['totals60', 'totals100', 'totals140'].forEach(key => {
      if (Array.isArray(state.matchAgg[key])) {
        [state.matchAgg[key][i], state.matchAgg[key][j]] =
          [state.matchAgg[key][j], state.matchAgg[key][i]];
      }
    });
  }
}
/*****************
 * ADMIN HUB + ADMIN PANELS
 *****************/
 function findGameForHighScore(row) {
  const games = getGameLog();
  if (!games || !games.length) return null;

  const targetName  = row.name;
  const targetScore = Number(row.score) || 0;
  const targetTs    = row.ts ? new Date(row.ts).getTime() : null;
  const windowMs    = 5 * 60 * 1000; // 5 minutes either side

  for (const g of games) {
    if (!g || !Array.isArray(g.players) || !Array.isArray(g.totals)) continue;

    const pIdx = g.players.findIndex(p => p && p.name === targetName);
    if (pIdx === -1) continue;

    const scoreHere = Number(g.totals[pIdx] || 0);
    if (scoreHere !== targetScore) continue;

    if (targetTs && g.ts) {
      const gt = new Date(g.ts).getTime();
      if (Math.abs(gt - targetTs) > windowMs) continue;
    }

    // Found a matching game + player index
    return { game: g, playerIndex: pIdx };
  }

  return null;
}
 
 function deleteLocalStatsForHighScore(row) {
  const games = getGameLog();
  if (!games || !games.length) return;

  const targetName  = row.name;
  const targetScore = Number(row.score) || 0;
  const targetTs    = row.ts ? new Date(row.ts).getTime() : null;
  const windowMs    = 5 * 60 * 1000; // 5 minutes either side

  const filtered = [];

  for (const g of games) {
    let matches = false;

    if (g && Array.isArray(g.players) && Array.isArray(g.totals)) {
      g.players.forEach((p, idx) => {
        if (!p) return;
        if (p.name !== targetName) return;

        const scoreHere = Number(g.totals[idx] || 0);
        if (scoreHere !== targetScore) return;

        if (targetTs && g.ts) {
          const gt = new Date(g.ts).getTime();
          if (Math.abs(gt - targetTs) <= windowMs) {
            matches = true;
          }
        } else {
          matches = true;
        }
      });
    }

    if (!matches) filtered.push(g);
  }

  if (filtered.length !== games.length) {
    setGameLog(filtered);
  }
}
// ------- High Score → Score Sheet (cloud-first) -------

// Try to find the exact game in Supabase by timestamp ±10min + name + score.
// Falls back to local getGameLog() via findGameForHighScore().
async function findGameForHighScoreCloudFirst(row, isPractice = false){
  const ts = row?.ts ? new Date(row.ts) : null;

  // 1) Cloud window query
  if (ts && window.sb) {
    const pad = 10 * 60 * 1000; // ±10 min
    const fromIso = new Date(ts.getTime() - pad).toISOString();
    const toIso   = new Date(ts.getTime() + pad).toISOString();

    try {
      const { data, error } = await sb
        .from(TABLE_GAMES)
        .select('created_at, state, totals, match_id')
        .gte('created_at', fromIso)
        .lte('created_at', toIso)
        .order('created_at', { ascending: true })
        .limit(100);

      if (error) throw error;

      const candidates = (data || []);
      for (const g of candidates) {
        const players = (g?.state?.players || []).map(p => (typeof p === 'string' ? { name:p } : p));
        const totals  = Array.isArray(g?.totals) ? g.totals : [];

        // Practice vs Official sanity check (optional but helps)
        const isSingle = players.length === 1 || !g.match_id;
        if (isPractice && !isSingle) continue;
        if (!isPractice && isSingle) continue;

        const pIdx = players.findIndex(p => p && eqName(p.name, row.name));
        if (pIdx === -1) continue;
        if (Number(totals[pIdx] || 0) !== Number(row.score || 0)) continue;

        // Convert to local shape the rest of the code expects
        const local = {
          ts: g.created_at || null,
          players,
          totals: totals.slice(),
          winners: [], // not needed for the sheet
          board: g?.state?.board || null
        };
        return { game: local, playerIndex: pIdx };
      }
    } catch (e) {
      console.error('cloud lookup for high-score row failed', e);
    }
  }

  // 2) Local fallback
  const local = findGameForHighScore(row);
  if (local) return { game: local.game, playerIndex: local.playerIndex };

  return null;
}

// Render a single game's score sheet (round-by-round) in a modal.
// Optionally highlight one player's column (e.g. the high-score row owner).
function openSingleGameScoreSheet(game, highlightIdx = -1){
  if (!game || !Array.isArray(game.players) || !game.board) {
    toast('Score sheet not available for this row yet.');
    return;
  }

  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal';

  const title = document.createElement('h3');
  const when  = game.ts ? new Date(game.ts).toLocaleString() : '';
  title.textContent = `Score Sheet${when ? ' — ' + when : ''}`;

  const body = document.createElement('div');
  body.className = 'modal-body';

  const wrap = document.createElement('div');
  wrap.className = 'table-wrap';

  const table = document.createElement('table');
  table.className = 'hs-table';

  // Header
  const thead = document.createElement('thead');
  const trh = document.createElement('tr');
  const thRound = document.createElement('th');
  thRound.textContent = 'Round';
  trh.appendChild(thRound);

  game.players.forEach((p, idx) => {
    const th = document.createElement('th');
    th.textContent = p.name;
    th.style.textAlign = 'center';
    if (idx === highlightIdx) {
      th.style.color = 'var(--accent-2)';
      th.style.fontWeight = '900';
    }
    trh.appendChild(th);
  });
  thead.appendChild(trh);
  table.appendChild(thead);

  // Body
  const tbody = document.createElement('tbody');
  const runningTotals = game.players.map(() => 0);

  for (let r = 0; r < MAX_ROUNDS; r++) {
    const tr = document.createElement('tr');

    const roundDef = ROUNDS[r];
    const roundTh = document.createElement('th');
    roundTh.textContent =
      roundDef.type === 'number'
        ? (roundDef.target + 's')
        : (roundDef.type === 'doubles' ? "D's" : (roundDef.type === 'triples' ? "T's" : 'Bull'));
    tr.appendChild(roundTh);

    for (let p = 0; p < game.players.length; p++) {
      const td = document.createElement('td');
      td.className = 'center num';

      const entry = game.board?.[p]?.[r];
      const hasDarts = entry && entry.darts && entry.darts.some(d => d);
      const rt = entry?.roundTotal || 0;

      if (hasDarts) {
        runningTotals[p] += rt;
        const main = document.createElement('div');
        main.className = 'cell-main';
        main.textContent = String(runningTotals[p]);

        const sub = document.createElement('div');
        sub.className = 'cell-sub';
        sub.textContent = rt ? `(${rt})` : '';

        td.appendChild(main);
        td.appendChild(sub);
      } else {
        td.textContent = '–';
      }

      tr.appendChild(td);
    }

    tbody.appendChild(tr);
  }

  table.appendChild(tbody);
  wrap.appendChild(table);
  body.appendChild(wrap);

  const footer = document.createElement('div');
  footer.className = 'modal-footer';
  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();
  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  modal.tabIndex = 0;
  modal.focus();
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
}


function openAdminHub(){
  const hub = byId('adminHubModal');
  hub.classList.remove('hidden');

  // Open sub-panels
  byId('openHsLeagueAdmin').onclick   = ()=>{ hub.classList.add('hidden'); openHighScoresAdminDialog(false); };
  byId('openHsPracticeAdmin').onclick = ()=>{ hub.classList.add('hidden'); openHighScoresAdminDialog(true); };
  byId('openSavedPlayersAdminBtn').onclick = ()=>{ hub.classList.add('hidden'); openSavedPlayersAdminDialog(); };

  // Remove deprecated backdate controls (if still present)
  ['backfillAllBtn','backdateNextSaveBtn','clearBackdateBtn'].forEach(id => { const el = byId(id); if (el) el.remove(); });

  // Ensure "All Games" button exists and opens the new dialog
  (function ensureAllGamesBtn(){
    const container = document.querySelector('#adminHubModal .modal-body') || hub;
    let btn = byId('openAllGamesBtn');
    if (!btn && container) {
      btn = document.createElement('button');
      btn.id = 'openAllGamesBtn';
      btn.className = 'btn';
      btn.textContent = 'All Games';
      container.appendChild(btn);
    }
    if (btn) btn.onclick = ()=>{ hub.classList.add('hidden'); openAllGamesDialog(); };
  })();

  // Return to previous screen (just closes the modal)
  byId('closeAdminHubBtn').onclick = ()=> hub.classList.add('hidden');
}

// ===== Public High Scores (League / Practice) =====
if (typeof window.openScoreSheetFromHighScore !== 'function') {
  window.openScoreSheetFromHighScore = async function(row, isPractice){
    try{
      const match = await findGameForHighScoreCloudFirst(row, isPractice);
      if (match && match.game) {
        openSingleGameScoreSheet(match.game, match.playerIndex);
      } else {
        toast('Score sheet not available for this row yet.');
      }
    }catch(e){
      console.error('openScoreSheetFromHighScore failed', e);
      toast('Could not open score sheet.');
    }
  };
}

async function openHighScoresMenuDialog(){
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className='modal';
  const title   = document.createElement('h3');  title.textContent='High Scores';
  const body    = document.createElement('div'); body.className='modal-body';
  const footer  = document.createElement('div'); footer.className='modal-footer';

  // Tabs
  const tabs = document.createElement('div');
  tabs.style.display = 'flex';
  tabs.style.gap = '8px';
  tabs.style.marginBottom = '10px';

  const leagueBtn   = document.createElement('button'); leagueBtn.className='btn primary'; leagueBtn.textContent='League';
  const practiceBtn = document.createElement('button'); practiceBtn.className='btn';           practiceBtn.textContent='Practice';
  tabs.append(leagueBtn, practiceBtn);

  const status = document.createElement('div');
  status.className = 'muted';
  status.style.fontSize = '0.85rem';
  status.style.margin = '6px 0 8px 0';

  body.append(tabs, status);

  const tableHost = document.createElement('div'); tableHost.className='table-wrap';
  body.appendChild(tableHost);

  async function render(isPractice){
    tableHost.innerHTML = '';
    status.textContent = '';

    // visual tabs
    leagueBtn.className   = isPractice ? 'btn' : 'btn primary';
    practiceBtn.className = isPractice ? 'btn primary' : 'btn';

    try{
      if (!ensureCloudInit()){
        status.textContent = 'Cloud not initialised — check keys or network.';
        return;
      }
    }catch(_){}

    let list = [];
    try{
      list = await cloudListHighScores(!!isPractice, 50);
    }catch(e){
      console.error('cloudListHighScores failed', e);
      status.textContent = (e && e.message) ? `Failed to load: ${e.message}` : 'Failed to load high scores.';
      return;
    }

    if (!list || !list.length){
      const p=document.createElement('p');
      p.textContent='No high scores yet.';
      tableHost.appendChild(p);
      return;
    }

    const table=document.createElement('table'); table.className='hs-table';
    const thead=document.createElement('thead'); const trh=document.createElement('tr');
    ['#','Player','Score','Avg / Round','When'].forEach(h=>{
      const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);
    });
    thead.appendChild(trh); table.appendChild(thead);

    const tb=document.createElement('tbody');
    list.forEach((row, idx) => {
      const tr=document.createElement('tr');

      const td1=document.createElement('td'); td1.textContent=String(idx+1);
      const td2=document.createElement('td'); td2.textContent=String(row.name || '');
      const td3=document.createElement('td'); td3.textContent=String(row.score || 0);
      const td4=document.createElement('td');
      const avgRound = MAX_ROUNDS ? (Number(row.score||0)/MAX_ROUNDS) : 0;
      td4.textContent = avgRound.toFixed(1);

      const td5=document.createElement('td');
      const d=new Date(row.ts);
      td5.textContent = !Number.isNaN(d.getTime())
        ? d.toLocaleString(undefined,{year:'2-digit',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit'})
        : '';

      tr.append(td1,td2,td3,td4,td5);

      tr.style.cursor='pointer';
      tr.title='Open score sheet';
      tr.onclick = ()=> window.openScoreSheetFromHighScore(row, !!isPractice);

      tb.appendChild(tr);
    });

    table.appendChild(tb);
    tableHost.appendChild(table);
  }

  // footer
  const backBtn=document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  backBtn.onclick=()=> overlay.remove();
  const closeBtn=document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Close';
  closeBtn.onclick=()=> overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); });
  modal.tabIndex=0; modal.focus();

  // wire tabs
  leagueBtn.onclick   = ()=> render(false);
  practiceBtn.onclick = ()=> render(true);

  // initial
  await render(false);
}

async function openHighScoresAdminDialog(single=false){ 
  const overlay = document.createElement('div'); overlay.className='modal-backdrop'; 
  const modal   = document.createElement('div'); modal.className='modal'; 
  const title   = document.createElement('h3'); title.textContent=`High Scores — Admin (${single?'Practice':'League'})`; 
  const body    = document.createElement('div'); body.className='modal-body'; 
  const footer  = document.createElement('div'); footer.className='modal-footer';

  async function render(){
    body.innerHTML = '';
    try{
      const list = await cloudListHighScores(single, 50);
      if(!list.length){
        const p=document.createElement('p'); p.textContent='No high scores.'; body.appendChild(p); return;
      }

      const table=document.createElement('table'); table.className='hs-table compact';
      const thead=document.createElement('thead'); const trh=document.createElement('tr');
      ['#','Player','Score','Avg / Round','When','Actions'].forEach(h=>{
        const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);
      });
      thead.appendChild(trh); table.appendChild(thead);

      const tb=document.createElement('tbody');
      list.forEach((row, idx) => {
        const tr=document.createElement('tr');

        const td1=document.createElement('td'); td1.textContent=String(idx+1);
        const td2=document.createElement('td'); td2.textContent=row.name;
        const td3=document.createElement('td'); td3.textContent=String(row.score);

        const td4=document.createElement('td');
        const avgRound = MAX_ROUNDS ? (Number(row.score||0)/MAX_ROUNDS) : 0;
        td4.textContent = avgRound.toFixed(1);

        const td5=document.createElement('td');
        const d=new Date(row.ts);
        td5.textContent = !Number.isNaN(d.getTime())
          ? d.toLocaleString(undefined,{year:'2-digit',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit'})
          : '';
        td5.style.fontSize='0.8rem';

        const td6=document.createElement('td'); td6.className='center';
        const del=document.createElement('button'); del.className='btn small danger'; del.textContent='Delete';
        del.onclick = async () => {
          if (!confirm('Delete this high score?')) return;
          try { await cloudDeleteHighScore(row, single); await render(); }
          catch(e){ console.error(e); toast('Delete failed'); }
        };
        td6.appendChild(del);

        tr.append(td1,td2,td3,td4,td5,td6);

        // click → score sheet
        tr.style.cursor='pointer';
        tr.title='Open score sheet';
        tr.onclick = (e)=> {
          if (e.target === del) return;           // don’t open when pressing Delete
          openScoreSheetFromHighScore(row, single);
        };

        tb.appendChild(tr);
      });

      table.appendChild(tb); 
      body.appendChild(table);
    } catch(err){
      console.error(err);
      const p=document.createElement('p'); p.textContent='Failed to load.'; body.appendChild(p);
    }
  }

  await render();

  const backBtn=document.createElement('button');
  backBtn.className='btn';
  backBtn.textContent='Back';
  backBtn.onclick=()=>{ overlay.remove(); openAdminHub(); };
  const closeBtn=document.createElement('button'); 
  closeBtn.className='btn'; 
  closeBtn.textContent='Exit'; 
  closeBtn.onclick=()=>overlay.remove(); 
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer); 
  overlay.appendChild(modal); 
  document.body.appendChild(overlay); 

  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); }); 
  modal.tabIndex=0; modal.focus(); 
}
// League Low Scores — Admin dialog
async function openLeagueLowsAdminDialog(){
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className='modal';
  const title   = document.createElement('h3');  title.textContent='League Low Scores — Admin';
  const body    = document.createElement('div'); body.className='modal-body';
  const footer  = document.createElement('div'); footer.className='modal-footer';

  async function render(){
    body.innerHTML = '';

    try{
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()){
        const p = document.createElement('p');
        p.textContent = 'Cloud not initialised.';
        body.appendChild(p);
        return;
      }
    }catch(_){}

    let rows = [];
    try{
      const tableName = (typeof TABLE_LEAGUE_LOW_SCORES !== 'undefined' && TABLE_LEAGUE_LOW_SCORES)
        ? TABLE_LEAGUE_LOW_SCORES
        : 'league_low_scores';

      const { data, error } = await sb
        .from(tableName)
        .select('name, score, ts')
        .order('score', { ascending: true })
        .order('ts',    { ascending: true })
        .limit(1000);
      if (error) throw error;
      rows = data || [];
    }catch(e){
      console.error('League low scores fetch failed', e);
      const p = document.createElement('p');
      p.textContent = 'Failed to load league low scores.';
      body.appendChild(p);
      return;
    }

    if (!rows.length){
      const p = document.createElement('p');
      p.textContent = 'No league low scores found.';
      body.appendChild(p);
      return;
    }

    const table = document.createElement('table'); table.className='hs-table compact';
    const thead = document.createElement('thead'); const trh=document.createElement('tr');
    ['#','Player','Score','When','Actions'].forEach(h=>{
      const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);
    });
    thead.appendChild(trh); table.appendChild(thead);

    const tb = document.createElement('tbody');

    rows.forEach((row, idx) => {
      const tr = document.createElement('tr');

      const td1 = document.createElement('td'); td1.textContent = String(idx+1);
      const td2 = document.createElement('td'); td2.textContent = row.name || '';
      const td3 = document.createElement('td'); td3.textContent = String(row.score ?? '');

      const td4 = document.createElement('td');
      const d   = new Date(row.ts);
      td4.textContent = !Number.isNaN(d.getTime())
        ? d.toLocaleString(undefined,{year:'2-digit',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit'})
        : '';
      td4.style.fontSize = '0.8rem';

      const td5 = document.createElement('td'); td5.className='center';
      const del = document.createElement('button'); del.className='btn small danger'; del.textContent='Delete';
      del.onclick = async (e) => {
        e.stopPropagation();
        if (!confirm(`Delete ${row.name}'s low score of ${row.score}?`)) return;
        try{
          const tableName = (typeof TABLE_LEAGUE_LOW_SCORES !== 'undefined' && TABLE_LEAGUE_LOW_SCORES)
            ? TABLE_LEAGUE_LOW_SCORES
            : 'league_low_scores';

          let q = sb.from(tableName)
            .delete()
            .eq('name', String(row.name || ''))
            .eq('score', Number(row.score || 0));
          if (row.ts) q = q.eq('ts', row.ts);
          const { error } = await q;
          if (error) throw error;

          if (typeof toast === 'function') toast('Deleted');
          await render();
        }catch(err){
          console.error('Delete league low score failed', err);
          if (typeof toast === 'function') toast('Delete failed');
        }
      };
      td5.appendChild(del);

      tr.append(td1, td2, td3, td4, td5);
      tb.appendChild(tr);
    });

    table.appendChild(tb);
    body.appendChild(table);
  }

  await render();

  const backBtn  = document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  backBtn.onclick = ()=>{ overlay.remove(); if (typeof openAdminHub === 'function') openAdminHub(); };
  const closeBtn = document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Exit';
  closeBtn.onclick = ()=> overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); });
  modal.tabIndex=0; modal.focus();
}

// All Games dialog (cloud-only, with Delete and re-render)
async function openAllGamesDialog(){
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className='modal';
  const title   = document.createElement('h3');  title.textContent='All Games';
  const body    = document.createElement('div'); body.className='modal-body';
  const footer  = document.createElement('div'); footer.className='modal-footer';

  // Header with filter controls (top-right)
  const header = document.createElement('div');
  header.style.cssText = 'display:flex; align-items:center; justify-content:space-between; gap:8px;';
  const controls = document.createElement('div');
  controls.style.cssText = 'display:flex; gap:6px;';
  const officialBtn = document.createElement('button'); officialBtn.className='btn primary'; officialBtn.textContent='Official';
  const practiceBtn = document.createElement('button'); practiceBtn.className='btn';          practiceBtn.textContent='Practice';
  controls.append(officialBtn, practiceBtn);
  header.append(title, controls);

  // Filter state + saved players cache
  let filterMode = 'official';
  let savedSet = null;
  async function getSavedSet(){
    try{
      if (savedSet) return savedSet;
      const players = await (typeof cloudListPlayers === 'function' ? cloudListPlayers() : []);
      savedSet = new Set((players||[]).map(p => String(p?.name || '').trim().toLowerCase()).filter(Boolean));
      return savedSet;
    }catch(_){
      savedSet = new Set();
      return savedSet;
    }
  }

  // Wire filter buttons
  officialBtn.onclick = async ()=>{
    filterMode = 'official';
    officialBtn.className = 'btn primary';
    practiceBtn.className = 'btn';
    await render();
  };
  practiceBtn.onclick = async ()=>{
    filterMode = 'practice';
    practiceBtn.className = 'btn primary';
    officialBtn.className = 'btn';
    await render();
  };

  async function render(){
    body.innerHTML = '';

    // Merge cloud + synthetic (extend beyond any cloud page limits)
    let cloudGames = [];
    try { cloudGames = await cloudFetchAllGamesAsLocal(); } catch(e){ console.error(e); }

    let synthGames = [];
    try {
      if (typeof cloudSynthAllGamesFromHighScores === 'function') {
        synthGames = await cloudSynthAllGamesFromHighScores(2000);
      }
    } catch(e){ console.warn('synth backfill failed', e); }

    const toTS = (g)=> {
      const t = g?.ts || g?.created_at || g?.inserted_at || (g?.meta && (g.meta.ts || g.meta.date)) || null;
      const n = t ? Date.parse(t) : NaN;
      return Number.isFinite(n) ? n : 0;
    };

    const stableKey = (g) => {
      const names = (g?.players || [])
        .map(p => (typeof p === 'string' ? p : (p && p.name) || ''))
        .map(s => String(s || '').trim().toLowerCase())
        .filter(Boolean);
      return [String(toTS(g)), names.join(','), (g?.totals || []).join(',')].join('|');
    };

    // Cloud wins over synth; both over any local (reads are cloud-only anyway)
    const map = new Map();
    (cloudGames || []).forEach(g => { if (!g) return; map.set(stableKey(g), g); });
    (synthGames || []).forEach(g => { if (!g) return; const k = stableKey(g); if (!map.has(k)) map.set(k, g); });

    let games = Array.from(map.values());

    // Build saved players set for robust Official/Practice classification
    const sset = await getSavedSet();
    const savedAvailable = !!(sset && sset.size);

    games = (games || [])
      .filter(Boolean)
      .sort((a,b)=> toTS(b) - toTS(a))
      .filter(g => {
        const names = (g.players || [])
          .map(p => (typeof p === 'string' ? p : (p && p.name) || ''))
          .map(s => String(s || '').trim())
          .filter(Boolean);
        if (!savedAvailable) {
          // Fallback: if we can't tell saved vs guest, treat 2+ players as Official
          const officialSimple = names.length >= 2;
          return (filterMode === 'official') ? officialSimple : !officialSimple;
        }
        const savedCount = names.reduce((acc,n)=> acc + (sset.has(n.toLowerCase()) ? 1 : 0), 0);
        const isOfficial = (names.length >= 2 && savedCount >= 2);
        const isPractice = (names.length === 1) || (savedCount < 2);
        return (filterMode === 'official') ? isOfficial : isPractice;
      });

    if (!games.length){
      const p=document.createElement('p'); p.textContent='No games found.'; body.appendChild(p); return;
    }

    const table=document.createElement('table'); table.className='hs-table';

    // Column layout: # | When | Players | Totals | Actions
    const colgroup = document.createElement('colgroup');
    const cIdx = document.createElement('col'); cIdx.style.width = '3ch'; colgroup.appendChild(cIdx); // #
    colgroup.appendChild(document.createElement('col')); // When
    colgroup.appendChild(document.createElement('col')); // Players
    colgroup.appendChild(document.createElement('col')); // Totals
    const cAct = document.createElement('col'); cAct.style.width = '88px'; colgroup.appendChild(cAct); // Actions
    table.appendChild(colgroup);

    const thead=document.createElement('thead'); const trh=document.createElement('tr');
    ['#','When','Players','Totals',''].forEach((h,i)=>{
      const th=document.createElement('th'); th.textContent=h;
      if(i===0) th.style.width='3ch';   // # column
      if(i===4) th.style.width='88px';  // actions column
      trh.appendChild(th);
    });
    thead.appendChild(trh); table.appendChild(thead);

    const tb=document.createElement('tbody');
    games.forEach((g, idx)=>{
      const tr=document.createElement('tr');

      const td1=document.createElement('td'); td1.textContent=String(idx+1); td1.style.width='3ch';
      const td2 = document.createElement('td');
      const tsVal = g.ts || g.created_at || g.inserted_at || (g.meta && (g.meta.ts || g.meta.date)) || null;
      td2.textContent = (window.fmtWhen && tsVal) ? window.fmtWhen(tsVal) : '';
      const td3=document.createElement('td'); td3.textContent=(g.players||[]).map(p=>p?.name||'').join(', ');
      const td4=document.createElement('td'); td4.textContent=(g.totals||[]).join(' · ');

      // Delete button as last column
      const tdDel=document.createElement('td'); tdDel.className='center';
      const delBtn=document.createElement('button'); delBtn.className='btn small danger'; delBtn.textContent='Delete';
      delBtn.title='Delete this game';
      delBtn.onclick = async (e) => {
        e.stopPropagation();
        if (!confirm('Delete this game from cloud (and related high-score rows)?')) return;
        try { await cloudDeleteGameCascade(g); toast('Game deleted'); await render(); }
        catch(err){ console.error(err); toast('Delete failed'); }
      };
      tdDel.appendChild(delBtn);

      tr.style.cursor='pointer';
      tr.title='Open score sheet';
      tr.onclick=()=>{ if (typeof openSingleGameScoreSheet === 'function') openSingleGameScoreSheet(g); };

      tr.append(td1, td2, td3, td4, tdDel); tb.appendChild(tr);
    });

    table.appendChild(tb); body.appendChild(table);
  }

  // Footer
  const backBtn=document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  backBtn.onclick=()=>{ overlay.remove(); if (typeof openAdminHub==='function') openAdminHub(); };
  const closeBtn=document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Close';
  closeBtn.onclick=()=> overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(header, body, footer); overlay.appendChild(modal); document.body.appendChild(overlay);
  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); });
  modal.tabIndex=0; modal.focus();

  await render();
}

async function openRoundHighScoresDialog(){
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className='modal';
  const title   = document.createElement('h3');  title.textContent='Round High Scores';
  const body    = document.createElement('div'); body.className='modal-body';
  const footer  = document.createElement('div'); footer.className='modal-footer';

  async function render(){
    body.innerHTML = '';
    try{
      const snap = await (typeof getPBGRSnapshot === 'function' ? getPBGRSnapshot() : Promise.resolve({ byTargetMeta: {} }));
      const order = [...Array.from({length:11},(_,i)=>10+i), 'D','T','B'];

      const table = document.createElement('table'); table.className='hs-table';
      const thead = document.createElement('thead'); const trh=document.createElement('tr');
      ['Round','WR','Darts','Holder'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
      thead.appendChild(trh); table.appendChild(thead);

      const tbody = document.createElement('tbody'); table.appendChild(tbody);
      const pending = [];

      order.forEach(key=>{
        const meta = (snap.byTargetMeta && snap.byTargetMeta[key]) ? snap.byTargetMeta[key] : { val:0, player:'', game_id:null, ridx:null };
        const tr   = document.createElement('tr');

        const tdR  = document.createElement('td'); tdR.textContent = String(key);
        const tdV  = document.createElement('td'); tdV.textContent = String(meta.val || 0);
        const tdD  = document.createElement('td'); tdD.textContent = '—'; // filled async
        const tdN  = document.createElement('td'); tdN.textContent = meta.player ? meta.player : '—';

        tr.append(tdR, tdV, tdD, tdN);
        tbody.appendChild(tr);

        if (meta && meta.game_id != null && meta.player && (meta.ridx || meta.ridx === 0)){
          pending.push(
            fetchRoundPattern(meta.game_id, meta.player, meta.ridx).then(pat=>{
              tdD.textContent = pat || '—';
            }).catch(()=>{ tdD.textContent = '—'; })
          );
        }
      });

      if (pending.length){ try{ await Promise.allSettled(pending); }catch(_){ /* ignore */ } }
      body.appendChild(table);
    }catch(e){
      console.error('Round High Scores render failed', e);
      const p=document.createElement('p'); p.textContent='Unable to load right now.'; body.appendChild(p);
    }
  }

  const backBtn=document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  backBtn.onclick=()=> overlay.remove();
  const closeBtn=document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Close';
  closeBtn.onclick=()=> overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); });
  modal.tabIndex=0; modal.focus();

  await render();
}

// Delete a game (by timestamp) and its related high-score rows from Supabase
async function cloudDeleteGameCascade(g){
  if (!ensureCloudInit()) throw new Error('Cloud not initialised');
  const ts = g?.ts;
  if (!ts) throw new Error('Missing timestamp for delete');

  // 1) Delete the game row by exact timestamp
  try {
    const { error } = await sb.from(TABLE_GAMES).delete().eq('created_at', ts);
    if (error) throw error;
  } catch (e) {
    // Try a fallback range delete ±2min if exact equality fails
    try {
      const pad = 2 * 60 * 1000;
      const fromIso = new Date(new Date(ts).getTime() - pad).toISOString();
      const toIso   = new Date(new Date(ts).getTime() + pad).toISOString();
      const { error } = await sb.from(TABLE_GAMES).delete().gte('created_at', fromIso).lte('created_at', toIso);
      if (error) throw error;
    } catch (ee) {
      console.error('Delete games failed', ee); throw ee;
    }
  }

  // 2) Delete related high-score rows (practice/league)
  const isSingle = (g?.players || []).length === 1;
  const players = g?.players || [];
  const totals  = g?.totals  || [];
  const tasks = players.map((p,i)=>{
    const row = { name: p?.name || '', score: Number(totals[i]||0), ts };
    return cloudDeleteHighScore(row, isSingle).catch(()=>{});
  });
  await Promise.all(tasks);
}

  /*****************
   * CLOUD INIT HELPER
   *****************/
  function ensureCloudInit(){
    try {
      // Library present?
      if (typeof window.supabase !== 'object' || !window.supabase.createClient) {
        try { setCloudStatus && setCloudStatus('error', 'Cloud not initialised'); } catch(_) {}
        return false;
      }
      // Keys present?
      if (typeof SUPABASE_URL === 'undefined' || typeof SUPABASE_ANON === 'undefined' || !SUPABASE_URL || !SUPABASE_ANON) {
        try { setCloudStatus && setCloudStatus('error', 'Cloud keys missing'); } catch(_) {}
        return false;
      }
      // Make client if missing
      if (!window.sb) {
        try { window.sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON); }
        catch (e) {
          console.error('supabase createClient failed', e);
          try { setCloudStatus && setCloudStatus('error', 'Cloud not initialised'); } catch(_) {}
          return false;
        }
      }
      return true;
    } catch (e) {
      console.error('ensureCloudInit failed', e);
      try { setCloudStatus && setCloudStatus('error', 'Cloud not initialised'); } catch(_) {}
      return false;
    }
  }

/*** CLOUD HIGH SCORES API — safe fallback implementations ***/
(function(){
  // Insert (or keep existing) → create only if missing to avoid duplicates
  if (typeof window.cloudInsertHighScore !== 'function') {
    window.cloudInsertHighScore = async function(name, score, isPractice){
      if (!ensureCloudInit()) throw new Error('Cloud not initialised');
      const table = isPractice
        ? (typeof TABLE_HS_PRACTICE !== 'undefined' ? TABLE_HS_PRACTICE : 'high_scores_practice')
        : (typeof TABLE_HS_LEAGUE   !== 'undefined' ? TABLE_HS_LEAGUE   : 'high_scores');

      const row = {
        name: String(name || '').trim(),
        score: Number(score || 0),
        // Prefer server default if your table has one; otherwise send a timestamp
        ts: new Date().toISOString()
      };

      // basic guards; don't write empty rows
      if (!row.name || row.score <= 0) return false;

      const { error } = await sb.from(table).insert(row);
      if (error) throw error;
      return true;
    };
  }
if (typeof window.cloudInsertHighScoreIfMissing !== 'function') {
  window.cloudInsertHighScoreIfMissing = async function(table, name, score, ts){
    if (!ensureCloudInit()) throw new Error('Cloud not initialised');
    const n = String(name || '').trim();
    const s = Number(score || 0);
    if (!n || s <= 0) return false;

    // Does a matching row already exist? (exact name/score; if ts is given, use ±2 min window)
    async function existsQuery() {
      try {
        if (ts) {
          const pad = 2 * 60 * 1000;
          const fromIso = new Date(new Date(ts).getTime() - pad).toISOString();
          const toIso   = new Date(new Date(ts).getTime() + pad).toISOString();
          const { count, error } = await sb
            .from(table)
            .select('name,score,ts', { count: 'exact', head: true })
            .gte('ts', fromIso).lte('ts', toIso)
            .eq('name', n).eq('score', s)
            .limit(1);
          if (error) throw error;
          return !!(count && count > 0);
        } else {
          const { count, error } = await sb
            .from(table)
            .select('name,score,ts', { count: 'exact', head: true })
            .eq('name', n).eq('score', s)
            .limit(1);
          if (error) throw error;
          return !!(count && count > 0);
        }
      } catch {
        // Fallback: non-head select
        try {
          if (ts) {
            const pad = 2 * 60 * 1000;
            const fromIso = new Date(new Date(ts).getTime() - pad).toISOString();
            const toIso   = new Date(new Date(ts).getTime() + pad).toISOString();
            const { data } = await sb
              .from(table).select('name,score,ts')
              .gte('ts', fromIso).lte('ts', toIso)
              .eq('name', n).eq('score', s).limit(1);
            return Array.isArray(data) && data.length > 0;
          } else {
            const { data } = await sb
              .from(table).select('name,score,ts')
              .eq('name', n).eq('score', s).limit(1);
            return Array.isArray(data) && data.length > 0;
          }
        } catch {
          return false;
        }
      }
    }

    if (await existsQuery()) return false;

    const row = { name: n, score: s, ts: ts || new Date().toISOString() };
    const { error } = await sb.from(table).insert(row);
    if (error) throw error;
    return true;
  };
}

  if (typeof window.cloudListHighScores !== 'function') {
    window.cloudListHighScores = async function(isPractice, limit = 50){
      if (!ensureCloudInit()) throw new Error('Cloud not initialised');
      const table = isPractice
        ? (typeof TABLE_HS_PRACTICE !== 'undefined' ? TABLE_HS_PRACTICE : 'high_scores_practice')
        : (typeof TABLE_HS_LEAGUE   !== 'undefined' ? TABLE_HS_LEAGUE   : 'high_scores');

      const { data, error } = await sb
        .from(table)
        .select('name, score, ts')
        .order('score', { ascending: false })
        .order('ts',    { ascending: true })
        .limit(limit);

      if (error) throw error;
      return data || [];
    };
  }

  if (typeof window.cloudDeleteHighScore !== 'function') {
    window.cloudDeleteHighScore = async function(row, isPractice){
      if (!ensureCloudInit()) throw new Error('Cloud not initialised');
      const table = isPractice
        ? (typeof TABLE_HS_PRACTICE !== 'undefined' ? TABLE_HS_PRACTICE : 'high_scores_practice')
        : (typeof TABLE_HS_LEAGUE   !== 'undefined' ? TABLE_HS_LEAGUE   : 'high_scores');

      // Try exact match (including ts if provided)
      try {
        let q = sb.from(table).delete()
          .eq('name', String(row?.name || ''))
          .eq('score', Number(row?.score || 0));
        if (row?.ts) q = q.eq('ts', row.ts);
        const { error } = await q;
        if (error) throw error;
        return;
      } catch (e) {
        // Fallback: delete on small time window if exact ts equality fails
        if (!row?.ts) throw e;
        const pad = 2 * 60 * 1000;
        const fromIso = new Date(new Date(row.ts).getTime() - pad).toISOString();
        const toIso   = new Date(new Date(row.ts).getTime() + pad).toISOString();
        const { error } = await sb.from(table).delete()
          .gte('ts', fromIso).lte('ts', toIso)
          .eq('name', String(row.name || ''))
          .eq('score', Number(row.score || 0));
        if (error) throw error;
      }
    };
  }
})();
// Toggle for writing per-player game rows to a table.
// Your project uses a view (`player_games_union`), so writes should be disabled.
const ENABLE_PLAYER_GAMES_WRITES = false;

/*****************
 * CLOUD-ONLY READS (force consistency across devices)
 *****************/
const READS_CLOUD_ONLY = true; // all reads come from Supabase

// If cloud-only reads are enabled, neutralise local log accessors so UI never reads from them
if (READS_CLOUD_ONLY) {
  window.getGameLog = function(){ return []; };
  window.setGameLog = function(){ /* no-op */ };
  window.logCompletedGame = function(){ /* no-op (we persist to cloud in recordFullGameToSupabase) */ };
  window.getMatchLog = function(){ return []; };
  window.setMatchLog = function(){ /* no-op */ };
  window.logCompletedMatch = function(){ /* no-op */ };
}

/* NEW: shared date formatter → "DD/MM/YY @ HH:MM" (24h) */
if (typeof window.fmtWhen !== 'function') {
  window.fmtWhen = function fmtWhen(ts){
    const d = new Date(ts);
    if (Number.isNaN(d.getTime())) return '';
    const dd = String(d.getDate()).padStart(2,'0');
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const yy = String(d.getFullYear()).slice(-2);
    const HH = String(d.getHours()).padStart(2,'0');
    const MI = String(d.getMinutes()).padStart(2,'0');
    return `${dd}/${mm}/${yy} @ ${HH}:${MI}`;
  };
}

// Helpers (define only if missing)
if (typeof window.eqName !== 'function') {
  window.eqName = (a,b) => String(a||'').trim().toLowerCase() === String(b||'').trim().toLowerCase();
}
if (typeof window.isOfficialGame !== 'function') {
  window.isOfficialGame = g => Array.isArray(g?.players) && g.players.length >= 2;
}
if (typeof window.isPracticeGame !== 'function') {
  window.isPracticeGame = g => Array.isArray(g?.players) && g.players.length === 1;
}

// Override readers to fetch **only** from cloud and dedupe by a stable key
window.getGamesForMode = async function getGamesForMode(mode){
  try {
    let cloudGames = await cloudFetchAllGamesAsLocal();
    cloudGames = Array.isArray(cloudGames) ? cloudGames : [];

    // Filter by mode
    const filtered = cloudGames.filter(g =>
      mode === 'official' ? isOfficialGame(g) : isPracticeGame(g)
    );

    // De-dup by stable key (ts | players(lowercased) | totals)
    const map = new Map();
    const stableKey = (g) => {
      const players = (g.players || [])
        .map(p => (p && p.name) ? String(p.name).trim().toLowerCase() : '')
        .join(',');
      return [g.ts || '', players, (g.totals || []).join(',')].join('|');
    };
    for (const g of filtered) {
      const key = stableKey(g);
      if (!map.has(key)) map.set(key, g);
    }
    return [...map.values()];
  } catch (e) {
    console.error('getGamesForMode (cloud-only) failed', e);
    return [];
  }
};

window.getMatchesOfficial = async function getMatchesOfficial(){
  try {
    const cloudMatches = await cloudFetchAllMatchesAsLocal();
    const list = Array.isArray(cloudMatches) ? cloudMatches : [];

    // De-dup by ts | players(lowercased)
    const map = new Map();
    const stableKey = (m) => {
      const players = (m.players || [])
        .map(p => (p && p.name) ? String(p.name).trim().toLowerCase() : '')
        .join(',');
      return [m.ts || '', players].join('|');
    };
    for (const m of list) {
      const key = stableKey(m);
      if (!map.has(key)) map.set(key, m);
    }
    return [...map.values()];
  } catch (e) {
    console.error('getMatchesOfficial (cloud-only) failed', e);
    return [];
  }
};

// Recover missing High Scores by scanning cloud Games for a recent window (default 24h).
async function recoverHighScoresFromCloudWindow(hours = 24){
  if (!ensureCloudInit()) { toast('Cloud not initialised'); return { inserted:0, scanned:0, skipped:0 }; }
  const now = Date.now();
  const fromIso = new Date(now - (hours * 60 * 60 * 1000)).toISOString();
  const toIso   = new Date(now + (5 * 60 * 1000)).toISOString(); // small future skew for device time drift

  let scanned = 0, inserted = 0, skipped = 0;
  let rows = [];
  try {
    const { data, error } = await sb
      .from(TABLE_GAMES)
      .select('created_at, state, totals')
      .gte('created_at', fromIso)
      .lte('created_at', toIso)
      .order('created_at', { ascending: true });
    if (error) throw error;
    rows = data || [];
  } catch (e) {
    console.error('recover HS: fetch games failed', e);
    toast('Recover HS failed: could not fetch games');
    return { inserted, scanned, skipped };
  }

  for (const g of rows) {
    scanned++;
    const players = (g?.state?.players || [])
      .map(p => (typeof p === 'string') ? { name: p } : p)
      .filter(Boolean);
    const totals = Array.isArray(g?.totals) ? g.totals : [];
    const ts = g?.created_at || new Date().toISOString();
    const isSingle = players.length === 1;
    const table = isSingle
      ? (typeof TABLE_HS_PRACTICE !== 'undefined' ? TABLE_HS_PRACTICE : 'high_scores_practice')
      : (typeof TABLE_HS_LEAGUE   !== 'undefined' ? TABLE_HS_LEAGUE   : 'high_scores');

    for (let i = 0; i < players.length; i++) {
      const name  = players[i]?.name || '';
      const score = Number(totals[i] || 0);
      if (!name || score <= 0) continue;
      try {
        const ok = await cloudInsertHighScoreIfMissing(table, name, score, ts);
        if (ok) inserted++; else skipped++;
      } catch (e) {
        console.error('recover HS: insert failed', e);
        skipped++;
      }
    }
  }

  return { inserted, scanned, skipped };
}

/*****************
 * BACKFILL: Sync all local data → Supabase
 *****************/
  async function backfillLocalGamesToCloud() {
    const games = (typeof getGameLog === 'function') ? (getGameLog() || []) : [];
    let inserted = 0, hs = 0, playerRows = 0;
    for (const g of games) {
      try {
        const players = (g.players || []).map(p => typeof p === 'string' ? { name:p } : p).filter(Boolean);
        const totals  = Array.isArray(g.totals) ? g.totals : [];
        const isSingle = players.length === 1;
        const ts = g.ts || new Date().toISOString();

        // --- games table
        if (typeof TABLE_GAMES !== 'undefined') {
          const payload = {
            created_at: ts,
            state: { players, board: g.board || null },
            totals,
            finished: true,
            match_id: g.match_id || null
          };
          try {
            const { error } = await sb.from(TABLE_GAMES).insert(payload);
            if (!error) inserted++;
          } catch (e) {
            // attempt upsert on conflict(created_at) if supported
            try {
              const { error } = await sb.from(TABLE_GAMES).upsert(payload);
              if (!error) inserted++;
            } catch(_) {}
          }
        }

        // --- high scores tables
        if (typeof cloudInsertHighScore === 'function') {
          for (let i = 0; i < players.length; i++) {
            const name = players[i]?.name || `Player ${i+1}`;
            const score = Number(totals[i] || 0);
            if (!name || score <= 0) continue;
            try { await cloudInsertHighScore(name, score, isSingle); hs++; } catch(_) {}
          }
        }

        // --- player_games (optional; skipped when using a view like `player_games_union`)
        if (ENABLE_PLAYER_GAMES_WRITES && typeof TABLE_PLAYER_GAMES !== 'undefined' && players.length) {
          const sorted = totals.map((t,i)=>({t:Number(t||0),i})).sort((a,b)=>b.t-a.t);
          const posByIdx = Array(players.length).fill(null);
          sorted.forEach((o,rank)=>{ posByIdx[o.i] = rank+1; });
          for (let i=0;i<players.length;i++){
            const row = {
              sheet_id: g.sheet_id || null,
              player: players[i]?.name || `Player ${i+1}`,
              score: Number(totals[i] || 0),
              position: posByIdx[i] || null,
              ts,
              is_practice: isSingle,
              rounds: (typeof MAX_ROUNDS === 'number' ? MAX_ROUNDS : null)
            };
            try {
              const { error } = await sb.from(TABLE_PLAYER_GAMES).insert(row);
              if (!error) playerRows++;
            } catch(_) {}
          }
        }
      } catch (e) {
        console.error('Backfill game failed', e);
      }
    }
    return { inserted, hs, playerRows, scanned: games.length };
  }
  
  async function backfillLocalMatchesToCloud() {
    const matches = (typeof getMatchLog === 'function') ? (getMatchLog() || []) : [];
    if (typeof TABLE_MATCHES === 'undefined') return { inserted: 0, scanned: matches.length };
    let inserted = 0;
    for (const m of matches) {
      try {
        const payload = {
          id: m.id || null,
          created_at: m.ts || new Date().toISOString(),
          players: (m.players || []).map(p => typeof p === 'string' ? { name:p } : p),
          wins: m.wins || [],
          total_games: m.games || (Array.isArray(m.history) ? m.history.length : null),
          history: (m.history || []).map(g => ({ totals: g.totals || [] }))
        };
        try {
          const { error } = await sb.from(TABLE_MATCHES).insert(payload);
          if (!error) inserted++;
        } catch(_) {
          try {
            const { error } = await sb.from(TABLE_MATCHES).upsert(payload);
            if (!error) inserted++;
          } catch(e) { console.warn('match upsert failed', e); }
        }
      } catch (e) {
        console.error('Backfill match failed', e);
      }
    }
    return { inserted, scanned: matches.length };
  }
  
  async function runBackfillAll(){
    if (!ensureCloudInit()) { toast('Cloud not initialised'); return; }
    const btn = document.getElementById('backfillAllBtn');
    if (btn) { btn.disabled = true; btn.textContent = 'Backdating…'; }
    toast('Starting backdate — syncing local → cloud');
    try {
      const gamesRes   = await backfillLocalGamesToCloud();
      const matchesRes = await backfillLocalMatchesToCloud();
      const msg = `Backdate done.
  Games: ${gamesRes.inserted}/${gamesRes.scanned} to cloud
  High scores rows: ${gamesRes.hs}
  Player-game rows: ${gamesRes.playerRows}
  Matches: ${matchesRes.inserted}/${matchesRes.scanned}`;
      console.log(msg.replace(/\\n/g,' '));
      toast('Backdate complete ✔');
    } catch (e) {
      console.error(e);
      toast('Backdate failed — see console');
    } finally {
      if (btn) { btn.disabled = false; btn.textContent = 'BACKDATE: Sync Local → Cloud'; }
      try { await initialCloudCheck(); } catch(_) {}
    }
  }

// === Player Summary Stats dialog (cloud-only, simple aggregate) ===
window.openPlayerSummaryStatsDialog = async function openPlayerSummaryStatsDialog(playerName, mode){
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal';
  const title   = document.createElement('h3');
  const body    = document.createElement('div'); body.className    = 'modal-body';
  const footer  = document.createElement('div'); footer.className  = 'modal-footer';

  const isPractice = (mode === 'practice' || mode === true);

  title.textContent = 'Player Stats — ' + (playerName || 'Unknown') + (isPractice ? ' (Practice)' : ' (Official)');

  async function render(){
    body.innerHTML = '';

    try{
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()){
        const p = document.createElement('p');
        p.textContent = 'Cloud not initialised.';
        body.appendChild(p);
        return;
      }
    } catch(_){}

    // Fetch all games for this player/mode from the cloud view
    let rows = [];
    try{
      const tableName = (typeof TABLE_PLAYER_GAMES !== 'undefined' && TABLE_PLAYER_GAMES)
        ? TABLE_PLAYER_GAMES
        : 'player_games_union';

      const query = sb
        .from(tableName)
        .select('score, position, ts, is_practice, rounds')
        .eq('player', playerName || '')
        .eq('is_practice', !!isPractice)
        .order('ts', { ascending: false })
        .limit(5000);

      const { data, error } = await query;
      if (error) throw error;
      rows = data || [];
    }catch(e){
      console.error('Player summary stats fetch failed', e);
      const p = document.createElement('p');
      p.textContent = 'Failed to load stats.';
      const d = document.createElement('p');
      d.className = 'tag';
      d.textContent = (e && e.message) ? e.message : 'Unknown error';
      body.append(p, d);
      return;
    }

    if (!rows.length){
      const p = document.createElement('p');
      p.textContent = 'No games found for this player in this mode.';
      body.appendChild(p);
      return;
    }

    // Basic aggregates
    const games = rows.length;
    const scores = rows.map(r => Number(r.score || 0));
    const wins   = rows.filter(r => Number(r.position || 0) === 1).length;
    const best   = Math.max(...scores);
    const worst  = Math.min(...scores);
    const total  = scores.reduce((s,v)=> s + v, 0);
    const avg    = total / games;

    const last   = rows[0];
    const lastScore = Number(last.score || 0);
    const lastWhen  = (window.fmtWhen && last.ts) ? window.fmtWhen(last.ts) : (last.ts || '');

    // Build a compact two-column table of stats
    const table = document.createElement('table');
    table.className = 'hs-table compact';

    const tbody = document.createElement('tbody');
    function addRow(label, value){
      const tr = document.createElement('tr');
      const tdL = document.createElement('td'); tdL.textContent = label;
      const tdV = document.createElement('td'); tdV.textContent = value;
      tr.append(tdL, tdV);
      tbody.appendChild(tr);
    }

    const winPct = games ? ((wins / games) * 100).toFixed(1) + '%' : '0%';
    addRow('Games Played', String(games));
    addRow('Wins',        `${wins} (${winPct})`);
    addRow('Best Score',  String(best));
    addRow('Worst Score', String(worst));
    addRow('Average Score', avg.toFixed(1));
    addRow('Last Game Score', String(lastScore));
    addRow('Last Game When',  lastWhen || '—');

    table.appendChild(tbody);
    body.appendChild(table);
  }

  await render();

  const backBtn  = document.createElement('button'); backBtn.className  = 'btn'; backBtn.textContent  = 'Return';
  const closeBtn = document.createElement('button'); closeBtn.className = 'btn'; closeBtn.textContent = 'Close';
backBtn.onclick  = () => {
  overlay.remove();
  try { 
    if (typeof window.openPlayerStatsModePicker === 'function') {
      window.openPlayerStatsModePicker(name || pretty || playerName);
    }
  } catch(_) {}
};  closeBtn.onclick = () => overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
  modal.tabIndex = 0; modal.focus();
};

// === SHARED: Official Power Rankings calculator =============================
// Returns [{ player, rounds, avgRound, qualifies }] sorted by avgRound desc
// Rules: practice excluded, rounds = 10..20 + D + T + B, last 50 rounds window,
//        qualifies with >= 15 rounds (1 game + 1 round)
window.getOfficialPowerRows = async function getOfficialPowerRows(){
  const MIN_ROUNDS = 15, WINDOW = 50;

  const allGames = (await __fetchOfficialGames(50000)).map(__normalizeGame)
    .filter(g => !g.is_practice && g.is_practice !== true);

  const gameTs = new Map();
  allGames.forEach(g=>{
    const gid = (g.raw && (g.raw.id||g.raw.game_id)) || g.id || g.game_id;
    if (gid) gameTs.set(gid, g.ts || null);
  });

  let allThrows = [];
  try {
    const ids = allGames.map(g => (g.raw && (g.raw.id||g.raw.game_id)) || g.id || g.game_id).filter(Boolean);
    allThrows = await __fetchThrowsForGames(ids);
  } catch(_) {}

  // fallback from boards if needed
  if (!allThrows.length){
    allGames.forEach(g=>{
      (g.players||[]).forEach(p=>{
        const rows = __throwsFromGamesForPlayer(p, [g]);
        if (rows && rows.length) allThrows.push(...rows);
      });
    });
  }

  // keep only proper rounds with finite points
  allThrows = allThrows.filter(t =>
    typeof t.round_index === 'number' && t.round_index >= 0 && t.round_index <= 13 &&
    Number.isFinite(Number(t.points))
  );

  // sum to per-player round objects (game+round)
  const roundsByPlayer = new Map(); // player -> [{key, ts, ri, sum}]
  allThrows.forEach(t=>{
    const p = String(t.player||'').trim(); if (!p) return;
    const gid = t.game_id;
    const ts  = gameTs.get(gid) || null;
    const ri  = Number(t.round_index||0);
    const pts = Number(t.points||0);
    const key = `${gid}|${ri}`;
    let list = roundsByPlayer.get(p); if (!list){ list=[]; roundsByPlayer.set(p,list); }
    let r = list.find(e=>e.key===key);
    if (!r){ r = { key, ts, ri, sum:0 }; list.push(r); }
    r.sum += pts;
  });

  // build rows (order rounds by time then round index)
  const rows = Array.from(roundsByPlayer.entries()).map(([player,list])=>{
    list.sort((a,b)=>{
      const at=a.ts?new Date(a.ts).getTime():0, bt=b.ts?new Date(b.ts).getTime():0;
      return (at-bt) || (a.ri-b.ri);
    });
    const last = list.slice(-WINDOW);
    const n    = last.length;
    const pts  = last.reduce((s,r)=>s+Number(r.sum||0),0);
    const avgRound = n ? (pts/n) : 0;
    const qualifies = n >= MIN_ROUNDS;
    return { player, rounds:n, avgRound, qualifies };
  });

  rows.sort((a,b)=> b.avgRound - a.avgRound);
  return rows;
};

// === Player Progression dialog (per‑game line graph for a player) ===
window.openPlayerProgressionDialog = async function openPlayerProgressionDialog(playerName, mode) {
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal compact';
  const title   = document.createElement('h3');
  const body    = document.createElement('div'); body.className    = 'modal-body';
  const footer  = document.createElement('div'); footer.className  = 'modal-footer';

  const isPractice = (mode === 'practice' || mode === true);
  const labelMode  = isPractice ? 'Practice' : 'Official';
  const safeName   = playerName || 'Unknown';

  title.textContent = `Progression — ${safeName} (${labelMode})`;

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  modal.tabIndex = 0;
  modal.focus();

  const close = () => { overlay.remove(); };

  const backBtn  = document.createElement('button');
  backBtn.className  = 'btn';
  backBtn.textContent  = 'Back';
  backBtn.onclick  = close;

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = close;

  footer.append(backBtn, closeBtn);

  // Top controls + chart area
  body.innerHTML = `
    <div class="row" style="gap:8px; margin-bottom:8px;">
      <button class="btn primary" data-metric="score">Game Score</button>
<button class="btn" data-metric="avg">5 Game Average</button>
<button class="btn" data-metric="target">Target %</button>
    </div>
    <div id="progChartWrap" style="border-radius:12px;border:1px solid #23284a;padding:8px;background:#101533;min-height:260px;">
      <canvas id="progChartCanvas" width="600" height="260"></canvas>
    </div>
    <p class="tag" id="progHint">Vertical: Score / %, Horizontal: Games (1, 2, 3, …)</p>
  `;

  const metricButtons = Array.from(body.querySelectorAll('button[data-metric]'));
  const canvas = body.querySelector('#progChartCanvas');
  const ctx = canvas && canvas.getContext ? canvas.getContext('2d') : null;

  if (!ctx) {
    const wrap = body.querySelector('#progChartWrap');
    if (wrap) wrap.innerHTML = '<p>Canvas not supported in this browser.</p>';
    return;
  }

  // ---- Fetch per‑game data for this player ----
  async function loadData() {
    try {
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) {
        return { labels: [], scores: [], avgs: [], targetPct: [] };
      }
    } catch (_) {}

    const tableName = (typeof TABLE_PLAYER_GAMES !== 'undefined' && TABLE_PLAYER_GAMES)
      ? TABLE_PLAYER_GAMES
      : 'player_games_union';

    let games = [];
    try {
      const { data, error } = await sb
        .from(tableName)
        .select('sheet_id, player, score, rounds, ts, is_practice')
        .eq('player', safeName)
        .eq('is_practice', !!isPractice)
        .order('ts', { ascending: true })
        .limit(200);
      if (error) throw error;
      games = data || [];
    } catch (e) {
      console.error('Progression: games fetch failed', e);
      return { labels: [], scores: [], avgs: [], targetPct: [] };
    }

    if (!games.length) {
      return { labels: [], scores: [], avgs: [], targetPct: [] };
    }

    // x‑axis labels: game index 1..N
    const labels = games.map((_, idx) => idx + 1);
const scores = games.map(g => Number(g.score || 0));

// 5 Game Average: only at games 5, 10, 15, ...
// game 5 = avg of games 1–5, game 10 = avg of games 6–10, etc.
const avgs = scores.map((_, idx) => {
  const gameNo = idx + 1;          // 1-based game index
  if (gameNo % 5 !== 0) return NaN; // only plot at 5, 10, 15, ...
  const start = idx - 4;           // start of the 5-game block
  if (start < 0) return NaN;
  let sum = 0;
  for (let i = start; i <= idx; i++) {
    sum += Number(scores[i] || 0);
  }
  return sum / 5;
});

    // Overall target hit % per game (all darts → (hits / attempts)*100)
    let targetPct = new Array(games.length).fill(0);

    try {
      const gameIds = games.map(g => g.sheet_id).filter(Boolean);
      if (gameIds.length && typeof TABLE_GAME_THROWS !== 'undefined') {
        const { data: throwsRaw, error: tErr } = await sb
          .from(TABLE_GAME_THROWS)
          .select('game_id, player, points')
          .in('game_id', gameIds)
          .eq('player', safeName);
        if (!tErr && Array.isArray(throwsRaw)) {
          const byGame = new Map();
          throwsRaw.forEach(row => {
            const gid = row.game_id;
            if (!gid) return;
            let agg = byGame.get(gid);
            if (!agg) {
              agg = { hits: 0, attempts: 0 };
              byGame.set(gid, agg);
            }
            agg.attempts += 1;
            const pts = Number(row.points || 0);
            if (pts > 0) agg.hits += 1;
          });

          targetPct = games.map(g => {
            const agg = byGame.get(g.sheet_id);
            if (!agg || !agg.attempts) return 0;
            return (agg.hits * 100) / agg.attempts;
          });
        }
      }
    } catch (e) {
      console.error('Progression: target% fetch failed', e);
    }

    return { labels, scores, avgs, targetPct };
  }

  const data = await loadData();

  if (!data.labels.length) {
    const wrap = body.querySelector('#progChartWrap');
    if (wrap) wrap.innerHTML = '<p>No games found for this player/mode.</p>';
    return;
  }

  function setActiveMetricButton(metric) {
    metricButtons.forEach(btn => {
      const m = btn.getAttribute('data-metric');
      if (m === metric) btn.classList.add('primary');
      else btn.classList.remove('primary');
    });
  }

  function drawLineChart(values, metric) {
    const labels = data.labels;
    const W = canvas.width;
    const H = canvas.height;
    const paddingLeft = 40;
    const paddingRight = 10;
    const paddingTop = 10;
    const paddingBottom = 28;

    ctx.clearRect(0, 0, W, H);

    if (!labels.length || !values.length) return;

const finiteVals = values.filter(v => Number.isFinite(v));
if (!finiteVals.length) return;
const maxValRaw = Math.max(...finiteVals);
const maxVal = maxValRaw > 0 ? maxValRaw : 1;

    const xMin = 0;
    const xMax = labels.length > 1 ? labels.length - 1 : 1;

    const plotW = W - paddingLeft - paddingRight;
    const plotH = H - paddingTop - paddingBottom;

    function xForIndex(i) {
      if (xMax === xMin) return paddingLeft + plotW / 2;
      return paddingLeft + ((i - xMin) / (xMax - xMin)) * plotW;
    }
    function yForValue(v) {
      const clamped = v < 0 ? 0 : v;
      return paddingTop + (1 - clamped / maxVal) * plotH;
    }

    // Axes
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 1;

    // Y-axis
    ctx.beginPath();
    ctx.moveTo(paddingLeft, paddingTop);
    ctx.lineTo(paddingLeft, H - paddingBottom);
    ctx.stroke();

    // X-axis
    ctx.beginPath();
    ctx.moveTo(paddingLeft, H - paddingBottom);
    ctx.lineTo(W - paddingRight, H - paddingBottom);
    ctx.stroke();

    // Y ticks
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.font = '10px system-ui';
    const steps = 4;
    for (let i = 0; i <= steps; i++) {
      const v = (maxVal * i) / steps;
      const y = yForValue(v);
      ctx.beginPath();
      ctx.moveTo(paddingLeft - 3, y);
      ctx.lineTo(W - paddingRight, y);
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.stroke();
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.fillText(metric === 'target' ? v.toFixed(0) + '%' : v.toFixed(0), 4, y + 3);
    }

// X labels (game index 1..N)
for (let i = 0; i < labels.length; i++) {
  const x = xForIndex(i);
  ctx.fillStyle = 'rgba(255,255,255,0.75)';
  ctx.fillText(String(labels[i]), x - 4, H - paddingBottom + 14);
}

// Trend line (linear regression) across finite values
const xs = [];
const ys = [];
values.forEach((v, i) => {
  if (!Number.isFinite(v)) return;
  xs.push(i);
  ys.push(v);
});

if (xs.length >= 2) {
  // Least-squares fit: y = m*x + b
  let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
  for (let i = 0; i < xs.length; i++) {
    const x = xs[i];
    const y = ys[i];
    sumX  += x;
    sumY  += y;
    sumXY += x * y;
    sumX2 += x * x;
  }
  const n = xs.length;
  const denom = (n * sumX2 - sumX * sumX) || 1;
  const m = (n * sumXY - sumX * sumY) / denom;
  const b = (sumY - m * sumX) / n;

  const xStartIdx = xs[0];
  const xEndIdx   = xs[xs.length - 1];
  const yStartVal = m * xStartIdx + b;
  const yEndVal   = m * xEndIdx + b;

  const xStart = xForIndex(xStartIdx);
  const xEnd   = xForIndex(xEndIdx);
  const yStart = yForValue(yStartVal);
  const yEnd   = yForValue(yEndVal);

  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.35)';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.moveTo(xStart, yStart);
  ctx.lineTo(xEnd,   yEnd);
  ctx.stroke();
  ctx.restore();
}

    // Line (skip positions without data, e.g. non-5th games for 5 Game Average)
ctx.strokeStyle = '#7bdcff';
ctx.lineWidth = 2;
ctx.beginPath();
let started = false;
values.forEach((v, i) => {
  if (!Number.isFinite(v)) return;
  const x = xForIndex(i);
  const y = yForValue(v);
  if (!started) {
    ctx.moveTo(x, y);
    started = true;
  } else {
    ctx.lineTo(x, y);
  }
});
if (started) ctx.stroke();

// Points
ctx.fillStyle = '#8cff9e';
values.forEach((v, i) => {
  if (!Number.isFinite(v)) return;
  const x = xForIndex(i);
  const y = yForValue(v);
  ctx.beginPath();
  ctx.arc(x, y, 3, 0, Math.PI * 2);
  ctx.fill();
});
  }

  function render(metric) {
    let values = data.scores;
    if (metric === 'avg') values = data.avgs;
    else if (metric === 'target') values = data.targetPct;
    setActiveMetricButton(metric);
    drawLineChart(values, metric);
  }

  // Wire metric buttons
  metricButtons.forEach(btn => {
    const metric = btn.getAttribute('data-metric');
    btn.onclick = () => render(metric);
  });

  // Initial render
  render('score');

  // Allow closing via ESC or click-outside
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
};

// === Patch Player Stats modal to wire PROGRESSION button ===
(function(){
  if (window.__playerProgressionPatch) return;
  window.__playerProgressionPatch = true;

  function attachProgression(root){
    try{
      const modal = root.querySelector('.modal');
      if (!modal) return;
      const h3 = modal.querySelector('h3');
      if (!h3) return;
      const title = (h3.textContent || '').trim();
      if (!/^Player Stats/i.test(title)) return;

      // Extract player name + mode from title: "Player Stats — Name (Practice)"
      let rest = title.replace(/^Player Stats\s*[\u2013\u2014\-]\s*/i, '');
      const isPractice = /\(practice\)/i.test(rest);
      rest = rest.replace(/\(.*\)\s*$/,'').trim();
      const playerName = rest || 'Unknown';

      const buttons = Array.from(modal.querySelectorAll('button'));
      const progBtn = buttons.find(b => (b.textContent || '').trim().toUpperCase() === 'PROGRESSION');
      if (!progBtn) return;

      // Avoid double-binding
      if (progBtn.dataset && progBtn.dataset.progressionBound === '1') return;
      if (progBtn.dataset) progBtn.dataset.progressionBound = '1';

      progBtn.onclick = () => {
        try{
          if (typeof window.openPlayerProgressionDialog === 'function'){
            window.openPlayerProgressionDialog(playerName, isPractice);
          }
        }catch(e){
          console.error('Progression button handler failed', e);
        }
      };
    }catch(e){
      console.error('attachProgression error', e);
    }
  }

  const mo = new MutationObserver(muts => {
    for (const m of muts){
      for (const n of m.addedNodes){
        if (n.nodeType !== 1) continue;
        if (n.classList.contains('modal-backdrop')){
          setTimeout(() => attachProgression(n), 0);
        } else if (n.querySelector){
          const backdrop = n.querySelector('.modal-backdrop');
          if (backdrop) setTimeout(() => attachProgression(backdrop), 0);
        }
      }
    }
  });

  try { mo.observe(document.body, { childList: true, subtree: true }); } catch(_) {}
})();

(function(){
  // >>> PATCH:game-utils START — shared game/time helpers for games lists
  if (window.__gameTimeUtilsPatched) return;
  window.__gameTimeUtilsPatched = true;

  // Canonical timestamp extractor for game rows
  window.getGameTimestamp = function getGameTimestamp(g){
    if (!g || typeof g !== 'object') return null;
    const tsVal = g.ts || g.created_at || g.inserted_at || (g.meta && (g.meta.ts || g.meta.date)) || null;
    if (!tsVal) return null;
    const d = new Date(tsVal);
    return Number.isNaN(d.getTime()) ? null : d;
  };

  // Canonical result line: "A 220 beat B 190 C 175" etc.
  window.formatGameResultLine = function formatGameResultLine(g){
    if (!g) return '';

    const players = (g.players || []).map(p =>
      (p && typeof p === 'object' && 'name' in p) ? p.name : String(p || '')
    );
    const totals  = Array.isArray(g.totals) ? g.totals : [];

    const ordered = players
      .map((name, i) => ({ name, score: Number(totals[i] || 0) }))
      .filter(x => x.name)
      .sort((a, b) => b.score - a.score);

    let result = '—';
    if (ordered.length >= 2){
      result = `${ordered[0].name} ${ordered[0].score} beat ${ordered[1].name} ${ordered[1].score}`;
      if (ordered.length > 2){
        result += ' ' + ordered.slice(2).map(o => `${o.name} ${o.score}`).join(' ');
      }
    } else if (ordered.length === 1){
      result = `${ordered[0].name} ${ordered[0].score}`;
    }

    return result;
  };

  // Canonical date/time formatter (Europe/London, DD/MM[/YY] HH:MM)
  window.fmtWhen = function fmtWhen(ts, opts){
    if (!ts) return '';
    const d = ts instanceof Date ? ts : new Date(ts);
    if (Number.isNaN(d.getTime())) return '';

    const dd = String(d.getDate()).padStart(2, '0');
    const mm = String(d.getMonth() + 1).padStart(2, '0');
    const yy = String(d.getFullYear()).slice(-2);
    const HH = String(d.getHours()).padStart(2, '0');
    const MI = String(d.getMinutes()).padStart(2, '0');

    if (opts && opts.omitYear) {
      return `${dd}/${mm} ${HH}:${MI}`;
    }
    return `${dd}/${mm}/${yy} ${HH}:${MI}`;
  };
})();
// >>> PATCH:game-utils END

// === Start-screen Vertical Game Ticker (Sky Sports-style) ===
(function(){
  if (window.__verticalGameTickerBootstrapped) return;
  window.__verticalGameTickerBootstrapped = true;

  const IN_MS   = 800;   // slower scroll in (bottom -> centre)
  const HOLD_MS = 3000;  // 3s pause while centred
  const OUT_MS  = 800;   // slower scroll out (centre -> top)

  function formatGameForTicker(g){
    if (!g) return '';

    const result = (typeof window.formatGameResultLine === 'function')
      ? window.formatGameResultLine(g)
      : (function fallbackResult(game){
          const players = (game.players || []).map(p =>
            (p && typeof p === 'object' && 'name' in p) ? p.name : String(p || '')
          );
          const totals  = Array.isArray(game.totals) ? game.totals : [];
          const ordered = players
            .map((name, i) => ({ name, score: Number(totals[i] || 0) }))
            .filter(x => x.name)
            .sort((a, b) => b.score - a.score);

          if (ordered.length >= 2){
            let r = `${ordered[0].name} ${ordered[0].score} beat ${ordered[1].name} ${ordered[1].score}`;
            if (ordered.length > 2){
              r += ' ' + ordered.slice(2).map(o => `${o.name} ${o.score}`).join(' ');
            }
            return r;
          } else if (ordered.length === 1){
            return `${ordered[0].name} ${ordered[0].score}`;
          }
          return '—';
        })(g);

    let when = '';
    if (typeof window.getGameTimestamp === 'function' && typeof window.fmtWhen === 'function'){
      const d = window.getGameTimestamp(g);
      if (d) when = window.fmtWhen(d, { omitYear: true });
    }

    return when ? `${when}  ${result}` : result;
  }

  function startVerticalTicker(container, track, items){
    if (!container || !track || !items || !items.length) return;

    // Ensure only a single line is ever visible
    container.style.overflow = 'hidden';
    container.style.whiteSpace = 'nowrap';

    let idx = 0;

    function step(){
      if (!container.isConnected || !items.length) return;

      // Use container height if set, otherwise fall back to a reasonable line height
      const height = container.clientHeight || 28;

      // Pick the next single line to show
      const line = items[idx % items.length];
      idx = (idx + 1) % items.length;

      // Reset track content and position off-screen at the bottom
      track.style.transition = 'none';
      track.style.transform  = `translateY(${height}px)`;
      track.innerHTML = '';

      const div = document.createElement('div');
      div.textContent = line || '';
      div.style.whiteSpace = 'nowrap';
      track.appendChild(div);

      // Scroll into view (bottom -> centre)
      requestAnimationFrame(() => {
        track.style.transition = `transform ${IN_MS}ms linear`;
        track.style.transform  = 'translateY(0px)';
      });

      // After the hold, scroll out through the top and then show the next single line
      setTimeout(() => {
        track.style.transition = `transform ${OUT_MS}ms linear`;
        track.style.transform  = `translateY(${-height}px)`;
        setTimeout(step, OUT_MS);
      }, IN_MS + HOLD_MS);
    }

    container.classList.remove('hidden');
    step();
  }

  // Public bootstrap used on the Start (details) screen
  window.initVerticalGameTicker = async function initVerticalGameTicker(){
    const ticker = document.getElementById('psTicker');
    const track  = ticker && ticker.querySelector('.track');
    if (!ticker || !track) return;

    try{
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()){
        ticker.classList.add('hidden');
        return;
      }
    }catch(_){}

    let games = [];
    try{
      if (typeof cloudFetchAllGamesAsLocal === 'function'){
        games = await cloudFetchAllGamesAsLocal();
      }
    }catch(e){
      console.error('Vertical ticker: failed to fetch games', e);
    }

    if (!Array.isArray(games) || !games.length){
      ticker.classList.add('hidden');
      return;
    }

    const toTS = (g) => {
      const t = g?.ts || g?.created_at || g?.inserted_at || (g?.meta && (g.meta.ts || g.meta.date)) || null;
      const n = t ? Date.parse(t) : NaN;
      return Number.isFinite(n) ? n : 0;
    };

    games = games.filter(Boolean).sort((a,b)=> toTS(b) - toTS(a)).slice(0, 25);

    const items = games
      .map(formatGameForTicker)
      .filter(line => line && line.trim().length > 0);

    if (!items.length){
      ticker.classList.add('hidden');
      return;
    }

    startVerticalTicker(ticker, track, items);
  };
})();

// Simple High Scores picker for start screen: Match vs Round
window.openStartHighScoresMenu = function openStartHighScoresMenu(){
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal  = document.createElement('div');
  modal.className = 'modal';

  const title  = document.createElement('h3');
  title.textContent = 'High Scores';

  const body   = document.createElement('div');
  body.className = 'modal-body';

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  // Buttons for existing High Scores views
  const matchBtn = document.createElement('button');
  matchBtn.className = 'btn';
  matchBtn.type = 'button';
  matchBtn.textContent = 'High Scores (Match)';

  const roundBtn = document.createElement('button');
  roundBtn.className = 'btn';
  roundBtn.type = 'button';
  roundBtn.textContent = 'High Scores (Round)';

  // Stack vertically with a small gap
  const row1 = document.createElement('div');
  row1.className = 'row';
  row1.style.cssText = 'justify-content:center; gap:8px; flex-wrap:wrap; margin-top:4px;';
  row1.appendChild(matchBtn);

  const row2 = document.createElement('div');
  row2.className = 'row';
  row2.style.cssText = 'justify-content:center; gap:8px; flex-wrap:wrap; margin-top:8px;';
  row2.appendChild(roundBtn);

  body.append(row1, row2);

  // Footer actions
  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.type = 'button';
  closeBtn.textContent = 'Close';
  closeBtn.onclick = () => overlay.remove();
  footer.appendChild(closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  // Wire through to existing dialogs, preserving previous behaviour
  matchBtn.onclick = () => {
    overlay.remove();
    if (typeof window.openHighScoresMenuDialog === 'function') {
      window.openHighScoresMenuDialog();
    }
  };

  roundBtn.onclick = () => {
    overlay.remove();
    if (typeof window.openRoundHighScoresDialog === 'function') {
      window.openRoundHighScoresDialog();
    }
  };

  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) overlay.remove();
  });

  overlay.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') overlay.remove();
  });

  modal.tabIndex = 0;
  modal.focus();
};

// === Start screen layout arranger (non-destructive; rebuilds start-actions) ===
function arrangeStartActions(){
  try{
    const host = document.querySelector('#details .start-actions.column') || document.querySelector('.start-actions.column');
    if (!host) return;
    const doc = document;

    // helpers
    const mkRow = (btn) => {
      const row = doc.createElement('div');
      row.className = 'row';
      // centred single button row, consistent small vertical gap
      row.style.cssText = 'justify-content:center; gap:8px; flex-wrap:wrap; margin-top:8px;';
      row.appendChild(btn);
      return row;
    };
    const mkSpacer = (h) => {
      const d = doc.createElement('div');
      d.style.height = (h || 16) + 'px';
      return d;
    };

    // ensure / find buttons
    const newBtn = document.getElementById('questBtn');
    if (newBtn) newBtn.textContent = 'NEW GAME';

    const resumeBtn = document.getElementById('resumeBtn');
    if (resumeBtn) resumeBtn.textContent = 'Resume Game';

    // Latest Scores
    let latest = document.getElementById('latestScoresBtn');
    if (!latest){
      latest = doc.createElement('button');
      latest.id = 'latestScoresBtn';
      latest.className = 'btn';
      latest.type = 'button';
      latest.textContent = 'Latest Scores';
    }

    // League / Rankings (start-screen popup)
    let league = document.getElementById('leagueRankingsBtn');
    if (!league){
      league = doc.createElement('button');
      league.id = 'leagueRankingsBtn';
      league.className = 'btn';
      league.type = 'button';
    }
    league.textContent = 'League / Rankings';

    // High Scores (wrapper button that opens Match/Round picker)
    let hsMain = document.getElementById('highScoresMainBtn');
    if (!hsMain){
      hsMain = doc.createElement('button');
      hsMain.id = 'highScoresMainBtn';
      hsMain.className = 'btn';
      hsMain.type = 'button';
      hsMain.textContent = 'High Scores';
    } else {
      hsMain.textContent = 'High Scores';
    }

    // High Scores (Match)
    let hsMatch = document.getElementById('highScoresMenuBtn') ||
                  document.getElementById('highScoresBtn');
    if (!hsMatch){
      hsMatch = doc.createElement('button');
      hsMatch.id = 'highScoresMenuBtn';
      hsMatch.className = 'btn';
      hsMatch.type = 'button';
    }
    hsMatch.textContent = 'High Scores (Match)';

    // High Scores (Round)
    let hsRound = document.getElementById('roundHighScoresBtn');
    if (!hsRound){
      hsRound = doc.createElement('button');
      hsRound.id = 'roundHighScoresBtn';
      hsRound.className = 'btn';
      hsRound.type = 'button';
    }
    hsRound.textContent = 'High Scores (Round)';

    // Player Stats
    let stats = document.getElementById('playerStatsBtn');
    if (!stats){
      stats = doc.createElement('button');
      stats.id = 'playerStatsBtn';
      stats.className = 'btn';
      stats.type = 'button';
      stats.textContent = 'Player Stats';
    } else {
      stats.textContent = 'Player Stats';
    }

    // Admin
    let admin = document.getElementById('adminBtn') ||
                Array.from(document.querySelectorAll('#details button, button'))
                  .find(b => /admin code|^admin$/i.test((b.textContent || b.innerText || '').trim()));
    if (!admin){
      admin = doc.createElement('button');
      admin.id = 'adminBtn';
      admin.className = 'btn';
      admin.type = 'button';
      admin.textContent = 'Admin';
    } else {
      admin.textContent = 'Admin';
    }

    // wire handlers (idempotent, safe if functions missing)
    if (typeof window.openLatestScoresDialog === 'function') latest.onclick = window.openLatestScoresDialog;
    if (typeof window.openLeagueRankingsDialog === 'function') league.onclick = window.openLeagueRankingsDialog;
    if (typeof window.openStartHighScoresMenu === 'function') hsMain.onclick = window.openStartHighScoresMenu;
    if (typeof window.openRoundHighScoresDialog === 'function') hsRound.onclick = window.openRoundHighScoresDialog;
    if (typeof window.openHighScoresMenuDialog === 'function') hsMatch.onclick = window.openHighScoresMenuDialog;
    if (typeof window.openAdminPasswordModal === 'function') {
      admin.onclick = window.openAdminPasswordModal;
    } else if (typeof window.openAdminHub === 'function') {
      admin.onclick = window.openAdminHub;
    }

    // rebuild layout to:
    // NEW GAME (big)
    // Resume Game (big)
    // GAP
    // Latest Scores
    // High Scores (Match)
    // High Scores (Round)
    // Player Stats
    // GAP
    // Admin
    const frag = doc.createDocumentFragment();

    if (newBtn) {
      newBtn.textContent = 'NEW GAME';
      frag.appendChild(newBtn);
    }
    if (resumeBtn) {
      resumeBtn.textContent = 'Resume Game';
      frag.appendChild(resumeBtn);
    }

    // GAP between large buttons and the medium stats buttons
    frag.appendChild(mkSpacer(16));

    // Medium buttons – one per row, equal spacing
    [latest, league, hsMain, stats].forEach(btn => {
      if (!btn) return;
      frag.appendChild(mkRow(btn));
    });

    // GAP before Admin
    frag.appendChild(mkSpacer(16));

    // Admin button row at the bottom
    if (admin) {
      frag.appendChild(mkRow(admin));
    }

    // clear and insert
    host.innerHTML = '';
    host.appendChild(frag);
  } catch(e){
    console.error('arrangeStartActions failed', e);
  }
}

/*****************
 * BOOT
 *****************/
document.addEventListener('DOMContentLoaded', () => {
  // Start on details screen
  show('details');
  updatePadSpacer();
  setupStartMenuButtons();
  initSetupSteppers();

  // Kick off initial cloud connectivity check
  if (ensureCloudInit()) initialCloudCheck();

// Restart buttons (Player Select + Game + Leaderboard)
  ['restartGameBtn', 'restartGameBtnLB', 'restartGameBtnGame'].forEach(id => {
    document.querySelectorAll('#' + id).forEach(btn => {
      btn.onclick = restartGame;
    });
  });

  // Stats buttons in top rows (game + final leaderboard)
  const statsHubBtnGame  = byId('statsHubBtnGame');    // game screen
  const statsHubBtnFinal = byId('statsHubBtnFinal');   // leaderboard screen

  if (statsHubBtnGame)  statsHubBtnGame.onclick  = openStatsHubDialog;
  if (statsHubBtnFinal) statsHubBtnFinal.onclick = openStatsHubDialog;
  const hsFinalBtn = byId('highScoresMenuBtnLB');
  if (hsFinalBtn) hsFinalBtn.onclick = openHighScoresMenuDialog;
  
  // High Scores button on start screen
  const hsStartBtn = byId('highScoresMenuBtn') || byId('highScoresBtn');
  if (hsStartBtn) hsStartBtn.onclick = openHighScoresMenuDialog;
  

  // Leaderboard buttons (guarded lookups)
  (function(){
    const map = [
      ['lbGameStatsBtn',   'openGameStatsDialog'],
      ['lbMatchStatsBtn',  'openMatchStatsDialog'],
      ['lbGameRaceBtn',    'openGameRaceDialog']
    ];
    map.forEach(([id, fn])=>{
      const el = byId(id);
      const handler = (typeof window[fn] === 'function') ? window[fn] : null;
      if (el && handler) el.onclick = handler;
    });
  })();

  // Global ESC/click-outside for add/select/admin modals
  document.addEventListener('click', function(event) {
    const addPlayerModal      = byId('addPlayerModal');
    const selectPlayerModal   = byId('selectPlayerModal');
    const adminHub            = byId('adminHubModal');
    const savedPlayersAdmin   = byId('savedPlayersAdminModal');

    if (addPlayerModal &&
        !addPlayerModal.classList.contains('hidden') &&
        event.target === addPlayerModal) {
      addPlayerModal.classList.add('hidden');
    }

    if (selectPlayerModal &&
        !selectPlayerModal.classList.contains('hidden') &&
        event.target === selectPlayerModal) {
      selectPlayerModal.classList.add('hidden');
    }

    if (adminHub &&
        !adminHub.classList.contains('hidden') &&
        event.target === adminHub) {
      adminHub.classList.add('hidden');
    }

    if (savedPlayersAdmin &&
        !savedPlayersAdmin.classList.contains('hidden') &&
        event.target === savedPlayersAdmin) {
      savedPlayersAdmin.classList.add('hidden');
    }
  });

  document.addEventListener('keydown', function(event) {
    if (event.key !== 'Escape') return;

    const addPlayerModal    = byId('addPlayerModal');
    const selectPlayerModal = byId('selectPlayerModal');
    const adminHub          = byId('adminHubModal');
    const savedPlayersAdmin = byId('savedPlayersAdminModal');

    if (addPlayerModal &&
        !addPlayerModal.classList.contains('hidden')) {
      addPlayerModal.classList.add('hidden');
    }

    if (selectPlayerModal &&
        !selectPlayerModal.classList.contains('hidden')) {
      selectPlayerModal.classList.add('hidden');
    }

    if (adminHub &&
        !adminHub.classList.contains('hidden')) {
      adminHub.classList.add('hidden');
    }

    if (savedPlayersAdmin &&
        !savedPlayersAdmin.classList.contains('hidden')) {
      savedPlayersAdmin.classList.add('hidden');
    }
  });
  

  try { arrangeStartActions(); } catch(_) {}
});
// ===== FINAL OVERRIDE: Admin Hub opener (safe + id compatible) =====
window.openAdminHub = function openAdminHub(){
  const hub = document.getElementById('adminHubModal');
  if (!hub) return;
  hub.classList.remove('hidden');

  const bind = (id, fn) => {
    const el = document.getElementById(id);
    if (el) el.onclick = fn;
  };

  // All Games
  bind('openAllGamesBtn', () => {
    hub.classList.add('hidden');
    if (typeof openAllGamesDialog === 'function') openAllGamesDialog();
  });

  // High scores (league / practice)
  bind('openHsLeagueAdmin',   () => { hub.classList.add('hidden'); if (typeof openHighScoresAdminDialog === 'function') openHighScoresAdminDialog(false); });
  bind('openHsPracticeAdmin', () => { hub.classList.add('hidden'); if (typeof openHighScoresAdminDialog === 'function') openHighScoresAdminDialog(true);  });

  // League Low Scores (admin)
  bind('openLeagueLowsAdminBtn', () => {
    hub.classList.add('hidden');
    if (typeof openLeagueLowsAdminDialog === 'function') openLeagueLowsAdminDialog();
  });
  bind('openLeagueLowsAdmin', () => {
    hub.classList.add('hidden');
    if (typeof openLeagueLowsAdminDialog === 'function') openLeagueLowsAdminDialog();
  });

  // Saved Players Admin — supports legacy ID too
  const spa = document.getElementById('openSavedPlayersAdminBtn') || document.getElementById('openSavedPlayersAdmin');
  if (spa) spa.onclick = () => {
    hub.classList.add('hidden');
    if (typeof openSavedPlayersAdminDialog === 'function') openSavedPlayersAdminDialog();
  };

  // PB / GR Admin (support both legacy/new IDs)
  bind('openPBGRAdminBtn', () => {
    hub.classList.add('hidden');
    if (typeof openPBGRAdminDialog === 'function') openPBGRAdminDialog();
  });
  bind('openPBGRAdmin', () => {
    hub.classList.add('hidden');
    if (typeof openPBGRAdminDialog === 'function') openPBGRAdminDialog();
  });
  
  // ===== PB / GR Admin dialog =====
async function openPBGRAdminDialog(){
  const modal = document.getElementById('pbgrAdminModal');
  const globalHost = document.getElementById('pbgrGlobal');
  const playerHost = document.getElementById('pbgrPlayer');
  const sel = document.getElementById('pbgrPlayerSelect');
  const back = document.getElementById('pbgrBackBtn');
  const close = document.getElementById('pbgrCloseBtn');
  const refresh = document.getElementById('pbgrRefreshBtn');
    const backfill = document.getElementById('pbgrBackfillBtn');
  if (backfill){
    backfill.onclick = async ()=>{
      backfill.disabled = true;
      try{
        const res = await backfillPBGRToCloud();
        toast(`Backfill complete – PB rows: ${res.pbRows}, WR rows: ${res.wrRows}`);
      }catch(e){
        console.error(e);
        toast('Backfill failed — see console');
      }finally{
        backfill.disabled = false;
      }
    };
  }
  if (!modal || !globalHost || !playerHost || !sel) return;

  modal.classList.remove('hidden');

  back.onclick = () => { modal.classList.add('hidden'); openAdminHub(); };
  close.onclick = () => { modal.classList.add('hidden'); };
  refresh.onclick = async () => { await refreshPBGRCloud(); await renderAll(); };

  async function renderGlobal(){
    const snap = await getPBGRSnapshot();
    const order = [...Array.from({length:11},(_,i)=>10+i), 'D','T','B'];
    const table = document.createElement('table'); table.className='hs-table';
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    ['Round','WR','Holder','Actions'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; hr.appendChild(th); });
    thead.appendChild(hr); table.appendChild(thead);
    const tbody = document.createElement('tbody');

    for (const key of order){
      const meta = snap.byTargetMeta[key] || { val:0, player:'' };
      const tr = document.createElement('tr');
      const tdR = document.createElement('td'); tdR.textContent = String(key);
      const tdV = document.createElement('td'); tdV.textContent = String(meta.val||0);
      const tdN = document.createElement('td'); tdN.textContent = meta.player ? meta.player : '—';
      const tdA = document.createElement('td');
      const delBtn = document.createElement('button'); delBtn.className='btn small danger'; delBtn.textContent='Delete';
      delBtn.disabled = !(meta && meta.game_id!=null && meta.ridx!=null && meta.player);
      delBtn.onclick = async ()=>{
        if (!confirm(`Delete WR for ${key} held by ${meta.player} (${meta.val})? This will delete the underlying round from cloud.`)) return;
        try{
          await cloudDeleteRound(meta.game_id, meta.player, meta.ridx);
          await refreshPBGRCloud();
          await renderAll();
          toast('Deleted.');
        }catch(e){ console.error(e); toast('Delete failed'); }
      };
      tdA.appendChild(delBtn);
      tr.append(tdR, tdV, tdN, tdA); tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    globalHost.innerHTML = '';
    globalHost.appendChild(table);
  }

  async function populatePlayers(){
    sel.innerHTML = '<option value="">Select a saved player…</option>';
    try{
      const players = await cloudListPlayers();
      players.forEach(p=>{
        const opt = document.createElement('option');
        opt.value = p.name; opt.textContent = p.name;
        sel.appendChild(opt);
      });
    }catch(_){}
  }

  async function renderPlayer(name){
    const snap = await getPBGRSnapshot();
    const nk = (name||'').trim().toLowerCase();
    const metaMap = snap.byPlayerMeta.get(nk) || {};
    const order = [...Array.from({length:11},(_,i)=>10+i), 'D','T','B'];

    const table = document.createElement('table'); table.className='hs-table';
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    ['Round','PB','Actions'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; hr.appendChild(th); });
    thead.appendChild(hr); table.appendChild(thead);
    const tbody = document.createElement('tbody');

    order.forEach(key=>{
      const m = metaMap[key];
      const tr = document.createElement('tr');
      const tdR = document.createElement('td'); tdR.textContent = String(key);
      const tdV = document.createElement('td'); tdV.textContent = m ? String(m.val||0) : '0';
      const tdA = document.createElement('td');
      const delBtn = document.createElement('button'); delBtn.className='btn small danger'; delBtn.textContent='Delete';
      delBtn.disabled = !(m && m.game_id!=null && m.ridx!=null);
      delBtn.onclick = async ()=>{
        if (!confirm(`Delete ${name}'s PB for ${key} (${m.val})?`)) return;
        try{
          await cloudDeleteRound(m.game_id, name, m.ridx);
          await refreshPBGRCloud();
          await renderAll();
          toast('Deleted.');
        }catch(e){ console.error(e); toast('Delete failed'); }
      };
      tdA.appendChild(delBtn);
      tr.append(tdR, tdV, tdA); tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    playerHost.innerHTML = '';
    playerHost.appendChild(table);
  }
  // Backfill PB/WR to cloud tables from current snapshot (saved players, official games only)
  async function backfillPBGRToCloud(){
    // Use the existing snapshot builder; if missing, abort
    const snap = await (typeof getPBGRSnapshot === 'function' ? getPBGRSnapshot() : null);
    if (!snap){ throw new Error('PB/GR snapshot unavailable'); }

    // Map saved player lower-case -> canonical case
    let saved = [];
    try { saved = await cloudListPlayers(); } catch(_){}
    const nameMap = new Map((saved||[]).map(p => [String(p.name).trim().toLowerCase(), String(p.name)]));

    // Build PB rows (per player per category)
    const pbRows = [];
    if (snap.byPlayerMeta && typeof snap.byPlayerMeta.forEach === 'function'){
      snap.byPlayerMeta.forEach((metaMap, nameKey) => {
        const playerName = nameMap.get(nameKey) || nameKey;
        Object.keys(metaMap||{}).forEach(cat => {
          const m = metaMap[cat];
          if (!m || !m.val) return;
          pbRows.push({
            player: playerName,
            cat: String(cat),                 // '10'..'20','D','T','B'
            val: Number(m.val)||0,            // round total
            game_id: m.game_id || null,
            ridx: (typeof m.ridx==='number')?m.ridx:null,
            ts: m.ts || null
          });
        });
      });
    }

    // Build WR rows (global best per category)
    const wrRows = [];
    const meta = snap.byTargetMeta || {};
    Object.keys(meta).forEach(cat => {
      const m = meta[cat];
      if (!m || !m.val) return;
      const proper = nameMap.get(String(m.player||'').trim().toLowerCase()) || m.player || '';
      wrRows.push({
        cat: String(cat),
        val: Number(m.val)||0,
        player: proper,
        game_id: m.game_id || null,
        ridx: (typeof m.ridx==='number')?m.ridx:null,
        ts: m.ts || null
      });
    });

    // Try upsert; if not available (no unique constraint), fallback to delete+insert
    async function tryUpsert(table, rows, conflictCols){
      if (!rows.length) return 0;
      try{
        const { error } = await sb.from(table).upsert(rows, { onConflict: conflictCols });
        if (error) throw error;
        return rows.length;
      }catch(e){
        const keys = (conflictCols||'').split(',').map(s=>s.trim()).filter(Boolean);
        for (const r of rows){
          try{
            const match = {}; keys.forEach(k => { match[k] = r[k]; });
            await sb.from(table).delete().match(match);
          }catch(_){}
          try{ await sb.from(table).insert(r); }catch(_){}
        }
        return rows.length;
      }
    }

    const pbCount = await tryUpsert(TABLE_PB_ROUNDS, pbRows, 'player,cat');
    const wrCount = await tryUpsert(TABLE_WR_ROUNDS, wrRows, 'cat');

    if (typeof markCloudOk === 'function') markCloudOk();
    return { pbRows: pbCount, wrRows: wrCount };
  }
  sel.onchange = ()=>{ const v = sel.value || ''; if (v) renderPlayer(v); else playerHost.innerHTML=''; };

  async function renderAll(){
    await renderGlobal();
    await populatePlayers();
    const v = sel.value || '';
    if (v) await renderPlayer(v); else playerHost.innerHTML='';
  }

  await renderAll();
}

async function cloudDeleteRound(game_id, playerName, round_index){
  const { error } = await sb
    .from(TABLE_GAME_THROWS)
    .delete()
    .eq('game_id', game_id)
    .eq('player', playerName)
    .eq('round_index', round_index);
  if (error) throw error;
  markCloudOk();
}

  // Ensure a 'Recover HS (24h)' button exists and is wired
  (function ensureRecoverHsBtn(){
    const container = hub.querySelector('.modal-body') || hub;
    let btn = document.getElementById('recoverHs24hBtn');
    if (!btn && container) {
      btn = document.createElement('button');
      btn.id = 'recoverHs24hBtn';
      btn.className = 'btn';
      btn.textContent = 'Recover HS (24h)';
      container.appendChild(btn);
    }
    if (btn) {
      btn.onclick = async () => {
        const old = btn.textContent;
        btn.disabled = true; btn.textContent = 'Recovering…';
        try {
          const res = await recoverHighScoresFromCloudWindow(24);
          toast(`Recovered: ${res.inserted} rows (scanned ${res.scanned}, skipped ${res.skipped})`);
        } catch (e) {
          console.error(e);
          toast('Recovery failed — see console');
        } finally {
          btn.disabled = false; btn.textContent = old;
        }
      };
    }
  })();

  // Return
  bind('closeAdminHubBtn', () => { hub.classList.add('hidden'); });
};

// ===== FINAL OVERRIDE: Cloud pill — dot-only indicator =====
// Replaces any previous setCloudStatus to remove text and show a single coloured dot.
window.setCloudStatus = function setCloudStatus(state, msg){
  var el = document.getElementById('cloudStatusPill') ||
           document.getElementById('cloudStatus') ||
           document.querySelector('.cloud-pill');
  if (!el) return;

  // Decide colour
  var root = getComputedStyle(document.documentElement);
  function pick(varName, fallback){ 
    try { 
      var v = root.getPropertyValue(varName); 
      return (v && v.trim()) ? v.trim() : fallback; 
    } catch(_) { return fallback; } 
  }
  var colour = pick('--muted', '#8a8fa6'); // default/checking
  if (state === 'ok' || state === 'connected' || state === 'online') {
    colour = pick('--good', '#7fffd4');
  } else if (state === 'warn' || state === 'checking') {
    colour = pick('--warn', '#ffcc66');
  } else if (state === 'error' || state === 'offline') {
    colour = pick('--danger', '#ff6b6b');
  }

  // Strip pill styling & content → dot only
  el.innerHTML = '';
  el.style.padding = '0';
  el.style.minWidth = '0';
  el.style.background = 'transparent';
  el.style.boxShadow = 'none';
  el.style.border = 'none';
  el.style.display = 'inline-block';

  var dot = document.createElement('span');
  dot.style.display = 'inline-block';
  dot.style.width = '12px';
  dot.style.height = '12px';
  dot.style.borderRadius = '50%';
  dot.style.background = colour;
  dot.title = msg || (state || '');
  el.appendChild(dot);
};

// ===== Match Stats helpers (avg throw/round + perfect rounds) =====
(function(){
  if (window.__matchStatsHelpers) return; // prevent double insert
  window.__matchStatsHelpers = true;

  // Gather all rounds (completed games + current in‑progress) for a player index
  function __iterateAllRoundsForPlayer(playerIdx){
    const acc = [];

    // Completed games in the current match
    const hist = (state && state.match && Array.isArray(state.match.history)) ? state.match.history : [];
    hist.forEach(g => {
      const board = g && g.board && g.board[playerIdx];
      if (!board) return;
      for (let r = 0; r < MAX_ROUNDS; r++){
        const ent = board[r];
        const rd  = ROUNDS[r];
        if (!ent || !rd) continue;
        const darts = Array.isArray(ent.darts) ? ent.darts : [];
        // If roundTotal missing, compute from darts
        const rt = Number(ent.roundTotal ?? darts.reduce((s,d)=> s + Number(d && d.points || 0), 0));
        acc.push({ rd, darts, roundTotal: rt });
      }
    });

    // Current (in‑progress) game
    const curRows = (state && state.score && state.score[playerIdx]) ? state.score[playerIdx] : [];
    for (let r = 0; r < (curRows ? curRows.length : 0); r++){
      const ent = curRows[r];
      const rd  = ROUNDS[r];
      if (!ent || !rd) continue;
      const darts = Array.isArray(ent.darts) ? ent.darts : [];
      const rt = Number(ent.roundTotal ?? darts.reduce((s,d)=> s + Number(d && d.points || 0), 0));
      acc.push({ rd, darts, roundTotal: rt });
    }

    return acc;
  }

  // Public API used by the modal fixer
  window.computeMatchAverages = function computeMatchAverages(){
    const players = (state && Array.isArray(state.players)) ? state.players : [];
    return players.map((_, i) => {
      const rounds = __iterateAllRoundsForPlayer(i);
      let points = 0, throws = 0, perfect = 0;

      rounds.forEach(({ rd, darts, roundTotal }) => {
        const rt = Number(roundTotal || 0);
        points += rt;

        // Count darts actually thrown (includes misses)
        const taken = (darts || []).filter(d => d !== null).length;
        throws += taken;

        // Perfect round = 3 darts, all on the intended target for that round
        // number/doubles/triples: any scoring hit (points > 0) counts
        // bull: only darts with kind === 'Bull' count
        if (taken === 3){
          let allHit = false;
          if (rd.type === 'number' || rd.type === 'doubles' || rd.type === 'triples'){
            allHit = darts.every(d => d && Number(d.points || 0) > 0);
          } else if (rd.type === 'bull') {
            allHit = darts.every(d => d && d.kind === 'Bull');
          }
          if (allHit) perfect++;
        }
      });

      const avgThrow = throws ? (points / throws) : 0;
      const avgRound = avgThrow * 3;
      return { points, throws, avgThrow, avgRound, perfect };
    });
  };
})();
  
// ===== Match Stats modal fixer (remove Avg Last 9, fix avgs, add Perfect Rounds) =====
(function(){
  if (window.__matchStatsModalFixer) return;
  window.__matchStatsModalFixer = true;

  function applyMatchStatsFix(root){
    try{
      // Find a modal with title "Match Stats"
      const modal = root.querySelector('.modal');
      if (!modal) return;
      const h3 = modal.querySelector('h3');
      if (!h3 || !/match stats/i.test((h3.textContent || '').trim())) return;

      const table = modal.querySelector('table');
      const tbody = table && table.querySelector('tbody');
      if (!tbody) return;

      const players = (state && Array.isArray(state.players)) ? state.players : [];
      const P = players.length;
      const stats = (typeof computeMatchAverages === 'function') ? computeMatchAverages() : players.map(()=>({avgThrow:0,avgRound:0,perfect:0}));

      // helpers
      const rows = Array.from(tbody.querySelectorAll('tr'));
      const getRow = (label) => rows.find(tr => (tr.firstElementChild && (tr.firstElementChild.textContent || '').trim().toLowerCase()) === label.toLowerCase());
      const setRowVals = (tr, values, fmt = (v)=>String(v)) => {
        if (!tr) return;
        for (let i = 0; i < P; i++){
          const td = tr.children[1 + i]; // first col is label
          if (td) td.textContent = fmt(values[i] ?? 0);
        }
      };

      // Remove "Avg Last 9" (keep it in Game Stats only)
      const avg9 = getRow('Avg Last 9');
      if (avg9) avg9.remove();

      // Update Avg Throw / Avg Round from computed values
      const rAvgT = getRow('Avg Throw');
      const rAvgR = getRow('Avg Round');
      setRowVals(rAvgT, stats.map(s => s.avgThrow), v => (Number(v)||0).toFixed(1));
      setRowVals(rAvgR, stats.map(s => s.avgRound), v => (Number(v)||0).toFixed(1));

      // Insert "Perfect Rounds" after "Round Streak" (or at the end if not found)
      const afterRow = getRow('Round Streak') || rows[rows.length - 1];
      const existingPR = getRow('Perfect Rounds');
      const valuesPR = stats.map(s => s.perfect);

      if (existingPR) {
        // just update values if it already exists
        setRowVals(existingPR, valuesPR);
      } else {
        // create the row
        const tr = document.createElement('tr');
        const tdLabel = document.createElement('td');
        tdLabel.textContent = 'Perfect Rounds';
        tr.appendChild(tdLabel);
        for (let i = 0; i < P; i++){
          const td = document.createElement('td');
          td.textContent = String(valuesPR[i] || 0);
          tr.appendChild(td);
        }
        if (afterRow && afterRow.parentElement) {
          afterRow.insertAdjacentElement('afterend', tr);
        } else {
          tbody.appendChild(tr);
        }
      }
    } catch(e){
      console.error('applyMatchStatsFix error', e);
    }
  }

  // Observe for modal creation; patch when Match Stats dialog appears
  const mo = new MutationObserver(muts => {
    for (const m of muts){
      for (const n of m.addedNodes){
        if (n.nodeType === 1 && n.classList.contains('modal-backdrop')){
          // let the dialog render, then patch
          setTimeout(() => applyMatchStatsFix(n), 0);
        }
      }
    }
  });
  try { mo.observe(document.body, { childList: true, subtree: true }); } catch(_) {}
})();

// ===== High Scores modals: force compact style (League / Practice / Match / Round) =====
(function(){
  if (window.__hsCompactModalFixer) return;
  window.__hsCompactModalFixer = true;

  function applyHsCompact(root){
    try{
      const modal = root.querySelector('.modal');
      if (!modal) return;
      const h3 = modal.querySelector('h3');
      if (!h3) return;
      const title = (h3.textContent || '').trim().toLowerCase();

      // Any modal titled "High Scores" → compact
      if (title.includes('high scores')) {
        modal.classList.add('compact');
      }
    } catch(e){
      console.error('applyHsCompact error', e);
    }
  }

  const mo = new MutationObserver(muts => {
    for (const m of muts){
      for (const n of m.addedNodes){
        if (n.nodeType === 1 && n.classList.contains('modal-backdrop')){
          // Let the dialog render, then patch
          setTimeout(() => applyHsCompact(n), 0);
        }
      }
    }
  });

  try {
    mo.observe(document.body, { childList: true, subtree: true });
  } catch(_) {}
})();

// ===== PB/GR snapshot + refresh (cloud-first; saved players, official-only) =====
(function(){
  // Build PB/WR from throws; fallback to games.board if needed
  window.getPBGRSnapshot = async function getPBGRSnapshot(){
    try{
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) {
        return { byTargetMeta: {}, byPlayerMeta: new Map() };
      }

      // Saved players only (case-insensitive)
      let saved = [];
      try { saved = await (typeof cloudListPlayers === 'function' ? cloudListPlayers() : []); } catch(_){}
      const savedSet = new Set((saved||[]).map(p => String(p?.name || '').trim().toLowerCase()));
      const canonical = new Map((saved||[]).map(p => [String(p?.name || '').trim().toLowerCase(), String(p?.name || '')]));

      function catForRoundIdx(r){
        const rd = (typeof ROUNDS !== 'undefined') ? ROUNDS[r] : null;
        if (!rd) return null;
        if (rd.type === 'number')  return String(rd.target);
        if (rd.type === 'doubles') return 'D';
        if (rd.type === 'triples') return 'T';
        if (rd.type === 'bull')    return 'B';
        return null;
      }
      function preferNew(cur, val, ts){
        if (!cur) return true;
        if (val > (cur.val || 0)) return true;
        if (val < (cur.val || 0)) return false;
        if (ts && cur.ts) return new Date(ts) < new Date(cur.ts);
        return false;
      }

      const byPlayerMeta = new Map(); // nameKey -> { cat -> { val, ts, game_id, ridx } }
      const byTargetMeta = {};        // cat -> { val, player, ts, game_id, ridx }
      function updatePB(nameKey, cat, val, ts, game_id, ridx){
        let m = byPlayerMeta.get(nameKey); if (!m){ m={}; byPlayerMeta.set(nameKey,m); }
        const cur = m[cat];
        if (preferNew(cur, val, ts)) m[cat] = { val:Number(val)||0, ts:ts||null, game_id:game_id??null, ridx:(typeof ridx==='number'?ridx:null) };
      }
      function updateWR(cat, playerName, val, ts, game_id, ridx){
        const cur = byTargetMeta[cat];
        if (preferNew(cur, val, ts)) byTargetMeta[cat] = { val:Number(val)||0, player:String(playerName||''), ts:ts||null, game_id:game_id??null, ridx:(typeof ridx==='number'?ridx:null) };
      }

      // 1) OFFICIAL games (2+ players) → ids + timestamps
      let gameRows = [];
      try{
        const { data, error } = await sb.from(TABLE_GAMES)
          .select('id, created_at, state')
          .order('created_at', { ascending: true });
        if (error) throw error;
        gameRows = (data||[]).filter(g => Array.isArray(g?.state?.players) && g.state.players.length >= 2);
      }catch(e){ console.error('getPBGRSnapshot: fetch games failed', e); }

      const gameMeta = new Map();
      const officialIds = [];
      for (const g of gameRows){
        if (g?.id == null) continue;
        gameMeta.set(g.id, { ts: g.created_at || null, players: (g?.state?.players||[]).map(p => (typeof p==='string'?{name:p}:p)) });
        officialIds.push(g.id);
      }

      // 2) Prefer throws-table path
      if (officialIds.length){
        let throwsRows = [];
        try{
          const { data, error } = await sb.from(TABLE_GAME_THROWS)
            .select('game_id, player, round_index, dart_index, points, kind')
            .in('game_id', officialIds)
            .order('game_id', { ascending: true })
            .order('round_index', { ascending: true })
            .order('dart_index', { ascending: true });
          if (error) throw error;
          throwsRows = data || [];
        }catch(e){ console.error('getPBGRSnapshot: throws fetch failed (falling back)', e); }

        if (throwsRows.length){
          const byKey = new Map(); // gid|playerLC|ridx -> {points, meta}
          for (const t of throwsRows){
            const gm = gameMeta.get(t.game_id); if (!gm) continue;
            const plc = String(t?.player||'').trim().toLowerCase();
            if (!savedSet.has(plc)) continue;
            const key = `${t.game_id}|${plc}|${t.round_index}`;
            let rec = byKey.get(key);
            if (!rec){
              rec = { game_id:t.game_id, ridx:Number(t.round_index||0), playerLC:plc, player: canonical.get(plc) || t.player || '', ts: gm.ts, points:0 };
              byKey.set(key, rec);
            }
            rec.points += Number(t.points||0);
          }
          for (const rec of byKey.values()){
            const cat = catForRoundIdx(rec.ridx); if (!cat) continue;
            const val = Number(rec.points||0); if (val <= 0) continue;
            updatePB(rec.playerLC, cat, val, rec.ts, rec.game_id, rec.ridx);
            updateWR(cat, rec.player, val, rec.ts, rec.game_id, rec.ridx);
          }
          return { byTargetMeta, byPlayerMeta };
        }
      }

      // 3) Fallback: compute from games.state.board
      for (const g of gameRows){
        const ts = g?.created_at || null;
        const players = (g?.state?.players||[]).map(p => (typeof p==='string'?{name:p}:p));
        const board = g?.state?.board || null;
        if (!Array.isArray(players) || !board) continue;
        for (let p = 0; p < players.length; p++){
          const name = players[p]?.name || '';
          const key  = name.trim().toLowerCase();
          if (!savedSet.has(key)) continue;
          const rows = board[p] || [];
          const maxR = (typeof MAX_ROUNDS==='number') ? Math.min(MAX_ROUNDS, rows.length) : rows.length;
          for (let r = 0; r < maxR; r++){
            const cat = catForRoundIdx(r); if (!cat) continue;
            const ent = rows[r] || {};
            let val = Number(ent.roundTotal ?? 0);
            if (!val && Array.isArray(ent.darts)) val = ent.darts.reduce((s,d)=> s + Number(d && d.points || 0), 0);
            if (val <= 0) continue;
            updatePB(key, cat, val, ts, g.id ?? null, r);
            updateWR(cat, name, val, ts, g.id ?? null, r);
          }
        }
      }
      return { byTargetMeta, byPlayerMeta };
    } catch (e){
      console.error('getPBGRSnapshot failed', e);
      return { byTargetMeta: {}, byPlayerMeta: new Map() };
    }
  };

  window.refreshPBGRCloud = async function refreshPBGRCloud(){
    try { window.__pbgrSnapshot = await window.getPBGRSnapshot(); return window.__pbgrSnapshot; }
    catch(e){ console.error('refreshPBGRCloud failed', e); return null; }
  };
})();

// High Score League — per-player best match score, rows clickable to open game
window.openHighScoreLeagueDialog = async function openHighScoreLeagueDialog() {
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); 
  modal.className = 'modal compact';
  const title   = document.createElement('h3');  title.textContent = 'High Score League — Best Match Score';
  const body    = document.createElement('div'); body.className    = 'modal-body';
  const footer  = document.createElement('div'); footer.className  = 'modal-footer';

  // When a league row is clicked, try to find & open the underlying game
  async function openGameForHighScore(row) {
    try {
      let games = [];
      if (typeof cloudFetchAllGamesAsLocal === 'function') {
        games = await cloudFetchAllGamesAsLocal();
      } else if (typeof ensureCloudInit === 'function' && ensureCloudInit()) {
        const table = (typeof TABLE_GAMES !== 'undefined' ? TABLE_GAMES : 'games');
        const { data } = await sb
          .from(table)
          .select('*')
          .order('created_at', { ascending: false })
          .limit(2000);
        games = data || [];
      }

      if (!Array.isArray(games) || !games.length) {
        if (typeof toast === 'function') toast('No games available to look up.');
        return;
      }

      const targetNameLC = String(row.name || '').trim().toLowerCase();
      const targetScore  = Number(row.score || 0);
      const rowTs        = row.ts || row.created_at || row.inserted_at || null;
      const rowTime      = rowTs ? new Date(rowTs).getTime() : null;

      let bestMatch = null;

      games.forEach(g => {
        const players = (g.players || []).map(p =>
          (p && p.name) ? p.name : String(p || '')
        );
        const idx = players.findIndex(n =>
          String(n || '').trim().toLowerCase() === targetNameLC
        );
        if (idx < 0) return;

        const totals = Array.isArray(g.totals) ? g.totals : [];
        const score  = Number(totals[idx] || 0);
        if (score !== targetScore) return;

        const gTsVal = g.ts || g.created_at || g.inserted_at ||
                       (g.meta && (g.meta.ts || g.meta.date)) || null;
        const gTime  = gTsVal ? new Date(gTsVal).getTime() : null;

        let penalty = 0;
        if (rowTime != null && gTime != null) {
          penalty = Math.abs(gTime - rowTime);      // smaller = closer in time
        }

        const cand = { game: g, penalty };
        if (!bestMatch || cand.penalty < bestMatch.penalty) {
          bestMatch = cand;
        }
      });

      if (!bestMatch) {
        if (typeof toast === 'function') toast('Could not locate game for this high score.');
        return;
      }

      if (typeof openSingleGameScoreSheet === 'function') {
        openSingleGameScoreSheet(bestMatch.game);
      }
    } catch (e) {
      console.error('openGameForHighScore failed', e);
      if (typeof toast === 'function') toast('Unable to open game for this high score.');
    }
  }

  async function render() {
    body.innerHTML = '';

    let rows = [];
    try {
      if (typeof cloudListHighScores === 'function') {
        // false → league (not practice), pull a generous number of rows
        rows = await cloudListHighScores(false, 2000);
      } else {
        if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) {
          throw new Error('Cloud not initialised');
        }
        const table = (typeof TABLE_HS_LEAGUE !== 'undefined' ? TABLE_HS_LEAGUE : 'high_scores');
        const { data, error } = await sb
          .from(table)
          .select('name, score, ts')
          .order('score', { ascending: false })
          .order('ts',    { ascending: true })
          .limit(2000);
        if (error) throw error;
        rows = data || [];
      }
    } catch (e) {
      console.error('High Score League fetch failed', e);
      const p = document.createElement('p');
      p.textContent = 'Failed to load high score league.';
      body.appendChild(p);
      return;
    }
    
        // Restrict to saved players only, if we can fetch them
    try {
      if (typeof cloudListPlayers === 'function') {
        const saved = await cloudListPlayers();
        const savedSet = new Set(
          (saved || [])
            .map(p => (p && p.name ? String(p.name).trim().toLowerCase() : ''))
            .filter(Boolean)
        );
        rows = (rows || []).filter(r => {
          const nameLC = String(r.name || '').trim().toLowerCase();
          return nameLC && savedSet.has(nameLC);
        });
      }
    } catch (_) {}

    if (!Array.isArray(rows) || !rows.length) {
      const p = document.createElement('p');
      p.textContent = 'No high scores logged yet.';
      body.appendChild(p);
      return;
    }

    // Pick the single best row per player (highest score, then earliest ts)
    const bestByPlayer = new Map();
    rows.forEach(r => {
      const name = String(r.name || '').trim();
      if (!name) return;
      const key = name.toLowerCase();
      const ts  = r.ts || r.created_at || r.inserted_at || null;
      const score = Number(r.score || 0);

      const cur = bestByPlayer.get(key);
      if (!cur) {
        bestByPlayer.set(key, { name, score, ts, raw: r });
      } else {
        const curScore = Number(cur.score || 0);
        if (
          score > curScore ||
          (score === curScore && ts && cur.ts && new Date(ts) < new Date(cur.ts))
        ) {
          bestByPlayer.set(key, { name, score, ts, raw: r });
        }
      }
    });

    const league = Array.from(bestByPlayer.values()).sort((a, b) => {
      const ds = Number(b.score || 0) - Number(a.score || 0);
      if (ds !== 0) return ds;
      const at = a.ts ? new Date(a.ts).getTime() : 0;
      const bt = b.ts ? new Date(b.ts).getTime() : 0;
      return at - bt;
    });

    const table = document.createElement('table');
    table.className = 'hs-table hs-league-table';

    const colgroup = document.createElement('colgroup');
const colNum   = document.createElement('col');  colNum.style.width  = '3.5ch';
    const colName  = document.createElement('col');  colName.style.width = '10ch';
    const colScore = document.createElement('col');  colScore.style.width = '7ch';
    const colWhen  = document.createElement('col');
    colgroup.append(colNum, colName, colScore, colWhen);
    table.appendChild(colgroup);

    const thead = document.createElement('thead');
    const trh   = document.createElement('tr');
    ['#', 'Player', 'High Score', 'When'].forEach(h => {
      const th = document.createElement('th');
      th.textContent = h;
      trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');

    league.forEach((row, idx) => {
      const tr = document.createElement('tr');

      const tdRank  = document.createElement('td');
      const tdName  = document.createElement('td');
      const tdScore = document.createElement('td');
      const tdWhen  = document.createElement('td');

      tdRank.textContent  = String(idx + 1);
      tdName.textContent  = row.name || '';
      tdScore.textContent = String(row.score || 0);
      if (row.ts && typeof window.fmtWhen === 'function') {
        tdWhen.textContent = window.fmtWhen(row.ts);
      } else {
        tdWhen.textContent = '';
      }

      tr.append(tdRank, tdName, tdScore, tdWhen);

      // Make the row clickable to open the game
      tr.style.cursor = 'pointer';
      tr.title = 'Open the game where this score was hit';
      tr.onclick = () => { openGameForHighScore(row); };

      tbody.appendChild(tr);
    });

    table.appendChild(tbody);

    const wrap = document.createElement('div');
    wrap.className = 'table-wrap';
    wrap.appendChild(table);
    body.appendChild(wrap);
  }

  await render();

  const backBtn  = document.createElement('button'); backBtn.className  = 'btn'; backBtn.textContent  = 'Back';
  const closeBtn = document.createElement('button'); closeBtn.className = 'btn'; closeBtn.textContent = 'Close';
  backBtn.onclick  = () => overlay.remove();
  closeBtn.onclick = () => overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
  modal.tabIndex = 0;
  modal.focus();
};

// ---- one-time error banner (shows first JS crash) ----
(function attachFirstErrorBanner(){
  if (window.__errorBannerAttached) return;
  window.__errorBannerAttached = true;
  window.addEventListener('error', function(ev){
    try {
      if (document.getElementById('firstErrorBanner')) return;
      const b = document.createElement('div');
      b.id = 'firstErrorBanner';
      b.style.cssText = 'position:fixed;left:8px;right:8px;top:8px;z-index:99999;padding:8px 10px;border-radius:6px;background:#400;color:#fff;font:12px/1.4 system-ui';
      b.textContent = 'JS error: ' + (ev.message || 'unknown') + (ev.filename?(' @ '+ev.filename+':'+ev.lineno):'');
      document.body.appendChild(b);
      setTimeout(()=>{ if(b && b.parentNode) b.parentNode.removeChild(b); }, 6000);
    } catch(_) {}
  });
})();

// League / Rankings popup (Power League + High Score League)
window.openLeagueRankingsDialog = async function openLeagueRankingsDialog(){
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal';
  const body    = document.createElement('div'); body.className    = 'modal-body';
  const footer  = document.createElement('div'); footer.className  = 'modal-footer';

  // Column container for the two league options
  const col = document.createElement('div');
  col.className = 'column';
  col.style.alignItems = 'center';
  col.style.gap = '10px';

  // Power Rankings button + description
  const powerBtn = document.createElement('button');
  powerBtn.id = 'powerRankingsBtn';
  powerBtn.className = 'btn';
  powerBtn.type = 'button';
  powerBtn.style.width = 'min(360px,92%)';
  powerBtn.textContent = 'Power Rankings';

  const powerP = document.createElement('p');
  powerP.className = 'tag';
  powerP.textContent = 'Form Guide';
  powerP.style.width = powerBtn.style.width;
  powerP.style.textAlign = 'center';
  
    // Premier League button + description
  const premierBtn = document.createElement('button');
  premierBtn.id = 'premierLeagueBtn';
  premierBtn.className = 'btn';
  premierBtn.type = 'button';
  premierBtn.style.width = 'min(360px,92%)';
  premierBtn.textContent = 'Premier League';

  const premierP = document.createElement('p');
  premierP.className = 'tag';
  premierP.textContent = 'Monthly Highest Average League';
  premierP.style.width = premierBtn.style.width;
  premierP.style.textAlign = 'center';

  // High Score League button + description
  const highBtn = document.createElement('button');
  highBtn.id = 'highScoreLeagueBtn';
  highBtn.className = 'btn';
  highBtn.type = 'button';
  highBtn.style.width = 'min(360px,92%)';
  highBtn.textContent = 'High Score League';

  const highP = document.createElement('p');
  highP.className = 'tag';
  highP.textContent = 'Each Players PBs';
  highP.style.width = highBtn.style.width;
  highP.style.textAlign = 'center';

  col.appendChild(powerBtn);
  col.appendChild(powerP);
  col.appendChild(premierBtn);
  col.appendChild(premierP);
  col.appendChild(highBtn);
  col.appendChild(highP);
  body.appendChild(col);

  // Footer: Back / Close
  const backBtn  = document.createElement('button');
  backBtn.className  = 'btn';
  backBtn.textContent  = 'Back';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';

  backBtn.onclick  = () => overlay.remove();
  closeBtn.onclick = () => overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
  modal.tabIndex = 0;
  modal.focus();

  // Wire buttons to dialogs
  powerBtn.onclick = () => {
    overlay.remove();
    if (typeof window.openPowerLeagueDialog === 'function') {
      window.openPowerLeagueDialog();
    }
  };

  premierBtn.onclick = () => {
    overlay.remove();
    if (typeof window.openPremierLeagueDialog === 'function') {
      window.openPremierLeagueDialog();
    }
  };

  highBtn.onclick = () => {
    overlay.remove();
    if (typeof window.openHighScoreLeagueDialog === 'function') {
      window.openHighScoreLeagueDialog();
    }
  };
};

// === Power Rankings — official only (hard cap + min sample; grey-out unqualified) ===
window.openPowerLeagueDialog = async function openPowerLeagueDialog(){
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal compact';

  // Config
  const LIMIT = 50;      // hard cap window
  const MIN_ROUNDS = 15; // threshold for "qualified" status

  const title   = document.createElement('h3');
  title.textContent = `Power Rankings — Last ${LIMIT} Rounds (Official)`;
  const body    = document.createElement('div'); body.className    = 'modal-body';
  const footer  = document.createElement('div'); footer.className  = 'modal-footer';

  // Footer buttons
  const backBtn  = document.createElement('button');
  backBtn.className  = 'btn';
  backBtn.textContent  = 'Back';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';

  backBtn.onclick  = () => {
    overlay.remove();
    if (typeof window.openLeagueRankingsDialog === 'function') {
      window.openLeagueRankingsDialog();
    }
  };
  closeBtn.onclick = () => overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
  modal.tabIndex = 0;
  modal.focus();

 async function computePowerLeagueRows(){
  // Guard cloud
  try { if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) throw new Error('Cloud not initialised'); } catch(_) {}

if (typeof sb === 'undefined'
    || typeof TABLE_GAMES === 'undefined'
    || typeof TABLE_GAME_THROWS === 'undefined'
    || typeof TABLE_PLAYER_GAMES === 'undefined') {
  throw new Error('Cloud tables not configured');
}

  // Saved players (case-insensitive)
  let saved = [];
  try { if (typeof cloudListPlayers === 'function') saved = await cloudListPlayers(); } catch(_){}
  const savedSet = new Set(
    (saved || []).map(p => (p && p.name ? String(p.name).trim().toLowerCase() : '')).filter(Boolean)
  );
  const canonical = new Map((saved || []).map(p => [String(p.name).trim().toLowerCase(), String(p.name)]));

  // 1) Fetch OFFICIAL games (2+ players), oldest → newest
  let gameRows = [];
  try{
    const { data, error } = await sb
      .from(TABLE_GAMES)
      .select('id, created_at, state')
      .order('created_at', { ascending: true })
      .limit(5000);
    if (error) throw error;
    gameRows = (data || []).filter(g => Array.isArray(g?.state?.players) && g.state.players.length >= 2);
  } catch(e){
    console.error('Power League: fetch games failed', e);
    throw new Error('Failed to fetch games for Power League');
  }

  if (!gameRows.length) return [];

  const gameMeta = new Map(); // id -> { ts, players:[{name}] }
  const officialIds = [];
  for (const g of gameRows){
    if (g?.id == null) continue;
    officialIds.push(g.id);
    const players = (g?.state?.players || []).map(p => (typeof p === 'string' ? { name: p } : p));
    gameMeta.set(g.id, { ts: g.created_at || null, players });
  }

// 2) Build ROUNDS list, prefer THROWS; fallback to PLAYER_GAMES

// Helper: fetch throws in small chunks to avoid URL length / IN() limits
async function fetchThrowsForGamesChunked(ids, chunkSize = 200){
  const all = [];
  for (let i = 0; i < ids.length; i += chunkSize) {
    const slice = ids.slice(i, i + chunkSize);
    const { data, error } = await sb
      .from(TABLE_GAME_THROWS)
      .select('game_id, player, round_index, dart_index, points, kind')
      .in('game_id', slice)
      .order('game_id',   { ascending: true })
      .order('round_index',{ ascending: true })
      .order('dart_index',{ ascending: true });
    if (error) throw error;
    all.push(...(data || []));
  }
  return all;
}

let roundsList = [];

// Try THROWS first
try {
  const throwsRows = await fetchThrowsForGamesChunked(officialIds);

  if (throwsRows.length) {
    // Group throws → rounds
    const byRoundKey = new Map();
    for (const t of throwsRows){
      const plc = String(t?.player || '').trim().toLowerCase();
      if (savedSet.size && !savedSet.has(plc)) continue;

      const ridx = (typeof t.round_index === 'number') ? t.round_index : null;
      if (ridx == null || ridx < 0 || ridx > 13) continue; // 10..20, D, T, B

      const key = `${t.game_id}|${plc}|${ridx}`;
      let rec = byRoundKey.get(key);
      if (!rec){
        const gm = gameMeta.get(t.game_id) || {};
        const proper = canonical.get(plc) || t.player || '';
        rec = { gid: t.game_id, ts: gm.ts || null, name: proper, playerLC: plc, ridx, total: 0 };
        byRoundKey.set(key, rec);
      }
      rec.total += Number(t.points || 0); // includes D/T/B naturally
    }

    roundsList = Array.from(byRoundKey.values());
  }
} catch (e) {
  console.error('Power League: throws fetch failed (will fallback)', e);
}

// Fallback: build approximate rounds from player_games if no throws
if (!roundsList.length) {
  try {
    const { data, error } = await sb
      .from(TABLE_PLAYER_GAMES)
      .select('player, score, rounds, ts, is_practice')
      .eq('is_practice', false)
      .order('ts', { ascending: true })
      .limit(20000);
    if (error) throw error;

    const pgRows = data || [];
    for (const r of pgRows){
      const name = String(r.player || '').trim();
      if (!name) continue;
      const plc = name.toLowerCase();
      if (savedSet.size && !savedSet.has(plc)) continue;

      let rounds = Number(r.rounds || 0);
      const score = Number(r.score || 0);
      if (!Number.isFinite(score)) continue;

      // Treat a full game as 14 rounds (11 + D + T + B)
      if (rounds >= 11) rounds = Math.min(14, rounds + 3);
      if (rounds <= 0) continue;

      const perRound = score / rounds;
      for (let i = 0; i < rounds; i++){
        roundsList.push({
          gid: null,
          ts: r.ts || null,
          name,
          playerLC: plc,
          ridx: i,
          total: perRound
        });
      }
    }
  } catch (e) {
    console.error('Power League: fallback player_games fetch failed', e);
    // keep roundsList empty → UI will show the "No official games..." message later
  }
}

if (!roundsList.length) return []; // nothing to compute

 // 4) Chronologically order rounds (oldest → newest)
roundsList.sort((a, b) => {
  const ta = a.ts ? Date.parse(a.ts) : 0;
  const tb = b.ts ? Date.parse(b.ts) : 0;
  if (ta !== tb) return ta - tb;
  if (a.gid !== b.gid) return (a.gid < b.gid ? -1 : 1);
  return a.ridx - b.ridx;
});

  // 5) Build per-player rolling window of LAST 50 ROUNDS
  const byPlayer = new Map(); // nameLC -> { name, buf:number[], lastTs }
  for (const r of roundsList){
    const key = r.playerLC;
    let rec = byPlayer.get(key);
    if (!rec){
      rec = { name: r.name, buf: [], lastTs: null };
      byPlayer.set(key, rec);
    }
    rec.buf.push(Number(r.total || 0));
    while (rec.buf.length > LIMIT) rec.buf.shift(); // hard cap at 50 rounds
    if (r.ts) rec.lastTs = r.ts;
  }

  // 6) Compute outputs
  const out = [];
  for (const [key, rec] of byPlayer){
    const count = Math.min(LIMIT, rec.buf.length);
    if (count <= 0) continue;

    const total = rec.buf.reduce((s, v) => s + v, 0);
    const avg   = total / count;
    const qualifies = count >= MIN_ROUNDS;

    // Use canonical casing when available
    const name = canonical.get(key) || rec.name || '—';
    out.push({ name, rounds: count, avg, ts: rec.lastTs || null, qualifies });
  }

  // 7) Sort: qualified first (ranked), then unqualified (grey/unranked)
  out.sort((a, b) => {
    if (a.qualifies !== b.qualifies) return a.qualifies ? -1 : 1;
    if (b.avg !== a.avg) return b.avg - a.avg;
    if ((b.rounds || 0) !== (a.rounds || 0)) return (b.rounds || 0) - (a.rounds || 0);
    const ta = a.ts ? Date.parse(a.ts) : 0;
    const tb = b.ts ? Date.parse(b.ts) : 0;
    if (tb !== ta) return tb - ta;
    return String(a.name || '').localeCompare(String(b.name || ''));
  });

  return out;
}

  async function render(){
    body.innerHTML = '<p class="tag">Loading Power League…</p>';

    let rows = [];
    try {
      rows = await computePowerLeagueRows();
    } catch (e) {
      console.error(e);
      body.innerHTML = `<p>${(e && e.message) ? e.message : 'Failed to load Power League.'}</p>`;
      return;
    }

    if (!rows.length) {
      body.innerHTML = '<p>No official games found for any saved players yet.</p>';
      return;
    }

    const note = document.createElement('p');
    note.className = 'tag';
    if (rows.some(r => !r.qualifies)) {
      note.textContent = `Players with fewer than ${MIN_ROUNDS} rounds (1 game + 1 round) are greyed out and unranked.`;
      body.innerHTML = '';
      body.appendChild(note);
    } else {
      body.innerHTML = '';
    }

    const table = document.createElement('table');
    table.className = 'hs-table';

    const thead = document.createElement('thead');
    const trh   = document.createElement('tr');
    ['#','Player',`Rounds (up to ${LIMIT})`,'Avg / Round'].forEach(h => {
      const th = document.createElement('th');
      th.textContent = h;
      trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);
    
    // -- rank change arrows (persisted since last open) --
const LS_KEY = 'powerLeague.lastRanks';
let prevRanks = new Map();
try {
  const raw = localStorage.getItem(LS_KEY);
  if (raw) {
    const obj = JSON.parse(raw);
    if (obj && obj.ranks && typeof obj.ranks === 'object') {
      prevRanks = new Map(Object.entries(obj.ranks)); // nameLC -> rank (1-based)
    }
  }
} catch (_) {}

    const tbody = document.createElement('tbody');

// rank only qualified rows
let rankCounter = 0;
const currRanksObj = {}; // nameLC -> rank

rows.forEach((row) => {
  const tr = document.createElement('tr');

  // Grey-out (and unrank) unqualified rows
  const unq = !row.qualifies;
  if (unq) {
    tr.classList.add('muted');
    tr.style.opacity = '0.6';
    const need = Math.max(0, MIN_ROUNDS - (row.rounds || 0));
    tr.title = need ? `Needs ${need} more round${need===1?'':'s'} to qualify` : `Below ${MIN_ROUNDS} rounds`;
  }

  // Determine current rank (qualified only)
  const currentRank = unq ? null : (++rankCounter);

  const tdRank   = document.createElement('td');
  tdRank.textContent = unq ? '—' : String(currentRank);

  const tdName   = document.createElement('td');
  tdName.textContent = row.name || '—';

  // Append green/red arrow if rank changed since last snapshot
  const keyLC = String(row.name || '').trim().toLowerCase();
  if (!unq && keyLC) {
    const prev = prevRanks.get(keyLC);
    if (typeof prev === 'number' && Number.isFinite(prev) && prev !== currentRank) {
      const up = prev > currentRank; // improved if current rank number is smaller
      const arrow = document.createElement('span');
      arrow.textContent = up ? '▲' : '▼';
      arrow.style.marginLeft = '6px';
      arrow.style.color = up ? '#7fffd4' : '#ff6b6b';
      arrow.title = up ? `Up ${prev - currentRank}` : `Down ${currentRank - prev}`;
      tdName.appendChild(arrow);
    }
    // record current rank for persistence
    currRanksObj[keyLC] = currentRank;
  }

  const tdRounds = document.createElement('td'); tdRounds.textContent = String(row.rounds); // capped count
  const tdAvg    = document.createElement('td'); tdAvg.textContent    = (Number(row.avg)||0).toFixed(2);

  tr.append(tdRank, tdName, tdRounds, tdAvg);
  tbody.appendChild(tr);
});

    table.appendChild(tbody);


    const wrap = document.createElement('div');
    wrap.className = 'table-wrap';
    wrap.appendChild(table);

// Persist current ranks snapshot for next comparison
try {
  localStorage.setItem(LS_KEY, JSON.stringify({
    ts: new Date().toISOString(),
    ranks: currRanksObj
  }));
} catch (_) {}

    body.appendChild(wrap);
  }

  await render();
};

// Premier League popup – average match total per player, with month filters
window.openPremierLeagueDialog = async function openPremierLeagueDialog() {
  const overlay = document.createElement('div');
  overlay.className = 'modal-backdrop';

  const modal = document.createElement('div');
  modal.className = 'modal compact';

  const title = document.createElement('h3');
  title.textContent = 'Premier League';

  const body = document.createElement('div');
  body.className = 'modal-body';
  
  // Lock outer modal — let only the inner table scroll
modal.style.maxHeight = '90vh';
modal.style.overflow = 'hidden';
body.style.maxHeight = 'none';
body.style.overflowY = 'visible';

  const footer = document.createElement('div');
  footer.className = 'modal-footer';

  // Filter row + table mount
  const filterRow = document.createElement('div');
  filterRow.className = 'row';
  filterRow.style.marginBottom = '8px';

  const tableMount = document.createElement('div');
  tableMount.className = 'table-wrap';

  body.appendChild(filterRow);
  body.appendChild(tableMount);

  // Footer buttons
  const backBtn = document.createElement('button');
  backBtn.className = 'btn';
  backBtn.textContent = 'Back';

  const closeBtn = document.createElement('button');
  closeBtn.className = 'btn';
  closeBtn.textContent = 'Close';

  backBtn.onclick = () => {
    overlay.remove();
    if (typeof window.openLeagueRankingsDialog === 'function') {
      window.openLeagueRankingsDialog();
    }
  };

  closeBtn.onclick = () => {
    overlay.remove();
  };

  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) overlay.remove();
  });

  overlay.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') overlay.remove();
  });

  modal.tabIndex = 0;
  modal.focus();

  // --- Data helpers ---

  async function fetchRows() {
    try {
      if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) {
        tableMount.innerHTML = '<p>Cloud not initialised.</p>';
        return [];
      }
    } catch (_) {}

    tableMount.innerHTML = '<p class="tag">Loading Premier League…</p>';

    try {
      const { data, error } = await sb
        .from(TABLE_PLAYER_GAMES)
        .select('player, score, ts, is_practice')
        .eq('is_practice', false)
        .order('player', { ascending: true })
        .order('ts', { ascending: true })
        .limit(5000);
      if (error) throw error;

      let rows = data || [];

      // Restrict to saved players only, if available
      try {
        if (typeof cloudListPlayers === 'function') {
          const saved = await cloudListPlayers();
          const savedSet = new Set(
            (saved || [])
              .map(p => (p && p.name ? String(p.name).trim().toLowerCase() : ''))
              .filter(Boolean)
          );
          rows = rows.filter(r => {
            const nameLC = String(r.player || '').trim().toLowerCase();
            return nameLC && savedSet.has(nameLC);
          });
        }
      } catch (_) {}

      return rows;
    } catch (e) {
      console.error('Premier League fetch failed', e);
      tableMount.innerHTML = '<p>Failed to load Premier League.</p>';
      return [];
    }
  }

  function buildFilters() {
    const filters = [];
    
      // RECORDS (new tab)
  filters.push({
    id: 'RECORDS',
    label: 'RECORDS',
    match: () => true
  });

    // ALL TIME
    filters.push({
      id: 'ALL',
      label: 'ALL TIME',
      match: () => true
    });

       const now = new Date();
    for (let i = 0; i < 6; i++) {
      const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
      const month = d.getMonth();   // 0–11
      const year = d.getFullYear();
      const label = d.toLocaleString('en-GB', { month: 'short' }).toUpperCase();

      filters.push({
        id: `${year}-${month}`,
        label,
        match: (ts) => {
          if (!ts) return false;
          const dt = new Date(ts);
          if (Number.isNaN(dt.getTime())) return false;
          return dt.getFullYear() === year && dt.getMonth() === month;
        }
      });
    }

    return filters;
  }

  function renderFilters(filters, onChange) {
    filterRow.innerHTML = '';
    const buttons = [];

  filters.forEach((f) => {
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.className = 'btn small';
  btn.textContent = (f.id === 'ALL') ? 'ALL TIME' : f.label;
  btn.dataset.filterId = f.id;
  filterRow.appendChild(btn);
  buttons.push(btn);

  btn.onclick = () => {
    buttons.forEach(b => b.classList.remove('primary'));
    btn.classList.add('primary');
    onChange(f);
  };
});

// Default highlight = ALL TIME
const allBtn = buttons.find(b => b.dataset.filterId === 'ALL');
if (allBtn) allBtn.classList.add('primary');
  }
  
  function renderRecords(rows){
  // Clear host
  tableMount.innerHTML = '';

// Records thresholds (RECORDS only)
const MIN_MONTHLY_GAMES = 3;
const MIN_ALLTIME_GAMES = 15; // Highest All Time Averages require 15+ games
const wrap = document.createElement('div');
  wrap.className = 'table-wrap';

  // small helper
  const monthLabel = (ts)=>{
    const d = ts ? new Date(ts) : null;
    if (!d || Number.isNaN(d.getTime())) return '';
    return d.toLocaleString('en-GB', { month:'short', year:'numeric' }).toUpperCase();
  };

  // ---------- Highest Score (top 3 distinct) ----------
  const topBest = (() => {
    const ordered = (rows || [])
      .map(r => ({ name: String(r.player||'').trim(), score: Number(r.score||0), ts: r.ts }))
      .filter(x => x.name && Number.isFinite(x.score))
      .sort((a,b) => (b.score - a.score) || (new Date(a.ts) - new Date(b.ts)));
    const seen = new Set(); const out = [];
    for (const r of ordered){
      if (!seen.has(r.score)) { seen.add(r.score); out.push(r); }
      if (out.length === 3) break;
    }
    return out;
  })();

  // ---------- Highest Monthly Average (top 3 distinct) ----------
  const topMonthlyAvg = (() => {
    const agg = new Map(); // key: name|YYYY-M -> {total,games,tsAny}
    rows.forEach(r=>{
      const name = String(r.player||'').trim();
      const d = r.ts ? new Date(r.ts) : null;
      if (!name || !d || Number.isNaN(d.getTime())) return;
      const key = `${name}|${d.getFullYear()}-${d.getMonth()}`;
      const a = agg.get(key) || { total:0, games:0, ts:r.ts };
      a.total += Number(r.score||0); a.games += 1; if (!a.ts) a.ts = r.ts;
      agg.set(key, a);
    });
  let rowsM = [];
  agg.forEach((v, key)=>{
    const [name, ym] = key.split('|');
    const avg = v.games ? v.total / v.games : 0;
    rowsM.push({ name, avg, ts: v.ts, ym, games: v.games });
  });

  // Require at least 3 games in that month
  rowsM = rowsM.filter(r => (r.games || 0) >= MIN_MONTHLY_GAMES);

  rowsM.sort((a,b)=> (b.avg - a.avg) || (new Date(a.ts) - new Date(b.ts)));
  const seen = new Set(); const out = [];
  for (const r of rowsM){
    const k = r.avg.toFixed(3);
    if (!seen.has(k)) { seen.add(k); out.push(r); }
    if (out.length === 3) break;
  }
  return out;
})();
  
// ---------- Highest All Time Averages (top 3 distinct) ----------
const topCareerAvg = (() => {
  const agg = new Map(); // name -> { total, games, ts }

  (rows || []).forEach(r => {
    const name = String(r.player || '').trim();
    const sc = Number(r.score || 0);
    if (!name || !Number.isFinite(sc)) return;

    const ts = r.ts || r.created_at || r.inserted_at || null;
    const a = agg.get(name) || { total: 0, games: 0, firstTs: null, lastTs: null };

    a.total += sc;
    a.games += 1;

    if (!a.firstTs || (ts && new Date(ts) < new Date(a.firstTs))) a.firstTs = ts;
    if (!a.lastTs  || (ts && new Date(ts) > new Date(a.lastTs)))  a.lastTs  = ts;

    agg.set(name, a);
  });

 let list = [];
   agg.forEach((v, name) => {
    const avg = v.games ? v.total / v.games : 0;
      list.push({ name, avg, ts: v.lastTs, games: v.games });

  });
  // Require at least 5 career games
  list = list.filter(r => (r.games || 0) >= MIN_ALLTIME_GAMES);


  // Sort by avg desc, then by earliest ts (stable)
  list.sort((a, b) => (b.avg - a.avg) || (new Date(a.ts) - new Date(b.ts)));

  // Take top 3 distinct averages (treat near-equals as same)
  const seen = new Set(); const out = [];
  for (const r of list) {
    const k = r.avg.toFixed(3);
    if (!seen.has(k)) { seen.add(k); out.push(r); }
    if (out.length === 3) break;
  }
  return out;
})();

function section(title, rows, valueFmt, showMonth, noteText){
  const h = document.createElement('h4');
  h.textContent = title;
  h.style.margin = '8px 0 6px';
  wrap.appendChild(h);
  if (noteText) {
      const p = document.createElement('p');
      p.className = 'tag';
      p.textContent = noteText;
      p.style.marginTop = '0';
      p.style.marginBottom = '6px';
      wrap.appendChild(p);
    }

    const table = document.createElement('table');
    table.className = 'hs-table';
    const thead = document.createElement('thead');
    const trh = document.createElement('tr');
    ['#','Player','Score','Month'].forEach((t,i)=>{
      const th = document.createElement('th'); th.textContent = t;
      trh.appendChild(th);
    });
    thead.appendChild(trh); table.appendChild(thead);
    const tbody = document.createElement('tbody');

    rows.forEach((r, i)=>{
      const tr = document.createElement('tr');
      const tdRank  = document.createElement('td'); tdRank.textContent  = String(i+1);
      const tdName  = document.createElement('td'); tdName.textContent  = r.name;
      const tdScore = document.createElement('td'); tdScore.textContent = valueFmt(r);
      const tdMonth = document.createElement('td'); tdMonth.textContent = showMonth ? monthLabel(r.ts) : '';
      tr.append(tdRank, tdName, tdScore, tdMonth);
      tbody.appendChild(tr);
    });

    table.appendChild(tbody);
    wrap.appendChild(table);
  }

  section('Highest Score',
    topBest,
    r => String(r.score),
    true
  );

  section('Highest Monthly Average',
    topMonthlyAvg,
    r => (Number(r.avg)||0).toFixed(1),
    true
  );

section('Highest All Time Averages',
  topCareerAvg,
  r => (Number(r.avg)||0).toFixed(1),
  true,
  'Minimum 15 Games played'
);
  
    // Scroll only inside records list
  const scroll = document.createElement('div');
  scroll.style.maxHeight = '56vh';
  scroll.style.overflowY = 'auto';
  scroll.style.borderRadius = '8px';
  scroll.appendChild(wrap);
  tableMount.appendChild(scroll);


}

  function renderTable(rows, filter, prevFilter) {
    // Qualification thresholds
const MIN_MONTHLY_GAMES = 3;
const MIN_ALLTIME_GAMES = 5;
    const filtered = rows.filter(r => {
      if (!r || !r.player) return false;
      const score = Number(r.score || 0);
      if (!Number.isFinite(score)) return false;
      if (!filter || filter.id === 'ALL') return true;
      return filter.match(r.ts);
    });

    if (!filtered.length) {
      tableMount.innerHTML = '<p>No games found for this period.</p>';
      return;
    }

    const byPlayer = new Map();

    filtered.forEach(r => {
      const name = String(r.player || '').trim();
      if (!name) return;
      const score = Number(r.score || 0);
      if (!Number.isFinite(score)) return;

      const existing = byPlayer.get(name) || {
        player: name,
        games: 0,
        total: 0,
        best: 0
      };

      existing.games += 1;
      existing.total += score;
      if (score > existing.best) existing.best = score;

      byPlayer.set(name, existing);
    });
    
const threshold = (!filter || filter.id === 'ALL') ? MIN_ALLTIME_GAMES : MIN_MONTHLY_GAMES;

const rowsOut = Array.from(byPlayer.values())
  .map(p => {
    const avg = p.games ? (p.total / p.games) : 0;
    return {
      player: p.player,
      games: p.games,
      avg,
      best: p.best,
      qualifies: p.games >= threshold
    };
  })
  .sort((a, b) => {
    // Qualified first
    if (a.qualifies !== b.qualifies) return a.qualifies ? -1 : 1;
    // Then by Avg desc
    if (b.avg !== a.avg) return b.avg - a.avg;
    // Then by Games desc
    if (b.games !== a.games) return b.games - a.games;
    // Then by name asc
    return String(a.player||'').localeCompare(String(b.player||''));
  });
      
      // ALL TIME medals (based on BEST): precompute top 3 distinct best scores
let bestTop3 = null;
if (!filter || filter.id === 'ALL') {
  const uniques = Array.from(
    new Set(rowsOut.map(p => Number(p.best || 0)).filter(v => Number.isFinite(v) && v > 0))
  ).sort((a, b) => b - a);
  bestTop3 = uniques.slice(0, 3); // [gold, silver, bronze]
}
      
      // --- Helpers to detect "NEW this month" ---
const monthKey = (ts) => {
  if (!ts) return null;
  const d = new Date(ts);
  return Number.isNaN(d.getTime()) ? null : `${d.getFullYear()}-${d.getMonth()}`; // matches buildFilters id
};

// Earliest official game timestamp per player (from ALL rows)
const earliestByPlayer = new Map();
rows.forEach(r => {
  const name = String(r.player || '').trim();
  if (!name || !r.ts) return;
  const cur = earliestByPlayer.get(name);
  if (!cur || new Date(r.ts) < new Date(cur)) {
    earliestByPlayer.set(name, r.ts);
  }
});

// Current month id for ALL TIME "NEW" badge logic
const _now = new Date();
const currentMonthId = `${_now.getFullYear()}-${_now.getMonth()}`;

// --- PB / WR precompute (all-time) ---

// All-time single-game PB per player + global WR (best game)
const bestGameAllByPlayer = new Map();
let globalBestGameWR = -Infinity;

rows.forEach(r => {
  const name = String(r.player || '').trim();
  if (!name) return;
  const sc = Number(r.score || 0);
  if (!Number.isFinite(sc)) return;

  const cur = bestGameAllByPlayer.get(name) || -Infinity;
  if (sc > cur) bestGameAllByPlayer.set(name, sc);
  if (sc > globalBestGameWR) globalBestGameWR = sc;
});

// Monthly average records (per player PB, and global WR)
const monthlyAgg = new Map(); // key: `${name}|${monthId}` -> { total, games }
rows.forEach(r => {
  const name = String(r.player || '').trim();
  const mId  = monthKey(r.ts);
  const sc   = Number(r.score || 0);
  if (!name || !mId || !Number.isFinite(sc)) return;

  const key = `${name}|${mId}`;
  const acc = monthlyAgg.get(key) || { total: 0, games: 0 };
  acc.total += sc; acc.games += 1;
  monthlyAgg.set(key, acc);
});

const maxMonthlyAvgByPlayer = new Map();
let globalMonthlyAvgWR = -Infinity;
monthlyAgg.forEach((v, key) => {
  const [name] = key.split('|');
  const avg = v.games ? (v.total / v.games) : 0;
  const cur = maxMonthlyAvgByPlayer.get(name) ?? -Infinity;
  if (avg > cur) maxMonthlyAvgByPlayer.set(name, avg);
  if (avg > globalMonthlyAvgWR) globalMonthlyAvgWR = avg;
});

    // --- Build previous-month aggregates (avg, best, rank) if prevFilter is provided ---
    let prevMap = null;
    let prevRankMap = null;

    if (prevFilter && filter && filter.id !== 'ALL') {
      const prevFiltered = rows.filter(r => {
        if (!r || !r.player) return false;
        const score = Number(r.score || 0);
        if (!Number.isFinite(score)) return false;
        return prevFilter.match(r.ts);
      });

      if (prevFiltered.length) {
        const prevByPlayer = new Map();

        prevFiltered.forEach(r => {
          const name = String(r.player || '').trim();
          if (!name) return;
          const score = Number(r.score || 0);
          if (!Number.isFinite(score)) return;

          const existing = prevByPlayer.get(name) || {
            player: name,
            games: 0,
            total: 0,
            best: 0
          };

          existing.games += 1;
          existing.total += score;
          if (score > existing.best) existing.best = score;

          prevByPlayer.set(name, existing);
        });

        const prevRowsOut = Array.from(prevByPlayer.values())
          .map(p => ({
            player: p.player,
            games: p.games,
            avg: p.games ? p.total / p.games : 0,
            best: p.best
          }))
          .sort((a, b) => b.avg - a.avg);

        prevMap = new Map();
        prevRankMap = new Map();
        prevRowsOut.forEach((p, idx) => {
          prevMap.set(p.player, p);
          prevRankMap.set(p.player, idx + 1);
        });
      }
    }

    function addRankArrow(td, prevRank, currRank) {
      if (!prevRank || !currRank || prevRank === currRank) return;
      const improved = currRank < prevRank; // lower rank number = better
      const span = document.createElement('span');
      span.textContent = improved ? '▲' : '▼';
      span.style.marginLeft = '4px';
      span.style.color = improved ? '#7fffd4' : '#ff6b6b'; // green up, red down
      td.appendChild(span);
    }
    
    function addBadge(td, text, colour, title){
  const badge = document.createElement('span');
  badge.textContent = ' ' + text;
  badge.style.marginLeft = '6px';
  badge.style.color = colour;
  if (title) badge.title = title;
  td.appendChild(badge);
}

    function addMetricArrow(td, curr, prev) {
      if (prev == null || !Number.isFinite(prev)) return;
      const diff = curr - prev;
      if (Math.abs(diff) < 0.01) return; // ignore tiny noise
      const up = diff > 0;
      const span = document.createElement('span');
      span.textContent = up ? '▲' : '▼';
      span.style.marginLeft = '4px';
      span.style.color = up ? '#7fffd4' : '#ff6b6b';
      td.appendChild(span);
    }

    const table = document.createElement('table');
    table.className = 'hs-table';

    const thead = document.createElement('thead');
    const trh = document.createElement('tr');
    ['#', 'Player', 'Games', 'Avg Total', 'Best'].forEach(h => {
      const th = document.createElement('th');
      th.textContent = h;
      trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);
    
    // Keep the table header fixed while tbody scrolls
Array.from(trh.children).forEach(th => {
  th.style.position = 'sticky';
  th.style.top = '0';
  th.style.zIndex = '2';
  th.style.background = 'rgba(0,0,0,0.4)'; // subtle backdrop
});

    const tbody = document.createElement('tbody');

let rankCounter = 0; // rank only qualified players

rowsOut.forEach((p) => {
  const tr = document.createElement('tr');

  const qualifies = !!p.qualifies;
  const rank = qualifies ? (++rankCounter) : null;

  // Grey-out styling for unqualified rows
  if (!qualifies) {
    tr.classList.add('muted');
    tr.style.opacity = '0.6';
    const need = (!filter || filter.id === 'ALL')
      ? Math.max(0, 5 - (p.games || 0))
      : Math.max(0, 3 - (p.games || 0));
    tr.title = need ? `Needs ${need} more game${need===1?'':'s'} to qualify` : 'Unqualified';
  }

  const tdRank = document.createElement('td');
  tdRank.textContent = qualifies ? String(rank) : '—';

  const tdName  = document.createElement('td'); tdName.textContent  = p.player;
  const tdGames = document.createElement('td'); tdGames.textContent = String(p.games);
  const tdAvg   = document.createElement('td'); tdAvg.textContent   = p.avg.toFixed(1);
  const tdBest  = document.createElement('td'); tdBest.textContent  = String(p.best);

  // Add arrows for month-on-month changes when we have previous stats (qualified only)
  if (qualifies && prevMap && prevRankMap) {
    const prevRow  = prevMap.get(p.player);
    const prevRank = prevRankMap.get(p.player);
    addRankArrow(tdRank, prevRank, rank);
    if (prevRow) {
      addMetricArrow(tdAvg, p.avg, prevRow.avg);
      addMetricArrow(tdBest, p.best, prevRow.best);
    }
  }

  // Medals on ALL TIME: 🥇🥈🥉 for top 3 distinct BEST scores
  if (!filter || filter.id === 'ALL') {
    const b = Number(p.best || 0);
    if (bestTop3 && b > 0) {
      let medalText = null, colour = null;
      if (bestTop3[0] != null && b === bestTop3[0]) { medalText = ' 🥇'; colour = '#ffcc66'; }
      else if (bestTop3[1] != null && b === bestTop3[1]) { medalText = ' 🥈'; colour = '#c0c0c0'; }
      else if (bestTop3[2] != null && b === bestTop3[2]) { medalText = ' 🥉'; colour = '#cd7f32'; }
      if (medalText) {
        const m = document.createElement('span');
        m.textContent = medalText;
        m.style.marginLeft = '6px';
        m.style.color = colour;
        m.title = 'Top 3 all-time best score';
        tdBest.appendChild(m);
      }
    }
  }

  // "NEW" badge (unchanged): still shows even if unranked
  {
    const firstTs  = earliestByPlayer.get(p.player);
    const firstId  = firstTs ? monthKey(firstTs) : null;
    const isAll    = !filter || filter.id === 'ALL';
    const _now = new Date(); const currentMonthId = `${_now.getFullYear()}-${_now.getMonth()}`;
    const showNew  = firstId && (
      (!isAll && firstId === filter.id) ||
      (isAll && firstId === currentMonthId)
    );
    if (showNew) {
      const badge = document.createElement('span');
      badge.textContent = ' NEW';
      badge.style.marginLeft = '6px';
      badge.style.color = '#ffcc66';
      tdRank.appendChild(badge);
    }
  }

  // PB / WR badges – monthly tabs only (unchanged)
  {
    const isAll = !filter || filter.id === 'ALL';
    if (!isAll) {
      const allPBGame = bestGameAllByPlayer.get(p.player) ?? -Infinity;
      const isWRBest  = p.best > 0 && p.best === globalBestGameWR;
      const isPBBest  = p.best > 0 && p.best === allPBGame;
      if (isWRBest)      addBadge(tdBest, 'WR 🥇', '#ffcc66', 'World record game score');
      else if (isPBBest) addBadge(tdBest, 'PB',    '#7fffd4', 'Personal best game score');

      const pbMonthlyAvg = maxMonthlyAvgByPlayer.get(p.player) ?? -Infinity;
      const isWRAvg  = p.avg > 0 && Math.abs(p.avg - globalMonthlyAvgWR) < 0.01;
      const isPBAvg  = p.avg > 0 && Math.abs(p.avg - pbMonthlyAvg)      < 0.01;
      if (isWRAvg)      addBadge(tdAvg, 'WR 🥇', '#ffcc66', 'World record monthly average');
      else if (isPBAvg) addBadge(tdAvg, 'PB',    '#7fffd4', 'Personal best monthly average');
    }
  }

  tr.append(tdRank, tdName, tdGames, tdAvg, tdBest);
  tbody.appendChild(tr);
});

    table.appendChild(tbody);
// Clear and add minimum-games note + table (only rows scroll)
tableMount.innerHTML = '';
const _isAll = !filter || filter.id === 'ALL';
const minNote = document.createElement('p');
minNote.className = 'tag';
minNote.textContent = _isAll ? '5 Games Minimum' : '3 Games Minimum';

// Scrolling area for the table body only
const scroll = document.createElement('div');
scroll.style.maxHeight = '56vh';     // keeps everything inside the modal
scroll.style.overflowY = 'auto';
scroll.style.borderRadius = '8px';

// Put the table inside the scroll area
scroll.appendChild(table);

// Mount: note stays fixed, header is sticky inside the scroll area
tableMount.appendChild(minNote);
tableMount.appendChild(scroll);

  }

  // Kick it all off
  (async () => {
    const rows = await fetchRows();
    if (!rows.length) return;

const filters = buildFilters();
// Default to ALL TIME even though RECORDS is the first button
let currentFilter = filters.find(f => f.id === 'ALL') || filters[0];

function getPrevFilter(f) {
  if (!f || f.id === 'ALL' || f.id === 'RECORDS') return null;
  const idx = filters.indexOf(f);
  if (idx < 0) return null;
  const nextIdx = idx + 1;
  if (nextIdx >= filters.length) return null;
  const prev = filters[nextIdx];
  if (!prev || prev.id === 'ALL' || prev.id === 'RECORDS') return null;
  return prev;
}

renderFilters(filters, f => {
  currentFilter = f;
  if (f.id === 'RECORDS') {
    renderRecords(rows);
  } else {
    const prev = getPrevFilter(currentFilter);
    renderTable(rows, currentFilter, prev);
  }
});

// Initial render = ALL TIME table
const initialPrev = getPrevFilter(currentFilter);
renderTable(rows, currentFilter, initialPrev);
  })();
};


// Latest Scores modal: overlay with # | Result | Date/Time (no delete column)
async function openLatestScoresDialog(){
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
   const modal   = document.createElement('div'); modal.className   = 'modal compact';
  const title   = document.createElement('h3');  title.textContent = 'Latest Scores';
  const body    = document.createElement('div'); body.className    = 'modal-body';
  const footer  = document.createElement('div'); footer.className  = 'modal-footer';

  async function render(){
    body.innerHTML = '';

    // Fetch all games from cloud and sort newest → oldest
    let games = [];
    try {
      games = await cloudFetchAllGamesAsLocal();
    } catch (e) {
      console.error('Latest Scores fetch failed', e);
      const p = document.createElement('p');
      p.textContent = 'Failed to load latest scores.';
      body.appendChild(p);
      return;
    }

    const toTS = (g) => {
      const t = g?.ts || g?.created_at || g?.inserted_at || (g?.meta && (g.meta.ts || g.meta.date)) || null;
      const n = t ? Date.parse(t) : NaN;
      return Number.isFinite(n) ? n : 0;
    };

    games = (games || []).filter(Boolean).sort((a,b)=> toTS(b) - toTS(a)).slice(0, 10);

    if (!games.length){
      const p = document.createElement('p');
      p.textContent = 'No games found.';
      body.appendChild(p);
      return;
    }

    const table = document.createElement('table');
    table.className = 'hs-table';

    // Columns: # | Result | Date/Time
    const colgroup = document.createElement('colgroup');
    const maxDigits = Math.max(2, String(games.length || 0).length);
    const colNum  = document.createElement('col');  colNum.style.width  = `${Math.min(3, maxDigits)}ch`;
    const colRes  = document.createElement('col');
    const colWhen = document.createElement('col');  colWhen.style.width = '14ch';
    colgroup.append(colNum, colRes, colWhen);
    table.appendChild(colgroup);

    const thead = document.createElement('thead');
    const trh   = document.createElement('tr');
    ['#','Result','Date/Time'].forEach(h => {
      const th = document.createElement('th');
      th.textContent = h;
      trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');

    games.forEach((g, idx) => {
      const tr  = document.createElement('tr');

      // #
      const tdNum = document.createElement('td');
      tdNum.textContent = String(idx + 1);

      // Result string (winner beat runner-up [others...])
      const tdResult = document.createElement('td');
      if (typeof window.formatGameResultLine === 'function') {
        tdResult.textContent = window.formatGameResultLine(g);
      } else {
        const players = (g.players || []).map(p => (p && p.name) ? p.name : '');
        const totals  = Array.isArray(g.totals) ? g.totals : [];
        const ordered = players
          .map((name, i) => ({ name, score: Number(totals[i] || 0) }))
          .filter(x => x.name)
          .sort((a, b) => b.score - a.score);

        let result = '—';
        if (ordered.length >= 2) {
          result = `${ordered[0].name} ${ordered[0].score} beat ${ordered[1].name} ${ordered[1].score}`;
          if (ordered.length > 2) {
            result += ' ' + ordered.slice(2).map(o => `${o.name} ${o.score}`).join(' ');
          }
        } else if (ordered.length === 1) {
          result = `${ordered[0].name} ${ordered[0].score}`;
        }
        tdResult.textContent = result;
      }

      // Date/Time (use shared fmtWhen helper if available)
      const tdWhen = document.createElement('td');
      if (typeof window.getGameTimestamp === 'function' && typeof window.fmtWhen === 'function') {
        const d = window.getGameTimestamp(g);
        tdWhen.textContent = d ? window.fmtWhen(d) : '';
      } else {
        const tsVal = g.ts || g.created_at || g.inserted_at || (g.meta && (g.meta.ts || g.meta.date)) || null;
        if (tsVal) {
          const d = new Date(tsVal);
          tdWhen.textContent = !Number.isNaN(d.getTime())
            ? d.toLocaleString(undefined,{ year:'2-digit', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit' })
            : '';
        } else {
          tdWhen.textContent = '';
        }
      }

      tr.append(tdNum, tdResult, tdWhen);

      // Click row to open the score sheet if available
      tr.style.cursor = 'pointer';
      tr.title = 'Open score sheet';
      tr.onclick = () => {
        try {
          if (typeof openSingleGameScoreSheet === 'function') openSingleGameScoreSheet(g);
        } catch (_) {}
      };

      tbody.appendChild(tr);
    });

    table.appendChild(tbody);

    const tw = document.createElement('div');
    tw.className = 'table-wrap';
    tw.appendChild(table);
    body.appendChild(tw);
  }

  // Footer buttons
  const backBtn  = document.createElement('button'); backBtn.className  = 'btn'; backBtn.textContent  = 'Back';
  const closeBtn = document.createElement('button'); closeBtn.className = 'btn'; closeBtn.textContent = 'Close';
  backBtn.onclick  = () => overlay.remove();
  closeBtn.onclick = () => overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
  modal.tabIndex = 0; modal.focus();

  await render();
}

// === Player Stats — redesigned overview =====================================
window.openPlayerStatsDialog = async function openPlayerStatsDialog(playerName){
  const name = String(playerName || '').trim();
  if (!name) { try{ toast('Pick a player'); }catch(_){ } return; }

  // Modal shell
  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal compact';
  const title   = document.createElement('h3');  title.textContent = `Player Stats — ${name}`;
  const body    = document.createElement('div'); body.className    = 'modal-body';
  const footer  = document.createElement('div'); footer.className  = 'modal-footer';

  // Fixed outer; inner content can scroll
  modal.style.maxHeight = '90vh'; modal.style.overflow = 'hidden';
  body .style.maxHeight = 'none'; body .style.overflowY = 'auto';
  
    // Mount early so we never "flash" back to home between dialogs
  body.innerHTML = '<p class="muted">Loading…</p>';
  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e => { if (e.key === 'Escape') overlay.remove(); });
  modal.tabIndex = 0; 
  modal.focus();

  // Helpers
  const monthKey = d => {
    const x = (d instanceof Date) ? d : (d ? new Date(d) : null);
    return x && !Number.isNaN(x.getTime()) ? `${x.getFullYear()}-${String(x.getMonth()+1).padStart(2,'0')}` : '';
  };
  const monthLabel = k => {
    if (!k) return '—';
    const [y,m] = k.split('-').map(Number);
    return new Date(y, m-1, 1).toLocaleString(undefined,{ month:'short', year:'numeric' }).toUpperCase();
  };

  // 1) All official games (normalized, oldest→newest)
  const games = (await __fetchOfficialGames(50000)).map(__normalizeGame)
    .filter(g => Array.isArray(g.players) && g.players.some(p => String(p||'').trim().toLowerCase()===name.toLowerCase()))
    .sort((a,b)=> (new Date(a.ts) - new Date(b.ts)));

  // Short-circuit if nothing
    if (!games.length){
    body.innerHTML = '';
    const p = document.createElement('p');
    p.textContent = 'No official games found for this player.';
    body.appendChild(p);
    footer.innerHTML = '';
    const closeBtn = document.createElement('button'); 
    closeBtn.className='btn'; 
    closeBtn.textContent='Close';
    closeBtn.onclick = () => overlay.remove();
    footer.append(closeBtn);
    modal.focus();
    return;
  }

  // Index for this player and raw scores
  const idxOf = g => g.players.findIndex(p => String(p||'').trim().toLowerCase()===name.toLowerCase());
  const scores = games.map(g => Number(g.totals[idxOf(g)] || 0));

  // 2) Basic aggregates
  const GAMES = scores.length;
  const TOTAL = scores.reduce((s,v)=>s+v,0);
  const AVG   = GAMES ? (TOTAL / GAMES) : 0;
  const PB    = GAMES ? Math.max(...scores) : 0;
  const LOW   = GAMES ? Math.min(...scores) : 0;

  // Per-game ranks (1st place detection) and per-month buckets
  const monthly = new Map(); // key -> { sum, n, wins }
  games.forEach((g,i)=>{
    const meI = idxOf(g);
    const meS = Number(g.totals[meI] || 0);
    const max = Math.max(...(g.totals||[]).map(Number));
    const win = meS === max ? 1 : 0;

    const k = monthKey(g.ts);
    const rec = monthly.get(k) || { sum:0, n:0, wins:0 };
    rec.sum += meS; rec.n += 1; rec.wins += win;
    monthly.set(k, rec);
  });

  // Highest/lowest monthly averages
  const monthlyRows = Array.from(monthly.entries()).map(([k,rec])=>({ k, avg: rec.n ? rec.sum/rec.n : 0, wins: rec.wins }));
  monthlyRows.sort((a,b)=> a.k.localeCompare(b.k));
  const bestMonth = monthlyRows.length ? monthlyRows.reduce((m,r)=> r.avg>m.avg?r:m, monthlyRows[0]) : null;
  const worstMonth= monthlyRows.length ? monthlyRows.reduce((m,r)=> r.avg<m.avg?r:m, monthlyRows[0]) : null;

  // PL Average (career) & PL Monthly Wins (current month)
const nowK = monthKey(new Date());

// Premier League "Monthly Wins":
// # of months this player finished 1st by monthly average (min 3 games)
function computePLMonthlyWinsTop(games, minGames = 3, me = name){
  const byMonthPlayer = new Map(); // `${month}|${player}` -> { sum, n }

  games.forEach(g=>{
    const mk = monthKey(g.ts);
    (g.players||[]).forEach((p,i)=>{
      const key = `${mk}|${p}`;
      const rec = byMonthPlayer.get(key) || { sum:0, n:0 };
      rec.sum += Number(g.totals[i] || 0);
      rec.n   += 1;
      byMonthPlayer.set(key, rec);
    });
  });

  const months = new Set(Array.from(byMonthPlayer.keys()).map(k=>k.split('|')[0]));
  let wins = 0;

  months.forEach(mk=>{
    const contenders = [];
    byMonthPlayer.forEach((rec,key)=>{
      const [k,p] = key.split('|');
      if (k !== mk) return;
      if (rec.n >= minGames) contenders.push({ player:p, avg: rec.sum/rec.n });
    });
    if (!contenders.length) return;
    contenders.sort((a,b)=> b.avg - a.avg);
    if (contenders[0].player.toLowerCase() === me.toLowerCase()) wins += 1;
  });

  return wins;
}
const plMonthlyWins = computePLMonthlyWinsTop(games, 3, name);

 // 3) Highest Scoring Round (10→20 only) with S/D/T breakdown — robust via boards
function bestRoundFromBoards(playerName, games){
  const nameLC = String(playerName||'').trim().toLowerCase();
  let best = null;

  games.forEach(g=>{
    const pIdx = (g.players||[]).findIndex(p => String(p||'').trim().toLowerCase()===nameLC);
    if (pIdx < 0) return;
    const b = g.board; if (!b) return;

    const looksA = Array.isArray(b[pIdx]);
    const looksB = Array.isArray(b[0]) && Array.isArray(b[0][pIdx]);
    const rounds = looksA ? b[pIdx] : (looksB ? b.map(r => r ? r[pIdx] : null) : []);

    for (let r = 0; r < Math.min(14, rounds.length || 0); r++){
      if (r > 10) break; // 10..20 only
      const cell = rounds[r]; if (!cell) continue;

      const list = Array.isArray(cell)
        ? cell
        : (Array.isArray(cell.throws) ? cell.throws : (Array.isArray(cell.darts) ? cell.darts : []));

      let sum = 0, s = 0, d = 0, t = 0;
      const target = 10 + r;

      list.forEach(tw=>{
        const ringRaw = (tw?.kind || tw?.type || tw?.segment || tw?.ring || '').toString().toLowerCase();
        let mult = Number(tw?.mult ?? tw?.multiplier);
        if (!mult || !Number.isFinite(mult)) {
          // infer multiplier from points if needed
          const pts = Number(tw?.points ?? tw?.score ?? 0);
          const ratio = target ? (pts/target) : 0;
          if (ratio >= 2.5) mult = 3;
          else if (ratio >= 1.5) mult = 2;
          else mult = pts>0 ? 1 : 0;
        }
        const pts = Number.isFinite(Number(tw?.points ?? tw?.score))
          ? Number(tw?.points ?? tw?.score)
          : (target * mult);

        sum += pts;
        if (mult === 3 || ringRaw.includes('treb')) t++;
        else if (mult === 2 || ringRaw.includes('doub')) d++;
        else if (mult === 1) s++;
      });

      if (!best || sum > best.sum) best = { round: 10+r, sum, s, d, t };
    }
  });

  return best;
}
const bestRound = bestRoundFromBoards(name, games) || null;

  // 4) H2H for Nemesis/BFF (>=10 games vs opponent)
  const vs = new Map();
  games.forEach(g=>{
    const meI = idxOf(g), meS = Number(g.totals[meI]||0);
    g.players.forEach((op,j)=>{
      if (j===meI) return;
      const opp = String(op||'').trim();
      const theirs = Number(g.totals[j]||0);
      const rec = vs.get(opp) || { opp, W:0, L:0, n:0 };
      if (meS > theirs) rec.W++; else if (meS < theirs) rec.L++;
      rec.n++; vs.set(opp, rec);
    });
  });
const qualifiedOpp = Array.from(vs.values()).filter(r=> r.n >= 5).map(r=>({ ...r, pct: (r.W+r.L) ? (100*r.W/(r.W+r.L)) : 0 }));  const bff = qualifiedOpp.length ? qualifiedOpp.reduce((m,r)=> r.pct>m.pct?r:m, qualifiedOpp[0]) : null;
  const nem = qualifiedOpp.length ? qualifiedOpp.reduce((m,r)=> r.pct<m.pct?r:m, qualifiedOpp[0]) : null;

  // lifetime, from the games we already loaded at the top of this function
const myThrowsFromBoards = __throwsFromGamesForPlayer(name, games);
let onlyTargetRounds = [];
if (Array.isArray(myThrowsFromBoards) && myThrowsFromBoards.length) {
  onlyTargetRounds = myThrowsFromBoards.filter(
    t => typeof t.round_index === 'number' && t.round_index >= 0 && t.round_index <= 10 // 10..20 only
  );
}

  // Reuse same hits model: “marks per dart” (single=1, double=2, treble=3)
  const markUnits = (t, target) => {
    const k = String(t.kind||'').toLowerCase();
    if (k.includes('treble') || k.includes('triple')) return 3;
    if (k.includes('double')) return 2;
    if (k.includes('single')) return Number(t.points||0)>0 ? 1 : 0;
    const ratio = Number(t.points||0) / target; // fallback
    if (ratio >= 2.5) return 3; if (ratio >= 1.5) return 2; if (ratio >= 0.5) return 1; return 0;
  };
  const favRows = [];
  for (let r=0; r<=10; r++){
    const target = 10 + r;
    const shots  = onlyTargetRounds.filter(t => t.round_index === r);
    const throwsN = shots.length;
    const hitsUnits = shots.reduce((s,t)=> s + markUnits(t,target), 0);
    const pct = throwsN ? (100 * hitsUnits / (3*throwsN)) : 0; // units ÷ (3 per throw)
    favRows.push({ target, throwsN, pct });
  }
  // require a small sample to avoid noise
  const MIN_THROWS_PER_TARGET = 30;
  const favCandidates = favRows.filter(r => r.throwsN >= MIN_THROWS_PER_TARGET);
  const fav = favCandidates.length ? favCandidates.reduce((m,r)=> r.pct>m.pct?r:m, favCandidates[0]) : null;
  const worst = favCandidates.length ? favCandidates.reduce((m,r)=> r.pct<m.pct?r:m, favCandidates[0]) : null;

// 6) Current Power Rank — mirror “Power Rankings — Last 50 Rounds (Official)”
const MIN_ROUNDS_QUALIFY = 15;   // 1 game + 1 round (as agreed)
const WINDOW_ROUNDS      = 50;   // last 50 rounds

// Use ALL official games (not just this player's) so we can rank everyone
const allGames = (await __fetchOfficialGames(50000)).map(__normalizeGame);

// Map game_id -> timestamp (for ordering rounds)
const gameTs = new Map();
allGames.forEach(g => {
  const gid = (g.raw && (g.raw.id || g.raw.game_id)) || g.id || g.game_id;
  if (gid) gameTs.set(gid, g.ts || null);
});

// Fetch throws for all those games; fallback to reconstruct from boards
let allThrows = [];
try {
  const allIds = allGames
    .map(g => (g.raw && (g.raw.id || g.raw.game_id)) || g.id || g.game_id)
    .filter(Boolean);
  allThrows = await __fetchThrowsForGames(allIds);
} catch (_) {}

if (!allThrows.length) {
  // fallback: synthesize from boards
  allGames.forEach(g => {
    (g.players || []).forEach(p => {
      const rows = __throwsFromGamesForPlayer(p, [g]);
      if (rows && rows.length) allThrows.push(...rows);
    });
  });
}

// Keep only real round rows and finite points
allThrows = allThrows.filter(t =>
  typeof t.round_index === 'number' &&
  t.round_index >= 0 && t.round_index <= 13 &&
  Number.isFinite(Number(t.points))
);

// Aggregate to per-player round totals, ordered by (game ts, round index)
const roundsByPlayer = new Map(); // player -> [{ts, ri, pts}, ...]
allThrows.forEach(t => {
  const player = String(t.player || '').trim();
  if (!player) return;
  const gid = t.game_id;
  const ts  = gameTs.get(gid) || null;
  const ri  = Number(t.round_index || 0);
  const pts = Number(t.points || 0);

  // key per game+round so multiple darts sum to that round
  const bucketKey = `${gid}|${ri}`;
  let list = roundsByPlayer.get(player);
  if (!list) { list = []; roundsByPlayer.set(player, list); }

  // find or create that round entry
  let entry = list.find(e => e.key === bucketKey);
  if (!entry) {
    entry = { key: bucketKey, ts, ri, sum: 0 };
    list.push(entry);
  }
  entry.sum += pts;
});

// Build power rows: last 50 rounds -> avg per round; qualify if >= 15 rounds
const powerRows = Array.from(roundsByPlayer.entries()).map(([player, list]) => {
  // order by time then round index
  list.sort((a, b) => {
    const at = a.ts ? new Date(a.ts).getTime() : 0;
    const bt = b.ts ? new Date(b.ts).getTime() : 0;
    return (at - bt) || (a.ri - b.ri);
  });

  const last     = list.slice(-WINDOW_ROUNDS);
  const n        = last.length;
  const pts      = last.reduce((s, r) => s + Number(r.sum || 0), 0);
  const avgRound = n ? (pts / n) : 0;
  const recentTs = last.length ? (last[last.length - 1].ts || 0) : 0;
  const qualifies = n >= MIN_ROUNDS_QUALIFY;

  return { player, rounds: n, avgRound, recentTs, qualifies };
});

// Sort using the same tie-breakers as the Power Rankings table:
// 1) avg/round ↓, 2) rounds ↓, 3) most-recent ts ↓, 4) player name ↑
const qualified = powerRows
  .filter(r => r.qualifies)
  .sort((a, b) =>
    (b.avgRound - a.avgRound) ||
    (b.rounds   - a.rounds)   ||
    (b.recentTs - a.recentTs) ||
    String(a.player).localeCompare(String(b.player))
  );

// My row + absolute position among qualified
const myPower = qualified.find(
  r => r.player.toLowerCase() === name.toLowerCase()
) || null;

const myPowerPos = myPower ? (qualified.indexOf(myPower) + 1) : null;

  // Highest power rank (historical) — not tracked; show current as best for now.
  const bestPowerPos = myPowerPos || null;

  // Best-score leaderboard rank (use each player's PB across all games)
  const bestByPlayer = new Map();
  games.forEach(g=>{
    (g.players||[]).forEach((p,i)=>{
      const s = Number(g.totals[i]||0);
      const prev = bestByPlayer.get(p) || 0;
      if (s > prev) bestByPlayer.set(p, s);
    });
  });
  const bestList = Array.from(bestByPlayer.entries()).map(([p,b])=>({p,b})).sort((a,b)=> b.b - a.b);
  const myPB = PB;
  const myPBPos = myPB ? (bestList.findIndex(x => x.p.toLowerCase()===name.toLowerCase()) + 1 || null) : null;

  // ---- Render as a tidy two-column grid of “stat cards” ----
  const grid = document.createElement('div');
  grid.style.display = 'grid';
  grid.style.gridTemplateColumns = '1fr 1fr';
  grid.style.gap = '10px';

  function card(label, value, hint){
    const c = document.createElement('div');
    c.className = 'tag';
    c.style.display='flex'; c.style.justifyContent='space-between'; c.style.alignItems='center';
    c.style.padding='8px 10px';
    const L = document.createElement('span'); L.textContent = label;
    const R = document.createElement('span'); R.textContent = value;
    if (hint) R.title = hint;
    c.append(L,R);
    return c;
  }

  // Section helper
  function section(titleTxt){
    const h = document.createElement('h4');
    h.textContent = titleTxt;
    h.style.margin = '12px 0 6px';
    return h;
  }

  // Top: Games / Current & Highest Power Rank
  body.appendChild(section('Overview'));
  grid.appendChild(card('Games', String(GAMES)));
grid.appendChild(card(
  'Current Power Rank',
  (myPower && myPower.qualifies) ? `${myPower.avgRound.toFixed(2)}  (#${myPowerPos})` : '—',
  myPower ? `${myPower.rounds} rounds (last ${WINDOW_ROUNDS} window)` : ''
));
  grid.appendChild(card('Highest Power Rank', bestPowerPos ? `#${bestPowerPos}` : '—', 'Best historical position (requires rank history)'));
  body.appendChild(grid);

  // Premier League style
  body.appendChild(section('Premier League'));
  const gridPL = document.createElement('div');
  gridPL.style.display='grid'; gridPL.style.gridTemplateColumns='1fr 1fr'; gridPL.style.gap='10px';
  gridPL.appendChild(card('PL Average', AVG.toFixed(1)));
gridPL.appendChild(card('PL Monthly Wins', String(plMonthlyWins)));
gridPL.appendChild(card('Highest Monthly Average', bestMonth ? `${bestMonth.avg.toFixed(1)} (${monthLabel(bestMonth.k)})` : '—'));
  gridPL.appendChild(card('Lowest Monthly Average',  worstMonth ? `${worstMonth.avg.toFixed(1)} (${monthLabel(worstMonth.k)})` : '—'));
  body.appendChild(gridPL);

  // Game highs/lows + best round
  body.appendChild(section('Game Highs & Lows'));
  const gridGL = document.createElement('div');
  gridGL.style.display='grid'; gridGL.style.gridTemplateColumns='1fr 1fr'; gridGL.style.gap='10px';
  gridGL.appendChild(card('Highest Score', myPB ? `${myPB}  (#${myPBPos||'—'})` : '—'));
  gridGL.appendChild(card('Lowest Score', GAMES ? String(LOW) : '—'));
function lettersFromCounts(s,d,t){
  return `${'S'.repeat(s).split('').join('/')}${s&& (d||t)?'/':''}${'D'.repeat(d).split('').join('/')}${d&&t?'/':''}${'T'.repeat(t).split('').join('/')}`.replace(/^\/|\/$/g,'') || '—';
}
const brTxt = bestRound ? `${bestRound.round} • ${bestRound.sum}  (${lettersFromCounts(bestRound.s, bestRound.d, bestRound.t)})` : '—';
  gridGL.appendChild(card('Highest Scoring Round', brTxt, '10→20 rounds only'));
  body.appendChild(gridGL);

  // Opponents
  body.appendChild(section('Opponents'));
  const gridOP = document.createElement('div');
  gridOP.style.display='grid'; gridOP.style.gridTemplateColumns='1fr 1fr'; gridOP.style.gap='10px';
gridOP.appendChild(card('Nemesis', nem ? `${nem.opp}  (${nem.pct.toFixed(1)}%)` : '—', '≥5 games'));
gridOP.appendChild(card('BFF', bff ? `${bff.opp}  (${bff.pct.toFixed(1)}%)` : '—', '≥5 games'));
  body.appendChild(gridOP);

  // Targets
  body.appendChild(section('Targets'));
  const gridTG = document.createElement('div');
  gridTG.style.display='grid'; gridTG.style.gridTemplateColumns='1fr 1fr'; gridTG.style.gap='10px';
  gridTG.appendChild(card('Favorite Number', fav ? `${fav.target}  (${fav.pct.toFixed(1)}%)` : '—', 'min 30 throws'));
  gridTG.appendChild(card('Worst Number',   worst ? `${worst.target}  (${worst.pct.toFixed(1)}%)` : '—', 'min 30 throws'));
  body.appendChild(gridTG);

  // Footer buttons
  const backBtn  = document.createElement('button'); backBtn.className = 'btn'; backBtn.textContent = 'Back';
  const closeBtn = document.createElement('button'); closeBtn.className = 'btn'; closeBtn.textContent = 'Close';
  backBtn.onclick  = () => { overlay.remove(); if (typeof window.openPlayerStatsModePicker==='function') window.openPlayerStatsModePicker(name); };
  closeBtn.onclick = () => overlay.remove();
  footer.append(backBtn, closeBtn);

};

// === Player Hub — Latest Matches / High Scores / Progression / Target % / D T B % / H2H ===
window.openPlayerStatsHub = function openPlayerStatsHub(playerName){
  const name = String(playerName || '').trim();
  if (!name){ try{ toast('Pick a player'); }catch(_){} return; }

  const overlay = document.createElement('div'); overlay.className = 'modal-backdrop';
  const modal   = document.createElement('div'); modal.className   = 'modal compact';
  const title   = document.createElement('h3');  title.textContent = `Player — ${name}`;
  const body    = document.createElement('div'); body.className    = 'modal-body';
  const footer  = document.createElement('div'); footer.className  = 'modal-footer';

  // fixed outer; only inner scrolls if needed
  modal.style.maxHeight = '80vh';
  modal.style.overflow  = 'hidden';
  body .style.maxHeight = 'none';
  body .style.overflowY = 'visible';

  const col = document.createElement('div');
  col.className = 'column';
  col.style.alignItems = 'center';
  col.style.gap = '10px';

function addBtn(text, desc, handler){
  const btn = document.createElement('button'); 
  btn.className = 'btn'; 
  btn.type = 'button';
  btn.style.width = 'min(360px,92%)';
  btn.textContent = text;

  const p = document.createElement('p');
  p.className = 'tag';
  p.textContent = desc;
  p.style.width = btn.style.width;
  p.style.textAlign = 'center';

  btn.onclick = () => {
    try { handler(); }
    finally { setTimeout(() => { try { overlay.remove(); } catch(_){} }, 0); }
  };

  // actually add to the column!
  col.append(btn, p);
}

  // 1) Latest Matches
  addBtn('Latest Matches', 'Position / Points / Round Avg', () => {
    if (typeof window.openPlayerLatestMatchesDialog === 'function') return window.openPlayerLatestMatchesDialog(name);
    if (typeof toast==='function') toast('Latest Matches not available');
  });

  // 2) High Scores (row opens match)
  addBtn('High Scores', 'Full Game History', () => {
    if (typeof window.openPlayerHighScoresDialog === 'function') return window.openPlayerHighScoresDialog(name);
    if (typeof toast==='function') toast('High Scores not available');
  });

  // 3) Progression
  addBtn('Progression', 'Players Scores Mapped Over Time', () => {
    if (typeof window.openPlayerProgressionDialog === 'function') return window.openPlayerProgressionDialog(name);
    if (typeof toast==='function') toast('Progression not available');
  });

// 4) Target Hit %
addBtn('Target Hit %', 'Target Hits per Round', () => {
  if (typeof window.openPlayerTargetPctDialog === 'function') return window.openPlayerTargetPctDialog(name);
  if (typeof toast==='function') toast('Target Hit % not available');
});
  
// 4b) Target Points %
addBtn('Target Points %', 'Available Points Hit Per Round', () => {
  if (typeof window.openPlayerTargetPointsPctDialog === 'function') return window.openPlayerTargetPointsPctDialog(name);
  if (typeof toast==='function') toast('Target Points % not available');
});
  
    // 4c) D T B %
  addBtn('D T B %', 'Double or Treble hit rate by target', () => {
    if (typeof window.openPlayerDTBCombinedPctDialog === 'function') return window.openPlayerDTBCombinedPctDialog(name);
    if (typeof toast==='function') toast('D T B % not available');
  });
  
// 6) H2H
addBtn('H2H', 'Record vs other players', () => {
  if (typeof window.openPlayerH2HDialog === 'function') return window.openPlayerH2HDialog(name);
  if (typeof toast === 'function') toast('H2H not available');
});

  // 7) Stats (your existing detail screen)
  addBtn('Stats', 'Averages, PB, recent games', () => {
    if (typeof window.openPlayerStatsDialog === 'function') return window.openPlayerStatsDialog(name);
    if (typeof toast==='function') toast('Stats view not available');
  });

  body.appendChild(col);

  const backBtn  = document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  const closeBtn = document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Close';
  backBtn.onclick = () => overlay.remove();
  closeBtn.onclick= () => overlay.remove();
  footer.append(backBtn, closeBtn);

  modal.append(title, body, footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  overlay.addEventListener('click', e=>{ if(e.target===overlay) overlay.remove(); });
  overlay.addEventListener('keydown', e=>{ if(e.key==='Escape') overlay.remove(); });
  modal.tabIndex = 0; modal.focus();
};


// ==== Player-Stats helpers ====================================================
async function __fetchOfficialGames(limit=5000){
  try{
    // Prefer local fetch if available (already normalized in your app)
    if (typeof cloudFetchAllGamesAsLocal === 'function') {
      const all = await cloudFetchAllGamesAsLocal();
      return (all||[]).filter(g => Array.isArray(g?.players) && g.players.length >= 2);
    }
    if (typeof ensureCloudInit === 'function' && !ensureCloudInit()) return [];
    const table = (typeof TABLE_GAMES !== 'undefined' ? TABLE_GAMES : 'games');
    const { data, error } = await sb.from(table).select('*').order('created_at',{ascending:false}).limit(limit);
    if (error) throw error;
    return (data||[]).filter(g => Array.isArray(g?.state?.players) && g.state.players.length >= 2);
  }catch(e){ console.error('__fetchOfficialGames failed', e); return []; }
}
function __gameTs(g){
  return g?.ts || g?.created_at || g?.inserted_at || (g?.meta && (g.meta.ts || g.meta.date)) || null;
}
function __isSameLocalDay(a, b){
  if (!a || !b) return false;
  const da = new Date(a), db = new Date(b);
  return (
    da.getFullYear() === db.getFullYear() &&
    da.getMonth()    === db.getMonth() &&
    da.getDate()     === db.getDate()
  );
}
function __normalizeGame(g){
  const players = Array.isArray(g.players)
    ? g.players.map(p => (p && p.name) ? p.name : String(p||''))
    : (Array.isArray(g?.state?.players) ? g.state.players.map(p => (p && p.name) ? p.name : String(p||'')) : []);
  const totals = Array.isArray(g.totals) ? g.totals : (Array.isArray(g?.state?.totals) ? g.state.totals : []);
// prefer top-level board if present, else state.board
const board  = Array.isArray(g.board) ? g.board : (g?.state?.board || null);
  const ts     = __gameTs(g);
  return { players, totals, board, ts, raw: g };
}
// Filter helper for Premier League tabs (supports: ALL TIME, TODAY, and month codes like DEC/NOV/…)
function __filterGamesByPLTab(mode, games){
  const m = String(mode || '').trim().toUpperCase();
  if (!Array.isArray(games)) return [];

  if (m === 'ALL TIME' || m === 'ALL' || m === 'ALLTIME') return games;

  if (m === 'TODAY') {
    const now   = new Date();
    const start = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const end   = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
    return games.filter(g => {
      const t = __gameTs(g.raw || g);
      if (!t) return false;
      const dt = new Date(t);
      return dt >= start && dt < end;
    });
  }

  // Month filters: JAN..DEC (3-letter uppercase codes)
  const MONTHS = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
  const mi = MONTHS.indexOf(m);
  if (mi >= 0) {
    return games.filter(g => {
      const t = __gameTs(g.raw || g);
      return t && new Date(t).getMonth() === mi;
    });
  }

  // Fallback = no filter
  return games;
}
function __roundCountFor(g, idx){
  if (g.board && Array.isArray(g.board[idx])) return Math.min(14, g.board[idx].length||0);
  return 14; // fallback
}
function __roundLabels(){
  return ['10','11','12','13','14','15','16','17','18','19','20','D','T','B'];
}

// Build throw rows for a player from normalized games' boards.
// Supports two shapes:
//   A) board[playerIndex][round][throw]
//   B) board[round][playerIndex][throw]
// Returns rows like: { game_id, player, round_index, dart_index, points, kind }
function __throwsFromGamesForPlayer(playerName, games){
  const nameLC = String(playerName||'').trim().toLowerCase();
  const out = [];

  (games||[]).forEach(g=>{
    const pIdx = (g.players||[]).findIndex(p => String(p||'').trim().toLowerCase()===nameLC);
    if (pIdx < 0) return;

    const b = g.board;
    if (!Array.isArray(b) || !b.length) return;

    // Detect shape
    // Shape A: b[pIdx] exists and is array of rounds
    const looksLikeA = Array.isArray(b[pIdx]) && (b[pIdx].length > 0);
    // Shape B: b[0][pIdx] exists => array of rounds where each round has array for this player
    const looksLikeB = Array.isArray(b[0]) && Array.isArray(b[0][pIdx]);

    // Build a per-player "rounds list" no matter the shape
    let rounds = [];
    if (looksLikeA) {
      rounds = b[pIdx]; // [round][throw]
    } else if (looksLikeB) {
      rounds = b.map(r => r ? r[pIdx] : null); // [round][throw]
    } else {
      // Unknown layout — give up on this game
      return;
    }

    for (let r = 0; r < Math.min(14, rounds.length || 0); r++){
      const cell = rounds[r];
      if (!cell) continue;

      // Each cell can be:
      //  - array of throws
      //  - object with { throws: [...] } or { darts: [...] }
      const list = Array.isArray(cell) ? cell
                  : (Array.isArray(cell.throws) ? cell.throws
                     : (Array.isArray(cell.darts) ? cell.darts : []));

      list.forEach((t, di)=>{
        const ringRaw = (t?.kind || t?.type || t?.segment || t?.ring || '').toString().toLowerCase();
        const mult  = Number(
          t?.mult ?? t?.multiplier ??
          (ringRaw==='double' ? 2 : (ringRaw==='treble'||ringRaw==='triple' ? 3 : 1))
        ) || 1;

        // value/number: for rounds 0..10 use 10+r fallback; D/T/B rows (11..13) have no number
        const baseVal = Number(t?.value ?? t?.number ?? t?.n ?? (r<=10 ? (10+r) : NaN));
        let points  = Number(t?.points ?? t?.pts ?? t?.score);
        if (!Number.isFinite(points)) {
          points = (Number.isFinite(baseVal) ? baseVal : 0) * mult;
        }

        let kind = ringRaw;
        if (!kind){
          if (mult===2) kind = 'double';
          else if (mult===3) kind = 'treble';
          else if (r===13)   kind = 'bull';
          else               kind = 'single';
        }

        out.push({
          game_id: g.raw?.id || g.raw?.game_id || null,
          player: g.players[pIdx],
          round_index: r,
          dart_index: di,
          points: Number.isFinite(points) ? points : 0,
          kind
        });
      });
    }
  });

  return out;
}

// Fetch throws for a set of game IDs; returns rows normalized to:
// { game_id, player, round_index, dart_index, points, kind }
async function __fetchThrowsForGames(gameIds){
  const ids = Array.isArray(gameIds) ? gameIds.filter(Boolean) : [];
  if (!ids.length) return [];

  // Candidate tables to try (put your real table first if you know it)
  const tableCandidates = [
    (typeof TABLE_GAME_THROWS !== 'undefined') ? TABLE_GAME_THROWS : 'game_throws',
    'throws', 'shots', 'game_shots', 'game_darts'
  ];
  // Candidate game-id columns to try
  const idCols = ['game_id','game','gid','match_id','gameId','gameID'];

  // Map raw row -> normalized row
  const norm = (r) => {
    const gid =
      r.game_id ?? r.game ?? r.gid ?? r.match_id ?? r.gameId ?? r.gameID ?? null;
    const player =
      r.player ?? r.name ?? r.player_name ?? r.playerName ?? r.p ?? null;

    // round index: prefer 0..13; otherwise derive from number/ring if present
    let ri = r.round_index ?? r.round ?? r.roundIdx ?? r.ri ?? null;
    if (ri == null) {
      const target = r.target ?? r.number ?? r.n ?? null; // 10..20
      const ring   = (r.ring ?? r.segment ?? r.kind ?? r.type ?? '').toString().toUpperCase();
      if (typeof target === 'number' && target >= 10 && target <= 20) ri = target - 10;
      else if (ring === 'D') ri = 11;
      else if (ring === 'T' || ring === 'TRIPLE' || ring === 'TREBLE') ri = 12;
      else if (ring === 'B' || ring === 'BULL') ri = 13;
    }

    let di = r.dart_index ?? r.throw_index ?? r.dart ?? r.d ?? r.index ?? r.di ?? null;

    // points
    let pts = Number(r.points ?? r.pts ?? r.score ?? NaN);
    if (!Number.isFinite(pts)) {
      const val = Number(r.value ?? r.number ?? NaN);
      const mul = Number(r.mult ?? r.multiplier ?? NaN);
      if (Number.isFinite(val) && Number.isFinite(mul)) pts = val * mul;
    }

    // kind
    let kind = r.kind ?? r.type ?? r.segment ?? r.ring ?? '';
    if (!kind) {
      const mul = Number(r.mult ?? r.multiplier ?? NaN);
      if (mul === 2) kind = 'double';
      else if (mul === 3) kind = 'treble';
      else if (mul === 1) kind = 'single';
    }

    return {
      game_id: gid, player, round_index: ri, dart_index: di,
      points: Number.isFinite(pts) ? pts : 0, kind: String(kind || '').toLowerCase()
    };
  };

  const out = [];
  const CHUNK = 200;

  for (const table of tableCandidates) {
    try {
      for (let i = 0; i < ids.length; i += CHUNK) {
        const slice = ids.slice(i, i + CHUNK);

        // try each id column until one works
        let data = null, errLast = null;
        for (const col of idCols) {
          try {
            const { data: d, error } = await sb
              .from(table)
              .select('*')
              .in(col, slice)
              .order(col, { ascending: true })
              .limit(2000);
            if (!error && Array.isArray(d)) { data = d; break; }
            errLast = error;
          } catch (e) { errLast = e; }
        }
        if (data && data.length) out.push(...data.map(norm));
      }
      if (out.length) {
        console.info('[throws] using table:', table, 'rows:', out.length);
        break; // found a working table
      }
    } catch (e) {
      console.warn('[throws] failed table', table, e);
    }
  }

  if (!out.length) {
    console.warn('[throws] no throw rows found for supplied game ids:', ids.slice(0,10), '…');
  }
  return out;
}


// ==== (1) Latest Matches ======================================================
window.openPlayerLatestMatchesDialog = async function openPlayerLatestMatchesDialog(playerName){
  const name = String(playerName||'').trim();
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal compact';
  const title   = document.createElement('h3');  title.textContent=`Latest Matches — ${name}`;
  const body    = document.createElement('div'); body.className   ='modal-body';
  const footer  = document.createElement('div'); footer.className ='modal-footer';
  modal.style.maxHeight='90vh'; modal.style.overflow='hidden';
  body .style.maxHeight='none'; body .style.overflowY='visible';

  let games = (await __fetchOfficialGames(5000)).map(__normalizeGame)
    .filter(g => g.players.some(p => String(p||'').trim().toLowerCase()===name.toLowerCase()))
    .sort((a,b)=> (new Date(__gameTs(b.raw)) - new Date(__gameTs(a.raw))));

  const table=document.createElement('table'); table.className='hs-table';
  const thead=document.createElement('thead'); const trh=document.createElement('tr');
  ['#','Position','Points','Round Avg','When'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
  thead.appendChild(trh); table.appendChild(thead);
  Array.from(trh.children).forEach(th => { th.style.position='sticky'; th.style.top='0'; th.style.zIndex='2'; th.style.background='rgba(0,0,0,0.4)'; });
  const tbody=document.createElement('tbody');

  games.forEach((g,i)=>{
    const idx = g.players.findIndex(p => String(p||'').trim().toLowerCase()===name.toLowerCase());
    const score = Number(g.totals[idx]||0);
    const rank = g.totals.map((s,j)=>({j,s:Number(s||0)})).sort((a,b)=>b.s-a.s).findIndex(x=>x.j===idx)+1;
    const rounds=__roundCountFor(g, idx);
    const ravg = rounds ? score/rounds : 0;

    const tr=document.createElement('tr');
    const tdN=document.createElement('td'); tdN.textContent=String(i+1);
    const tdP=document.createElement('td'); tdP.textContent=String(rank||'');
    const tdS=document.createElement('td'); tdS.textContent=String(score);
    const tdA=document.createElement('td'); tdA.textContent=ravg.toFixed(1);
    const tdW=document.createElement('td'); tdW.textContent=(g.ts && typeof window.fmtWhen==='function') ? window.fmtWhen(g.ts) : (g.ts? new Date(g.ts).toLocaleString() : '');
    tr.append(tdN,tdP,tdS,tdA,tdW);
    tr.style.cursor='pointer'; tr.title='Open score sheet';
    tr.onclick = ()=>{ try{ if (typeof openSingleGameScoreSheet==='function') openSingleGameScoreSheet(g.raw); }catch(_){} };
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  const scroll=document.createElement('div'); scroll.style.maxHeight='56vh'; scroll.style.overflowY='auto'; scroll.appendChild(table);
  body.appendChild(scroll);

  const backBtn=document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Close';
  backBtn.onclick=()=>{ overlay.remove(); if (typeof window.openPlayerStatsModePicker==='function') window.openPlayerStatsModePicker(name); };
  closeBtn.onclick=()=>overlay.remove(); footer.append(backBtn,closeBtn);

  modal.append(title,body,footer); overlay.appendChild(modal); document.body.appendChild(overlay);
  overlay.addEventListener('click',e=>{ if(e.target===overlay) overlay.remove();}); overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') overlay.remove();});
  modal.tabIndex=0; modal.focus();
};

// ==== (2) High Scores — per-player (rows open match) =========================
window.openPlayerHighScoresDialog = async function openPlayerHighScoresDialog(playerName){
  const name = String(playerName||'').trim();
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal compact';
  const title   = document.createElement('h3');  title.textContent=`High Scores — ${name}`;
  const body    = document.createElement('div'); body.className   ='modal-body';
  const footer  = document.createElement('div'); footer.className ='modal-footer';
  modal.style.maxHeight='90vh'; modal.style.overflow='hidden';
  body .style.maxHeight='none'; body .style.overflowY='visible';

  let games = (await __fetchOfficialGames(5000)).map(__normalizeGame)
    .filter(g => g.players.some(p => String(p||'').trim().toLowerCase()===name.toLowerCase()));

  // Rows: score + per-game average-per-round
  const rows = [];
  games.forEach(g => {
    const i = g.players.findIndex(p => String(p||'').trim().toLowerCase() === name.toLowerCase());
    const score  = Number(g.totals[i] || 0);
    const rounds = __roundCountFor(g, i);   // uses board if available, else 14
    const avgRound = rounds ? (score / rounds) : 0;
    rows.push({ score, avgRound, ts: g.ts, g });
  });
  rows.sort((a, b) => b.score - a.score);

  const table=document.createElement('table'); table.className='hs-table';
  const thead=document.createElement('thead'); const trh=document.createElement('tr');
  ['#','Score','Avg / Round','When'].forEach(h => { const th = document.createElement('th'); th.textContent = h; trh.appendChild(th); });
  thead.appendChild(trh); table.appendChild(thead);
  Array.from(trh.children).forEach(th => { th.style.position='sticky'; th.style.top='0'; th.style.zIndex='2'; th.style.background='rgba(0,0,0,0.4)'; });

  const tbody=document.createElement('tbody');
  rows.slice(0, 50).forEach((r, idx) => {
    const tr  = document.createElement('tr');
    const tdN = document.createElement('td'); tdN.textContent = String(idx + 1);
    const tdS = document.createElement('td'); tdS.textContent = String(r.score);
    const tdA = document.createElement('td'); tdA.textContent = (Number(r.avgRound) || 0).toFixed(1);
    const tdW = document.createElement('td');
    tdW.textContent = (r.ts && typeof window.fmtWhen === 'function') ? window.fmtWhen(r.ts) : (r.ts ? new Date(r.ts).toLocaleString() : '');
    tr.append(tdN, tdS, tdA, tdW);
    tr.style.cursor = 'pointer'; tr.title = 'Open this match';
    tr.onclick = () => { try { if (typeof openSingleGameScoreSheet === 'function') openSingleGameScoreSheet(r.g.raw); } catch (_) {} };
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);

  const scroll=document.createElement('div'); scroll.style.maxHeight='56vh'; scroll.style.overflowY='auto'; scroll.appendChild(table);
  body.appendChild(scroll);

  const backBtn=document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Close';
  backBtn.onclick=()=>{ overlay.remove(); if (typeof window.openPlayerStatsModePicker==='function') window.openPlayerStatsModePicker(name); };
  closeBtn.onclick=()=>overlay.remove(); footer.append(backBtn,closeBtn);

  modal.append(title,body,footer); overlay.appendChild(modal); document.body.appendChild(overlay);
  overlay.addEventListener('click',e=>{ if(e.target===overlay) overlay.remove();}); overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') overlay.remove();});
  modal.tabIndex=0; modal.focus();
};

// ==== (3) Progression (buttons + proper axes) =============================
window.openPlayerProgressionDialog = async function openPlayerProgressionDialog(playerName){
  const name = String(playerName||'').trim();
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal compact';
  const title   = document.createElement('h3');  title.textContent=`Progression — ${name}`;
  const body    = document.createElement('div'); body.className   ='modal-body';
  const footer  = document.createElement('div'); footer.className ='modal-footer';
  modal.style.maxHeight='90vh'; modal.style.overflow='hidden';
  body .style.maxHeight='none'; body .style.overflowY='visible';

  // --- Load & prep data: sort OLDEST → NEWEST so X (game #) grows left→right
  const games = (await __fetchOfficialGames(5000)).map(__normalizeGame)
    .filter(g => g.players.some(p => String(p||'').trim().toLowerCase()===name.toLowerCase()))
    .sort((a,b)=> (new Date(a.ts) - new Date(b.ts))); // oldest first

  const scores = games.map(g => {
    const i = g.players.findIndex(p => String(p || '').trim().toLowerCase() === name.toLowerCase());
    return Number(g.totals[i] || 0);
  });
  
  // Fixed Y-axis (same for all modes) and overall average (used for the dashed line)
const avgAll = scores.length ? (scores.reduce((s, v) => s + v, 0) / scores.length) : 0;
const baseMaxScore = scores.length ? Math.max(...scores) : 0;
const FIXED_Y_MAX = Math.max(25, Math.ceil(baseMaxScore / 25) * 25);

  // --- UI: mode buttons row
  const row = document.createElement('div');
  row.className = 'row';
  row.style.gap = '8px';
  row.style.marginBottom = '8px';
  const modes = [
    { id:'ALL', label:'All Games' },
    { id:'AVG5',  label:'5 Game AV'  },
    { id:'AVG10', label:'10 Game AV' },
    { id:'AVG20', label:'20 Game AV' },
  ];
  const buttons = [];
  modes.forEach(m=>{
    const b = document.createElement('button');
    b.type='button'; b.className='btn small'; b.textContent=m.label; b.dataset.mode=m.id;
    b.onclick = ()=> { buttons.forEach(x=>x.classList.remove('primary')); b.classList.add('primary'); render(m.id); };
    buttons.push(b); row.appendChild(b);
  });
  // Default
  (buttons[0]||{}).classList.add('primary');

  // Mount row and a container where we’ll draw the chart
  const chartHost = document.createElement('div');
  body.appendChild(row);
  body.appendChild(chartHost);
  chartHost.style.position = 'relative';
  chartHost.style.paddingBottom = '22px'; // space for the pill below the axis labels

// --- helpers
function chunkAvg(arr, k){
  // Non-overlapping buckets: [0..k-1], [k..2k-1], ...; ignore tail < k
  const out = [];
  for (let end = k; end <= arr.length; end += k) {
    const start = end - k;
    const slice = arr.slice(start, end);
    const mean = slice.reduce((s,v)=>s+Number(v||0),0) / slice.length;
    out.push({ x: end, y: mean }); // x = game number at bucket end (5,10,15,...)
  }
  return out;
}

  function render(mode){
    chartHost.innerHTML = '';

   // Build points:
//  - ALL: per-game points (x = 1..N, y = score)
//  - AVG5/10/20: non-overlapping bucket means at x = 5/10/20, 10/20/40, ...
let pts;
if (mode === 'ALL') {
  pts = scores.map((y, idx) => ({ x: idx + 1, y: Number(y || 0) }));
} else if (mode === 'AVG5') {
  pts = chunkAvg(scores, 5);
} else if (mode === 'AVG10') {
  pts = chunkAvg(scores, 10);
} else if (mode === 'AVG20') {
  pts = chunkAvg(scores, 20);
} else {
  pts = scores.map((y, idx) => ({ x: idx + 1, y: Number(y || 0) }));
}
   
    // SVG setup
    const w = 560, h = 260, padL = 36, padB = 28, padT = 10, padR = 10;
    const plotW = w - padL - padR;
    const plotH = h - padT - padB;

    // Axis ranges
const yMin = 0;
const yMax = FIXED_Y_MAX; // keep left scale identical across modes
    const xMin = 1;
const xMax = pts.length ? Math.max(...pts.map(p => p.x)) : 1;
    const sx = x => padL + ((x - xMin) / (xMax - xMin || 1)) * plotW;
    const sy = y => padT + plotH - ((y - yMin) / (yMax - yMin || 1)) * plotH;

    const ns  = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(ns, 'svg');
    svg.setAttribute('width', String(w));
    svg.setAttribute('height', String(h));
    svg.style.display = 'block';
    svg.style.margin  = '6px auto';

    // Axes
    const xAxis = document.createElementNS(ns,'line');
    xAxis.setAttribute('x1', padL); xAxis.setAttribute('y1', padT + plotH);
    xAxis.setAttribute('x2', padL + plotW); xAxis.setAttribute('y2', padT + plotH);
    xAxis.setAttribute('stroke','currentColor'); xAxis.setAttribute('stroke-opacity','0.4');
    svg.appendChild(xAxis);

    const yAxis = document.createElementNS(ns,'line');
    yAxis.setAttribute('x1', padL); yAxis.setAttribute('y1', padT);
    yAxis.setAttribute('x2', padL); yAxis.setAttribute('y2', padT + plotH);
    yAxis.setAttribute('stroke','currentColor'); yAxis.setAttribute('stroke-opacity','0.4');
    svg.appendChild(yAxis);

    // X ticks = game number (step 5 if many)
    const xStep = xMax > 30 ? 5 : 1;
    for (let v = xMin; v <= xMax; v += xStep) {
      const x = sx(v);
      const t = document.createElementNS(ns,'line');
      t.setAttribute('x1', x); t.setAttribute('x2', x);
      t.setAttribute('y1', padT + plotH); t.setAttribute('y2', padT + plotH + 4);
      t.setAttribute('stroke','currentColor'); t.setAttribute('stroke-opacity','0.6');
      svg.appendChild(t);

      const lbl = document.createElementNS(ns,'text');
      lbl.setAttribute('x', x);
      lbl.setAttribute('y', padT + plotH + 16);
      lbl.setAttribute('text-anchor','middle');
      lbl.setAttribute('font-size','10');
      lbl.setAttribute('fill','currentColor');
      lbl.textContent = String(v);
      svg.appendChild(lbl);
    }

    // Y ticks = points (every 25)
    for (let v = yMin; v <= yMax; v += 25) {
      const yy = sy(v);
      const t = document.createElementNS(ns,'line');
      t.setAttribute('x1', padL - 4); t.setAttribute('x2', padL);
      t.setAttribute('y1', yy); t.setAttribute('y2', yy);
      t.setAttribute('stroke','currentColor'); t.setAttribute('stroke-opacity','0.6');
      svg.appendChild(t);

      const lbl = document.createElementNS(ns,'text');
      lbl.setAttribute('x', padL - 6); lbl.setAttribute('y', yy + 3);
      lbl.setAttribute('text-anchor','end');
      lbl.setAttribute('font-size','10'); lbl.setAttribute('fill','currentColor');
      lbl.textContent = String(v);
      svg.appendChild(lbl);
    }
    
    // light gridlines every 50 points across the plot
for (let gv = 50; gv <= yMax; gv += 50) {
  const yy = sy(gv);
  const gl = document.createElementNS(ns, 'line');
  gl.setAttribute('x1', padL);
  gl.setAttribute('x2', padL + plotW);
  gl.setAttribute('y1', yy);
  gl.setAttribute('y2', yy);
  gl.setAttribute('stroke', 'currentColor');
  gl.setAttribute('stroke-opacity', '0.15');
  gl.setAttribute('stroke-dasharray', '2 4');
  svg.appendChild(gl);
}

    // Line + dots (dots only in ALL mode)
    if (pts.length) {
      const path = document.createElementNS(ns,'path');
      path.setAttribute('d', pts.map((p,i) => (i ? 'L' : 'M') + sx(p.x) + ',' + sy(p.y)).join(' '));
path.setAttribute('fill','none');
// Blue in AVG modes, normal color in ALL
path.setAttribute('stroke', (mode === 'ALL') ? 'currentColor' : '#4da3ff');
path.setAttribute('stroke-width','2');
      svg.appendChild(path);

     // Dots only in ALL mode (keep clean lines in AV modes)
if (mode === 'ALL') {
  pts.forEach(p => {
    const c = document.createElementNS(ns,'circle');
    c.setAttribute('cx', sx(p.x)); c.setAttribute('cy', sy(p.y));
    c.setAttribute('r', '2'); c.setAttribute('fill', 'currentColor'); c.setAttribute('fill-opacity', '0.9');
    svg.appendChild(c);
  });
}

// For AVG modes, show labels but de-clutter aggressively
if (mode !== 'ALL') {
  // pixel positions so we can enforce spacing
  const xs = pts.map(p => sx(p.x));
  let lastLabeledX = -Infinity;

  // dynamic spacing — more points ⇒ larger min gap
  const n = pts.length;
  const MIN_GAP = n > 20 ? 48 : (n > 12 ? 40 : 32);

  for (let i = 0; i < pts.length; i++) {
    const p = pts[i];
    const x = xs[i];
    const y = sy(p.y);

    const isFirst = (i === 0);
    const isLast  = (i === pts.length - 1);

    // local extrema (peak or valley)
    let isExtrema = false;
    if (!isFirst && !isLast) {
      const py = pts[i - 1].y;
      const ny = pts[i + 1].y;
      isExtrema = (p.y > py && p.y >= ny) || (p.y < py && p.y <= ny);
    }

    const spacedEnough = (x - lastLabeledX) >= MIN_GAP;

    if (isFirst || isLast || isExtrema || spacedEnough) {
      // slight vertical shift to reduce chance of overlap with line
      const yOffset = isExtrema ? (isLast ? -6 : -10) : -6;

      const tx = document.createElementNS(ns, 'text');
      tx.setAttribute('x', x + 4);
      tx.setAttribute('y', y + yOffset);
      tx.setAttribute('font-size', '10');
      tx.setAttribute('fill', 'currentColor');
      tx.setAttribute('fill-opacity', '0.85');
      tx.setAttribute('pointer-events', 'none');
      tx.textContent = (Number(p.y) || 0).toFixed(1);
      svg.appendChild(tx);

      lastLabeledX = x;
    }
  }
}

// Overall average (visible in ALL and in AV modes)
const yAvg = sy(avgAll);
const avgLine = document.createElementNS(ns,'line');
avgLine.setAttribute('x1', padL);
avgLine.setAttribute('x2', padL + plotW);
avgLine.setAttribute('y1', yAvg);
avgLine.setAttribute('y2', yAvg);
avgLine.setAttribute('stroke', '#4da3ff');       // blue
avgLine.setAttribute('stroke-opacity', '0.7');
avgLine.setAttribute('stroke-dasharray', '4 4');
svg.appendChild(avgLine);
    }

chartHost.appendChild(svg);

// ---- stats pill (mode-aware) ----
const oldPill = chartHost.querySelector('.prog-stats');
if (oldPill) oldPill.remove();

const ys = pts.map(p => Number(p.y) || 0);
const curAvg = ys.length ? ys.reduce((s,v)=>s+v,0) / ys.length : 0;
const lo = ys.length ? Math.min(...ys) : 0;
const hi = ys.length ? Math.max(...ys) : 0;

const pill = document.createElement('div');
pill.className = 'tag prog-stats';
pill.textContent = `Avg ${curAvg.toFixed(1)} • Low ${lo.toFixed(1)} • High ${hi.toFixed(1)}`;
pill.style.position = 'absolute';
pill.style.right = '6px';
pill.style.bottom = '-14px';  // sit just below the axis area
pill.style.zIndex = '3';      // keep above the SVG
pill.style.pointerEvents = 'none';pill.style.opacity = '0.9';
chartHost.appendChild(pill);
  }

// initial render (guarded so an error can’t kill the modal)
try { render('ALL'); } catch (e) { console.error('Progression render failed', e); }

  // Footer
  const backBtn=document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Close';
  backBtn.onclick=()=>{ overlay.remove(); if (typeof window.openPlayerStatsModePicker==='function') window.openPlayerStatsModePicker(name); };
  closeBtn.onclick=()=>overlay.remove(); footer.append(backBtn,closeBtn);

  modal.append(title,body,footer); overlay.appendChild(modal); document.body.appendChild(overlay);
  overlay.addEventListener('click',e=>{ if(e.target===overlay) overlay.remove();}); overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') overlay.remove();});
  modal.tabIndex=0; modal.focus();
};

// ==== (4) Target % — per round (10→20 + D + T + B) ==========================
window.openPlayerTargetPctDialog = async function openPlayerTargetPctDialog(playerName){
  const name = String(playerName||'').trim();
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal compact';
const title   = document.createElement('h3');  title.textContent=`Target Hit % — ${name}`;  const body    = document.createElement('div'); body.className   ='modal-body';
  const footer  = document.createElement('div'); footer.className ='modal-footer';
  modal.style.maxHeight='90vh'; modal.style.overflow='hidden';
  body .style.maxHeight='none'; body .style.overflowY='visible';

// Collect game IDs from player_games (official only), fallback to official games if needed
let ids = [];
try {
  const { data: pg } = await sb
    .from(TABLE_PLAYER_GAMES)
    .select('game_id, is_practice')
    .eq('player', name)
    .eq('is_practice', false)
    .order('game_id', { ascending: true })
    .limit(5000);
  ids = (pg || []).map(r => r.game_id).filter(Boolean);
} catch (_) {}

if (!ids.length) {
  const games = (await __fetchOfficialGames(50000)).map(__normalizeGame);
  ids = games
    .map(g => (g.raw && (g.raw.id || g.raw.game_id)) || g.id || g.game_id)
    .filter(Boolean);
}

let throwsRows = ids.length ? await __fetchThrowsForGames(ids) : [];
if (!throwsRows.length) {
  // Fallback to reconstruct from game boards (lifetime official)
  const gamesAll = (await __fetchOfficialGames(50000)).map(__normalizeGame);
  throwsRows = __throwsFromGamesForPlayer(name, gamesAll);
}
  const labels = __roundLabels();
  const nameLC = name.toLowerCase();

  const taken = Array(14).fill(0), hits = Array(14).fill(0);
  throwsRows.filter(t => String(t.player||'').trim().toLowerCase()===nameLC)
    .forEach(t=>{
      const r=(typeof t.round_index==='number')?t.round_index:null;
      if (r==null || r<0 || r>13) return;
      taken[r] += 1;
      if (Number(t.points||0)>0) hits[r] += 1; // any scoring counts as a hit (incl. bull)
    });

  const table=document.createElement('table'); table.className='hs-table';
  const thead=document.createElement('thead'); const trh=document.createElement('tr');
  ['Round','Throws','Hits','%'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);});  thead.appendChild(trh); table.appendChild(thead);
  const tbody=document.createElement('tbody');
   for (let i=0;i<14;i++){
    const tr=document.createElement('tr');
    const tdR=document.createElement('td'); tdR.textContent=labels[i];
    const tdT=document.createElement('td'); tdT.textContent=String(taken[i]); // Throws
    const tdH=document.createElement('td'); tdH.textContent=String(hits[i]);  // Hits
    const pct= taken[i]? (100*hits[i]/taken[i]) : 0;
    const tdP=document.createElement('td'); tdP.textContent=pct.toFixed(1)+'%';
    tr.append(tdR,tdT,tdH,tdP); tbody.appendChild(tr);
  }
  table.appendChild(tbody);
  const scroll=document.createElement('div'); scroll.style.maxHeight='56vh'; scroll.style.overflowY='auto'; scroll.appendChild(table);
  body.appendChild(scroll);

  const backBtn=document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Close';
  backBtn.onclick=()=>{ overlay.remove(); if (typeof window.openPlayerStatsModePicker==='function') window.openPlayerStatsModePicker(name); };
  closeBtn.onclick=()=>overlay.remove(); footer.append(backBtn,closeBtn);

  modal.append(title,body,footer); overlay.appendChild(modal); document.body.appendChild(overlay);
  overlay.addEventListener('click',e=>{ if(e.target===overlay) overlay.remove();}); overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') overlay.remove();});
  modal.tabIndex=0; modal.focus();
};

// ==== (4b) Target Points % — lifetime, per target (10..20) ===================
window.openPlayerTargetPointsPctDialog = async function openPlayerTargetPointsPctDialog(playerName){
  const name = String(playerName||'').trim();

  // Modal shell
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal compact';
  const title   = document.createElement('h3');  title.textContent = `Target Points % — ${name}`;
  const body    = document.createElement('div'); body.className   ='modal-body';
  const footer  = document.createElement('div'); footer.className ='modal-footer';
  modal.style.maxHeight='90vh'; modal.style.overflow='hidden';
  body .style.maxHeight='none'; body .style.overflowY='visible';

  // Mount early so user always sees something
  modal.append(title,body,footer); overlay.appendChild(modal); document.body.appendChild(overlay);
  overlay.addEventListener('click',e=>{ if(e.target===overlay) overlay.remove();});
  overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') overlay.remove();});
  modal.tabIndex=0; modal.focus();

  const backBtn=document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Close';
  backBtn.onclick=()=>{ overlay.remove(); if (typeof window.openPlayerStatsModePicker==='function') window.openPlayerStatsModePicker(name); };
  closeBtn.onclick=()=>overlay.remove(); footer.append(backBtn,closeBtn);

  body.innerHTML = '<p class="muted">Loading…</p>';

  try{
    // Build official game IDs for this player (lifetime), fallback to scan official games
    let ids = [];
    try {
      const { data: pg } = await sb
        .from(TABLE_PLAYER_GAMES)
        .select('game_id, is_practice')
        .eq('player', name)
        .eq('is_practice', false)
        .order('game_id', { ascending: true })
        .limit(5000);
      ids = (pg || []).map(r => r.game_id).filter(Boolean);
    } catch(_){}

    if (!ids.length) {
      const games = (await __fetchOfficialGames(50000)).map(__normalizeGame);
      ids = games
        .map(g => (g.raw && (g.raw.id || g.raw.game_id)) || g.id || g.game_id)
        .filter(Boolean);
    }

    // Fetch throws; fallback to reconstruct from boards
    let throwsRows = ids.length ? await __fetchThrowsForGames(ids) : [];
    if (!throwsRows.length) {
      const gamesAll = (await __fetchOfficialGames(50000)).map(__normalizeGame);
      throwsRows = __throwsFromGamesForPlayer(name, gamesAll);
    }

    const mineAll = throwsRows.filter(t => String(t.player||'').trim().toLowerCase() === name.toLowerCase());
    const mine    = mineAll.filter(t => typeof t.round_index === 'number' && t.round_index >= 0 && t.round_index <= 10); // 10..20 only

    // Aggregate per target 10..20
    const rows=[];
    for (let r=0; r<=10; r++){
      const target  = 10 + r;
      const shots   = mine.filter(t => t.round_index === r);
      const throwsN = shots.length;

      // Actual Hits (marks): single=1, double=2, treble=3 (miss=0)
      const hitsUnits = shots.reduce((s,t)=>{
        const k = String(t.kind||'').toLowerCase();
        if (k.includes('treble') || k.includes('triple')) return s + 3;
        if (k.includes('double')) return s + 2;
        if (k.includes('single')) return s + (Number(t.points||0) > 0 ? 1 : 0);
        // Fallback: infer from points/target if kind missing
        const ratio = Number(t.points||0) / target;
        if (ratio >= 2.5) return s + 3;
        if (ratio >= 1.5) return s + 2;
        if (ratio >= 0.5) return s + 1;
        return s;
      }, 0);

      const available = 3 * throwsN;                        // 3 marks per dart (9 per round)
      const pct       = available ? (100 * hitsUnits / available) : 0;  // Actual ÷ Available
      const scoreRound = (pct / 100) * 9 * target;          // expected points in one 3-dart round

      rows.push({ target, throwsN, hitsUnits, available, pct, scoreRound });
    }

    // Rank by expected per-round score (desc). Tie: hits, then thrown, then lower target.
    const scoreRanks = rows
      .filter(r => r.throwsN > 0)
      .slice()
      .sort((a,b) =>
        (b.scoreRound - a.scoreRound) ||
        (b.hitsUnits  - a.hitsUnits)  ||
        (b.throwsN    - a.throwsN)    ||
        (a.target     - b.target)
      )
      .map((r, idx) => ({ target: r.target, rank: idx + 1 }));
    const scoreRankMap = new Map(scoreRanks.map(x => [x.target, x.rank]));

    // Table
    const table=document.createElement('table'); table.className='hs-table';
    const thead=document.createElement('thead'); const trh=document.createElement('tr');
    ['Target','Thrown','Available Hits','Actual Hits','Points %','Score','Rank']
      .forEach(h => { const th = document.createElement('th'); th.textContent = h; trh.appendChild(th); });
    thead.appendChild(trh); table.appendChild(thead);

    // sticky header
    Array.from(trh.children).forEach(th => {
      th.style.position = 'sticky';
      th.style.top = '0';
      th.style.zIndex = '2';
      th.style.background = 'rgba(0,0,0,0.4)';
    });

    const tbody=document.createElement('tbody');
    rows.forEach(r=>{
      const tr=document.createElement('tr');

      const tdTarget = document.createElement('td'); tdTarget.textContent = String(r.target);
      const tdThrown = document.createElement('td'); tdThrown.textContent = String(r.throwsN);
      const tdAvail  = document.createElement('td'); tdAvail.textContent  = String(r.available);
      const tdHits   = document.createElement('td'); tdHits.textContent   = String(r.hitsUnits || 0);
      const tdPct    = document.createElement('td'); tdPct.textContent    = (r.pct||0).toFixed(1)+'%';
      const tdScore  = document.createElement('td'); tdScore.textContent  = (r.scoreRound||0).toFixed(1);
      const tdRank   = document.createElement('td'); tdRank.textContent   = String(scoreRankMap.get(r.target) || '—');

      tr.append(tdTarget, tdThrown, tdAvail, tdHits, tdPct, tdScore, tdRank);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);

    const info=document.createElement('p');
    info.className='tag';
    info.style.marginTop='8px';
    info.textContent = 'Actual Hits = single 1 • double 2 • treble 3 — Available Hits = 3 × thrown (9 per round) — Points % = Actual ÷ Available — Score (per round) = Points% × 9 × target';

    const scroll=document.createElement('div');
    scroll.style.maxHeight='56vh';
    scroll.style.overflowY='auto';
    scroll.style.borderRadius='8px';
    scroll.appendChild(table);

    body.innerHTML='';
    body.appendChild(scroll);
    body.appendChild(info);

  }catch(e){
    console.error('Target Points % failed', e);
    body.innerHTML = '<p>Failed to load Target Points %.</p>';
    try{ if (typeof toast==='function') toast('Failed to open Target Points %'); }catch(_){}
  }
};

// ==== (5) D T B Hit % — per number (10..20), lifetime =======================
window.openPlayerDTBPctDialog = async function openPlayerDTBPctDialog(playerName){
  const name = String(playerName||'').trim();
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal compact';
  const title   = document.createElement('h3');  title.textContent = `D T B Hit % — ${name}`;
  const body    = document.createElement('div'); body.className   ='modal-body';
  const footer  = document.createElement('div'); footer.className ='modal-footer';
  modal.style.maxHeight='90vh'; modal.style.overflow='hidden';
  body .style.maxHeight='none'; body .style.overflowY='visible';

// Lifetime throws across all official games (build IDs from player_games)
let ids = [];
try {
  const { data: pg } = await sb
    .from(TABLE_PLAYER_GAMES)
    .select('game_id, is_practice')
    .eq('player', name)
    .eq('is_practice', false)
    .order('game_id', { ascending: true })
    .limit(5000);
  ids = (pg || []).map(r => r.game_id).filter(Boolean);
} catch (_) {}

if (!ids.length) {
  const games = (await __fetchOfficialGames(50000)).map(__normalizeGame);
  ids = games
    .map(g => (g.raw && (g.raw.id || g.raw.game_id)) || g.id || g.game_id)
    .filter(Boolean);
}

let throwsRows = ids.length ? await __fetchThrowsForGames(ids) : [];
if (!throwsRows.length) {
  const gamesAll = (await __fetchOfficialGames(50000)).map(__normalizeGame);
  throwsRows = __throwsFromGamesForPlayer(name, gamesAll);
}
const mineAll = throwsRows.filter(t => String(t.player||'').trim().toLowerCase() === name.toLowerCase());
const mine    = mineAll.filter(t => typeof t.round_index === 'number' && t.round_index >= 0 && t.round_index <= 10); // 10..20 only
const kindL = t => String(t.kind||'').toLowerCase();

  // Build per-target stats for 10..20 (round_index 0..10)
  const rows = [];
  for (let r=0; r<=10; r++){
    const target = 10 + r;
    const shots = mine.filter(t => t.round_index === r);
    const throwsN = shots.length;
    const dHits = shots.filter(t => kindL(t).includes('double')).length;
    const tHits = shots.filter(t => kindL(t).includes('treble') || kindL(t).includes('triple')).length;
    const dPct = throwsN ? (100 * dHits / throwsN) : 0;
    const tPct = throwsN ? (100 * tHits / throwsN) : 0;
    const hitPct = throwsN ? (100 * (dHits + tHits) / throwsN) : 0; // for ranking
    rows.push({ target, throwsN, dPct, tPct, hitPct });
  }
  // Rank by total hit% (D or T) descending, only among rows with throws>0
  const rankedTargets = rows
    .filter(r => r.throwsN > 0)
    .slice()
    .sort((a,b)=> b.hitPct - a.hitPct || b.dPct - a.dPct || b.tPct - a.tPct)
    .map((r,idx)=>({target:r.target, rank: idx+1}));
  const rankMap = new Map(rankedTargets.map(x=>[x.target, x.rank]));

  // Table
  const table=document.createElement('table'); table.className='hs-table';
  const thead=document.createElement('thead'); const trh=document.createElement('tr');
  ['Target','Throws','D %','T %','Rank'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);});
  thead.appendChild(trh); table.appendChild(thead);

  const tbody=document.createElement('tbody');
  rows.forEach(r=>{
    const tr=document.createElement('tr');
    const mk = v => { const td=document.createElement('td'); td.textContent = (typeof v==='number') ? (Number.isFinite(v) ? (v % 1 === 0 ? String(v) : v.toFixed(1)) : '0') : (v??''); return td; };
    tr.append(mk(r.target), mk(r.throwsN), mk(r.dPct ? (r.dPct.toFixed(1)+'%') : '0%'), mk(r.tPct ? (r.tPct.toFixed(1)+'%') : '0%'), mk(rankMap.get(r.target) || '—'));
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);

  const scroll=document.createElement('div'); scroll.style.maxHeight='56vh'; scroll.style.overflowY='auto'; scroll.appendChild(table);
  body.appendChild(scroll);

  const backBtn=document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Close';
  backBtn.onclick=()=>{ overlay.remove(); if (typeof window.openPlayerStatsModePicker==='function') window.openPlayerStatsModePicker(name); };
  closeBtn.onclick=()=>overlay.remove(); footer.append(backBtn,closeBtn);

  modal.append(title,body,footer); overlay.appendChild(modal); document.body.appendChild(overlay);
  overlay.addEventListener('click',e=>{ if(e.target===overlay) overlay.remove();});
  overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') overlay.remove();});
  modal.tabIndex=0; modal.focus();
};

// ==== (4c) D T B % — combined D/T hit rate per target (10..20), lifetime ====
window.openPlayerDTBCombinedPctDialog = async function openPlayerDTBCombinedPctDialog(playerName){
  const name = String(playerName||'').trim();
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal compact';
const title   = document.createElement('h3');  title.textContent = `D T B % (10–20 only) — ${name}`;  const body    = document.createElement('div'); body.className   ='modal-body';
  const footer  = document.createElement('div'); footer.className ='modal-footer';
  modal.style.maxHeight='90vh'; modal.style.overflow='hidden';
  body .style.maxHeight='none'; body .style.overflowY='visible';

  // Build player's official game IDs (lifetime), fallback to scanning official games
  let ids = [];
  try {
    const { data: pg } = await sb
      .from(TABLE_PLAYER_GAMES)
      .select('game_id, is_practice')
      .eq('player', name)
      .eq('is_practice', false)
      .order('game_id', { ascending: true })
      .limit(5000);
    ids = (pg || []).map(r => r.game_id).filter(Boolean);
  } catch (_) {}

  if (!ids.length) {
    const games = (await __fetchOfficialGames(50000)).map(__normalizeGame);
    ids = games
      .map(g => (g.raw && (g.raw.id || g.raw.game_id)) || g.id || g.game_id)
      .filter(Boolean);
  }

  // Fetch throws; if table is absent, reconstruct from boards
  let throwsRows = ids.length ? await __fetchThrowsForGames(ids) : [];
  if (!throwsRows.length) {
    const gamesAll = (await __fetchOfficialGames(50000)).map(__normalizeGame);
    throwsRows = __throwsFromGamesForPlayer(name, gamesAll);
  }

const mineAll = throwsRows.filter(t => String(t.player||'').trim().toLowerCase() === name.toLowerCase());
const mine    = mineAll.filter(t => typeof t.round_index === 'number' && t.round_index >= 0 && t.round_index <= 10); // 10..20 only

// Aggregate per target 10..20
const rows = [];
for (let r = 0; r <= 10; r++) {
  const target  = 10 + r;
  const shots   = mine.filter(t => t.round_index === r);
  const throwsN = shots.length;

  const kindL = t => String(t.kind || '').toLowerCase();

  // Count doubles / trebles
  const dHits = shots.reduce((s,t)=>{
    const k = kindL(t);
    if (k.includes('double')) return s + 1;
    // fallback if kind missing: points/target ≈ 2
    const ratio = Number(t.points||0) / target;
    return s + (ratio >= 1.5 && ratio < 2.5 ? 1 : 0);
  }, 0);

  const tHits = shots.reduce((s,t)=>{
    const k = kindL(t);
    if (k.includes('treble') || k.includes('triple')) return s + 1;
    // fallback if kind missing: points/target ≈ 3
    const ratio = Number(t.points||0) / target;
    return s + (ratio >= 2.5 ? 1 : 0);
  }, 0);

  const dPct = throwsN ? (100 * dHits / throwsN) : 0;
  const tPct = throwsN ? (100 * tHits / throwsN) : 0;

  rows.push({ target, throwsN, dHits, dPct, tHits, tPct });
}

// Build ranks per column (D-only and T-only)
const dRanked = rows
  .filter(r => r.throwsN > 0)
  .slice()
  .sort((a,b) => (b.dPct - a.dPct) || (b.dHits - a.dHits) || (a.target - b.target))
  .map((r,idx) => ({ target: r.target, rank: idx + 1 }));
const tRanked = rows
  .filter(r => r.throwsN > 0)
  .slice()
  .sort((a,b) => (b.tPct - a.tPct) || (b.tHits - a.tHits) || (a.target - b.target))
  .map((r,idx) => ({ target: r.target, rank: idx + 1 }));

const dRankMap = new Map(dRanked.map(x => [x.target, x.rank]));
const tRankMap = new Map(tRanked.map(x => [x.target, x.rank]));

  // Table
  const table=document.createElement('table'); table.className='hs-table';
  const thead=document.createElement('thead'); const trh=document.createElement('tr');
['Target','Throws','Doubles (Hits + %)','D Rank','Trebles (Hits + %)','T Rank']
  .forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
thead.appendChild(trh);
table.appendChild(thead);

  // sticky header
  Array.from(trh.children).forEach(th => {
    th.style.position = 'sticky';
    th.style.top = '0';
    th.style.zIndex = '2';
    th.style.background = 'rgba(0,0,0,0.4)';
  });

 const tbody = document.createElement('tbody');
rows.forEach(r=>{
  const tr = document.createElement('tr');

  const tdTarget = document.createElement('td'); tdTarget.textContent = String(r.target);
  const tdThrows = document.createElement('td'); tdThrows.textContent = String(r.throwsN);

  const tdD = document.createElement('td');
  tdD.textContent = `${r.dHits} (${(r.dPct || 0).toFixed(1)}%)`;
  const tdDRank = document.createElement('td');
  tdDRank.textContent = r.throwsN ? String(dRankMap.get(r.target) || '—') : '—';

  const tdT = document.createElement('td');
  tdT.textContent = `${r.tHits} (${(r.tPct || 0).toFixed(1)}%)`;
  const tdTRank = document.createElement('td');
  tdTRank.textContent = r.throwsN ? String(tRankMap.get(r.target) || '—') : '—';

  tr.append(tdTarget, tdThrows, tdD, tdDRank, tdT, tdTRank);
  tbody.appendChild(tr);
});
table.appendChild(tbody);

  // Append BULL rows (outer & inner) using bull round (round_index === 13).
  // These are informational; D/T columns and ranks do not apply.
  try {
    const bullShots = mineAll.filter(t => t.round_index === 13);
    if (bullShots.length) {
      const totalBullThrows = bullShots.length;

      // Heuristics: kind may be 'inner'/'outer'; otherwise infer via points (≈25 outer, ≈50 inner)
      const outerCount = bullShots.filter(t => {
        const k = String(t.kind || '').toLowerCase();
        if (k.includes('outer')) return true;
        if (k.includes('inner')) return false;
        const pts = Number(t.points || 0);
        return pts > 0 && pts < 40; // ~25
      }).length;

      const innerCount = bullShots.filter(t => {
        const k = String(t.kind || '').toLowerCase();
        if (k.includes('inner')) return true;
        if (k.includes('outer')) return false;
        const pts = Number(t.points || 0);
        return pts >= 40; // ~50
      }).length;

      const addBullRow = (label) => {
        const tr = document.createElement('tr');
        const tdTarget = document.createElement('td'); tdTarget.textContent = label;
        const tdThrows = document.createElement('td'); tdThrows.textContent = String(totalBullThrows);
        const tdD  = document.createElement('td'); tdD.textContent  = '—';
        const tdDR = document.createElement('td'); tdDR.textContent = '—';
        const tdT  = document.createElement('td'); tdT.textContent  = '—';
        const tdTR = document.createElement('td'); tdTR.textContent = '—';
        tr.append(tdTarget, tdThrows, tdD, tdDR, tdT, tdTR);
        tbody.appendChild(tr);
      };

      // Add in this order, after the numeric targets
      addBullRow(`BULL (outer) — hits: ${outerCount}`);
      addBullRow(`BULL (inner) — hits: ${innerCount}`);
    }
  } catch (_) {}

  const scroll=document.createElement('div'); 
  scroll.style.maxHeight='56vh'; 
  scroll.style.overflowY='auto'; 
  scroll.style.borderRadius='8px';
  scroll.appendChild(table);
  body.appendChild(scroll);

  const backBtn=document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Close';
  backBtn.onclick=()=>{ overlay.remove(); if (typeof window.openPlayerStatsModePicker==='function') window.openPlayerStatsModePicker(name); };
  closeBtn.onclick=()=>overlay.remove(); footer.append(backBtn,closeBtn);

  modal.append(title,body,footer); overlay.appendChild(modal); document.body.appendChild(overlay);
  overlay.addEventListener('click',e=>{ if(e.target===overlay) overlay.remove();});
  overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') overlay.remove();});
  modal.tabIndex=0; modal.focus();
};

// ==== (6) H2H — wins/losses vs each opponent =================================
window.openPlayerH2HDialog = async function openPlayerH2HDialog(playerName){
  const nameLC = String(playerName||'').trim().toLowerCase();
  const pretty = playerName;
  const overlay = document.createElement('div'); overlay.className='modal-backdrop';
  const modal   = document.createElement('div'); modal.className  ='modal compact';
  const title   = document.createElement('h3');  title.textContent=`H2H — ${pretty}`;
  const body    = document.createElement('div'); body.className   ='modal-body';
  const footer  = document.createElement('div'); footer.className ='modal-footer';
  modal.style.maxHeight='90vh'; modal.style.overflow='hidden';
  body .style.maxHeight='none'; body .style.overflowY='visible';

  const games=(await __fetchOfficialGames(5000)).map(__normalizeGame)
    .filter(g => g.players.some(p => String(p||'').trim().toLowerCase()===nameLC));

  const vs=new Map();
  games.forEach(g=>{
    const i = g.players.findIndex(p => String(p||'').trim().toLowerCase()===nameLC);
    const me=Number(g.totals[i]||0);
    g.players.forEach((op,j)=>{
      const lc=String(op||'').trim().toLowerCase(); if (!lc || lc===nameLC) return;
      const their=Number(g.totals[j]||0);
      const rec=vs.get(lc) || { opp: op, W:0, L:0, diffs:[], games:0 };
      if (me>their) rec.W++; else if (me<their) rec.L++;
      rec.games++; rec.diffs.push(me-their);
      vs.set(lc,rec);
    });
  });

  const rows=Array.from(vs.values()).map(r=>({
    opp:r.opp, W:r.W, L:r.L,
    winp: (r.W+r.L)? (100*r.W/(r.W+r.L)) : 0,
    avgdiff: r.diffs.length ? (r.diffs.reduce((s,x)=>s+x,0)/r.diffs.length) : 0
  })).sort((a,b)=> (b.winp-a.winp) || (b.avgdiff-a.avgdiff) || String(a.opp).localeCompare(String(b.opp)));

  const table=document.createElement('table'); table.className='hs-table';
  const thead=document.createElement('thead'); const trh=document.createElement('tr');
  ['Opponent','Wins','Losses','Win %','Avg Score Diff'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th);});
  thead.appendChild(trh); table.appendChild(thead);
  const tbody=document.createElement('tbody');
  rows.forEach(r=>{
    const tr=document.createElement('tr');
    const tdO=document.createElement('td'); tdO.textContent=r.opp;
    const tdW=document.createElement('td'); tdW.textContent=String(r.W);
    const tdL=document.createElement('td'); tdL.textContent=String(r.L);
    const tdP=document.createElement('td'); tdP.textContent=r.winp.toFixed(1)+'%';
    const tdD=document.createElement('td'); tdD.textContent=r.avgdiff.toFixed(1);
    tr.append(tdO,tdW,tdL,tdP,tdD); tbody.appendChild(tr);
  });
  table.appendChild(tbody);

  const scroll=document.createElement('div'); scroll.style.maxHeight='56vh'; scroll.style.overflowY='auto'; scroll.appendChild(table);
  body.appendChild(scroll);

  const backBtn=document.createElement('button'); backBtn.className='btn'; backBtn.textContent='Back';
  const closeBtn=document.createElement('button'); closeBtn.className='btn'; closeBtn.textContent='Close';
  backBtn.onclick=()=>{ overlay.remove(); if (typeof window.openPlayerStatsModePicker==='function') window.openPlayerStatsModePicker(pretty); };
  closeBtn.onclick=()=>overlay.remove(); footer.append(backBtn,closeBtn);

  modal.append(title,body,footer); overlay.appendChild(modal); document.body.appendChild(overlay);
  overlay.addEventListener('click',e=>{ if(e.target===overlay) overlay.remove();}); overlay.addEventListener('keydown',e=>{ if(e.key==='Escape') overlay.remove();});
  modal.tabIndex=0; modal.focus();
};

// Back-compat alias (if any old code still calls the previous name)
window.openPlayerDTBPointsPctDialog = function(name){
  return window.openPlayerTargetPointsPctDialog(name);
};

// === Player Stats — shim so the Select Player modal can open stats (always hub) ===
window.openPlayerStatsModePicker = function openPlayerStatsModePicker(name) {
  const n = String(name || '').trim();
  if (!n) { if (typeof toast==='function') toast('Pick a player'); return; }
  if (typeof window.openPlayerStatsHub === 'function') return window.openPlayerStatsHub(n);
  // Fallback: open the detail dialog if hub is somehow missing
  if (typeof window.openPlayerStatsDialog === 'function') return window.openPlayerStatsDialog(n);
  if (typeof toast==='function') toast('Stats view not available in this build');
};

// ---- ensure "New Game" button always works ----
document.addEventListener('DOMContentLoaded', function(){
  const btn = document.getElementById('newGameBtn') || document.getElementById('startNewGameBtn');
  if (!btn) return;
  btn.onclick = function(){
    try {
      if (typeof window.openSelectPlayersDialog === 'function') {
        window.openSelectPlayersDialog();
      } else if (typeof window.startNewGame === 'function') {
        window.startNewGame();
      } else if (typeof window.openPlayerSelectDialog === 'function') {
        window.openPlayerSelectDialog();
      } else {
        console.warn('No New Game opener found');
      }
    } catch(e){
      console.error('New Game failed', e);
      try { if (typeof toast==='function') toast('Failed to open New Game'); } catch(_) {}
    }
  };
});

// === Christmas Theme (non-destructive, can be toggled) =======================
(function(){
  const STYLE_ID   = 'xmasStyles';
  const LIGHTS_ID  = 'xmasLights';
  const SNOW_ID    = 'xmasSnow';
  const TOGGLE_ID  = 'xmasToggle';

  let rafId = null;
  let flakes = [];

  function injectStyles(){
    if (document.getElementById(STYLE_ID)) return;
    const css = `
      /* palette + subtle effects */
      body.xmas {
        --brand: #e44343;            /* red */
        --brand-2: #28b35e;          /* pine */
        --hint: rgba(255,255,255,.65);
      }
      body.xmas .btn.primary { box-shadow: 0 0 0 2px rgba(255,255,255,.06), 0 8px 20px rgba(40,179,94,.25); }
      body.xmas .btn.primary:hover { box-shadow: 0 0 0 2px rgba(255,255,255,.08), 0 10px 26px rgba(228,67,67,.30); }
      body.xmas .tag { border: 1px solid rgba(255,255,255,.08); }
      /* title hat (cute, optional) */
      body.xmas h1::after, body.xmas .app-title::after {
        content: '🎅';
        margin-left: .35rem;
        filter: drop-shadow(0 1px 0 rgba(0,0,0,.35));
      }
      /* twinkling lights bar */
      #${LIGHTS_ID} {
        position: fixed; inset: 0 0 auto 0; height: 8px; z-index: 9999; pointer-events: none;
        background:
          radial-gradient(circle at  4% 50%, #ff4d4d 0 3px, transparent 4px) 0 0/60px 100%,
          radial-gradient(circle at 20% 50%, #ffd24d 0 3px, transparent 4px) 0 0/60px 100%,
          radial-gradient(circle at 36% 50%, #5be37d 0 3px, transparent 4px) 0 0/60px 100%,
          radial-gradient(circle at 52% 50%, #4da3ff 0 3px, transparent 4px) 0 0/60px 100%,
          radial-gradient(circle at 68% 50%, #ff7ad1 0 3px, transparent 4px) 0 0/60px 100%,
          radial-gradient(circle at 84% 50%, #fff 0 3px, transparent 4px) 0 0/60px 100%;
        animation: xmasTwinkle 1.8s ease-in-out infinite alternate;
        opacity: .85;
      }
      @keyframes xmasTwinkle { from { filter: brightness(.9); } to { filter: brightness(1.15); } }

      /* snowfall canvas sits above UI but non-interactive */
      #${SNOW_ID} {
        position: fixed; inset: 0; pointer-events: none; z-index: 9998; opacity: .85;
      }

      /* small floating toggle button */
      #${TOGGLE_ID} {
        position: fixed; right: 10px; bottom: 10px; z-index: 10000;
        border-radius: 999px; padding: 6px 10px; font-size: 14px;
        background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.12);
        backdrop-filter: blur(4px);
      }
      #${TOGGLE_ID}.on { background: rgba(40,179,94,.22); border-color: rgba(40,179,94,.35); }
            /* candy-cane accents */
      body.xmas .modal.compact::before {
        content: '';
        position: absolute; left: 0; right: 0; top: 0; height: 6px;
        background: repeating-linear-gradient(45deg,
          #e44343 0 10px, #ffffff 10px 20px, #28b35e 20px 30px, #ffffff 30px 40px);
        border-top-left-radius: 6px; border-top-right-radius: 6px;
        opacity: .9; pointer-events: none;
      }
      body.xmas table.hs-table thead th {
        border-bottom: 2px solid rgba(255,255,255,.15);
        background-image: linear-gradient(to bottom, rgba(255,255,255,.05), rgba(0,0,0,0));
      }
      /* medal glow */
      body.xmas .medal-gold  { filter: drop-shadow(0 0 6px rgba(255,215,0,.45)); }
      body.xmas .medal-silver{ filter: drop-shadow(0 0 6px rgba(210,210,210,.35)); }
      body.xmas .medal-bronze{ filter: drop-shadow(0 0 6px rgba(205,127,50,.35)); }
      /* heavy mode: brighter lights bar */
      body[data-xmas="heavy"] #xmasLights { filter: brightness(1.25); }
      /* subtle snow pile at the very bottom */
      body.xmas::after{
        content:''; position:fixed; left:0; right:0; bottom:0; height:18px; z-index:2; pointer-events:none;
        background: radial-gradient(50% 120% at 50% 150%, rgba(255,255,255,.25), rgba(255,255,255,0) 70%);
      }
      
    `;
    const style = document.createElement('style');
    style.id = STYLE_ID;
    style.textContent = css;
    document.head.appendChild(style);
  }
  
  

  function addLights(){
    if (document.getElementById(LIGHTS_ID)) return;
    const bar = document.createElement('div');
    bar.id = LIGHTS_ID;
    document.body.appendChild(bar);
  }

   function startSnow(mode){
    if (document.getElementById(SNOW_ID)) return;
    setSnowCfgFor(mode || getSavedMode() || 'light');

    const c = document.createElement('canvas');
    c.id = SNOW_ID;
    const ctx = c.getContext('2d');
    document.body.appendChild(c);

    function resize(){
      c.width = window.innerWidth; c.height = window.innerHeight;
      const base = Math.round((c.width * c.height) / 15000); // baseline density
      const target = Math.min(220, Math.max(40, Math.round(base * snowCfg.density)));
      flakes = Array.from({length: target}, ()=>({
        x: Math.random() * c.width,
        y: Math.random() * c.height,
        r: 0.8 + Math.random() * 2.2,
        s: (0.4 + Math.random() * 0.9) * snowCfg.speed,  // speed by mode
        d: Math.random() * 2 * Math.PI
      }));
    }
    resize();
    window.addEventListener('resize', resize);

    function tick(){
      ctx.clearRect(0,0,c.width,c.height);
      ctx.fillStyle = 'rgba(255,255,255,.9)';
      for (const f of flakes){
        f.y += f.s;
        f.x += Math.sin(f.d += 0.01) * 0.45;
        if (f.y > c.height + 6) { f.y = -6; f.x = Math.random()*c.width; }
        ctx.beginPath(); ctx.arc(f.x, f.y, f.r, 0, Math.PI*2); ctx.fill();
      }
      rafId = requestAnimationFrame(tick);
    }
    rafId = requestAnimationFrame(tick);
  }

  function stopSnow(){
    if (rafId) cancelAnimationFrame(rafId), rafId = null;
    const c = document.getElementById(SNOW_ID);
    if (c) c.remove();
    flakes = [];
  }
  function ensureToggle(){
    if (document.getElementById(TOGGLE_ID)) return;
    const btn = document.createElement('button');
    btn.id = TOGGLE_ID;
    btn.className = 'btn small';
    btn.type = 'button';
    document.body.appendChild(btn);

    btn.onclick = () => {
      // cycle: off -> light -> medium -> heavy -> off
      const enabled = document.body.classList.contains('xmas');
      let mode = (document.body.dataset.xmas || getSavedMode() || 'light');
      if (!enabled) {
        mode = 'light';
        enableXmas(true, mode);
      } else {
        const i = MODES.indexOf(mode);
        if (i < MODES.length - 1) {
          mode = MODES[i+1];
          // update without turning off
          setSnowCfgFor(mode);
          stopSnow(); startSnow(mode);
          localStorage.setItem('xmas','1');
          localStorage.setItem('xmasMode', mode);
        } else {
          // go OFF
          disableXmas(true);
        }
      }
      updateToggle();
    };

    updateToggle();
  }

  function updateToggle(){
    const btn = document.getElementById(TOGGLE_ID);
    if (!btn) return;
    const enabled = document.body.classList.contains('xmas');
    const mode = document.body.dataset.xmas || getSavedMode() || (enabled ? 'light' : 'off');
    btn.classList.toggle('on', enabled);
    btn.textContent = enabled ? `🎄 Xmas: ${mode[0].toUpperCase()+mode.slice(1)}` : '🎄 Xmas: Off';
  }

  function enableXmas(user, mode){
    injectStyles();
    document.body.classList.add('xmas');
    setSnowCfgFor(mode || getSavedMode() || 'light');
    addLights();
    startSnow(mode);
    ensureToggle(); updateToggle();
    if (user) {
      localStorage.setItem('xmas','1');
      localStorage.setItem('xmasMode', document.body.dataset.xmas || 'light');
    }
  }
  function disableXmas(user){
    document.body.classList.remove('xmas');
    document.body.removeAttribute('data-xmas');
    document.getElementById(LIGHTS_ID)?.remove();
    stopSnow();
    ensureToggle(); updateToggle();
    if (user) {
      localStorage.removeItem('xmas');
      localStorage.removeItem('xmasMode');
    }
  }

  // expose just in case
  window.enableChristmasTheme = enableXmas;
  window.disableChristmasTheme = disableXmas;

   // auto-enable in December or if user saved a mode
  const isDec = (new Date().getMonth() === 11);
  const saved = getSavedMode();
  if (saved) {
    setTimeout(()=> enableXmas(false, saved), 0);
  } else if (isDec) {
    setTimeout(()=> enableXmas(false, 'light'), 0);
  } else {
    setTimeout(()=> ensureToggle(), 0);
  }
    // Snow mode (light/medium/heavy)
  const MODES = ['light','medium','heavy'];
  let snowCfg = { density: 1.0, speed: 1.0 };

  function setSnowCfgFor(mode){
    if (mode === 'medium') { snowCfg = { density: 1.6, speed: 1.2 }; }
    else if (mode === 'heavy') { snowCfg = { density: 2.2, speed: 1.4 }; }
    else { snowCfg = { density: 1.0, speed: 1.0 }; }
    document.body.dataset.xmas = mode || 'light';
  }

  function getSavedMode(){
    return localStorage.getItem('xmasMode') || (localStorage.getItem('xmas')==='1' ? 'light' : '');
  }
})();

// === End Game (Leaderboard only): insert "PREMIER LEAGUE" below HIGH SCORES ===
(function plBtnLeaderboardOnly(){
  function onLeaderboard(){
    return (document.body && (document.body.dataset.page || '').toLowerCase()) === 'leaderboard';
  }
  function findLeaderboardHighScoresButton(){
    // search only within the leaderboard page
    const root = document.querySelector('[data-page="leaderboard"]') || document.body;
    return Array.from(root.querySelectorAll('button,.btn,[role="button"]'))
      .find(el => /^\s*high\s*scores\s*$/i.test((el.textContent || '')));
  }
  function ensureOpener(){
    // use existing opener if defined; otherwise click any visible UI that opens PL
    return async function openPL(){
      if (typeof window.openPremierLeaguePopup === 'function') { try { window.openPremierLeaguePopup(); return; } catch(_){} }
      const trigger = Array.from(document.querySelectorAll('button,.btn,a,[role="button"]'))
        .find(el => /premier\s*league|records/i.test((el.textContent||'')) && el.offsetParent);
      if (trigger) trigger.click();
    };
  }
  function ensureBtn(){
    if (!onLeaderboard()) return;
    const hs = findLeaderboardHighScoresButton();
    if (!hs) return;
    if (document.getElementById('btnPremierLeague')) return;

    const btn = document.createElement('button');
    btn.id = 'btnPremierLeague';
    btn.className = hs.className || 'btn';
    btn.type = 'button';
    btn.textContent = 'PREMIER LEAGUE';
    const openPL = ensureOpener();
    btn.addEventListener('click', (e)=>{ e.preventDefault(); openPL(); });

    // place directly under the High Scores button on the leaderboard screen
    hs.insertAdjacentElement('afterend', btn);
  }
  function tick(){ ensureBtn(); }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', tick); else tick();
  new MutationObserver(tick).observe(document.body || document.documentElement, { childList:true, subtree:true });
})();


// === Premier League — TODAY (clone a month pill; no min-games rule) =========
(function premierLeagueTodayCloneMonth(){
  const TITLE_RX = /^\s*premier league\s*$/i;
  const MONTHS   = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];

  // ---- helpers --------------------------------------------------------------
  function findModal(){
    const mods = document.querySelectorAll('.modal,[role="dialog"]');
    for (const m of mods){
      if (Array.from(m.querySelectorAll('h1,h2,h3')).some(h => TITLE_RX.test(h.textContent||''))) return m;
    }
    return null;
  }
  function findTabsRow(modal){
    if (!modal) return null;
    const blocks = modal.querySelectorAll('div,nav,section');
    for (const c of blocks){
      const btns = Array.from(c.querySelectorAll('button,.btn,[role="tab"]'));
      if (!btns.length) continue;
      const labs = btns.map(b => (b.textContent||'').trim().toUpperCase());
      const hasAll   = labs.includes('ALL TIME') || labs.includes('ALL') || labs.includes('ALLTIME');
      const hasMonth = labs.some(t => MONTHS.includes(t));
      const hasRec   = labs.includes('RECORDS');
      if (hasAll && (hasMonth || hasRec)) return c;
    }
    return null;
  }
  const visible = el => !!(el && el.offsetParent !== null);

  function todayRange(){
    const now = new Date();
    const start = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const end   = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1);
    return { start, end };
  }

  // ---- render Today table (replaces only the table, keeps pills visible) ----
  async function renderToday(modal){
   let row = findTabsRow(modal);
if (!row || row.offsetParent === null) {
  row = createFallbackTabsRow(modal);
}
let todayBtn = row && Array.from(row.querySelectorAll('button,.btn,[role="tab"]'))
  .find(b => /^today$/i.test((b.textContent||'').trim()));
if (!todayBtn) {
  // make sure there is a TODAY pill in this row
  const sample = row.querySelector('button,.btn,[role="tab"]');
  const tag = (sample && sample.tagName) ? sample.tagName.toLowerCase() : 'button';
  todayBtn = document.createElement(tag);
  todayBtn.type = 'button';
  todayBtn.setAttribute('role', (sample && (sample.getAttribute('role') || 'tab')) || 'tab');
  todayBtn.className = (sample && sample.className) || 'btn small';
  todayBtn.textContent = 'TODAY';
  row.insertAdjacentElement('afterbegin', todayBtn);
  todayBtn.addEventListener('click', (e)=>{ e.preventDefault(); renderToday(modal); });
}


    // hide only the table, NOT the tabs row
    const existingTable = modal.querySelector('table.hs-table');
    if (existingTable && !existingTable.dataset._pl_today_hidden){
      existingTable.dataset._pl_today_hidden = '1';
      existingTable.style.display = 'none';
    }

    // hide "X Games Minimum" banner (TODAY has no minimum)
    Array.from(modal.querySelectorAll('.tag,div,p,span'))
      .filter(el => /games\s+minimum/i.test((el.textContent||'')))
      .forEach(el => el.style.display = 'none');

    // remove any previous Today mount
    modal.querySelector('#plTodayMount')?.remove();

    // fetch & reduce
    let games = [];
    try { games = (await __fetchOfficialGames(50000)).map(__normalizeGame); } catch(e){ console.error(e); }
    const { start, end } = todayRange();
    games = games.filter(g => {
      const t = __gameTs(g.raw || g);
      if (!t) return false; const d = new Date(t);
      return d >= start && d < end;
    });

    const by = new Map(); // name -> {games,sum,best}
    games.forEach(g=>{
      (g.players||[]).forEach((p,i)=>{
        const name = String(p||'').trim(); if (!name) return;
        const score = Number(g.totals?.[i] || 0);
        const r = by.get(name) || { games:0, sum:0, best:0 };
        r.games += 1; r.sum += score; r.best = Math.max(r.best, score);
        by.set(name, r);
      });
    });
    const rows = Array.from(by.entries()).map(([name,r])=>({
      name, games:r.games, avg: r.games ? (r.sum / r.games) : 0, best:r.best
    })).sort((a,b)=> (b.avg - a.avg) || (b.games - a.games) || a.name.localeCompare(b.name));

    // build UI
    const mount = document.createElement('div'); mount.id = 'plTodayMount';

    const banner = document.createElement('div');
    banner.className = 'tag'; banner.textContent = 'Today Only'; banner.style.margin='6px 0';
    mount.appendChild(banner);

    const scroll = document.createElement('div');
    scroll.style.maxHeight='56vh'; scroll.style.overflowY='auto'; scroll.style.borderRadius='8px';
    mount.appendChild(scroll);

    const table = document.createElement('table'); table.className = 'hs-table';
    const thead = document.createElement('thead'); const trh = document.createElement('tr');
    ['#','Player','Games','Avg Total','Best'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
    thead.appendChild(trh); table.appendChild(thead);
    const tbody = document.createElement('tbody');
    rows.forEach((r,i)=>{
      const tr=document.createElement('tr');
      const td=v=>{const t=document.createElement('td'); t.textContent=v; return t;};
      tr.append(td(String(i+1)), td(r.name), td(String(r.games)), td((r.avg||0).toFixed(1)), td(String(r.best||0)));
      tbody.appendChild(tr);
    });
    table.appendChild(tbody); scroll.appendChild(table);

    // place the mount directly under the tabs row if visible, else top of modal body
    const rowEl = row && visible(row) ? row : null;
    if (rowEl) rowEl.insertAdjacentElement('afterend', mount);
    else (modal.querySelector('.modal-body') || modal).insertAdjacentElement('afterbegin', mount);
  }

  // ---- restore the app's default view when leaving TODAY --------------------
  function restore(modal){
    modal.querySelector('#plTodayMount')?.remove();
    Array.from(modal.querySelectorAll('.tag,div,p,span'))
      .filter(el => /games\s+minimum/i.test((el.textContent||'')))
      .forEach(el => el.style.display = '');
    const t = modal.querySelector('table.hs-table[data-_pl_today_hidden="1"]') || modal.querySelector('table.hs-table');
    if (t) { t.style.display=''; delete t.dataset._pl_today_hidden; }
  }
  
  function createFallbackTabsRow(modal){
  // if a visible real row exists, use it
  const real = findTabsRow(modal);
  if (real && real.offsetParent !== null) return real;

  // Build a compact row and clone styling from any button we can find
  const sampleBtn = modal.querySelector('button,.btn,[role="tab"]');
  const mk = (label) => {
    const tag = (sampleBtn && sampleBtn.tagName) ? sampleBtn.tagName.toLowerCase() : 'button';
    const b = document.createElement(tag);
    b.type = 'button';
    b.setAttribute('role', (sampleBtn && (sampleBtn.getAttribute('role') || 'tab')) || 'tab');
    b.className = (sampleBtn && sampleBtn.className) || 'btn small';
    b.textContent = label;
    return b;
  };

  const row = document.createElement('div');
  row.id = 'plTodayTabsFallback';
  row.style.display = 'flex';
  row.style.flexWrap = 'wrap';
  row.style.gap = '8px';
  row.style.margin = '6px 0 8px';

  // Standard set: RECORDS, ALL TIME, TODAY, months (DEC → JAN)
  const pills = [mk('RECORDS'), mk('ALL TIME'), mk('TODAY'), ...[...MONTHS].reverse().map(m => mk(m))];
  pills.forEach(b => row.appendChild(b));

  // Mount right under the title so it's always visible
  const titleEl = modal.querySelector('h1,h2,h3');
  if (titleEl) titleEl.insertAdjacentElement('afterend', row);
  else (modal.querySelector('.modal-body') || modal).insertAdjacentElement('afterbegin', row);

  // Wire: TODAY renders our view; other pills restore and try to trigger the real tab
  const clickOther = (label) => {
        restore(modal);
    const realRow = findTabsRow(modal);
    if (realRow) {
      const target = Array.from(realRow.querySelectorAll('button,.btn,[role="tab"]'))
        .find(b => new RegExp(`^${label}$`, 'i').test((b.textContent || '').trim()));
      if (target) target.click();
    }
  };
  pills.forEach(b => {
    const label = (b.textContent || '').trim().toUpperCase();
    if (label === 'TODAY') b.addEventListener('click', (e)=>{ e.preventDefault(); renderToday(modal); });
    else b.addEventListener('click', ()=> clickOther(label));
  });

  return row;
}

  // ---- add a TODAY pill by cloning a real month pill -----------------------
  function ensureTodayPill(modal){
    const row = findTabsRow(modal); if (!row || !visible(row)) return null;

    // already present?
    let btn = Array.from(row.querySelectorAll('button,.btn,[role="tab"]'))
      .find(b => /^today$/i.test((b.textContent||'').trim()));
    if (btn) return btn;

    // clone a month pill to copy exact styling
    const monthBtn = Array.from(row.querySelectorAll('button,.btn,[role="tab"]'))
      .find(b => MONTHS.includes((b.textContent||'').trim().toUpperCase()));
    if (!monthBtn) return null;

    const clone = monthBtn.cloneNode(true);
    clone.textContent = 'TODAY';
    clone.dataset.mode = 'TODAY';
    // remove any existing handlers by replacing the node
    const tag = clone.tagName.toLowerCase(); const fresh = document.createElement(tag);
    fresh.className = clone.className; fresh.type = 'button'; fresh.setAttribute('role', clone.getAttribute('role') || 'tab');
    fresh.textContent = 'TODAY'; fresh.dataset.mode = 'TODAY';

    // place it right after ALL TIME if present; else before first month
    const allBtn = Array.from(row.querySelectorAll('button,.btn,[role="tab"]')).find(b => /all\s*time/i.test((b.textContent||'')));
    if (allBtn && allBtn.parentElement === row) allBtn.insertAdjacentElement('afterend', fresh);
    else monthBtn.insertAdjacentElement('beforebegin', fresh);

    // wire: render Today on click
    fresh.addEventListener('click', (e)=>{ e.preventDefault(); renderToday(modal); });

    // when any other pill is clicked, restore the default table/banner
    if (!row.dataset._todayRestoreWired){
      row.dataset._todayRestoreWired = '1';
      row.addEventListener('click', (e)=>{
        const label = (e.target && (e.target.textContent||'').trim().toUpperCase()) || '';
        if (label && label !== 'TODAY') restore(modal);
      }, true);
    }

    return fresh;
  }

  function tick(){
    const m = findModal(); if (!m) return;
    ensureTodayPill(m);
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', tick); else tick();
  const mo = new MutationObserver(tick);
  mo.observe(document.body || document.documentElement, { childList:true, subtree:true });
})();

// === High Score League — rewritten: NEW + movement + even widths ============
(function highScoreLeagueRewritten(){
  const TITLE_RX = /high\s*score\s*league/i;
  const STORAGE_KEY = 'hsLeaguePositions.v2';
  const NEW_LIMIT_DAYS = 14;

  // ---- utilities ------------------------------------------------------------
  const daysBetween = (a,b) => Math.floor((a - b) / 86400000);
  const visible = el => !!(el && el.offsetParent !== null);

  function findHSModal(){
    const mods = document.querySelectorAll('.modal,[role="dialog"]');
    for (const m of mods){
      const ok = Array.from(m.querySelectorAll('h1,h2,h3'))
        .some(h => TITLE_RX.test(h.textContent || ''));
      if (ok) return m;
    }
    return null;
  }

  function getTable(modal){
    if (!modal) return null;
    const table = modal.querySelector('table.hs-table');
    if (!table) return null;
    const ths = Array.from(table.querySelectorAll('thead th'));
    if (!ths.length) return null;

    // Expected headers: "# | Player | High Score | When"
    const idxPos    = 0; // "#"
    const idxPlayer = ths.findIndex(th => /player/i.test(th.textContent||''));
    const idxHigh   = ths.findIndex(th => /high\s*score/i.test(th.textContent||''));
    const idxWhen   = ths.findIndex(th => /when/i.test(th.textContent||''));
    if (idxPlayer < 0 || idxHigh < 0 || idxWhen < 0) return null;
    return { table, ths, idxPos, idxPlayer, idxHigh, idxWhen };
  }

  async function earliestMap(){
    if (window.__hsEarliestMap_v2) return window.__hsEarliestMap_v2;
    let games = [];
    try { games = (await __fetchOfficialGames(50000)).map(__normalizeGame); } catch(_){}
    const map = new Map(); // nameLC -> earliest Date
    games.forEach(g=>{
      const t = __gameTs(g.raw || g); if (!t) return;
      const d = new Date(t);
      (g.players||[]).forEach(p=>{
        const k = String(p||'').trim().toLowerCase(); if (!k) return;
        const cur = map.get(k);
        if (!cur || d < cur) map.set(k, d);
      });
    });
    window.__hsEarliestMap_v2 = map;
    return map;
  }

  function arrowHTML(delta){
    if (delta > 0) return `<span title="+${delta}" style="color:#22c55e;font-weight:700">▲</span>`;
    if (delta < 0) return `<span title="${delta}" style="color:#ef4444;font-weight:700">▼</span>`;
    return `<span style="opacity:.5">–</span>`;
  }

  // ---- main apply -----------------------------------------------------------
  async function apply(modal){
    const refs = getTable(modal); if (!refs) return;
    const { table, ths, idxPos, idxPlayer, idxHigh, idxWhen } = refs;

    // 1) Insert movement header AFTER "#"
    let thMove = table.querySelector('thead th[data-move-col="1"]');
    if (!thMove){
      thMove = document.createElement('th');
      thMove.dataset.moveCol = '1';
      thMove.style.textAlign = 'center';
      thMove.style.width     = '26px';
      thMove.style.minWidth  = '24px';
      thMove.style.maxWidth  = '36px';
      ths[idxPos].insertAdjacentElement('afterend', thMove);
    }

    // 2) Even spacing for Player / High Score / When
    const headNow = Array.from(table.querySelectorAll('thead th'));
    const idxMove = headNow.findIndex(th => th.dataset && th.dataset.moveCol === '1');

    table.style.tableLayout = 'fixed';
    table.style.width = '100%';
    if (headNow[0]) {
      headNow[0].style.width    = '36px';
      headNow[0].style.minWidth = '32px';
      headNow[0].style.maxWidth = '42px';
    }
    if (idxMove >= 0 && headNow[idxMove]) {
      headNow[idxMove].style.width     = '26px';
      headNow[idxMove].style.minWidth  = '24px';
      headNow[idxMove].style.maxWidth  = '34px';
      headNow[idxMove].style.textAlign = 'center';
    }
    // recompute indexes by text (header DOM may have shifted)
    const idxPlayerNow = headNow.findIndex(th => /player/i.test(th.textContent||''));
    const idxHighNow   = headNow.findIndex(th => /high\s*score/i.test(th.textContent||''));
    const idxWhenNow   = headNow.findIndex(th => /when/i.test(th.textContent||''));

    const fixedPx = 36 + (idxMove >= 0 ? 26 : 0);
    const EVEN = `calc((100% - ${fixedPx}px) / 3)`;
    [idxPlayerNow, idxHighNow, idxWhenNow].forEach(i => {
      if (i >= 0 && headNow[i]) headNow[i].style.width = EVEN;
    });

    // 3) Per-row: add movement cell; add NEW tag if first-game ≤ 14 days
    const prevRaw = localStorage.getItem(STORAGE_KEY);
    const prevMap = prevRaw ? JSON.parse(prevRaw) : {}; // nameLC -> prev position
    const now = new Date();
    const firstMap = await earliestMap();

    const rows = Array.from(table.querySelectorAll('tbody tr'));
    const curMap = {}; // nameLC -> current position

    rows.forEach((tr, i) => {
      const pos = i + 1;
      const tds = Array.from(tr.children);
      const tdPos    = tds[idxPos];
      // movement cell sits AFTER position; if not there, create
      let tdMove = tds[idxMove];
      if (!tdMove || tdMove === tdPos || tdMove.dataset.moveCell !== '1') {
        tdMove = document.createElement('td');
        tdMove.dataset.moveCell = '1';
        tdMove.style.textAlign = 'center';
        tdPos.insertAdjacentElement('afterend', tdMove);
      }

      // After inserting a new td, refresh children and resolve Player cell
      const tds2 = Array.from(tr.children);
      // Player column shifts by +1 if movement col was inserted before it
      const tdPlayerCell = tds2[(idxPlayerNow >= 0 ? idxPlayerNow : idxPlayer) + (idxMove >= 0 ? 1 : 0)];
      if (!tdPlayerCell) return;

      // Player name (strip any existing "NEW")
      const nameText = (tdPlayerCell.textContent || '').replace(/\bNEW\b/gi,'').trim();
      const nameLC = nameText.toLowerCase();
      curMap[nameLC] = pos;

      // Movement arrow against previous snapshot
      let html = '<span style="opacity:.5">–</span>';
      const prevPos = prevMap[nameLC];
      if (typeof prevPos === 'number') {
        const delta = prevPos - pos; // positive = moved UP (better)
        html = arrowHTML(delta);
      }
      tdMove.innerHTML = html;

      // NEW tag (first official game within the last 14 days)
      if (nameLC && firstMap.has(nameLC)) {
        const first = firstMap.get(nameLC);
        const isNew = daysBetween(now, first) <= NEW_LIMIT_DAYS && daysBetween(now, first) >= 0;
        if (isNew && !/\bNEW\b/i.test(tdPlayerCell.innerHTML)) {
          const tag = document.createElement('span');
          tag.className = 'tag';
          tag.textContent = 'NEW';
          tag.style.marginLeft = '6px';
          tdPlayerCell.appendChild(tag);
        }
      }
    });

    // 4) Save snapshot for next time
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(curMap)); } catch(_) {}
  }

  // Debounced observer to apply when the league modal appears/updates
  let scheduled = false;
  function tick(){
    const m = findHSModal();
    if (!m || !visible(m)) return;
    if (scheduled) return;
    scheduled = true;
    requestAnimationFrame(async ()=>{ scheduled = false; try { await apply(m); } catch(e){ console.error(e); } });
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', tick); else tick();
  const mo = new MutationObserver(tick);
  mo.observe(document.body || document.documentElement, { childList:true, subtree:true });
})();

// === High Scores (Match) — v3: DD/MM/YY @ HH:MM + NEW(7d) + PB + narrow # ===
(function enhanceHighScoresMatch_v3(){
  const TITLE_RX = /^\s*high\s*scores\s*$/i;
  // Expected header: "# | Player | Score | Avg / Round | When"
  const COLS_RX  = [/^#$/i, /player/i, /^score$/i, /avg\s*\/\s*round/i, /when/i];
  const NEW_MS   = 7 * 24 * 60 * 60 * 1000; // 7 days

  // ---------- helpers ----------
  function findModalAndTable(){
    const mods = document.querySelectorAll('.modal,[role="dialog"]');
    for (const m of mods){
      const ok = Array.from(m.querySelectorAll('h1,h2,h3'))
        .some(h => TITLE_RX.test(h.textContent||''));
      if (!ok) continue;
      const table = m.querySelector('table.hs-table'); if (!table) continue;
      const ths = Array.from(table.querySelectorAll('thead th'));
      if (ths.length < 5) continue;
      const matches = COLS_RX.every((rx, idx)=> rx.test((ths[idx].textContent||'').trim()));
      if (matches) return { modal: m, table, ths };
    }
    return null;
  }

  // "20 Nov 25 at 20:35"  or "20 Nov 25 @ 20:35"  -> "20/11/25 @ 20:35"
  function fmt_DDMMYY_HHMM(text){
    if (!text) return text;
    const m = text.match(/^\s*(\d{1,2})\s+([A-Za-z]{3})\s+(\d{2})(?:\s+at|\s*@)\s+(\d{2}):(\d{2})\s*$/);
    if (!m) return text;
    const [, d, mon, yy, hh, mm] = m;
    const MONTH = {JAN:'01',FEB:'02',MAR:'03',APR:'04',MAY:'05',JUN:'06',JUL:'07',AUG:'08',SEP:'09',OCT:'10',NOV:'11',DEC:'12'};
    const mmNum = MONTH[mon.toUpperCase()];
    if (!mmNum) return text;
    const dd = String(d).padStart(2,'0');
    return `${dd}/${mmNum}/${yy} @ ${hh}:${mm}`;
  }

  function yellowNEW(){
    const span = document.createElement('span');
    span.className = 'tag';
    span.textContent = 'NEW';
    span.style.color = '#facc15';
    span.style.borderColor = 'rgba(250,204,21,.35)';
    span.style.background = 'rgba(250,204,21,.08)';
    return span;
  }

  // Build PB map + (player|score)→latest timestamp
  async function buildMaps(){
    if (window.__hsMatchMaps_v3) return window.__hsMatchMaps_v3;

    let games = [];
    try { games = (await __fetchOfficialGames(50000)).map(__normalizeGame); } catch(_) {}

    const pb = new Map();      // nameLC -> max score
    const keyTs = new Map();   // `${nameLC}|${score}` -> latest Date
    let globalMax = 0;

    games.forEach(g=>{
      const ts = __gameTs(g.raw || g);
      const d  = ts ? new Date(ts) : null;
      (g.players||[]).forEach((p,i)=>{
        const name = String(p||'').trim(); if (!name) return;
        const k = name.toLowerCase();
        const score = Number(g.totals?.[i] || 0);
        if (!Number.isFinite(score)) return;
        if (score > (pb.get(k) || 0)) pb.set(k, score);
        if (score > globalMax) globalMax = score;
        if (d) {
          const key = `${k}|${score}`;
          const prev = keyTs.get(key);
          if (!prev || d > prev) keyTs.set(key, d);
        }
      });
    });

    window.__hsMatchMaps_v3 = { pb, keyTs, globalMax };
    return window.__hsMatchMaps_v3;
  }

  async function apply(){
    const found = findModalAndTable(); if (!found) return;
    const { table, ths } = found;

    // Insert blank header after "#", narrow first column
    let thNew = table.querySelector('thead th[data-newcol="1"]');
    if (!thNew){
      thNew = document.createElement('th');
      thNew.dataset.newcol = '1';
      thNew.style.textAlign = 'center';
      thNew.style.width = '44px';
      thNew.style.minWidth = '38px';
      thNew.style.maxWidth = '60px';
      ths[0].insertAdjacentElement('afterend', thNew);
    }
    if (ths[0]) {
      ths[0].style.width     = '24px';
      ths[0].style.minWidth  = '22px';
      ths[0].style.maxWidth  = '28px';
      ths[0].style.textAlign = 'center';
    }
    Array.from(table.querySelectorAll('tbody tr')).forEach(tr=>{
      const td = tr.children[0];
      if (td) { td.style.width='24px'; td.style.minWidth='22px'; td.style.textAlign='center'; }
    });

    // Resolve indexes (robust even if columns shift)
    const head = Array.from(table.querySelectorAll('thead th'));
    const idxRank   = 0;
    const idxNew    = head.findIndex(th => th.dataset && th.dataset.newcol === '1');
    const idxPlayer = head.findIndex(th => /player/i.test(th.textContent||''));
    const idxScore  = head.findIndex(th => /^score$/i.test(th.textContent||''));
    let   idxWhen   = head.findIndex(th => /when/i.test(th.textContent||''));
    if (idxWhen < 0) idxWhen = head.length - 1; // fallback: last column is When
    if (idxNew < 0 || idxPlayer < 0 || idxScore < 0) return;

    const { pb, keyTs, globalMax } = await buildMaps();

    // Per-row updates
    const rows = Array.from(table.querySelectorAll('tbody tr'));
    rows.forEach((tr, i)=>{
      const tds     = Array.from(tr.children);
      const tdRank  = tds[idxRank];
      const tdNew   = (function(){
        let cell = tds[idxNew];
        if (!cell || cell === tdRank || cell.dataset.newCell !== '1') {
          cell = document.createElement('td');
          cell.dataset.newCell = '1';
          cell.style.textAlign = 'center';
          tdRank.insertAdjacentElement('afterend', cell);
        } else {
          cell.innerHTML = '';
        }
        return cell;
      })();

      // Adjusted indexes after inserting NEW cell before later columns
      const tds2    = Array.from(tr.children);
      const tdPlayer= tds2[idxPlayer + 1];
      const tdScore = tds2[idxScore  + 1];
      const tdWhen  = tds2[idxWhen   + 1] || tds2[tds2.length - 1];

      // 1) Format When => DD/MM/YY @ HH:MM
      if (tdWhen) {
        const orig = tdWhen.textContent || '';
        const fmt  = fmt_DDMMYY_HHMM(orig);
        if (fmt && fmt !== orig) tdWhen.textContent = fmt;
      }

      // 2) NEW (≤7 days since that exact (player,score))
      const nameLC = (tdPlayer?.textContent || '').trim().toLowerCase();
      const scoreN = Number((tdScore?.textContent || '').replace(/[^\d.]/g,''));
      if (nameLC && Number.isFinite(scoreN)) {
        const key = `${nameLC}|${scoreN}`;
        const ts = keyTs.get(key);
        if (ts && (Date.now() - ts.getTime()) <= NEW_MS) {
          tdNew.appendChild(yellowNEW());
        }
      }

      // 3) PB after Score (exclude global top score)
      const isGlobalTop = Number((tdScore?.textContent || '').replace(/[^\d.]/g,'')) === globalMax;
      const best = pb.get(nameLC) || -Infinity;
      const isPB = Number((tdScore?.textContent || '').replace(/[^\d.]/g,'')) === best;
      if (!isGlobalTop && isPB && tdScore && !/\bPB\b/i.test(tdScore.innerHTML)) {
        const tag = document.createElement('span');
        tag.className = 'tag';
        tag.textContent = 'PB';
        tag.style.marginLeft = '6px';
        tdScore.appendChild(tag);
      }
    });
  }

  function tick(){ try { apply(); } catch(e){ console.error('HS Match v3 failed', e); } }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', tick); else tick();
  const mo = new MutationObserver(tick);
  mo.observe(document.body || document.documentElement, { childList:true, subtree:true });
})();

/* === Gremlins Xmas GIF — resilient, no embed.js required ================ */

// === T button flash + shake — v3 (Safari-safe; 1→2→3 only when T is pressed)
(function tButtonFXv3(){
  // CSS (proper injection)
  if (!document.getElementById('tfx-css')) {
    const s = document.createElement('style'); s.id = 'tfx-css';
    s.textContent =
`.tfx{will-change:transform,filter}
@keyframes tFlashLow{0%{filter:brightness(1);box-shadow:none}12%{filter:brightness(1.4);box-shadow:0 0 10px rgba(255,255,255,.5),0 0 18px rgba(77,163,255,.3)}30%{filter:brightness(1.05);box-shadow:none}100%{filter:brightness(1);box-shadow:none}}
@keyframes tFlashMed{0%{filter:brightness(1);box-shadow:none}10%{filter:brightness(1.9);box-shadow:0 0 16px rgba(255,255,255,.7),0 0 28px rgba(77,163,255,.4)}24%{filter:brightness(1.1);box-shadow:none}38%{filter:brightness(1.6);box-shadow:0 0 12px rgba(255,255,255,.5),0 0 22px rgba(77,163,255,.35)}100%{filter:brightness(1);box-shadow:none}}
@keyframes tFlashHigh{0%{filter:brightness(1);box-shadow:none}8%{filter:brightness(2.6);box-shadow:0 0 22px rgba(255,255,255,.85),0 0 40px rgba(77,163,255,.5)}18%{filter:brightness(1.1);box-shadow:none}28%{filter:brightness(2.2);box-shadow:0 0 18px rgba(255,255,255,.7),0 0 34px rgba(77,163,255,.45)}42%{filter:brightness(1.15);box-shadow:none}100%{filter:brightness(1);box-shadow:none}}
@keyframes tShakeLow{0%,100%{transform:translateX(0)}20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-2px)}80%{transform:translateX(2px)}}
@keyframes tShakeMed{0%,100%{transform:translateX(0)}15%{transform:translateX(-5px)}30%{transform:translateX(5px)}45%{transform:translateX(-4px)}60%{transform:translateX(4px)}75%{transform:translateX(-3px)}}
@keyframes tShakeHigh{0%,100%{transform:translateX(0) rotate(0)}12%{transform:translateX(-8px) rotate(-1deg)}24%{transform:translateX(8px) rotate(1deg)}36%{transform:translateX(-7px) rotate(-.9deg)}48%{transform:translateX(7px) rotate(.9deg)}60%{transform:translateX(-6px) rotate(-.8deg)}72%{transform:translateX(6px) rotate(.8deg)}84%{transform:translateX(-4px) rotate(-.6deg)}}
.tfx.flash-low{animation:tFlashLow .22s ease-in-out,tShakeLow .22s linear}
.tfx.flash-med{animation:tFlashMed .34s ease-in-out,tShakeMed .34s linear}
.tfx.flash-high{animation:tFlashHigh .50s ease-in-out,tShakeHigh .50s linear}`;
    document.head.appendChild(s);
  }

  // Find the visible T button (label "T" or treble)
  function isT(el){
    if (!el) return false;
    const label = (el.textContent || el.getAttribute('aria-label') || el.title || '').trim().toUpperCase();
    const data  = ((el.dataset && (el.dataset.shot || el.dataset.kind || '')) || '').toUpperCase();
    const isBtn = /^(BUTTON|A)$/i.test(el.tagName) || el.hasAttribute('role');
    return isBtn && (label === 'T' || data === 'T' || /TREB|TREBLE/.test(label+data));
  }
  function findT(){ return Array.from(document.querySelectorAll('button,.btn,a,[role="button"]')).find(el => isT(el) && el.offsetParent); }

  // Press-order only: 1 -> 2 -> 3 -> 1 ... (only T presses advance)
  let count = 0;

  function animate(el){
    el.classList.add('tfx');
    el.classList.remove('flash-low','flash-med','flash-high');
    void el.offsetWidth; // restart
    el.classList.add(count===1 ? 'flash-low' : count===2 ? 'flash-med' : 'flash-high');
    setTimeout(() => el.classList.remove('flash-low','flash-med','flash-high'), 700);
  }

  function onPress(){
    const el = findT(); if (!el) return;
    count = (count % 3) + 1;     // 1→2→3→1…
    animate(el);
  }

  // Wire clicks only on T; keyboard 't' also triggers it
  function wire(){
    const btn = findT(); if (!btn || btn.dataset.tFxWired==='1') return;
    btn.dataset.tFxWired = '1';
    btn.addEventListener('click', onPress);
  }
  document.addEventListener('keydown', e => { if ((e.key||'').toLowerCase() === 't') onPress(); });

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', wire); else wire();
  new MutationObserver(wire).observe(document.body || document.documentElement, { childList:true, subtree:true });
})();

// === D button flash + shake — v1 (1→2→3: Ultra-low → Low → Medium)
(function dButtonFX(){
  // CSS for D (kept separate from T)
  if (!document.getElementById('dfx-css')) {
    const s = document.createElement('style'); s.id = 'dfx-css';
    s.textContent =
`.dfx{will-change:transform,filter}
@keyframes dFlashUltra{0%{filter:brightness(1);box-shadow:none}18%{filter:brightness(1.2);box-shadow:0 0 6px rgba(255,255,255,.35),0 0 12px rgba(77,163,255,.20)}100%{filter:brightness(1);box-shadow:none}}
@keyframes dFlashLow{0%{filter:brightness(1);box-shadow:none}14%{filter:brightness(1.45);box-shadow:0 0 10px rgba(255,255,255,.45),0 0 18px rgba(77,163,255,.28)}100%{filter:brightness(1);box-shadow:none}}
@keyframes dFlashMed{0%{filter:brightness(1);box-shadow:none}12%{filter:brightness(1.7);box-shadow:0 0 14px rgba(255,255,255,.6),0 0 24px rgba(77,163,255,.35)}32%{filter:brightness(1.1);box-shadow:none}100%{filter:brightness(1);box-shadow:none}}
@keyframes dShakeUltra{0%,100%{transform:translateX(0)}25%{transform:translateX(-1px)}75%{transform:translateX(1px)}}
@keyframes dShakeLow{0%,100%{transform:translateX(0)}20%{transform:translateX(-3px)}40%{transform:translateX(3px)}60%{transform:translateX(-2px)}80%{transform:translateX(2px)}}
@keyframes dShakeMed{0%,100%{transform:translateX(0)}15%{transform:translateX(-5px)}30%{transform:translateX(5px)}45%{transform:translateX(-4px)}60%{transform:translateX(4px)}}
.dfx.flash-ultra{animation:dFlashUltra .18s ease-in-out,dShakeUltra .18s linear}
.dfx.flash-low{animation:dFlashLow .26s ease-in-out,dShakeLow .26s linear}
.dfx.flash-med{animation:dFlashMed .34s ease-in-out,dShakeMed .34s linear}`;
    document.head.appendChild(s);
  }

  // Find the visible D button (label "D" or "Double")
  function isD(el){
    if (!el) return false;
    const label = (el.textContent || el.getAttribute('aria-label') || el.title || '').trim().toUpperCase();
    const data  = ((el.dataset && (el.dataset.shot || el.dataset.kind || '')) || '').toUpperCase();
    const isBtn = /^(BUTTON|A)$/i.test(el.tagName) || el.hasAttribute('role');
    return isBtn && (label === 'D' || data === 'D' || /DOUBLE/.test(label+data));
  }
  function findD(){ return Array.from(document.querySelectorAll('button,.btn,a,[role="button"]')).find(el => isD(el) && el.offsetParent); }

  // Press-order only for D (independent of T/S)
  let dCount = 0;

  function animate(el){
    el.classList.add('dfx');
    el.classList.remove('flash-ultra','flash-low','flash-med');
    void el.offsetWidth; // restart
    el.classList.add(dCount===1 ? 'flash-ultra' : dCount===2 ? 'flash-low' : 'flash-med');
    setTimeout(()=> el.classList.remove('flash-ultra','flash-low','flash-med'), 600);
  }

  function onPressD(){
    const el = findD(); if (!el) return;
    dCount = (dCount % 3) + 1;   // 1 (ultra-low) → 2 (low) → 3 (medium)
    animate(el);
  }

  // Wire clicks only on D; keyboard 'd' also triggers it
  function wire(){
    const btn = findD(); if (!btn || btn.dataset.dFxWired==='1') return;
    btn.dataset.dFxWired = '1';
    btn.addEventListener('click', onPressD);
  }
  document.addEventListener('keydown', e => { if ((e.key||'').toLowerCase() === 'd') onPressD(); });

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', wire); else wire();
  new MutationObserver(wire).observe(document.body || document.documentElement, { childList:true, subtree:true });
})();

// === S button flash + shake — v1 (1→2→3: Ultra-ultra low → Ultra low → Low)
(function sButtonFX(){
  // CSS for S
  if (!document.getElementById('sfx-css')) {
    const s = document.createElement('style'); s.id = 'sfx-css';
    s.textContent =
`.sfx{will-change:transform,filter}
@keyframes sFlashXXL{0%{filter:brightness(1);box-shadow:none}
  18%{filter:brightness(1.12);box-shadow:0 0 4px rgba(255,255,255,.25),0 0 8px rgba(77,163,255,.15)}
  100%{filter:brightness(1);box-shadow:none}}
@keyframes sFlashUltra{0%{filter:brightness(1);box-shadow:none}
  16%{filter:brightness(1.25);box-shadow:0 0 6px rgba(255,255,255,.35),0 0 12px rgba(77,163,255,.20)}
  100%{filter:brightness(1);box-shadow:none}}
@keyframes sFlashLow{0%{filter:brightness(1);box-shadow:none}
  14%{filter:brightness(1.4);box-shadow:0 0 9px rgba(255,255,255,.45),0 0 16px rgba(77,163,255,.25)}
  100%{filter:brightness(1);box-shadow:none}}
@keyframes sShakeXXL{0%,100%{transform:translateX(0)}
  50%{transform:translateX(.4px)}}
@keyframes sShakeUltra{0%,100%{transform:translateX(0)}
  25%{transform:translateX(-.8px)}75%{transform:translateX(.8px)}}
@keyframes sShakeLow{0%,100%{transform:translateX(0)}
  20%{transform:translateX(-2px)}40%{transform:translateX(2px)}}
.sfx.flash-xxl{animation:sFlashXXL .16s ease-in-out, sShakeXXL .16s linear}
.sfx.flash-ultra{animation:sFlashUltra .20s ease-in-out, sShakeUltra .20s linear}
.sfx.flash-low{animation:sFlashLow .26s ease-in-out, sShakeLow .26s linear}`;
    document.head.appendChild(s);
  }

  // Find the visible S button (label "S" or "Single")
  function isS(el){
    if (!el) return false;
    const label = (el.textContent || el.getAttribute('aria-label') || el.title || '').trim().toUpperCase();
    const data  = ((el.dataset && (el.dataset.shot || el.dataset.kind || '')) || '').toUpperCase();
    const isBtn = /^(BUTTON|A)$/i.test(el.tagName) || el.hasAttribute('role');
    return isBtn && (label === 'S' || /SINGLE/.test(label+data) || data === 'S');
  }
  function findS(){
    return Array.from(document.querySelectorAll('button,.btn,a,[role="button"]'))
      .find(el => isS(el) && el.offsetParent);
  }

  // Press-order only for S (independent of T/D)
  let sCount = 0;

  function animate(el){
    el.classList.add('sfx');
    el.classList.remove('flash-xxl','flash-ultra','flash-low');
    void el.offsetWidth; // restart
    el.classList.add(sCount===1 ? 'flash-xxl' : sCount===2 ? 'flash-ultra' : 'flash-low');
    setTimeout(()=> el.classList.remove('flash-xxl','flash-ultra','flash-low'), 500);
  }

  function onPressS(){
    const el = findS(); if (!el) return;
    sCount = (sCount % 3) + 1;   // 1 (XXL) → 2 (Ultra) → 3 (Low)
    animate(el);
  }

  // Wire clicks on S; keyboard 's' also triggers it
  function wire(){
    const btn = findS(); if (!btn || btn.dataset.sFxWired==='1') return;
    btn.dataset.sFxWired = '1';
    btn.addEventListener('click', onPressS);
  }
  document.addEventListener('keydown', e => { if ((e.key||'').toLowerCase() === 's') onPressS(); });

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', wire); else wire();
  new MutationObserver(wire).observe(document.body || document.documentElement, { childList:true, subtree:true });
})();

// === MISS button — red glow (1→2→3: soft → medium → high) ==================
(function missButtonFX(){
  // CSS for MISS
  if (!document.getElementById('mfx-css')) {
    const s = document.createElement('style'); s.id = 'mfx-css';
    s.textContent =
    ` .missfx{will-change:filter,box-shadow,transform,background-color}

/* existing glow tweaked to pair with bg pulse */
@keyframes mGlowSoft{
  0%{filter:brightness(1);box-shadow:none}
  20%{filter:brightness(1.15);box-shadow:0 0 10px rgba(244,63,94,.45),0 0 20px rgba(244,63,94,.25)}
  100%{filter:brightness(1);box-shadow:none}
}
@keyframes mGlowMed{
  0%{filter:brightness(1);box-shadow:none}
  18%{filter:brightness(1.35);box-shadow:0 0 16px rgba(244,63,94,.6),0 0 28px rgba(244,63,94,.35)}
  40%{filter:brightness(1.1);box-shadow:none}
  100%{filter:brightness(1);box-shadow:none}
}
@keyframes mGlowHigh{
  0%{filter:brightness(1);box-shadow:none;transform:scale(1)}
  14%{filter:brightness(1.6);box-shadow:0 0 22px rgba(244,63,94,.75),0 0 40px rgba(244,63,94,.45);transform:scale(1.02)}
  30%{filter:brightness(1.2);box-shadow:0 0 12px rgba(244,63,94,.45),0 0 26px rgba(244,63,94,.30);transform:scale(1.01)}
  100%{filter:brightness(1);box-shadow:none;transform:scale(1)}
}

/* pulse the actual red background from --miss-from to --miss-to and back */
@keyframes mBgPulse{
  0%  { background-color: var(--miss-from); }
  22% { background-color: var(--miss-to);   }
  100%{ background-color: var(--miss-from); }
}

/* combine glow + bg pulse; durations match levels */
.missfx.glow-soft{animation: mGlowSoft .26s ease-out, mBgPulse .26s ease-in-out}
.missfx.glow-med {animation: mGlowMed  .34s ease-out, mBgPulse .34s ease-in-out}
.missfx.glow-high{animation: mGlowHigh .44s ease-out, mBgPulse .44s ease-in-out}`
    
    document.head.appendChild(s);
  }

  // Find the visible MISS button (label "MISS"; allow 'X' only if marked as miss)
  function isMISS(el){
    if (!el) return false;
    const label = (el.textContent || el.getAttribute('aria-label') || el.title || '').trim();
    const up    = label.toUpperCase();
    const data  = ((el.dataset && (el.dataset.kind || el.dataset.shot || '')) || '').toLowerCase();
    const isBtn = /^(BUTTON|A)$/i.test(el.tagName) || el.hasAttribute('role');
    if (!isBtn) return false;
    if (up === 'MISS') return true;
    // Accept "X" only if metadata indicates miss
    if (up === 'X' && /miss/.test(data + ' ' + (el.getAttribute('aria-label')||'').toLowerCase())) return true;
    return /miss/.test(data);
  }
  function findMISS(){
    return Array.from(document.querySelectorAll('button,.btn,a,[role="button"]'))
      .find(el => isMISS(el) && el.offsetParent);
  }

  // Press-order only for MISS (independent)
  let mCount = 0;

  function animate(el){
    el.classList.add('missfx');
    el.classList.remove('glow-soft','glow-med','glow-high');
    void el.offsetWidth; // restart
    el.classList.add(mCount===1 ? 'glow-soft' : mCount===2 ? 'glow-med' : 'glow-high');
  }

  function onPressMISS(){
    const el = findMISS(); if (!el) return;
    mCount = (mCount % 3) + 1; // 1 soft → 2 med → 3 high
    animate(el);
  }

  // Wire clicks on MISS; keyboard 'm' also triggers it
  function wire(){
    const btn = findMISS(); if (!btn || btn.dataset.mFxWired==='1') return;
    btn.dataset.mFxWired = '1';
    btn.addEventListener('click', onPressMISS);
  }
  document.addEventListener('keydown', e => { if ((e.key||'').toLowerCase() === 'm') onPressMISS(); });

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', wire); else wire();
  new MutationObserver(wire).observe(document.body || document.documentElement, { childList:true, subtree:true });
})();


(function mountGremlins(){
  const WRAP_ID   = 'gremlinsGif';
  const GIF_PAGE  = 'https://tenor.com/view/gremlins-singing-christmascarol-christmas-monster-gif-4239908413876512369';

  // Fallback: paste a direct media.tenor.com GIF/MP4 URL here if your CSP blocks iframes.
  // Example (replace with the actual media link you copy from Tenor): 
  // const GIF_SRC = 'https://media.tenor.com/XXXXXAA/mp4';
const GIF_SRC = 'https://tenor.com/fdmZlr9yPBt.gif';  // direct GIF

  function findAdminAnchor(){
    return (
      document.getElementById('adminBtn') ||
      document.getElementById('adminCodeBtn') ||
      document.querySelector('[data-role="admin"]') ||
      Array.from(document.querySelectorAll('button,.btn,[role="button"]'))
        .find(el => /^\s*admin\s*$/i.test(el.textContent || ''))
    );
  }

  function buildWrapper(){
    const wrap = document.createElement('div');
    wrap.id = WRAP_ID;
    wrap.style.maxWidth   = '680px';
    wrap.style.width      = 'min(680px, 92%)';
    wrap.style.margin     = '12px auto 8px';
    wrap.style.borderRadius = '10px';
    wrap.style.overflow   = 'hidden';
    wrap.style.boxShadow  = '0 4px 22px rgba(0,0,0,.25)';
    wrap.style.background = 'rgba(255,255,255,0.03)';

    // Maintain ~16:9 area
    const holder = document.createElement('div');
    holder.style.position = 'relative';
    holder.style.paddingTop = '56.6%'; // 16:9
    const box = document.createElement('div');
    box.style.position = 'absolute';
    box.style.inset = '0';

const postId = '4239908413876512369';

if (GIF_SRC) {
  // Try a plain asset first (no third-party scripts/iframe)
  if (GIF_SRC.toLowerCase().endsWith('.mp4')) {
    const v = document.createElement('video');
    v.src = GIF_SRC;
    v.autoplay = true; v.loop = true; v.muted = true; v.playsInline = true;
    v.style.width = '100%'; v.style.height = '100%'; v.style.objectFit = 'cover';
    box.appendChild(v);
  } else {
    const img = new Image();
    img.alt = 'Gremlins Singing';
    img.style.width = '100%';
    img.style.height = '100%';
    img.style.objectFit = 'cover';

    // Fallback to Tenor’s official embed if the direct GIF 404s
    img.onerror = () => {
      box.innerHTML = '';
      const div = document.createElement('div');
      div.className = 'tenor-gif-embed';
      div.setAttribute('data-postid', postId);
      div.setAttribute('data-share-method', 'host');
      div.setAttribute('data-aspect-ratio', '1.76596');
      div.setAttribute('data-width', '100%');
      box.appendChild(div);

      if (!document.getElementById('tenorEmbedJS')) {
        const s = document.createElement('script');
        s.id = 'tenorEmbedJS';
        s.src = 'https://tenor.com/embed.js';
        s.async = true;
        document.body.appendChild(s);
      }
    };

    img.onload = () => { box.replaceChildren(img); };
    img.src = GIF_SRC;
  }
} else {
  // No direct asset supplied: use Tenor’s embed right away (no sandbox, let embed.js manage it)
  const div = document.createElement('div');
  div.className = 'tenor-gif-embed';
  div.setAttribute('data-postid', postId);
  div.setAttribute('data-share-method', 'host');
  div.setAttribute('data-aspect-ratio', '1.76596');
  div.setAttribute('data-width', '100%');
  box.appendChild(div);

  if (!document.getElementById('tenorEmbedJS')) {
    const s = document.createElement('script');
    s.id = 'tenorEmbedJS';
    s.src = 'https://tenor.com/embed.js';
    s.async = true;
    document.body.appendChild(s);
  }
}


    holder.appendChild(box);
    wrap.appendChild(holder);

    // Credit / fallback click-through
    const credit = document.createElement('a');
    credit.href = GIF_PAGE;
    credit.target = '_blank';
    credit.rel = 'noopener';
    credit.textContent = 'Gremlins Singing — Tenor';
    credit.className = 'tag';
    credit.style.display = 'block';
    credit.style.textAlign = 'center';
    credit.style.marginTop = '6px';
    wrap.appendChild(credit);

    return wrap;
  }

  function insertAfterAdmin(){
    if (document.getElementById(WRAP_ID)) return; // already mounted
    const admin = findAdminAnchor();
    if (!admin) return;
    admin.insertAdjacentElement('afterend', buildWrapper());
  }

  // Mount once DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertAfterAdmin);
  } else {
    insertAfterAdmin();
  }
})();

</script>
<!-- PB / GR Admin Modal -->
<div id="pbgrAdminModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="pbgrTitle">
  <h3 id="pbgrTitle">PB / GR Admin</h3>
  <div class="modal-body">
    <p class="muted" style="margin-top:-6px;margin-bottom:10px;">
      Manage Personal Bests and Game Records. Deleting a row will remove the underlying round from the cloud.
    </p>

    <h4 style="margin:8px 0 6px;">World Records (All Players)</h4>
    <div id="pbgrGlobal" class="table-wrap"></div>

    <hr style="border:0;border-top:1px solid rgba(255,255,255,.08);margin:12px 0;">

    <h4 style="margin:8px 0 6px;">Player PBs</h4>
    <label for="pbgrPlayerSelect" class="muted" style="display:block;margin-bottom:6px;">Select saved player:</label>
    <select id="pbgrPlayerSelect" class="input" style="min-width:220px;"></select>
    <div class="row" id="pbgrBackfillRow" style="margin-top:10px; gap:8px; align-items:center;">
  <button id="pbgrBackfillBtn" class="btn warn" type="button">Backdate PB / WR</button>
  <span class="muted">Scan cloud throws (saved players, official only) and write PBs + WRs.</span>
</div>
    <div id="pbgrPlayer" class="table-wrap" style="margin-top:8px;"></div>
  </div>
  <div class="modal-footer">
    <button id="pbgrBackBtn" class="btn">Back</button>
    <button id="pbgrRefreshBtn" class="btn">Refresh</button>
    <button id="pbgrCloseBtn" class="btn">Close</button>
  </div>
  
</div>
</body>
</html>